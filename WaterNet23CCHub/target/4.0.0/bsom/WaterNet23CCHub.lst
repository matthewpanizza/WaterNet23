
c:/Users/mligh/OneDrive/Particle/WaterNet23/WaterNet23CCHub/target/4.0.0/bsom/WaterNet23CCHub.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  000b4000  000b4000  00004000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  000b4018  000b4018  00004018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000e750  000b4020  000b4020  00004020  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .note.gnu.build-id 00000024  000c2770  000c2770  00012770  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .backup       00000004  2003f400  000c2794  0001f400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000001e0  2003daa8  000c2798  0002daa8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000b68  2003dc88  2003dc88  0003dc88  2**3
                  ALLOC
  7 .module_info_suffix 00000028  000c2978  000c2978  00032978  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .module_info_crc 00000004  000c29a0  000c29a0  000329a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .debug_info   001e11ed  00000000  00000000  000329a4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 0001f86c  00000000  00000000  00213b91  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    0005a76c  00000000  00000000  002333fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00003b98  00000000  00000000  0028db69  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_ranges 0000eba0  00000000  00000000  00291701  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  0004f077  00000000  00000000  002a02a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   00071aab  00000000  00000000  002ef318  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    00151dc2  00000000  00000000  00360dc3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_frame  0000be00  00000000  00000000  004b2b88  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

000b4020 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   b4020:	4809      	ldr	r0, [pc, #36]	; (b4048 <module_user_pre_init+0x28>)
   b4022:	490a      	ldr	r1, [pc, #40]	; (b404c <module_user_pre_init+0x2c>)
   b4024:	4288      	cmp	r0, r1
void* module_user_pre_init() {
   b4026:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
   b4028:	d005      	beq.n	b4036 <module_user_pre_init+0x16>
   b402a:	4a09      	ldr	r2, [pc, #36]	; (b4050 <module_user_pre_init+0x30>)
   b402c:	4282      	cmp	r2, r0
   b402e:	d002      	beq.n	b4036 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
   b4030:	1a12      	subs	r2, r2, r0
   b4032:	f00a ff3a 	bl	beeaa <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
   b4036:	4807      	ldr	r0, [pc, #28]	; (b4054 <module_user_pre_init+0x34>)
   b4038:	4a07      	ldr	r2, [pc, #28]	; (b4058 <module_user_pre_init+0x38>)
   b403a:	2100      	movs	r1, #0
   b403c:	1a12      	subs	r2, r2, r0
   b403e:	f00a ff5c 	bl	beefa <memset>
    return &link_global_data_start;
}
   b4042:	4801      	ldr	r0, [pc, #4]	; (b4048 <module_user_pre_init+0x28>)
   b4044:	bd08      	pop	{r3, pc}
   b4046:	bf00      	nop
   b4048:	2003daa8 	.word	0x2003daa8
   b404c:	000c2798 	.word	0x000c2798
   b4050:	2003dc88 	.word	0x2003dc88
   b4054:	2003dc88 	.word	0x2003dc88
   b4058:	2003e7ed 	.word	0x2003e7ed

000b405c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
   b405c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();

    // invoke constructors
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b405e:	4e07      	ldr	r6, [pc, #28]	; (b407c <module_user_init+0x20>)
   b4060:	4c07      	ldr	r4, [pc, #28]	; (b4080 <module_user_init+0x24>)
    module_user_init_hook();
   b4062:	f009 f96d 	bl	bd340 <module_user_init_hook>
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b4066:	1ba4      	subs	r4, r4, r6
   b4068:	08a4      	lsrs	r4, r4, #2
   b406a:	2500      	movs	r5, #0
   b406c:	42ac      	cmp	r4, r5
   b406e:	d100      	bne.n	b4072 <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
   b4070:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
   b4072:	f856 3b04 	ldr.w	r3, [r6], #4
   b4076:	4798      	blx	r3
    for (size_t ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
   b4078:	3501      	adds	r5, #1
   b407a:	e7f7      	b.n	b406c <module_user_init+0x10>
   b407c:	000c274c 	.word	0x000c274c
   b4080:	000c2770 	.word	0x000c2770

000b4084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
   b4084:	f002 bc90 	b.w	b69a8 <setup>

000b4088 <module_user_loop>:
}

void module_user_loop() {
   b4088:	b508      	push	{r3, lr}
    loop();
   b408a:	f002 ffef 	bl	b706c <loop>
    _post_loop();
}
   b408e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
   b4092:	f009 b90d 	b.w	bd2b0 <_post_loop>

000b4096 <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
   b4096:	f006 b9a9 	b.w	ba3ec <malloc>

000b409a <_Znaj>:
   b409a:	f006 b9a7 	b.w	ba3ec <malloc>

000b409e <_ZdlPvj>:
	free(p);
}

void operator delete(void *p, size_t size)
{
	free(p);
   b409e:	f006 b9ad 	b.w	ba3fc <free>
	...

000b40a4 <__cxa_pure_virtual>:
int __wrap_printf(const char* fmt, ...) {
    return -1;
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
   b40a4:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
   b40a6:	4a03      	ldr	r2, [pc, #12]	; (b40b4 <__cxa_pure_virtual+0x10>)
   b40a8:	4903      	ldr	r1, [pc, #12]	; (b40b8 <__cxa_pure_virtual+0x14>)
   b40aa:	200c      	movs	r0, #12
   b40ac:	f006 f8aa 	bl	ba204 <panic_>
  while (1);
   b40b0:	e7fe      	b.n	b40b0 <__cxa_pure_virtual+0xc>
   b40b2:	bf00      	nop
   b40b4:	000b9d61 	.word	0x000b9d61
   b40b8:	000c0fb8 	.word	0x000c0fb8

000b40bc <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
   b40bc:	7800      	ldrb	r0, [r0, #0]
   b40be:	fab0 f080 	clz	r0, r0
   b40c2:	0940      	lsrs	r0, r0, #5
   b40c4:	4770      	bx	lr

000b40c6 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
   b40c6:	2301      	movs	r3, #1
   b40c8:	7003      	strb	r3, [r0, #0]
   b40ca:	4770      	bx	lr

000b40cc <_ZN8particle11SPISettingsD1Ev>:
  SPISettings()
  {
  }

  virtual ~SPISettings() {
  }
   b40cc:	4770      	bx	lr

000b40ce <_ZN4File9availableEv>:
  void setpos(FatPos_t* pos);
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available() {
    return isFile() ? fileSize() - curPosition() : 0;
   b40ce:	7c03      	ldrb	r3, [r0, #16]
   b40d0:	f013 0308 	ands.w	r3, r3, #8
   b40d4:	bf1e      	ittt	ne
   b40d6:	6ac3      	ldrne	r3, [r0, #44]	; 0x2c
   b40d8:	6a40      	ldrne	r0, [r0, #36]	; 0x24
   b40da:	1a1b      	subne	r3, r3, r0
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    uint32_t n = FatFile::available();
    return n > INT_MAX ? INT_MAX : n;
   b40dc:	2b00      	cmp	r3, #0
  }
   b40de:	bfac      	ite	ge
   b40e0:	4618      	movge	r0, r3
   b40e2:	f06f 4000 	mvnlt.w	r0, #2147483648	; 0x80000000
   b40e6:	4770      	bx	lr

000b40e8 <_Z12actionTimer5v>:
        Serial1.println(outStr);                        //Print string on serial1 for XBee transmission
    }
}

void actionTimer5(){
    postStatus = true;
   b40e8:	4b07      	ldr	r3, [pc, #28]	; (b4108 <_Z12actionTimer5v+0x20>)
   b40ea:	2201      	movs	r2, #1
   b40ec:	701a      	strb	r2, [r3, #0]
      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }

      explicit _GLIBCXX20_CONSTEXPR
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
      : _M_current(__i) { }
   b40ee:	4b07      	ldr	r3, [pc, #28]	; (b410c <_Z12actionTimer5v+0x24>)
   b40f0:	e9d3 3100 	ldrd	r3, r1, [r3]
    for(WaterBot &w: WaterBots){
   b40f4:	4299      	cmp	r1, r3
   b40f6:	d006      	beq.n	b4106 <_Z12actionTimer5v+0x1e>
        w.reqActive++;
   b40f8:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   b40fc:	3201      	adds	r2, #1
   b40fe:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
      operator->() const _GLIBCXX_NOEXCEPT
      { return _M_current; }

      _GLIBCXX20_CONSTEXPR
      __normal_iterator&
      operator++() _GLIBCXX_NOEXCEPT
   b4102:	3350      	adds	r3, #80	; 0x50
      {
	++_M_current;
	return *this;
   b4104:	e7f6      	b.n	b40f4 <_Z12actionTimer5v+0xc>
    }
    //if(!BLE.connected)
}
   b4106:	4770      	bx	lr
   b4108:	2003ded4 	.word	0x2003ded4
   b410c:	2003dce4 	.word	0x2003dce4

000b4110 <_ZN4FileD1Ev>:
class File : public FatFile, public Stream {
   b4110:	4770      	bx	lr

000b4112 <_ZN8particle11SPISettingsD0Ev>:
  virtual ~SPISettings() {
   b4112:	b510      	push	{r4, lr}
  }
   b4114:	2110      	movs	r1, #16
  virtual ~SPISettings() {
   b4116:	4604      	mov	r4, r0
  }
   b4118:	f7ff ffc1 	bl	b409e <_ZdlPvj>
   b411c:	4620      	mov	r0, r4
   b411e:	bd10      	pop	{r4, pc}

000b4120 <_ZN4FileD0Ev>:
   b4120:	b510      	push	{r4, lr}
   b4122:	2134      	movs	r1, #52	; 0x34
   b4124:	4604      	mov	r4, r0
   b4126:	f7ff ffba 	bl	b409e <_ZdlPvj>
   b412a:	4620      	mov	r0, r4
   b412c:	bd10      	pop	{r4, pc}

000b412e <_ZN4File5flushEv>:
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
    FatFile::sync();
   b412e:	3010      	adds	r0, #16
   b4130:	f004 be6e 	b.w	b8e10 <_ZN7FatFile4syncEv>

000b4134 <_ZN4File4peekEv>:
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return FatFile::peek();
   b4134:	3010      	adds	r0, #16
   b4136:	f004 bd8c 	b.w	b8c52 <_ZN7FatFile4peekEv>

000b413a <_ZN4File4readEv>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
   b413a:	b507      	push	{r0, r1, r2, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
   b413c:	2201      	movs	r2, #1
   b413e:	f10d 0107 	add.w	r1, sp, #7
   b4142:	3010      	adds	r0, #16
   b4144:	f004 fcd7 	bl	b8af6 <_ZN7FatFile4readEPvj>
   b4148:	2801      	cmp	r0, #1
   b414a:	bf0c      	ite	eq
   b414c:	f89d 0007 	ldrbeq.w	r0, [sp, #7]
   b4150:	f04f 30ff 	movne.w	r0, #4294967295
    return FatFile::read();
  }
   b4154:	b003      	add	sp, #12
   b4156:	f85d fb04 	ldr.w	pc, [sp], #4

000b415a <_ZN4File5writeEPKhj>:
   * include write() is called before a file has been opened, write is called
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const uint8_t *buf, size_t size) {
    return FatFile::write(buf, size);
   b415a:	3010      	adds	r0, #16
   b415c:	f004 bef2 	b.w	b8f44 <_ZN7FatFile5writeEPKvj>

000b4160 <_ZN4File5writeEh>:
  size_t write(uint8_t b) {
   b4160:	b507      	push	{r0, r1, r2, lr}
  /** Write a single byte.
   * \param[in] b The byte to be written.
   * \return +1 for success or -1 for failure.
   */
  int write(uint8_t b) {
    return write(&b, 1);
   b4162:	2201      	movs	r2, #1
   b4164:	f88d 1007 	strb.w	r1, [sp, #7]
   b4168:	3010      	adds	r0, #16
   b416a:	f10d 0107 	add.w	r1, sp, #7
   b416e:	f004 fee9 	bl	b8f44 <_ZN7FatFile5writeEPKvj>
  }
   b4172:	b003      	add	sp, #12
   b4174:	f85d fb04 	ldr.w	pc, [sp], #4

000b4178 <_ZN5Timer7timeoutEv>:
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
    {
        if (callback) {
   b4178:	6943      	ldr	r3, [r0, #20]
   b417a:	b113      	cbz	r3, b4182 <_ZN5Timer7timeoutEv+0xa>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   b417c:	6983      	ldr	r3, [r0, #24]
   b417e:	300c      	adds	r0, #12
   b4180:	4718      	bx	r3
            callback();
        }
    }
   b4182:	4770      	bx	lr

000b4184 <_ZN5Timer12invoke_timerEPv>:
private:
	volatile bool running;
    os_timer_t handle;
    timer_callback_fn callback;

    static void invoke_timer(os_timer_t timer)
   b4184:	b513      	push	{r0, r1, r4, lr}
typedef std::function<os_thread_return_t(void)> wiring_thread_fn_t;

class SingleThreadedSection {
public:
    SingleThreadedSection() {
        os_thread_scheduling(false, NULL);
   b4186:	2100      	movs	r1, #0
   b4188:	4604      	mov	r4, r0
   b418a:	4608      	mov	r0, r1
   b418c:	f005 fec2 	bl	b9f14 <os_thread_scheduling>
    {
        Timer* t = nullptr;
        SINGLE_THREADED_BLOCK() {
            void* id = nullptr;
   b4190:	2300      	movs	r3, #0
            os_timer_get_id(timer, &id);
   b4192:	4620      	mov	r0, r4
   b4194:	a901      	add	r1, sp, #4
            void* id = nullptr;
   b4196:	9301      	str	r3, [sp, #4]
            os_timer_get_id(timer, &id);
   b4198:	f005 fed4 	bl	b9f44 <os_timer_get_id>
            t = static_cast<Timer*>(id);
   b419c:	9c01      	ldr	r4, [sp, #4]
            if (t) {
   b419e:	b10c      	cbz	r4, b41a4 <_ZN5Timer12invoke_timerEPv+0x20>
                t->running = true;
   b41a0:	2301      	movs	r3, #1
   b41a2:	7123      	strb	r3, [r4, #4]
    }

    ~SingleThreadedSection() {
        os_thread_scheduling(true, NULL);
   b41a4:	2100      	movs	r1, #0
   b41a6:	2001      	movs	r0, #1
   b41a8:	f005 feb4 	bl	b9f14 <os_thread_scheduling>
            }
        }
        if (t) {
   b41ac:	b12c      	cbz	r4, b41ba <_ZN5Timer12invoke_timerEPv+0x36>
            t->timeout();
   b41ae:	6823      	ldr	r3, [r4, #0]
   b41b0:	4620      	mov	r0, r4
   b41b2:	689b      	ldr	r3, [r3, #8]
   b41b4:	4798      	blx	r3
            t->running = false;
   b41b6:	2300      	movs	r3, #0
   b41b8:	7123      	strb	r3, [r4, #4]
        }
    }
   b41ba:	b002      	add	sp, #8
   b41bc:	bd10      	pop	{r4, pc}
	...

000b41c0 <_Z8jHandlerv>:
    Serial.println("Down trigger");
    #endif
}

//Joystick click handler, used to capture current latitude and longitude and enter sentry mode with those captured points
void jHandler(){
   b41c0:	b510      	push	{r4, lr}
    if(millis()-debounceTime < DEBOUNCE_MS) return;
   b41c2:	4c05      	ldr	r4, [pc, #20]	; (b41d8 <_Z8jHandlerv+0x18>)

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   b41c4:	f005 fddc 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b41c8:	6823      	ldr	r3, [r4, #0]
   b41ca:	1ac0      	subs	r0, r0, r3
   b41cc:	2895      	cmp	r0, #149	; 0x95
   b41ce:	d902      	bls.n	b41d6 <_Z8jHandlerv+0x16>
   b41d0:	f005 fdd6 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    debounceTime = millis();
   b41d4:	6020      	str	r0, [r4, #0]
    #ifdef VERBOSE
    Serial.println("Joystick trigger");
    #endif
}
   b41d6:	bd10      	pop	{r4, pc}
   b41d8:	2003dd74 	.word	0x2003dd74

000b41dc <_Z8rHandlerv>:
void rHandler(){
   b41dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    redrawMenu = true;                                          //Set redraw flag always so the display is updated with new highlighted item
   b41de:	4b27      	ldr	r3, [pc, #156]	; (b427c <_Z8rHandlerv+0xa0>)
    if(millis()-debounceTime < DEBOUNCE_MS) return;             //debounce this button, to make sure only one trigger is registered per press
   b41e0:	4d27      	ldr	r5, [pc, #156]	; (b4280 <_Z8rHandlerv+0xa4>)
    redrawMenu = true;                                          //Set redraw flag always so the display is updated with new highlighted item
   b41e2:	2401      	movs	r4, #1
   b41e4:	701c      	strb	r4, [r3, #0]
   b41e6:	f005 fdcb 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;             //debounce this button, to make sure only one trigger is registered per press
   b41ea:	682b      	ldr	r3, [r5, #0]
   b41ec:	1ac0      	subs	r0, r0, r3
   b41ee:	2895      	cmp	r0, #149	; 0x95
   b41f0:	d919      	bls.n	b4226 <_Z8rHandlerv+0x4a>
   b41f2:	f005 fdc5 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(selectingBots){                                          //If enter was hit over a menu item, the item will be open for modification, and this flag indicates true when not modifying items (i.e. selecting which bot to access)
   b41f6:	4b23      	ldr	r3, [pc, #140]	; (b4284 <_Z8rHandlerv+0xa8>)
    debounceTime = millis();    
   b41f8:	6028      	str	r0, [r5, #0]
    if(selectingBots){                                          //If enter was hit over a menu item, the item will be open for modification, and this flag indicates true when not modifying items (i.e. selecting which bot to access)
   b41fa:	781a      	ldrb	r2, [r3, #0]
   b41fc:	4b22      	ldr	r3, [pc, #136]	; (b4288 <_Z8rHandlerv+0xac>)
   b41fe:	b1ba      	cbz	r2, b4230 <_Z8rHandlerv+0x54>
      : _M_current(__i) { }
   b4200:	685c      	ldr	r4, [r3, #4]
        if(botSelect != WaterBots.back().botNum){               //Check if we are not at the leftmost bot in the list, otherwise we shouldn't try selecting a bot that doesn't exist
   b4202:	4d22      	ldr	r5, [pc, #136]	; (b428c <_Z8rHandlerv+0xb0>)
   b4204:	f814 2c4e 	ldrb.w	r2, [r4, #-78]
   b4208:	7828      	ldrb	r0, [r5, #0]
   b420a:	4282      	cmp	r2, r0
   b420c:	d00b      	beq.n	b4226 <_Z8rHandlerv+0x4a>
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
   b420e:	681b      	ldr	r3, [r3, #0]
            bool findCurrent = false;                           //Grab the first item in the waterbot list to make sure we don't accidentally access something null
   b4210:	2200      	movs	r2, #0
            for(WaterBot &ws: WaterBots){                       //Loop over the list of bots discovered
   b4212:	429c      	cmp	r4, r3
   b4214:	461e      	mov	r6, r3
   b4216:	d006      	beq.n	b4226 <_Z8rHandlerv+0x4a>
                if(findCurrent){                                //Funky algorithm to find the bot next to the current bot in the list
   b4218:	3350      	adds	r3, #80	; 0x50
                    botSelect = ws.botNum;
   b421a:	f813 1c4e 	ldrb.w	r1, [r3, #-78]
                if(findCurrent){                                //Funky algorithm to find the bot next to the current bot in the list
   b421e:	b11a      	cbz	r2, b4228 <_Z8rHandlerv+0x4c>
                    ControlledBot = &ws;
   b4220:	4b1b      	ldr	r3, [pc, #108]	; (b4290 <_Z8rHandlerv+0xb4>)
                    botSelect = ws.botNum;
   b4222:	7029      	strb	r1, [r5, #0]
                    ControlledBot = &ws;
   b4224:	601e      	str	r6, [r3, #0]
}
   b4226:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if(ws.botNum == botSelect) findCurrent = true;
   b4228:	1a41      	subs	r1, r0, r1
   b422a:	424a      	negs	r2, r1
   b422c:	414a      	adcs	r2, r1
	return *this;
   b422e:	e7f0      	b.n	b4212 <_Z8rHandlerv+0x36>
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
   b4230:	e9d3 3500 	ldrd	r3, r5, [r3]
            if(ws.botNum == botSelect){                         //If we find the one we're looking for in the list
   b4234:	4e15      	ldr	r6, [pc, #84]	; (b428c <_Z8rHandlerv+0xb0>)
                MenuItem *curItem = SelectedItem;               //Take the current selected menu item
   b4236:	4f17      	ldr	r7, [pc, #92]	; (b4294 <_Z8rHandlerv+0xb8>)
                modifiedValue = true;                           //Indicate to the main loop that some bot has a modified a value, so send out a new control packet
   b4238:	f8df c05c 	ldr.w	ip, [pc, #92]	; b4298 <_Z8rHandlerv+0xbc>
        for(WaterBot &ws: WaterBots){                           //Loop over all bots in the list of discovered bots
   b423c:	429d      	cmp	r5, r3
   b423e:	d0f2      	beq.n	b4226 <_Z8rHandlerv+0x4a>
            if(ws.botNum == botSelect){                         //If we find the one we're looking for in the list
   b4240:	7899      	ldrb	r1, [r3, #2]
   b4242:	7832      	ldrb	r2, [r6, #0]
   b4244:	4291      	cmp	r1, r2
   b4246:	d10c      	bne.n	b4262 <_Z8rHandlerv+0x86>
                MenuItem *curItem = SelectedItem;               //Take the current selected menu item
   b4248:	683a      	ldr	r2, [r7, #0]
                if(curItem == nullptr) return;                  //Make sure that there is a menu item currently selected
   b424a:	2a00      	cmp	r2, #0
   b424c:	d0eb      	beq.n	b4226 <_Z8rHandlerv+0x4a>
                if(curItem->statOnly) return;                   //Some menu items are a status-only display and can't be modified, so do nothing
   b424e:	7e11      	ldrb	r1, [r2, #24]
   b4250:	2900      	cmp	r1, #0
   b4252:	d1e8      	bne.n	b4226 <_Z8rHandlerv+0x4a>
                if(curItem->onOffSetting){                      //If this is an on/off setting, then it must be a boolean, so set it true
   b4254:	7d91      	ldrb	r1, [r2, #22]
   b4256:	b131      	cbz	r1, b4266 <_Z8rHandlerv+0x8a>
                    ws.*(curItem->MethodPointerBool) = true;
   b4258:	6912      	ldr	r2, [r2, #16]
   b425a:	549c      	strb	r4, [r3, r2]
                modifiedValue = true;                           //Indicate to the main loop that some bot has a modified a value, so send out a new control packet
   b425c:	f88c 4000 	strb.w	r4, [ip]
                ws.updatedControl = true;                       //Indicate that this bot has a modified value
   b4260:	705c      	strb	r4, [r3, #1]
      operator++() _GLIBCXX_NOEXCEPT
   b4262:	3350      	adds	r3, #80	; 0x50
	return *this;
   b4264:	e7ea      	b.n	b423c <_Z8rHandlerv+0x60>
                    if(ws.*(curItem->MethodPointer) < curItem->maxVal) ws.*(curItem->MethodPointer) += curItem->stepSize; //Increment the counter in the waterbot class that this menu item modifies, using the pointer to a element of the waterbot class (see the menuitem class for details)
   b4266:	68d0      	ldr	r0, [r2, #12]
   b4268:	f8b2 e01c 	ldrh.w	lr, [r2, #28]
   b426c:	5a19      	ldrh	r1, [r3, r0]
   b426e:	458e      	cmp	lr, r1
   b4270:	bf82      	ittt	hi
   b4272:	8a92      	ldrhhi	r2, [r2, #20]
   b4274:	1889      	addhi	r1, r1, r2
   b4276:	5219      	strhhi	r1, [r3, r0]
   b4278:	e7f0      	b.n	b425c <_Z8rHandlerv+0x80>
   b427a:	bf00      	nop
   b427c:	2003daaa 	.word	0x2003daaa
   b4280:	2003dd74 	.word	0x2003dd74
   b4284:	2003daab 	.word	0x2003daab
   b4288:	2003dce4 	.word	0x2003dce4
   b428c:	2003dd64 	.word	0x2003dd64
   b4290:	2003dca4 	.word	0x2003dca4
   b4294:	2003dcd4 	.word	0x2003dcd4
   b4298:	2003de06 	.word	0x2003de06

000b429c <_Z8lHandlerv>:
void lHandler(){
   b429c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b429e:	4b27      	ldr	r3, [pc, #156]	; (b433c <_Z8lHandlerv+0xa0>)
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b42a0:	4d27      	ldr	r5, [pc, #156]	; (b4340 <_Z8lHandlerv+0xa4>)
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b42a2:	2401      	movs	r4, #1
   b42a4:	701c      	strb	r4, [r3, #0]
   b42a6:	f005 fd6b 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b42aa:	682b      	ldr	r3, [r5, #0]
   b42ac:	1ac0      	subs	r0, r0, r3
   b42ae:	2895      	cmp	r0, #149	; 0x95
   b42b0:	d942      	bls.n	b4338 <_Z8lHandlerv+0x9c>
   b42b2:	f005 fd65 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(selectingBots){                                      //If enter was hit over a menu item, the item will be open for modification, and this flag indicates true when not modifying items (i.e. selecting which bot to access)
   b42b6:	4b23      	ldr	r3, [pc, #140]	; (b4344 <_Z8lHandlerv+0xa8>)
   b42b8:	4923      	ldr	r1, [pc, #140]	; (b4348 <_Z8lHandlerv+0xac>)
   b42ba:	781e      	ldrb	r6, [r3, #0]
    debounceTime = millis();
   b42bc:	6028      	str	r0, [r5, #0]
    if(selectingBots){                                      //If enter was hit over a menu item, the item will be open for modification, and this flag indicates true when not modifying items (i.e. selecting which bot to access)
   b42be:	b1b6      	cbz	r6, b42ee <_Z8lHandlerv+0x52>
      : _M_current(__i) { }
   b42c0:	680b      	ldr	r3, [r1, #0]
        if(botSelect != WaterBots.front().botNum){          //Check if we are not at the leftmost bot in the list, otherwise we shouldn't try selecting a bot that doesn't exist
   b42c2:	4c22      	ldr	r4, [pc, #136]	; (b434c <_Z8lHandlerv+0xb0>)
   b42c4:	7898      	ldrb	r0, [r3, #2]
   b42c6:	7822      	ldrb	r2, [r4, #0]
   b42c8:	4290      	cmp	r0, r2
   b42ca:	d035      	beq.n	b4338 <_Z8lHandlerv+0x9c>
   b42cc:	684f      	ldr	r7, [r1, #4]
                    ControlledBot = &ws;
   b42ce:	f8df c084 	ldr.w	ip, [pc, #132]	; b4354 <_Z8lHandlerv+0xb8>
   b42d2:	2500      	movs	r5, #0
            for(WaterBot &ws: WaterBots){                   //Loop over the list of bots discovered
   b42d4:	429f      	cmp	r7, r3
   b42d6:	d02d      	beq.n	b4334 <_Z8lHandlerv+0x98>
                if(ws.botNum == botSelect){                 //Funky algorithm to find the bot next to the current bot in the list
   b42d8:	7899      	ldrb	r1, [r3, #2]
   b42da:	4291      	cmp	r1, r2
                    botSelect = newBotNum;
   b42dc:	bf01      	itttt	eq
   b42de:	4602      	moveq	r2, r0
   b42e0:	4611      	moveq	r1, r2
                    ControlledBot = &ws;
   b42e2:	f8cc 3000 	streq.w	r3, [ip]
   b42e6:	4635      	moveq	r5, r6
   b42e8:	3350      	adds	r3, #80	; 0x50
	return *this;
   b42ea:	4608      	mov	r0, r1
   b42ec:	e7f2      	b.n	b42d4 <_Z8lHandlerv+0x38>
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
   b42ee:	e9d1 3500 	ldrd	r3, r5, [r1]
            if(ws.botNum == botSelect){                     //If we find the one we're looking for in the list
   b42f2:	4e16      	ldr	r6, [pc, #88]	; (b434c <_Z8lHandlerv+0xb0>)
                MenuItem *curItem = SelectedItem;           //Take the current selected menu item
   b42f4:	4f16      	ldr	r7, [pc, #88]	; (b4350 <_Z8lHandlerv+0xb4>)
                modifiedValue = true;                       //Indicate to the main loop that some bot has a modified a value, so send out a new control packet
   b42f6:	f8df c060 	ldr.w	ip, [pc, #96]	; b4358 <_Z8lHandlerv+0xbc>
        for(WaterBot &ws: WaterBots){                       //Loop over all bots in the list of discovered bots
   b42fa:	429d      	cmp	r5, r3
   b42fc:	d01c      	beq.n	b4338 <_Z8lHandlerv+0x9c>
            if(ws.botNum == botSelect){                     //If we find the one we're looking for in the list
   b42fe:	7899      	ldrb	r1, [r3, #2]
   b4300:	7832      	ldrb	r2, [r6, #0]
   b4302:	4291      	cmp	r1, r2
   b4304:	d10a      	bne.n	b431c <_Z8lHandlerv+0x80>
                MenuItem *curItem = SelectedItem;           //Take the current selected menu item
   b4306:	683a      	ldr	r2, [r7, #0]
                if(curItem == nullptr) return;              //Make sure that there is a menu item currently selected
   b4308:	b1b2      	cbz	r2, b4338 <_Z8lHandlerv+0x9c>
                if(curItem->statOnly) return;               //Some menu items are a status-only display and can't be modified, so do nothing
   b430a:	7e11      	ldrb	r1, [r2, #24]
   b430c:	b9a1      	cbnz	r1, b4338 <_Z8lHandlerv+0x9c>
                if(curItem->onOffSetting){                  //If this is an on/off setting, then it must be a boolean, so set it false
   b430e:	7d90      	ldrb	r0, [r2, #22]
   b4310:	b130      	cbz	r0, b4320 <_Z8lHandlerv+0x84>
                    ws.*(curItem->MethodPointerBool) = false;   //Modify the boolean in the waterbot class that this menu item modifies, using the pointer to a element of the waterbot class (see the menuitem class for details)
   b4312:	6912      	ldr	r2, [r2, #16]
   b4314:	5499      	strb	r1, [r3, r2]
                modifiedValue = true;                       //Indicate to the main loop that some bot has a modified a value, so send out a new control packet
   b4316:	f88c 4000 	strb.w	r4, [ip]
                ws.updatedControl = true;                   //Indicate that this bot has a modified value
   b431a:	705c      	strb	r4, [r3, #1]
      operator++() _GLIBCXX_NOEXCEPT
   b431c:	3350      	adds	r3, #80	; 0x50
	return *this;
   b431e:	e7ec      	b.n	b42fa <_Z8lHandlerv+0x5e>
                    if(ws.*(curItem->MethodPointer) > curItem->minVal) ws.*(curItem->MethodPointer) -= curItem->stepSize;   //Decrement the counter in the waterbot class that this menu item modifies, using the pointer to a element of the waterbot class (see the menuitem class for details)
   b4320:	68d0      	ldr	r0, [r2, #12]
   b4322:	f8b2 e01a 	ldrh.w	lr, [r2, #26]
   b4326:	5a19      	ldrh	r1, [r3, r0]
   b4328:	458e      	cmp	lr, r1
   b432a:	bf3e      	ittt	cc
   b432c:	8a92      	ldrhcc	r2, [r2, #20]
   b432e:	1a89      	subcc	r1, r1, r2
   b4330:	5219      	strhcc	r1, [r3, r0]
   b4332:	e7f0      	b.n	b4316 <_Z8lHandlerv+0x7a>
   b4334:	b105      	cbz	r5, b4338 <_Z8lHandlerv+0x9c>
   b4336:	7022      	strb	r2, [r4, #0]
}
   b4338:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   b433a:	bf00      	nop
   b433c:	2003daaa 	.word	0x2003daaa
   b4340:	2003dd74 	.word	0x2003dd74
   b4344:	2003daab 	.word	0x2003daab
   b4348:	2003dce4 	.word	0x2003dce4
   b434c:	2003dd64 	.word	0x2003dd64
   b4350:	2003dcd4 	.word	0x2003dcd4
   b4354:	2003dca4 	.word	0x2003dca4
   b4358:	2003de06 	.word	0x2003de06

000b435c <_Z10entHandlerv>:
void entHandler(){
   b435c:	b538      	push	{r3, r4, r5, lr}
    redrawMenu = true;                  //Always redraw to fix any bugs of not updating the screen when modifying values
   b435e:	4b11      	ldr	r3, [pc, #68]	; (b43a4 <_Z10entHandlerv+0x48>)
    if(millis()-debounceTime < DEBOUNCE_MS) return;     //Debounce the button to ensure only one trigger per press
   b4360:	4d11      	ldr	r5, [pc, #68]	; (b43a8 <_Z10entHandlerv+0x4c>)
    redrawMenu = true;                  //Always redraw to fix any bugs of not updating the screen when modifying values
   b4362:	2401      	movs	r4, #1
   b4364:	701c      	strb	r4, [r3, #0]
   b4366:	f005 fd0b 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;     //Debounce the button to ensure only one trigger per press
   b436a:	682b      	ldr	r3, [r5, #0]
   b436c:	1ac0      	subs	r0, r0, r3
   b436e:	2895      	cmp	r0, #149	; 0x95
   b4370:	d909      	bls.n	b4386 <_Z10entHandlerv+0x2a>
   b4372:	f005 fd05 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b4376:	4a0d      	ldr	r2, [pc, #52]	; (b43ac <_Z10entHandlerv+0x50>)
    debounceTime = millis();                            //Reset debounce timer
   b4378:	6028      	str	r0, [r5, #0]
    if(PopUps.size() != 0){                             //Dismiss a pop up if there is one
   b437a:	e9d2 1300 	ldrd	r1, r3, [r2]
   b437e:	428b      	cmp	r3, r1
   b4380:	d002      	beq.n	b4388 <_Z10entHandlerv+0x2c>
       */
      void
      pop_back() _GLIBCXX_NOEXCEPT
      {
	__glibcxx_requires_nonempty();
	--this->_M_impl._M_finish;
   b4382:	3b49      	subs	r3, #73	; 0x49
   b4384:	6053      	str	r3, [r2, #4]
}
   b4386:	bd38      	pop	{r3, r4, r5, pc}
    selectingBots = !selectingBots;                     //Switch between selecting bots or selecting menu items
   b4388:	4a09      	ldr	r2, [pc, #36]	; (b43b0 <_Z10entHandlerv+0x54>)
   b438a:	7813      	ldrb	r3, [r2, #0]
   b438c:	f083 0301 	eor.w	r3, r3, #1
   b4390:	7013      	strb	r3, [r2, #0]
    if(modifiedValue){                                  //Check if the left or right buttons were pressed to modify menu values, if so then signal to send out status updates immediately
   b4392:	4b08      	ldr	r3, [pc, #32]	; (b43b4 <_Z10entHandlerv+0x58>)
   b4394:	781a      	ldrb	r2, [r3, #0]
   b4396:	2a00      	cmp	r2, #0
   b4398:	d0f5      	beq.n	b4386 <_Z10entHandlerv+0x2a>
        updateControl = true;
   b439a:	4a07      	ldr	r2, [pc, #28]	; (b43b8 <_Z10entHandlerv+0x5c>)
   b439c:	7014      	strb	r4, [r2, #0]
        modifiedValue = false;
   b439e:	2200      	movs	r2, #0
   b43a0:	701a      	strb	r2, [r3, #0]
   b43a2:	e7f0      	b.n	b4386 <_Z10entHandlerv+0x2a>
   b43a4:	2003daaa 	.word	0x2003daaa
   b43a8:	2003dd74 	.word	0x2003dd74
   b43ac:	2003dcc4 	.word	0x2003dcc4
   b43b0:	2003daab 	.word	0x2003daab
   b43b4:	2003de06 	.word	0x2003de06
   b43b8:	2003e638 	.word	0x2003e638

000b43bc <_ZNSt17_Function_handlerIFvvEPS0_E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation>:
	switch (__op)
   b43bc:	2a01      	cmp	r2, #1
   b43be:	d102      	bne.n	b43c6 <_ZNSt17_Function_handlerIFvvEPS0_E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0xa>
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
   b43c0:	6001      	str	r1, [r0, #0]
      }
   b43c2:	2000      	movs	r0, #0
   b43c4:	4770      	bx	lr
	  switch (__op)
   b43c6:	2a02      	cmp	r2, #2
	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
   b43c8:	bf04      	itt	eq
   b43ca:	680b      	ldreq	r3, [r1, #0]
   b43cc:	6003      	streq	r3, [r0, #0]
	      break;
   b43ce:	e7f8      	b.n	b43c2 <_ZNSt17_Function_handlerIFvvEPS0_E10_M_managerERSt9_Any_dataRKS3_St18_Manager_operation+0x6>

000b43d0 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
   b43d0:	6803      	ldr	r3, [r0, #0]
   b43d2:	4718      	bx	r3

000b43d4 <_ZN5Print6printfEPKcz>:
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);
    size_t println(const __FlashStringHelper*);

    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b43d4:	b40e      	push	{r1, r2, r3}
   b43d6:	b503      	push	{r0, r1, lr}
   b43d8:	ab03      	add	r3, sp, #12
    {
        va_list args;
        va_start(args, format);
        auto r = this->vprintf(false, format, args);
   b43da:	2100      	movs	r1, #0
    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b43dc:	f853 2b04 	ldr.w	r2, [r3], #4
        va_start(args, format);
   b43e0:	9301      	str	r3, [sp, #4]
        auto r = this->vprintf(false, format, args);
   b43e2:	f008 fe08 	bl	bcff6 <_ZN5Print7vprintfEbPKcSt9__va_list>
        va_end(args);
        return r;
    }
   b43e6:	b002      	add	sp, #8
   b43e8:	f85d eb04 	ldr.w	lr, [sp], #4
   b43ec:	b003      	add	sp, #12
   b43ee:	4770      	bx	lr

000b43f0 <_ZNK8particle11SPISettings7printToER5Print>:
  bool operator!=(const SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
   b43f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   b43f2:	4604      	mov	r4, r0
   b43f4:	4608      	mov	r0, r1
  {
    if (default_ && clock_ == 0)
   b43f6:	7922      	ldrb	r2, [r4, #4]
   b43f8:	68a3      	ldr	r3, [r4, #8]
   b43fa:	b132      	cbz	r2, b440a <_ZNK8particle11SPISettings7printToER5Print+0x1a>
   b43fc:	b9a3      	cbnz	r3, b4428 <_ZNK8particle11SPISettings7printToER5Print+0x38>
      return p.print("<SPISettings default>");
   b43fe:	490b      	ldr	r1, [pc, #44]	; (b442c <_ZNK8particle11SPISettings7printToER5Print+0x3c>)
    else
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
          bitOrder_ == MSBFIRST ? "MSB" : "LSB", (unsigned int)dataMode_);
  }
   b4400:	b002      	add	sp, #8
   b4402:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return p.print("<SPISettings default>");
   b4406:	f008 bdbb 	b.w	bcf80 <_ZN5Print5printEPKc>
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
   b440a:	4a09      	ldr	r2, [pc, #36]	; (b4430 <_ZNK8particle11SPISettings7printToER5Print+0x40>)
   b440c:	7b26      	ldrb	r6, [r4, #12]
   b440e:	4d09      	ldr	r5, [pc, #36]	; (b4434 <_ZNK8particle11SPISettings7printToER5Print+0x44>)
   b4410:	4909      	ldr	r1, [pc, #36]	; (b4438 <_ZNK8particle11SPISettings7printToER5Print+0x48>)
   b4412:	7b64      	ldrb	r4, [r4, #13]
   b4414:	2e01      	cmp	r6, #1
   b4416:	bf18      	it	ne
   b4418:	4629      	movne	r1, r5
   b441a:	e9cd 1400 	strd	r1, r4, [sp]
   b441e:	4907      	ldr	r1, [pc, #28]	; (b443c <_ZNK8particle11SPISettings7printToER5Print+0x4c>)
   b4420:	f7ff ffd8 	bl	b43d4 <_ZN5Print6printfEPKcz>
  }
   b4424:	b002      	add	sp, #8
   b4426:	bd70      	pop	{r4, r5, r6, pc}
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
   b4428:	4a05      	ldr	r2, [pc, #20]	; (b4440 <_ZNK8particle11SPISettings7printToER5Print+0x50>)
   b442a:	e7ef      	b.n	b440c <_ZNK8particle11SPISettings7printToER5Print+0x1c>
   b442c:	000c0fde 	.word	0x000c0fde
   b4430:	000c1076 	.word	0x000c1076
   b4434:	000c0fda 	.word	0x000c0fda
   b4438:	000c0fd6 	.word	0x000c0fd6
   b443c:	000c0ff4 	.word	0x000c0ff4
   b4440:	000c0fcd 	.word	0x000c0fcd

000b4444 <_ZN5Print8printlnfEPKcz>:

    size_t printlnf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b4444:	b40e      	push	{r1, r2, r3}
   b4446:	b503      	push	{r0, r1, lr}
   b4448:	ab03      	add	r3, sp, #12
    {
        va_list args;
        va_start(args, format);
        auto r = this->vprintf(true, format, args);
   b444a:	2101      	movs	r1, #1
    size_t printlnf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
   b444c:	f853 2b04 	ldr.w	r2, [r3], #4
        va_start(args, format);
   b4450:	9301      	str	r3, [sp, #4]
        auto r = this->vprintf(true, format, args);
   b4452:	f008 fdd0 	bl	bcff6 <_ZN5Print7vprintfEbPKcSt9__va_list>
        va_end(args);
        return r;
    }
   b4456:	b002      	add	sp, #8
   b4458:	f85d eb04 	ldr.w	lr, [sp], #4
   b445c:	b003      	add	sp, #12
   b445e:	4770      	bx	lr

000b4460 <_ZNSt14_Function_baseD1Ev>:
    ~_Function_base()
   b4460:	b510      	push	{r4, lr}
      if (_M_manager)
   b4462:	6883      	ldr	r3, [r0, #8]
    ~_Function_base()
   b4464:	4604      	mov	r4, r0
      if (_M_manager)
   b4466:	b113      	cbz	r3, b446e <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   b4468:	2203      	movs	r2, #3
   b446a:	4601      	mov	r1, r0
   b446c:	4798      	blx	r3
    }
   b446e:	4620      	mov	r0, r4
   b4470:	bd10      	pop	{r4, pc}
	...

000b4474 <_ZN5TimerD1Ev>:
    virtual ~Timer() {
   b4474:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b4476:	4b13      	ldr	r3, [pc, #76]	; (b44c4 <_ZN5TimerD1Ev+0x50>)
   b4478:	6003      	str	r3, [r0, #0]
   b447a:	4604      	mov	r4, r0
        if (handle) {
   b447c:	6880      	ldr	r0, [r0, #8]
   b447e:	b1c8      	cbz	r0, b44b4 <_ZN5TimerD1Ev+0x40>
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
   b4480:	2500      	movs	r5, #0
   b4482:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   b4486:	e9cd 3500 	strd	r3, r5, [sp]
   b448a:	2102      	movs	r1, #2
   b448c:	462b      	mov	r3, r5
   b448e:	462a      	mov	r2, r5
   b4490:	f005 fd60 	bl	b9f54 <os_timer_change>
            os_timer_set_id(handle, nullptr);
   b4494:	68a0      	ldr	r0, [r4, #8]
   b4496:	4629      	mov	r1, r5
   b4498:	f005 fd7c 	bl	b9f94 <os_timer_set_id>
            while (running) {
   b449c:	7923      	ldrb	r3, [r4, #4]
   b449e:	f003 05ff 	and.w	r5, r3, #255	; 0xff
   b44a2:	b113      	cbz	r3, b44aa <_ZN5TimerD1Ev+0x36>
                os_thread_yield();
   b44a4:	f005 fd2e 	bl	b9f04 <os_thread_yield>
            while (running) {
   b44a8:	e7f8      	b.n	b449c <_ZN5TimerD1Ev+0x28>
            os_timer_destroy(handle, nullptr);
   b44aa:	68a0      	ldr	r0, [r4, #8]
   b44ac:	4629      	mov	r1, r5
   b44ae:	f005 fd41 	bl	b9f34 <os_timer_destroy>
            handle = nullptr;
   b44b2:	60a5      	str	r5, [r4, #8]
    class function<_Res(_ArgTypes...)>
   b44b4:	f104 000c 	add.w	r0, r4, #12
   b44b8:	f7ff ffd2 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
    }
   b44bc:	4620      	mov	r0, r4
   b44be:	b003      	add	sp, #12
   b44c0:	bd30      	pop	{r4, r5, pc}
   b44c2:	bf00      	nop
   b44c4:	000c142c 	.word	0x000c142c

000b44c8 <_ZN5TimerD0Ev>:
    virtual ~Timer() {
   b44c8:	b510      	push	{r4, lr}
   b44ca:	4604      	mov	r4, r0
    }
   b44cc:	f7ff ffd2 	bl	b4474 <_ZN5TimerD1Ev>
   b44d0:	4620      	mov	r0, r4
   b44d2:	211c      	movs	r1, #28
   b44d4:	f7ff fde3 	bl	b409e <_ZdlPvj>
   b44d8:	4620      	mov	r0, r4
   b44da:	bd10      	pop	{r4, pc}

000b44dc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>:
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
   b44dc:	b510      	push	{r4, lr}
      if (--_M_use_count == 0)
   b44de:	6843      	ldr	r3, [r0, #4]
   b44e0:	3b01      	subs	r3, #1
    {
   b44e2:	4604      	mov	r4, r0
      if (--_M_use_count == 0)
   b44e4:	6043      	str	r3, [r0, #4]
   b44e6:	b963      	cbnz	r3, b4502 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv+0x26>
        {
          _M_dispose();
   b44e8:	6803      	ldr	r3, [r0, #0]
   b44ea:	689b      	ldr	r3, [r3, #8]
   b44ec:	4798      	blx	r3
          if (--_M_weak_count == 0)
   b44ee:	68a3      	ldr	r3, [r4, #8]
   b44f0:	3b01      	subs	r3, #1
   b44f2:	60a3      	str	r3, [r4, #8]
   b44f4:	b92b      	cbnz	r3, b4502 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv+0x26>
            _M_destroy();
   b44f6:	6823      	ldr	r3, [r4, #0]
   b44f8:	4620      	mov	r0, r4
   b44fa:	68db      	ldr	r3, [r3, #12]
        }
    }
   b44fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            _M_destroy();
   b4500:	4718      	bx	r3
    }
   b4502:	bd10      	pop	{r4, pc}

000b4504 <_ZN7FatFile4openEPKci>:
  bool open(const char* path, oflag_t oflag = O_RDONLY) {
   b4504:	4613      	mov	r3, r2
    return open(m_cwd, path, oflag);
   b4506:	460a      	mov	r2, r1
   b4508:	4901      	ldr	r1, [pc, #4]	; (b4510 <_ZN7FatFile4openEPKci+0xc>)
   b450a:	6809      	ldr	r1, [r1, #0]
   b450c:	f004 bcbd 	b.w	b8e8a <_ZN7FatFile4openEPS_PKci>
   b4510:	2003e64c 	.word	0x2003e64c

000b4514 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv>:
void offloadDataReceived(const uint8_t* data, size_t len, const BlePeerDevice& peer, void* context) {
   b4514:	b5f0      	push	{r4, r5, r6, r7, lr}
   b4516:	b095      	sub	sp, #84	; 0x54
   b4518:	4604      	mov	r4, r0
   b451a:	af00      	add	r7, sp, #0
   b451c:	460d      	mov	r5, r1
    memset(fileCommand,0,8 + MAX_FILENAME_LEN);
   b451e:	221e      	movs	r2, #30
   b4520:	2100      	movs	r1, #0
   b4522:	f107 0030 	add.w	r0, r7, #48	; 0x30
   b4526:	f00a fce8 	bl	beefa <memset>
    memcpy(fileCommand,data,8);
   b452a:	6820      	ldr	r0, [r4, #0]
   b452c:	6861      	ldr	r1, [r4, #4]
   b452e:	f107 0328 	add.w	r3, r7, #40	; 0x28
   b4532:	c303      	stmia	r3!, {r0, r1}
    if(fileCommand[0] == 'f'){      //Check if we received a file string or if we received a command for making a file or quitting
   b4534:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   b4538:	2b66      	cmp	r3, #102	; 0x66
    myFile.print(dataStr);          //Print it to the file that is now on the SD card here
   b453a:	466e      	mov	r6, sp
    if(fileCommand[0] == 'f'){      //Check if we received a file string or if we received a command for making a file or quitting
   b453c:	d150      	bne.n	b45e0 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xcc>
        if(!strcmp(fileCommand,"filename")){        //Filename command creates a new file named with the characters following in the data string
   b453e:	4930      	ldr	r1, [pc, #192]	; (b4600 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xec>)
   b4540:	f107 0028 	add.w	r0, r7, #40	; 0x28
   b4544:	f00a fd1f 	bl	bef86 <strcmp>
   b4548:	bb90      	cbnz	r0, b45b0 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x9c>
    return m_attr;
   b454a:	482e      	ldr	r0, [pc, #184]	; (b4604 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf0>)
            if(myFile.isOpen()) myFile.close();     //Close the current file
   b454c:	7c03      	ldrb	r3, [r0, #16]
   b454e:	b113      	cbz	r3, b4556 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x42>
   b4550:	3010      	adds	r0, #16
   b4552:	f004 fc93 	bl	b8e7c <_ZN7FatFile5closeEv>
            memcpy(fileCommand,data,8 + MAX_FILENAME_LEN);      //Copy int he new filename from the received data
   b4556:	4623      	mov	r3, r4
   b4558:	f107 0228 	add.w	r2, r7, #40	; 0x28
   b455c:	f104 0520 	add.w	r5, r4, #32
   b4560:	6818      	ldr	r0, [r3, #0]
   b4562:	6859      	ldr	r1, [r3, #4]
   b4564:	4614      	mov	r4, r2
   b4566:	c403      	stmia	r4!, {r0, r1}
   b4568:	3308      	adds	r3, #8
   b456a:	42ab      	cmp	r3, r5
   b456c:	4622      	mov	r2, r4
   b456e:	d1f7      	bne.n	b4560 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x4c>
   b4570:	6818      	ldr	r0, [r3, #0]
   b4572:	6020      	str	r0, [r4, #0]
   b4574:	889b      	ldrh	r3, [r3, #4]
   b4576:	80a3      	strh	r3, [r4, #4]
            strncpy(offloadFilename,fileCommand+8,MAX_FILENAME_LEN);
   b4578:	221e      	movs	r2, #30
   b457a:	f107 0130 	add.w	r1, r7, #48	; 0x30
   b457e:	4822      	ldr	r0, [pc, #136]	; (b4608 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf4>)
   b4580:	f00a fd4d 	bl	bf01e <strncpy>
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b4584:	2300      	movs	r3, #0
    return file.open(this, path, O_RDONLY);
   b4586:	4a20      	ldr	r2, [pc, #128]	; (b4608 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf4>)
   b4588:	4920      	ldr	r1, [pc, #128]	; (b460c <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf8>)
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b458a:	607b      	str	r3, [r7, #4]
    return file.open(this, path, O_RDONLY);
   b458c:	1d38      	adds	r0, r7, #4
   b458e:	f004 fc7c 	bl	b8e8a <_ZN7FatFile4openEPS_PKci>
            if(sd.exists(offloadFilename)){         //Try to open a file with the received name
   b4592:	b118      	cbz	r0, b459c <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x88>
  *
  * \return The value true is returned for success and
  * the value false is returned for failure.
  */
  bool remove(const char* path) {
    return FatFile::remove(vwd(), path);
   b4594:	491c      	ldr	r1, [pc, #112]	; (b4608 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf4>)
   b4596:	481d      	ldr	r0, [pc, #116]	; (b460c <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf8>)
   b4598:	f004 fcc3 	bl	b8f22 <_ZN7FatFile6removeEPS_PKc>
            myFile.open(offloadFilename, O_RDWR | O_CREAT | O_AT_END);
   b459c:	491a      	ldr	r1, [pc, #104]	; (b4608 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf4>)
   b459e:	481c      	ldr	r0, [pc, #112]	; (b4610 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xfc>)
   b45a0:	f244 2202 	movw	r2, #16898	; 0x4202
   b45a4:	f7ff ffae 	bl	b4504 <_ZN7FatFile4openEPKci>
}
   b45a8:	3754      	adds	r7, #84	; 0x54
   b45aa:	46b5      	mov	sp, r6
   b45ac:	46bd      	mov	sp, r7
   b45ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if(!strcmp(fileCommand,"filecomp")){       //Command to indicate that we have reached the end of the currently copyin file
   b45b0:	4918      	ldr	r1, [pc, #96]	; (b4614 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x100>)
   b45b2:	f107 0028 	add.w	r0, r7, #40	; 0x28
   b45b6:	f00a fce6 	bl	bef86 <strcmp>
   b45ba:	b938      	cbnz	r0, b45cc <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xb8>
    return m_attr;
   b45bc:	4b11      	ldr	r3, [pc, #68]	; (b4604 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf0>)
            if(myFile.isOpen()) myFile.close();
   b45be:	7c1b      	ldrb	r3, [r3, #16]
   b45c0:	2b00      	cmp	r3, #0
   b45c2:	d0f1      	beq.n	b45a8 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x94>
   b45c4:	4812      	ldr	r0, [pc, #72]	; (b4610 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xfc>)
   b45c6:	f004 fc59 	bl	b8e7c <_ZN7FatFile5closeEv>
   b45ca:	e7ed      	b.n	b45a8 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x94>
        else if(!strcmp(fileCommand,"filedone")){       //Command to indicate that we are done copying all files
   b45cc:	4912      	ldr	r1, [pc, #72]	; (b4618 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x104>)
   b45ce:	f107 0028 	add.w	r0, r7, #40	; 0x28
   b45d2:	f00a fcd8 	bl	bef86 <strcmp>
   b45d6:	b918      	cbnz	r0, b45e0 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xcc>
            offloadingDone = true;                      //Set flag to break the loop in the offloading function
   b45d8:	4b10      	ldr	r3, [pc, #64]	; (b461c <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x108>)
   b45da:	2201      	movs	r2, #1
   b45dc:	701a      	strb	r2, [r3, #0]
   b45de:	e7ed      	b.n	b45bc <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xa8>
    char dataStr[len];      
   b45e0:	1deb      	adds	r3, r5, #7
   b45e2:	f023 0307 	bic.w	r3, r3, #7
   b45e6:	ebad 0d03 	sub.w	sp, sp, r3
    memcpy(dataStr,data,len);       //Copy that data from the byte array
   b45ea:	4621      	mov	r1, r4
   b45ec:	462a      	mov	r2, r5
   b45ee:	4668      	mov	r0, sp
   b45f0:	f00a fc5b 	bl	beeaa <memcpy>
    myFile.print(dataStr);          //Print it to the file that is now on the SD card here
   b45f4:	4669      	mov	r1, sp
   b45f6:	4803      	ldr	r0, [pc, #12]	; (b4604 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0xf0>)
   b45f8:	f008 fcc2 	bl	bcf80 <_ZN5Print5printEPKc>
   b45fc:	e7d4      	b.n	b45a8 <_Z19offloadDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x94>
   b45fe:	bf00      	nop
   b4600:	000c1011 	.word	0x000c1011
   b4604:	2003de08 	.word	0x2003de08
   b4608:	2003de3c 	.word	0x2003de3c
   b460c:	2003e5e8 	.word	0x2003e5e8
   b4610:	2003de18 	.word	0x2003de18
   b4614:	000c101a 	.word	0x000c101a
   b4618:	000c1023 	.word	0x000c1023
   b461c:	2003de5a 	.word	0x2003de5a

000b4620 <_ZN5SdFat5beginEhN8particle11SPISettingsE>:
   *
   * \param[in] csPin SD card chip select pin.
   * \param[in] spiSettings SPI speed, mode, and bit order.
   * \return true for success else false.
   */
  bool begin(uint8_t csPin = SS, SPISettings spiSettings = SPI_FULL_SPEED) {
   b4620:	b530      	push	{r4, r5, lr}
   b4622:	b085      	sub	sp, #20
class SPISettings : public Printable {
   b4624:	4b1b      	ldr	r3, [pc, #108]	; (b4694 <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x74>)
   b4626:	9300      	str	r3, [sp, #0]
   b4628:	7913      	ldrb	r3, [r2, #4]
   b462a:	f88d 3004 	strb.w	r3, [sp, #4]
   b462e:	6893      	ldr	r3, [r2, #8]
   b4630:	9302      	str	r3, [sp, #8]
    return m_card.begin(&m_spi, csPin, spiSettings) &&
   b4632:	f500 658c 	add.w	r5, r0, #1120	; 0x460
   b4636:	8993      	ldrh	r3, [r2, #12]
   b4638:	f8ad 300c 	strh.w	r3, [sp, #12]
  bool begin(uint8_t csPin = SS, SPISettings spiSettings = SPI_FULL_SPEED) {
   b463c:	4604      	mov	r4, r0
    return m_card.begin(&m_spi, csPin, spiSettings) &&
   b463e:	460a      	mov	r2, r1
   b4640:	466b      	mov	r3, sp
   b4642:	f200 416c 	addw	r1, r0, #1132	; 0x46c
   b4646:	4628      	mov	r0, r5
   b4648:	f004 ffb8 	bl	b95bc <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE>
   b464c:	b910      	cbnz	r0, b4654 <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x34>
   b464e:	2000      	movs	r0, #0
           SdFileSystem::begin();
  }
   b4650:	b005      	add	sp, #20
   b4652:	bd30      	pop	{r4, r5, pc}
    m_blockDev = blockDev;
   b4654:	6025      	str	r5, [r4, #0]
  FatVolume* vol() {
    return this;
  }
  /** \return a pointer to the volume working directory. */
  FatFile* vwd() {
    return &m_vwd;
   b4656:	f204 453c 	addw	r5, r4, #1084	; 0x43c
    vwd()->close();
   b465a:	4628      	mov	r0, r5
   b465c:	f004 fc0e 	bl	b8e7c <_ZN7FatFile5closeEv>
    return (part ? init(part) : init(1) || init(0))
   b4660:	2101      	movs	r1, #1
   b4662:	4620      	mov	r0, r4
   b4664:	f004 fe54 	bl	b9310 <_ZN9FatVolume4initEh>
   b4668:	4601      	mov	r1, r0
   b466a:	b168      	cbz	r0, b4688 <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x68>
            && vwd()->openRoot(this) && FatFile::setCwd(vwd());
   b466c:	4621      	mov	r1, r4
   b466e:	4628      	mov	r0, r5
   b4670:	f004 fa3b 	bl	b8aea <_ZN7FatFile8openRootEP9FatVolume>
   b4674:	2800      	cmp	r0, #0
   b4676:	d0ea      	beq.n	b464e <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x2e>
    if (!dir->isDir()) {
   b4678:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
   b467c:	f013 0f70 	tst.w	r3, #112	; 0x70
   b4680:	d0e5      	beq.n	b464e <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x2e>
    m_cwd = dir;
   b4682:	4b05      	ldr	r3, [pc, #20]	; (b4698 <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x78>)
   b4684:	601d      	str	r5, [r3, #0]
    return true;
   b4686:	e7e3      	b.n	b4650 <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x30>
    return (part ? init(part) : init(1) || init(0))
   b4688:	4620      	mov	r0, r4
   b468a:	f004 fe41 	bl	b9310 <_ZN9FatVolume4initEh>
   b468e:	2800      	cmp	r0, #0
   b4690:	d1ec      	bne.n	b466c <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x4c>
   b4692:	e7dc      	b.n	b464e <_ZN5SdFat5beginEhN8particle11SPISettingsE+0x2e>
   b4694:	000c1418 	.word	0x000c1418
   b4698:	2003e64c 	.word	0x2003e64c

000b469c <_Z10logMessagePKc>:
void logMessage(const char *message){           //Function to take a string and log it to the SD card by opening/closing the file
   b469c:	b538      	push	{r3, r4, r5, lr}
    return m_attr;
   b469e:	4c0d      	ldr	r4, [pc, #52]	; (b46d4 <_Z10logMessagePKc+0x38>)
    if(!logFile.isOpen()){                      //if the file is not open, open it and then close it afterwards to ensure changes take place
   b46a0:	7c23      	ldrb	r3, [r4, #16]
void logMessage(const char *message){           //Function to take a string and log it to the SD card by opening/closing the file
   b46a2:	4605      	mov	r5, r0
    if(!logFile.isOpen()){                      //if the file is not open, open it and then close it afterwards to ensure changes take place
   b46a4:	b983      	cbnz	r3, b46c8 <_Z10logMessagePKc+0x2c>
        logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b46a6:	490c      	ldr	r1, [pc, #48]	; (b46d8 <_Z10logMessagePKc+0x3c>)
   b46a8:	f244 2202 	movw	r2, #16898	; 0x4202
   b46ac:	f104 0010 	add.w	r0, r4, #16
   b46b0:	f7ff ff28 	bl	b4504 <_ZN7FatFile4openEPKci>
        logFile.println(message);
   b46b4:	4629      	mov	r1, r5
   b46b6:	4620      	mov	r0, r4
   b46b8:	f008 fc75 	bl	bcfa6 <_ZN5Print7printlnEPKc>
        logFile.close();
   b46bc:	f104 0010 	add.w	r0, r4, #16
}
   b46c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        logFile.close();
   b46c4:	f004 bbda 	b.w	b8e7c <_ZN7FatFile5closeEv>
    else logFile.println(message);
   b46c8:	4601      	mov	r1, r0
   b46ca:	4620      	mov	r0, r4
}
   b46cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    else logFile.println(message);
   b46d0:	f008 bc69 	b.w	bcfa6 <_ZN5Print7printlnEPKc>
   b46d4:	2003ddd0 	.word	0x2003ddd0
   b46d8:	2003dd78 	.word	0x2003dd78

000b46dc <_ZN8WaterBotC1Ev>:
class WaterBot{
   b46dc:	b510      	push	{r4, lr}
   b46de:	f44f 7180 	mov.w	r1, #256	; 0x100
   b46e2:	4c0e      	ldr	r4, [pc, #56]	; (b471c <_ZN8WaterBotC1Ev+0x40>)
   b46e4:	8001      	strh	r1, [r0, #0]
   b46e6:	2200      	movs	r2, #0
   b46e8:	8281      	strh	r1, [r0, #20]
   b46ea:	490d      	ldr	r1, [pc, #52]	; (b4720 <_ZN8WaterBotC1Ev+0x44>)
   b46ec:	6181      	str	r1, [r0, #24]
   b46ee:	e9c0 2401 	strd	r2, r4, [r0, #4]
   b46f2:	61c1      	str	r1, [r0, #28]
   b46f4:	2401      	movs	r4, #1
   b46f6:	2100      	movs	r1, #0
   b46f8:	e9c0 2210 	strd	r2, r2, [r0, #64]	; 0x40
   b46fc:	e9c0 2212 	strd	r2, r2, [r0, #72]	; 0x48
   b4700:	7304      	strb	r4, [r0, #12]
   b4702:	81c2      	strh	r2, [r0, #14]
   b4704:	6102      	str	r2, [r0, #16]
   b4706:	7582      	strb	r2, [r0, #22]
   b4708:	6201      	str	r1, [r0, #32]
   b470a:	6241      	str	r1, [r0, #36]	; 0x24
   b470c:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
   b4710:	62c1      	str	r1, [r0, #44]	; 0x2c
   b4712:	6301      	str	r1, [r0, #48]	; 0x30
   b4714:	6341      	str	r1, [r0, #52]	; 0x34
   b4716:	6381      	str	r1, [r0, #56]	; 0x38
   b4718:	63c1      	str	r1, [r0, #60]	; 0x3c
   b471a:	bd10      	pop	{r4, pc}
   b471c:	01010000 	.word	0x01010000
   b4720:	c479c000 	.word	0xc479c000

000b4724 <_Z17processRPiCommandPKch>:
void processRPiCommand(const char *command, uint8_t mode){
   b4724:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   b4728:	b095      	sub	sp, #84	; 0x54
    if(command[0] == 'R' && command[1] == 'P'){         //Check that we have received a Pi message and not some kind of garbage
   b472a:	7803      	ldrb	r3, [r0, #0]
   b472c:	2b52      	cmp	r3, #82	; 0x52
void processRPiCommand(const char *command, uint8_t mode){
   b472e:	af06      	add	r7, sp, #24
   b4730:	4604      	mov	r4, r0
    if(command[0] == 'R' && command[1] == 'P'){         //Check that we have received a Pi message and not some kind of garbage
   b4732:	d15b      	bne.n	b47ec <_Z17processRPiCommandPKch+0xc8>
   b4734:	7843      	ldrb	r3, [r0, #1]
   b4736:	2b50      	cmp	r3, #80	; 0x50
   b4738:	d158      	bne.n	b47ec <_Z17processRPiCommandPKch+0xc8>
        char dataStr[strlen(command)-8];                //String to hold the data portion of the command
   b473a:	f00a fc54 	bl	befe6 <strlen>
   b473e:	3801      	subs	r0, #1
   b4740:	f020 0007 	bic.w	r0, r0, #7
        }
   b4744:	46e8      	mov	r8, sp
        char dataStr[strlen(command)-8];                //String to hold the data portion of the command
   b4746:	ebad 0d00 	sub.w	sp, sp, r0
        dataStr[strlen(command)-9] = '\0';              //Put null terminator so string functions don't flow into surrounding memory - a time-costly bug
   b474a:	4620      	mov	r0, r4
   b474c:	f00a fc4b 	bl	befe6 <strlen>
        char dataStr[strlen(command)-8];                //String to hold the data portion of the command
   b4750:	f10d 0918 	add.w	r9, sp, #24
        dataStr[strlen(command)-9] = '\0';              //Put null terminator so string functions don't flow into surrounding memory - a time-costly bug
   b4754:	4448      	add	r0, r9
   b4756:	2500      	movs	r5, #0
   b4758:	f800 5c09 	strb.w	r5, [r0, #-9]
        checkStr[0] = command[strlen(command)-2];       //Get last two characters
   b475c:	4620      	mov	r0, r4
        cmdStr[3] = '\0';                               //Termination character to use string compare properly
   b475e:	74fd      	strb	r5, [r7, #19]
        checkStr[0] = command[strlen(command)-2];       //Get last two characters
   b4760:	f00a fc41 	bl	befe6 <strlen>
   b4764:	4420      	add	r0, r4
   b4766:	f810 3c02 	ldrb.w	r3, [r0, #-2]
   b476a:	733b      	strb	r3, [r7, #12]
        checkStr[1] = command[strlen(command)-1];
   b476c:	4620      	mov	r0, r4
   b476e:	f00a fc3a 	bl	befe6 <strlen>
   b4772:	4420      	add	r0, r4
        checksum = (uint8_t)strtol(checkStr, NULL, 16);       // number base 16
   b4774:	4629      	mov	r1, r5
        checkStr[1] = command[strlen(command)-1];
   b4776:	f810 3c01 	ldrb.w	r3, [r0, #-1]
        checkStr[2] = '\0';                             
   b477a:	73bd      	strb	r5, [r7, #14]
        checksum = (uint8_t)strtol(checkStr, NULL, 16);       // number base 16
   b477c:	2210      	movs	r2, #16
   b477e:	f107 000c 	add.w	r0, r7, #12
        checkStr[1] = command[strlen(command)-1];
   b4782:	737b      	strb	r3, [r7, #13]
        checksum = (uint8_t)strtol(checkStr, NULL, 16);       // number base 16
   b4784:	f00b fb1c 	bl	bfdc0 <strtol>
        for(uint8_t i = 4; i < strlen(command)-2;i++){  //Copy in data characters to data string
   b4788:	2504      	movs	r5, #4
        checksum = (uint8_t)strtol(checkStr, NULL, 16);       // number base 16
   b478a:	4606      	mov	r6, r0
        for(uint8_t i = 4; i < strlen(command)-2;i++){  //Copy in data characters to data string
   b478c:	4620      	mov	r0, r4
   b478e:	f00a fc2a 	bl	befe6 <strlen>
   b4792:	3802      	subs	r0, #2
   b4794:	4285      	cmp	r5, r0
   b4796:	d212      	bcs.n	b47be <_Z17processRPiCommandPKch+0x9a>
            if(i < 7) cmdStr[i-4] = command[i];
   b4798:	2d06      	cmp	r5, #6
   b479a:	bf9b      	ittet	ls
   b479c:	f107 0338 	addls.w	r3, r7, #56	; 0x38
   b47a0:	195b      	addls	r3, r3, r5
            else dataStr[i-7] = command[i];
   b47a2:	eb09 0305 	addhi.w	r3, r9, r5
            if(i < 7) cmdStr[i-4] = command[i];
   b47a6:	5d62      	ldrbls	r2, [r4, r5]
            else dataStr[i-7] = command[i];
   b47a8:	bf8c      	ite	hi
   b47aa:	5d62      	ldrbhi	r2, [r4, r5]
            if(i < 7) cmdStr[i-4] = command[i];
   b47ac:	f803 2c2c 	strbls.w	r2, [r3, #-44]
        for(uint8_t i = 4; i < strlen(command)-2;i++){  //Copy in data characters to data string
   b47b0:	f105 0501 	add.w	r5, r5, #1
            else dataStr[i-7] = command[i];
   b47b4:	bf88      	it	hi
   b47b6:	f803 2c07 	strbhi.w	r2, [r3, #-7]
        for(uint8_t i = 4; i < strlen(command)-2;i++){  //Copy in data characters to data string
   b47ba:	b2ed      	uxtb	r5, r5
   b47bc:	e7e6      	b.n	b478c <_Z17processRPiCommandPKch+0x68>
        if(checksum != strlen(command)-2){              //Compare checksum, reject command if the checksum does not match
   b47be:	b2f6      	uxtb	r6, r6
   b47c0:	42b0      	cmp	r0, r6
   b47c2:	d01d      	beq.n	b4800 <_Z17processRPiCommandPKch+0xdc>
   b47c4:	4d3e      	ldr	r5, [pc, #248]	; (b48c0 <_Z17processRPiCommandPKch+0x19c>)
            if(!logFile.isOpen()){                      //Log warning to SD card when non-matching strings are caught
   b47c6:	7c2b      	ldrb	r3, [r5, #16]
   b47c8:	b9a3      	cbnz	r3, b47f4 <_Z17processRPiCommandPKch+0xd0>
                logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b47ca:	493e      	ldr	r1, [pc, #248]	; (b48c4 <_Z17processRPiCommandPKch+0x1a0>)
   b47cc:	f244 2202 	movw	r2, #16898	; 0x4202
   b47d0:	f105 0010 	add.w	r0, r5, #16
   b47d4:	f7ff fe96 	bl	b4504 <_ZN7FatFile4openEPKci>
                logFile.printlnf("[WARN] RPi Message Checksum Does Not Match!: %s",command);
   b47d8:	493b      	ldr	r1, [pc, #236]	; (b48c8 <_Z17processRPiCommandPKch+0x1a4>)
   b47da:	4622      	mov	r2, r4
   b47dc:	4628      	mov	r0, r5
   b47de:	f7ff fe31 	bl	b4444 <_ZN5Print8printlnfEPKcz>
                logFile.close();
   b47e2:	f105 0010 	add.w	r0, r5, #16
   b47e6:	f004 fb49 	bl	b8e7c <_ZN7FatFile5closeEv>
   b47ea:	46c5      	mov	sp, r8
}
   b47ec:	373c      	adds	r7, #60	; 0x3c
   b47ee:	46bd      	mov	sp, r7
   b47f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            else logFile.printlnf("[WARN] RPi Message Checksum Does Not Match!: %s",command);
   b47f4:	4934      	ldr	r1, [pc, #208]	; (b48c8 <_Z17processRPiCommandPKch+0x1a4>)
   b47f6:	4622      	mov	r2, r4
   b47f8:	4628      	mov	r0, r5
   b47fa:	f7ff fe23 	bl	b4444 <_ZN5Print8printlnfEPKcz>
   b47fe:	e7f4      	b.n	b47ea <_Z17processRPiCommandPKch+0xc6>
        if(!strcmp(cmdStr,"ctl")){                      //Control packet from raspberry pi. Takes new coordinates, drive mode, offloading mode, recording mode
   b4800:	4932      	ldr	r1, [pc, #200]	; (b48cc <_Z17processRPiCommandPKch+0x1a8>)
   b4802:	f107 0010 	add.w	r0, r7, #16
   b4806:	f00a fbbe 	bl	bef86 <strcmp>
   b480a:	4606      	mov	r6, r0
   b480c:	2800      	cmp	r0, #0
   b480e:	d1ec      	bne.n	b47ea <_Z17processRPiCommandPKch+0xc6>
            sscanf(dataStr,"%s %s %s %d %d %d %d",idStr,GPSLatstr,GPSLonstr,&drivemode,&offloading,&recording,&signal);
   b4810:	1dfb      	adds	r3, r7, #7
   b4812:	9304      	str	r3, [sp, #16]
   b4814:	1dbb      	adds	r3, r7, #6
   b4816:	9303      	str	r3, [sp, #12]
   b4818:	1d3b      	adds	r3, r7, #4
   b481a:	9302      	str	r3, [sp, #8]
   b481c:	f107 052c 	add.w	r5, r7, #44	; 0x2c
   b4820:	1d7b      	adds	r3, r7, #5
   b4822:	492b      	ldr	r1, [pc, #172]	; (b48d0 <_Z17processRPiCommandPKch+0x1ac>)
   b4824:	9301      	str	r3, [sp, #4]
   b4826:	f107 0214 	add.w	r2, r7, #20
   b482a:	f107 0320 	add.w	r3, r7, #32
   b482e:	9500      	str	r5, [sp, #0]
   b4830:	4648      	mov	r0, r9
   b4832:	f005 fdfb 	bl	ba42c <sscanf>
            char botChar[2] = {command[8], '\0'};       //String to hold the bot identifier of the control packet
   b4836:	7a23      	ldrb	r3, [r4, #8]
   b4838:	723b      	strb	r3, [r7, #8]
            uint8_t targetBot = atoi(botChar);
   b483a:	f107 0008 	add.w	r0, r7, #8
            char botChar[2] = {command[8], '\0'};       //String to hold the bot identifier of the control packet
   b483e:	727e      	strb	r6, [r7, #9]
            uint8_t targetBot = atoi(botChar);
   b4840:	f00a fb1f 	bl	bee82 <atoi>
      : _M_current(__i) { }
   b4844:	4b23      	ldr	r3, [pc, #140]	; (b48d4 <_Z17processRPiCommandPKch+0x1b0>)
   b4846:	e9d3 3100 	ldrd	r3, r1, [r3]
   b484a:	b2c0      	uxtb	r0, r0
            for(WaterBot &wb: WaterBots){               //Loop over discovered water bots and look for the target water bot this control packet addresses
   b484c:	4299      	cmp	r1, r3
   b484e:	461c      	mov	r4, r3
   b4850:	d0cb      	beq.n	b47ea <_Z17processRPiCommandPKch+0xc6>
                if(wb.botNum == targetBot){             //Found the one we are targeting
   b4852:	78a2      	ldrb	r2, [r4, #2]
   b4854:	4282      	cmp	r2, r0
   b4856:	f103 0350 	add.w	r3, r3, #80	; 0x50
   b485a:	d1f7      	bne.n	b484c <_Z17processRPiCommandPKch+0x128>
                    wb.TargetLat = atof(GPSLatstr);     //Extract the latitude and longitude from the scanf statement
   b485c:	f107 0020 	add.w	r0, r7, #32
   b4860:	f00a fb0c 	bl	bee7c <atof>
   b4864:	ec51 0b10 	vmov	r0, r1, d0
   b4868:	f00a fa94 	bl	bed94 <__aeabi_d2f>
   b486c:	61a0      	str	r0, [r4, #24]
                    wb.TargetLon = atof(GPSLonstr);     
   b486e:	4628      	mov	r0, r5
   b4870:	f00a fb04 	bl	bee7c <atof>
   b4874:	ec51 0b10 	vmov	r0, r1, d0
   b4878:	f00a fa8c 	bl	bed94 <__aeabi_d2f>
                    wb.driveMode = drivemode;           //Extract the target drive mode from the message
   b487c:	797b      	ldrb	r3, [r7, #5]
   b487e:	81e3      	strh	r3, [r4, #14]
                    wb.offloading = offloading;         //Check if we have requested an SD card data offload from the Pi
   b4880:	793b      	ldrb	r3, [r7, #4]
                    if(botSelect == wb.botNum) redrawMenu = true;   //Redraw the menu if this is updating data of the displayed bot
   b4882:	4a15      	ldr	r2, [pc, #84]	; (b48d8 <_Z17processRPiCommandPKch+0x1b4>)
   b4884:	78a1      	ldrb	r1, [r4, #2]
   b4886:	7812      	ldrb	r2, [r2, #0]
                    wb.TargetLon = atof(GPSLonstr);     
   b4888:	61e0      	str	r0, [r4, #28]
                    wb.offloading = offloading;         //Check if we have requested an SD card data offload from the Pi
   b488a:	3b00      	subs	r3, #0
   b488c:	bf18      	it	ne
   b488e:	2301      	movne	r3, #1
   b4890:	75a3      	strb	r3, [r4, #22]
                    wb.dataRecording = recording;       //Check if we should be recording data from sensors
   b4892:	79bb      	ldrb	r3, [r7, #6]
   b4894:	3b00      	subs	r3, #0
   b4896:	bf18      	it	ne
   b4898:	2301      	movne	r3, #1
   b489a:	7563      	strb	r3, [r4, #21]
                    wb.signal = signal;                 //Check if user wants to signal the LED
   b489c:	79fb      	ldrb	r3, [r7, #7]
   b489e:	3b00      	subs	r3, #0
   b48a0:	bf18      	it	ne
   b48a2:	2301      	movne	r3, #1
                    if(botSelect == wb.botNum) redrawMenu = true;   //Redraw the menu if this is updating data of the displayed bot
   b48a4:	4291      	cmp	r1, r2
   b48a6:	bf08      	it	eq
   b48a8:	4a0c      	ldreq	r2, [pc, #48]	; (b48dc <_Z17processRPiCommandPKch+0x1b8>)
                    wb.signal = signal;                 //Check if user wants to signal the LED
   b48aa:	7423      	strb	r3, [r4, #16]
                    wb.LTEInitialStatus = true;         //Flag for sending over LTE since the status has changed
   b48ac:	f04f 0301 	mov.w	r3, #1
                    if(botSelect == wb.botNum) redrawMenu = true;   //Redraw the menu if this is updating data of the displayed bot
   b48b0:	bf08      	it	eq
   b48b2:	7013      	strbeq	r3, [r2, #0]
                    updateControl = true;               //Signal to control publisher that a bot has been updated
   b48b4:	4a0a      	ldr	r2, [pc, #40]	; (b48e0 <_Z17processRPiCommandPKch+0x1bc>)
                    wb.LTEInitialStatus = true;         //Flag for sending over LTE since the status has changed
   b48b6:	71a3      	strb	r3, [r4, #6]
                    wb.updatedControl = true;           //Indicate this bot had had its control updated, this triggers a control packet to be sent to the modified bot
   b48b8:	7063      	strb	r3, [r4, #1]
                    updateControl = true;               //Signal to control publisher that a bot has been updated
   b48ba:	7013      	strb	r3, [r2, #0]
                    return;
   b48bc:	e795      	b.n	b47ea <_Z17processRPiCommandPKch+0xc6>
   b48be:	bf00      	nop
   b48c0:	2003ddd0 	.word	0x2003ddd0
   b48c4:	2003dd78 	.word	0x2003dd78
   b48c8:	000c102c 	.word	0x000c102c
   b48cc:	000c105c 	.word	0x000c105c
   b48d0:	000c1060 	.word	0x000c1060
   b48d4:	2003dce4 	.word	0x2003dce4
   b48d8:	2003dd64 	.word	0x2003dd64
   b48dc:	2003daaa 	.word	0x2003daaa
   b48e0:	2003e638 	.word	0x2003e638

000b48e4 <_Z9setupXBeev>:
void setupXBee(){           //Function to send the bypass characters to XBee modules that have the integrated microcontrollers - done on startup
   b48e4:	b508      	push	{r3, lr}
    Serial1.printf("\n");    //First character to set Bypass mode
   b48e6:	f009 fbb1 	bl	be04c <_Z22__fetch_global_Serial1v>
   b48ea:	4908      	ldr	r1, [pc, #32]	; (b490c <_Z9setupXBeev+0x28>)
   b48ec:	f7ff fd72 	bl	b43d4 <_ZN5Print6printfEPKcz>
    delay(20);              //Wait some time before sending next character
   b48f0:	2014      	movs	r0, #20
   b48f2:	f008 fcb1 	bl	bd258 <delay>
    Serial1.printf("B");     //Second character to set Bypass mode
   b48f6:	f009 fba9 	bl	be04c <_Z22__fetch_global_Serial1v>
   b48fa:	4905      	ldr	r1, [pc, #20]	; (b4910 <_Z9setupXBeev+0x2c>)
   b48fc:	f7ff fd6a 	bl	b43d4 <_ZN5Print6printfEPKcz>
}
   b4900:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    delay(20);
   b4904:	2014      	movs	r0, #20
   b4906:	f008 bca7 	b.w	bd258 <delay>
   b490a:	bf00      	nop
   b490c:	000c1075 	.word	0x000c1075
   b4910:	000c0fdc 	.word	0x000c0fdc

000b4914 <_Z15RPiStatusUpdatev>:
void RPiStatusUpdate(){                         //Function to check if any water bots have received a status update and pusblish an update to the Raspberry Pi so the website is updated
   b4914:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   b4918:	4b2f      	ldr	r3, [pc, #188]	; (b49d8 <_Z15RPiStatusUpdatev+0xc4>)
            Serial.printlnf("CCRPsupB%d %d %0.6f %0.6f %d %d %d",wb.botNum, wb.battPercent, wb.GPSLat, wb.GPSLon, statusFlags,wb.battPower, wb.panelPower); //Print out status string to the Raspberry Pi over the USB port
   b491a:	4f30      	ldr	r7, [pc, #192]	; (b49dc <_Z15RPiStatusUpdatev+0xc8>)
   b491c:	e9d3 4600 	ldrd	r4, r6, [r3]
void RPiStatusUpdate(){                         //Function to check if any water bots have received a status update and pusblish an update to the Raspberry Pi so the website is updated
   b4920:	b08b      	sub	sp, #44	; 0x2c
   b4922:	3450      	adds	r4, #80	; 0x50
            wb.updatedStatus = false;           //Indicate this bot is up to date, until the next status update is received
   b4924:	f04f 0800 	mov.w	r8, #0
    for(WaterBot &wb: WaterBots){               //Loop over discovered water bots
   b4928:	f1a4 0350 	sub.w	r3, r4, #80	; 0x50
   b492c:	429e      	cmp	r6, r3
   b492e:	d050      	beq.n	b49d2 <_Z15RPiStatusUpdatev+0xbe>
        if(wb.updatedStatus){                   //Check if their internal flag for a new status update has been set
   b4930:	f814 3c50 	ldrb.w	r3, [r4, #-80]
   b4934:	2b00      	cmp	r3, #0
   b4936:	d04a      	beq.n	b49ce <_Z15RPiStatusUpdatev+0xba>
            statusFlags |= wb.BLEAvail << 2;
   b4938:	f814 5c49 	ldrb.w	r5, [r4, #-73]
            statusFlags |= wb.XBeeAvail << 1;
   b493c:	f814 3c47 	ldrb.w	r3, [r4, #-71]
            statusFlags |= wb.BLEAvail << 2;
   b4940:	00ad      	lsls	r5, r5, #2
   b4942:	ea45 0343 	orr.w	r3, r5, r3, lsl #1
            statusFlags |= wb.XBeeAvail << 1;
   b4946:	f814 5c48 	ldrb.w	r5, [r4, #-72]
            statusFlags |= wb.BLEAvail << 2;
   b494a:	431d      	orrs	r5, r3
            statusFlags |= wb.offloading << 3;
   b494c:	f814 3c3a 	ldrb.w	r3, [r4, #-58]
   b4950:	ea45 05c3 	orr.w	r5, r5, r3, lsl #3
            statusFlags |= wb.driveMode << 4;
   b4954:	f834 3c42 	ldrh.w	r3, [r4, #-66]
   b4958:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
            statusFlags |= wb.lowBatt << 6;
   b495c:	f814 3c3f 	ldrb.w	r3, [r4, #-63]
   b4960:	ea45 1583 	orr.w	r5, r5, r3, lsl #6
            statusFlags |= wb.dataRecording << 7;
   b4964:	f814 3c3b 	ldrb.w	r3, [r4, #-59]
   b4968:	ea45 15c3 	orr.w	r5, r5, r3, lsl #7
            statusFlags |= wb.GPSAvail << 8;
   b496c:	f814 3c46 	ldrb.w	r3, [r4, #-70]
   b4970:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
            statusFlags |= wb.CompassAvail << 9;
   b4974:	f814 3c45 	ldrb.w	r3, [r4, #-69]
   b4978:	ea45 2543 	orr.w	r5, r5, r3, lsl #9
            statusFlags |= wb.SDAvail << 10;
   b497c:	f814 3c44 	ldrb.w	r3, [r4, #-68]
   b4980:	ea45 2583 	orr.w	r5, r5, r3, lsl #10
            Serial.printlnf("CCRPsupB%d %d %0.6f %0.6f %d %d %d",wb.botNum, wb.battPercent, wb.GPSLat, wb.GPSLon, statusFlags,wb.battPower, wb.panelPower); //Print out status string to the Raspberry Pi over the USB port
   b4984:	f009 f8a2 	bl	bdacc <_Z16_fetch_usbserialv>
   b4988:	f834 1c10 	ldrh.w	r1, [r4, #-16]
   b498c:	f834 3c4c 	ldrh.w	r3, [r4, #-76]
   b4990:	f814 2c4e 	ldrb.w	r2, [r4, #-78]
   b4994:	9106      	str	r1, [sp, #24]
   b4996:	f834 1c0e 	ldrh.w	r1, [r4, #-14]
   b499a:	9309      	str	r3, [sp, #36]	; 0x24
            statusFlags |= wb.SDAvail << 10;
   b499c:	b2ad      	uxth	r5, r5
            Serial.printlnf("CCRPsupB%d %d %0.6f %0.6f %d %d %d",wb.botNum, wb.battPercent, wb.GPSLat, wb.GPSLon, statusFlags,wb.battPower, wb.panelPower); //Print out status string to the Raspberry Pi over the USB port
   b499e:	e9cd 5104 	strd	r5, r1, [sp, #16]
   b49a2:	4681      	mov	r9, r0
   b49a4:	f854 0c2c 	ldr.w	r0, [r4, #-44]
   b49a8:	9208      	str	r2, [sp, #32]
   b49aa:	f009 fee1 	bl	be770 <__aeabi_f2d>
   b49ae:	e9cd 0102 	strd	r0, r1, [sp, #8]
   b49b2:	f854 0c30 	ldr.w	r0, [r4, #-48]
   b49b6:	f009 fedb 	bl	be770 <__aeabi_f2d>
   b49ba:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   b49be:	e9cd 0100 	strd	r0, r1, [sp]
   b49c2:	4639      	mov	r1, r7
   b49c4:	4648      	mov	r0, r9
   b49c6:	f7ff fd3d 	bl	b4444 <_ZN5Print8printlnfEPKcz>
            wb.updatedStatus = false;           //Indicate this bot is up to date, until the next status update is received
   b49ca:	f804 8c50 	strb.w	r8, [r4, #-80]
      operator++() _GLIBCXX_NOEXCEPT
   b49ce:	3450      	adds	r4, #80	; 0x50
	return *this;
   b49d0:	e7aa      	b.n	b4928 <_Z15RPiStatusUpdatev+0x14>
}
   b49d2:	b00b      	add	sp, #44	; 0x2c
   b49d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   b49d8:	2003dce4 	.word	0x2003dce4
   b49dc:	000c1077 	.word	0x000c1077

000b49e0 <_Z10RPiHandlerv>:
void RPiHandler(){                                          //Function to check if any strings have been received from the Raspberry Pi, if so, then process them using the dictionary
   b49e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            if(logMessages){
   b49e4:	4e27      	ldr	r6, [pc, #156]	; (b4a84 <_Z10RPiHandlerv+0xa4>)
   b49e6:	4c28      	ldr	r4, [pc, #160]	; (b4a88 <_Z10RPiHandlerv+0xa8>)
                logFile.printlnf("[INFO] Received Raspberry Pi Message: %s",data);
   b49e8:	f8df 80a8 	ldr.w	r8, [pc, #168]	; b4a94 <_Z10RPiHandlerv+0xb4>
void RPiHandler(){                                          //Function to check if any strings have been received from the Raspberry Pi, if so, then process them using the dictionary
   b49ec:	b088      	sub	sp, #32
   b49ee:	af00      	add	r7, sp, #0
    while(Serial.available()){                              //Check if the serial buffer has anythingin it
   b49f0:	f009 f86c 	bl	bdacc <_Z16_fetch_usbserialv>
   b49f4:	6803      	ldr	r3, [r0, #0]
   b49f6:	691b      	ldr	r3, [r3, #16]
   b49f8:	4798      	blx	r3
   b49fa:	2800      	cmp	r0, #0
   b49fc:	d03d      	beq.n	b4a7a <_Z10RPiHandlerv+0x9a>
            String data = Serial.readStringUntil('\n');     //Read until the newline character, which is at the end of every transmission
   b49fe:	f009 f865 	bl	bdacc <_Z16_fetch_usbserialv>
   b4a02:	220a      	movs	r2, #10
   b4a04:	4601      	mov	r1, r0
   b4a06:	4638      	mov	r0, r7
   b4a08:	f008 fb3c 	bl	bd084 <_ZN6Stream15readStringUntilEc>
	// memory management
	// return true on success, false on failure (in which case, the string
	// is left unchanged).  reserve(0), if successful, will validate an
	// invalid string (i.e., "if (s)" will be true afterwards)
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}
   b4a0c:	68ba      	ldr	r2, [r7, #8]
            char buffer[data.length() + 2];                 //Create a buffer for the data and give space for null character
   b4a0e:	f102 0309 	add.w	r3, r2, #9
   b4a12:	f023 0307 	bic.w	r3, r3, #7
    }
   b4a16:	466d      	mov	r5, sp
            char buffer[data.length() + 2];                 //Create a buffer for the data and give space for null character
   b4a18:	ebad 0d03 	sub.w	sp, sp, r3
	void setCharAt(unsigned int index, char c);
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{getBytes((unsigned char *)buf, bufsize, index);}
   b4a1c:	3201      	adds	r2, #1
   b4a1e:	2300      	movs	r3, #0
   b4a20:	4669      	mov	r1, sp
   b4a22:	4638      	mov	r0, r7
   b4a24:	f005 ff64 	bl	ba8f0 <_ZNK6String8getBytesEPhjj>
            buffer[data.length() + 1] = 0;                  //Put null character so wild memory stuff does not happen (I've never seen emoji's printed to a console before this bug).
   b4a28:	68bb      	ldr	r3, [r7, #8]
   b4a2a:	446b      	add	r3, sp
   b4a2c:	2200      	movs	r2, #0
   b4a2e:	705a      	strb	r2, [r3, #1]
            processRPiCommand(buffer,3);                    //Process the command received from the Pi
   b4a30:	2103      	movs	r1, #3
   b4a32:	4668      	mov	r0, sp
   b4a34:	f7ff fe76 	bl	b4724 <_Z17processRPiCommandPKch>
            if(logMessages){
   b4a38:	7833      	ldrb	r3, [r6, #0]
   b4a3a:	b1cb      	cbz	r3, b4a70 <_Z10RPiHandlerv+0x90>
                if(!logFile.isOpen()) logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b4a3c:	7c23      	ldrb	r3, [r4, #16]
   b4a3e:	b92b      	cbnz	r3, b4a4c <_Z10RPiHandlerv+0x6c>
   b4a40:	4912      	ldr	r1, [pc, #72]	; (b4a8c <_Z10RPiHandlerv+0xac>)
   b4a42:	4813      	ldr	r0, [pc, #76]	; (b4a90 <_Z10RPiHandlerv+0xb0>)
   b4a44:	f244 2202 	movw	r2, #16898	; 0x4202
   b4a48:	f7ff fd5c 	bl	b4504 <_ZN7FatFile4openEPKci>
                logFile.printlnf("[INFO] Received Raspberry Pi Message: %s",data);
   b4a4c:	4639      	mov	r1, r7
   b4a4e:	f107 0010 	add.w	r0, r7, #16
   b4a52:	f005 fedf 	bl	ba814 <_ZN6StringC1ERKS_>
   b4a56:	f107 0210 	add.w	r2, r7, #16
   b4a5a:	4641      	mov	r1, r8
   b4a5c:	4620      	mov	r0, r4
   b4a5e:	f7ff fcf1 	bl	b4444 <_ZN5Print8printlnfEPKcz>
   b4a62:	f107 0010 	add.w	r0, r7, #16
   b4a66:	f005 fe3f 	bl	ba6e8 <_ZN6StringD1Ev>
                logFile.close();
   b4a6a:	4809      	ldr	r0, [pc, #36]	; (b4a90 <_Z10RPiHandlerv+0xb0>)
   b4a6c:	f004 fa06 	bl	b8e7c <_ZN7FatFile5closeEv>
            String data = Serial.readStringUntil('\n');     //Read until the newline character, which is at the end of every transmission
   b4a70:	4638      	mov	r0, r7
   b4a72:	f005 fe39 	bl	ba6e8 <_ZN6StringD1Ev>
   b4a76:	46ad      	mov	sp, r5
    while(Serial.available()){                              //Check if the serial buffer has anythingin it
   b4a78:	e7ba      	b.n	b49f0 <_Z10RPiHandlerv+0x10>
}
   b4a7a:	3720      	adds	r7, #32
   b4a7c:	46bd      	mov	sp, r7
   b4a7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   b4a82:	bf00      	nop
   b4a84:	2003de04 	.word	0x2003de04
   b4a88:	2003ddd0 	.word	0x2003ddd0
   b4a8c:	2003dd78 	.word	0x2003dd78
   b4a90:	2003dde0 	.word	0x2003dde0
   b4a94:	000c109a 	.word	0x000c109a

000b4a98 <_Z8sendDataPKchbbb>:
void sendData(const char *dataOut, uint8_t sendMode, bool sendBLE, bool sendXBee, bool sendLTE){
   b4a98:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   b4a9c:	b084      	sub	sp, #16
   b4a9e:	af02      	add	r7, sp, #8
   b4aa0:	4680      	mov	r8, r0
   b4aa2:	4691      	mov	r9, r2
   b4aa4:	461e      	mov	r6, r3
   b4aa6:	460d      	mov	r5, r1
    char outStr[strlen(dataOut)+2];                     //Get the length of the inputted string and extend it by 2 for the checksum characters
   b4aa8:	f00a fa9d 	bl	befe6 <strlen>
   b4aac:	3009      	adds	r0, #9
   b4aae:	f020 0107 	bic.w	r1, r0, #7
   b4ab2:	ebad 0d01 	sub.w	sp, sp, r1
    sprintf(outStr,"%s%02x",dataOut,strlen(dataOut));   //Copy the characters into the string along with the checksum
   b4ab6:	4640      	mov	r0, r8
   b4ab8:	f00a fa95 	bl	befe6 <strlen>
void sendData(const char *dataOut, uint8_t sendMode, bool sendBLE, bool sendXBee, bool sendLTE){
   b4abc:	f897 a028 	ldrb.w	sl, [r7, #40]	; 0x28
    sprintf(outStr,"%s%02x",dataOut,strlen(dataOut));   //Copy the characters into the string along with the checksum
   b4ac0:	4926      	ldr	r1, [pc, #152]	; (b4b5c <_Z8sendDataPKchbbb+0xc4>)
    char outStr[strlen(dataOut)+2];                     //Get the length of the inputted string and extend it by 2 for the checksum characters
   b4ac2:	ac02      	add	r4, sp, #8
    sprintf(outStr,"%s%02x",dataOut,strlen(dataOut));   //Copy the characters into the string along with the checksum
   b4ac4:	4603      	mov	r3, r0
   b4ac6:	4642      	mov	r2, r8
   b4ac8:	4620      	mov	r0, r4
   b4aca:	f005 fca7 	bl	ba41c <sprintf>
    if(sendLTE || sendMode == 4){                       //Check to send out over LTE
   b4ace:	f1ba 0f00 	cmp.w	sl, #0
   b4ad2:	d101      	bne.n	b4ad8 <_Z8sendDataPKchbbb+0x40>
   b4ad4:	2d04      	cmp	r5, #4
   b4ad6:	d10d      	bne.n	b4af4 <_Z8sendDataPKchbbb+0x5c>
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(ValueT val) :
   b4ad8:	4b21      	ldr	r3, [pc, #132]	; (b4b60 <_Z8sendDataPKchbbb+0xc8>)
        return publish(eventName, eventData, DEFAULT_CLOUD_EVENT_TTL, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
   b4ada:	4922      	ldr	r1, [pc, #136]	; (b4b64 <_Z8sendDataPKchbbb+0xcc>)
   b4adc:	781b      	ldrb	r3, [r3, #0]
   b4ade:	f88d 3000 	strb.w	r3, [sp]
   b4ae2:	4638      	mov	r0, r7
   b4ae4:	233c      	movs	r3, #60	; 0x3c
   b4ae6:	4622      	mov	r2, r4
   b4ae8:	f008 fdae 	bl	bd648 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
   b4aec:	6878      	ldr	r0, [r7, #4]
   b4aee:	b108      	cbz	r0, b4af4 <_Z8sendDataPKchbbb+0x5c>
	  _M_pi->_M_release();
   b4af0:	f7ff fcf4 	bl	b44dc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
    if((sendBLE || sendMode == 1) && BLE.connected()){  //Check to send out over BLE, only do so if BLE is connected
   b4af4:	f1b9 0f00 	cmp.w	r9, #0
   b4af8:	d101      	bne.n	b4afe <_Z8sendDataPKchbbb+0x66>
   b4afa:	2d01      	cmp	r5, #1
   b4afc:	d121      	bne.n	b4b42 <_Z8sendDataPKchbbb+0xaa>
   b4afe:	f006 fc11 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b4b02:	f006 fcbc 	bl	bb47e <_ZNK8particle14BleLocalDevice9connectedEv>
   b4b06:	b1e0      	cbz	r0, b4b42 <_Z8sendDataPKchbbb+0xaa>
        uint8_t txBuf_tmp[strlen(outStr)];              //BLE requires a uint8_t (byte) array instead of chars, so copy to a byte array
   b4b08:	4620      	mov	r0, r4
   b4b0a:	f00a fa6c 	bl	befe6 <strlen>
   b4b0e:	3007      	adds	r0, #7
   b4b10:	f020 0007 	bic.w	r0, r0, #7
        peerRxCharacteristic.setValue(txBuf_tmp, strlen(outStr));   //Set the value for the tx characteristic to write to the bot
   b4b14:	46e8      	mov	r8, sp
        uint8_t txBuf_tmp[strlen(outStr)];              //BLE requires a uint8_t (byte) array instead of chars, so copy to a byte array
   b4b16:	ebad 0d00 	sub.w	sp, sp, r0
        memcpy(txBuf_tmp,outStr,strlen(outStr));        //Use memcpy to make it ez
   b4b1a:	4620      	mov	r0, r4
   b4b1c:	f00a fa63 	bl	befe6 <strlen>
        uint8_t txBuf_tmp[strlen(outStr)];              //BLE requires a uint8_t (byte) array instead of chars, so copy to a byte array
   b4b20:	f10d 0908 	add.w	r9, sp, #8
        memcpy(txBuf_tmp,outStr,strlen(outStr));        //Use memcpy to make it ez
   b4b24:	4602      	mov	r2, r0
   b4b26:	4621      	mov	r1, r4
   b4b28:	4648      	mov	r0, r9
   b4b2a:	f00a f9be 	bl	beeaa <memcpy>
        peerRxCharacteristic.setValue(txBuf_tmp, strlen(outStr));   //Set the value for the tx characteristic to write to the bot
   b4b2e:	4620      	mov	r0, r4
   b4b30:	f00a fa59 	bl	befe6 <strlen>
   b4b34:	2300      	movs	r3, #0
   b4b36:	4602      	mov	r2, r0
   b4b38:	4649      	mov	r1, r9
   b4b3a:	480b      	ldr	r0, [pc, #44]	; (b4b68 <_Z8sendDataPKchbbb+0xd0>)
   b4b3c:	f006 fa8c 	bl	bb058 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE>
   b4b40:	46c5      	mov	sp, r8
    if(sendXBee || sendMode == 2){                      //Check to send out over XBee
   b4b42:	b90e      	cbnz	r6, b4b48 <_Z8sendDataPKchbbb+0xb0>
   b4b44:	2d02      	cmp	r5, #2
   b4b46:	d104      	bne.n	b4b52 <_Z8sendDataPKchbbb+0xba>
        Serial1.println(outStr);                        //Print string on serial1 for XBee transmission
   b4b48:	f009 fa80 	bl	be04c <_Z22__fetch_global_Serial1v>
   b4b4c:	4621      	mov	r1, r4
   b4b4e:	f008 fa2a 	bl	bcfa6 <_ZN5Print7printlnEPKc>
}
   b4b52:	3708      	adds	r7, #8
   b4b54:	46bd      	mov	sp, r7
   b4b56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   b4b5a:	bf00      	nop
   b4b5c:	000c10c3 	.word	0x000c10c3
   b4b60:	2003dd2c 	.word	0x2003dd2c
   b4b64:	000c10ca 	.word	0x000c10ca
   b4b68:	2003dec4 	.word	0x2003dec4

000b4b6c <_Z18manualMotorControlh>:
void manualMotorControl(uint8_t commandedBot){              //Function to read the joystick on the CCHub, convert to left and right motor speeds, and transmit out the motor command
   b4b6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b4b70:	4607      	mov	r7, r0
   b4b72:	b08b      	sub	sp, #44	; 0x2c
    VRead = 4095-analogRead(JOYV_ADC);                      //Read the vertical joystick, invert the direction
   b4b74:	2010      	movs	r0, #16
   b4b76:	f009 fa36 	bl	bdfe6 <analogRead>
   b4b7a:	f5c0 647f 	rsb	r4, r0, #4080	; 0xff0
   b4b7e:	4606      	mov	r6, r0
    HRead = analogRead(JOYH_ADC);                           //Read horizontal joystick
   b4b80:	2011      	movs	r0, #17
   b4b82:	f009 fa30 	bl	bdfe6 <analogRead>
    VRead = 4095-analogRead(JOYV_ADC);                      //Read the vertical joystick, invert the direction
   b4b86:	340f      	adds	r4, #15
    if(VRead < JOY_MID - JOY_DEADZONE){                     //Implement a deadzone so there is no response when the stick is only barely bumped
   b4b88:	f240 73dc 	movw	r3, #2012	; 0x7dc
   b4b8c:	429c      	cmp	r4, r3
   b4b8e:	f300 80b3 	bgt.w	b4cf8 <_Z18manualMotorControlh+0x18c>
        VSet = -90 * (VRead - (JOY_MID - JOY_DEADZONE))/(JOY_MIN - (JOY_MID - JOY_DEADZONE));   //Calculate a value between 0 and -90 when going down
   b4b92:	f5c6 6302 	rsb	r3, r6, #2080	; 0x820
        if(VSet < -90) VSet = -90;                                                              //Place caps at lower end of the joystick
   b4b96:	4ab0      	ldr	r2, [pc, #704]	; (b4e58 <_Z18manualMotorControlh+0x2ec>)
        VSet = -90 * (VRead - (JOY_MID - JOY_DEADZONE))/(JOY_MIN - (JOY_MID - JOY_DEADZONE));   //Calculate a value between 0 and -90 when going down
   b4b98:	3302      	adds	r3, #2
   b4b9a:	f06f 0659 	mvn.w	r6, #89	; 0x59
   b4b9e:	4373      	muls	r3, r6
        if(VSet < -90) VSet = -90;                                                              //Place caps at lower end of the joystick
   b4ba0:	4293      	cmp	r3, r2
   b4ba2:	dc03      	bgt.n	b4bac <_Z18manualMotorControlh+0x40>
        VSet = -90 * (VRead - (JOY_MID - JOY_DEADZONE))/(JOY_MIN - (JOY_MID - JOY_DEADZONE));   //Calculate a value between 0 and -90 when going down
   b4ba4:	f2a6 7682 	subw	r6, r6, #1922	; 0x782
        VSet = 90 * (VRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));    //Calculate a value between 0 and 90 when going up
   b4ba8:	fb93 f6f6 	sdiv	r6, r3, r6
    if(HRead < JOY_MID - JOY_DEADZONE){                    //Implement the same deadzoning and ramping as the vertical joystick on the horizontal joystick
   b4bac:	f240 73dc 	movw	r3, #2012	; 0x7dc
   b4bb0:	4298      	cmp	r0, r3
   b4bb2:	f300 80b1 	bgt.w	b4d18 <_Z18manualMotorControlh+0x1ac>
        if(HSet < -90) HSet = -90;
   b4bb6:	4ba8      	ldr	r3, [pc, #672]	; (b4e58 <_Z18manualMotorControlh+0x2ec>)
        HSet = -90 * (HRead - (JOY_MID - JOY_DEADZONE))/(JOY_MIN - (JOY_MID - JOY_DEADZONE));
   b4bb8:	f2a0 70dd 	subw	r0, r0, #2013	; 0x7dd
   b4bbc:	f06f 0a59 	mvn.w	sl, #89	; 0x59
   b4bc0:	fb0a f000 	mul.w	r0, sl, r0
        if(HSet < -90) HSet = -90;
   b4bc4:	4298      	cmp	r0, r3
   b4bc6:	dc02      	bgt.n	b4bce <_Z18manualMotorControlh+0x62>
        HSet = -90 * (HRead - (JOY_MID - JOY_DEADZONE))/(JOY_MIN - (JOY_MID - JOY_DEADZONE));
   b4bc8:	4ba4      	ldr	r3, [pc, #656]	; (b4e5c <_Z18manualMotorControlh+0x2f0>)
   b4bca:	fb90 faf3 	sdiv	sl, r0, r3
    LSpeed = 90 + VSet/2;
   b4bce:	eb06 73d6 	add.w	r3, r6, r6, lsr #31
   b4bd2:	105b      	asrs	r3, r3, #1
   b4bd4:	335a      	adds	r3, #90	; 0x5a
    if(VSet > 0){                   //Determine quandrants for doing math and affecting the motor behavior
   b4bd6:	2e00      	cmp	r6, #0
    LSpeed = 90 + VSet/2;
   b4bd8:	4ca1      	ldr	r4, [pc, #644]	; (b4e60 <_Z18manualMotorControlh+0x2f4>)
    if(VSet > 0){                   //Determine quandrants for doing math and affecting the motor behavior
   b4bda:	4da2      	ldr	r5, [pc, #648]	; (b4e64 <_Z18manualMotorControlh+0x2f8>)
    LSpeed = 90 + VSet/2;
   b4bdc:	b2da      	uxtb	r2, r3
    if(VSet > 0){                   //Determine quandrants for doing math and affecting the motor behavior
   b4bde:	f340 80c0 	ble.w	b4d62 <_Z18manualMotorControlh+0x1f6>
        if(HSet > 0){               //Top right quadrant
   b4be2:	f106 015a 	add.w	r1, r6, #90	; 0x5a
   b4be6:	ea4f 73da 	mov.w	r3, sl, lsr #31
   b4bea:	f1ba 0f00 	cmp.w	sl, #0
   b4bee:	b2c9      	uxtb	r1, r1
                RSpeed = 90 - HSet/2 + VSet;
   b4bf0:	4453      	add	r3, sl
        if(HSet > 0){               //Top right quadrant
   b4bf2:	f340 80a7 	ble.w	b4d44 <_Z18manualMotorControlh+0x1d8>
            if(HSet > VSet){        //Below the y = x line on the graph //H = 90, V = 0 -> LS = 135, RS = 45, H = 90, V = 90 -> LS = 180, RS = 135
   b4bf6:	4556      	cmp	r6, sl
                RSpeed = 90 - HSet/2 + VSet;
   b4bf8:	eba1 0363 	sub.w	r3, r1, r3, asr #1
   b4bfc:	b2db      	uxtb	r3, r3
                LSpeed = 90 + HSet/2 + VSet/2;
   b4bfe:	bfba      	itte	lt
   b4c00:	eb02 026a 	addlt.w	r2, r2, sl, asr #1
   b4c04:	7022      	strblt	r2, [r4, #0]
                LSpeed = 90 + VSet;
   b4c06:	7021      	strbge	r1, [r4, #0]
                RSpeed = 90 - HSet/2 + VSet;
   b4c08:	702b      	strb	r3, [r5, #0]
    if(lastLSpeed - LSpeed > LTE_MIN_DIFF || LSpeed - lastLSpeed > LTE_MIN_DIFF){
   b4c0a:	4e97      	ldr	r6, [pc, #604]	; (b4e68 <_Z18manualMotorControlh+0x2fc>)
   b4c0c:	7821      	ldrb	r1, [r4, #0]
   b4c0e:	7833      	ldrb	r3, [r6, #0]
   b4c10:	1a5a      	subs	r2, r3, r1
   b4c12:	2a03      	cmp	r2, #3
   b4c14:	dc02      	bgt.n	b4c1c <_Z18manualMotorControlh+0xb0>
   b4c16:	1acb      	subs	r3, r1, r3
   b4c18:	2b03      	cmp	r3, #3
   b4c1a:	dd03      	ble.n	b4c24 <_Z18manualMotorControlh+0xb8>
        ctlSpeedDiff = true;        //Set this flag true if data should be sent out sooner - due to a large difference since the last position
   b4c1c:	4b93      	ldr	r3, [pc, #588]	; (b4e6c <_Z18manualMotorControlh+0x300>)
        lastLSpeed = LSpeed;
   b4c1e:	7031      	strb	r1, [r6, #0]
        ctlSpeedDiff = true;        //Set this flag true if data should be sent out sooner - due to a large difference since the last position
   b4c20:	2201      	movs	r2, #1
   b4c22:	701a      	strb	r2, [r3, #0]
    if(lastRSpeed - RSpeed > LTE_MIN_DIFF || RSpeed - lastRSpeed > LTE_MIN_DIFF){
   b4c24:	4892      	ldr	r0, [pc, #584]	; (b4e70 <_Z18manualMotorControlh+0x304>)
   b4c26:	782a      	ldrb	r2, [r5, #0]
   b4c28:	7803      	ldrb	r3, [r0, #0]
   b4c2a:	eba3 0c02 	sub.w	ip, r3, r2
   b4c2e:	f1bc 0f03 	cmp.w	ip, #3
   b4c32:	dc02      	bgt.n	b4c3a <_Z18manualMotorControlh+0xce>
   b4c34:	1ad3      	subs	r3, r2, r3
   b4c36:	2b03      	cmp	r3, #3
   b4c38:	dd05      	ble.n	b4c46 <_Z18manualMotorControlh+0xda>
        ctlSpeedDiff = true;
   b4c3a:	4b8c      	ldr	r3, [pc, #560]	; (b4e6c <_Z18manualMotorControlh+0x300>)
        lastRSpeed = RSpeed;
   b4c3c:	7002      	strb	r2, [r0, #0]
        ctlSpeedDiff = true;
   b4c3e:	f04f 0c01 	mov.w	ip, #1
   b4c42:	f883 c000 	strb.w	ip, [r3]
    if(lastLSpeed != LSpeed && LSpeed == 90){
   b4c46:	7833      	ldrb	r3, [r6, #0]
   b4c48:	428b      	cmp	r3, r1
   b4c4a:	d005      	beq.n	b4c58 <_Z18manualMotorControlh+0xec>
   b4c4c:	295a      	cmp	r1, #90	; 0x5a
        ctlSpeedDiff = true;
   b4c4e:	bf01      	itttt	eq
   b4c50:	4b86      	ldreq	r3, [pc, #536]	; (b4e6c <_Z18manualMotorControlh+0x300>)
        lastLSpeed = LSpeed;
   b4c52:	7031      	strbeq	r1, [r6, #0]
        ctlSpeedDiff = true;
   b4c54:	2101      	moveq	r1, #1
   b4c56:	7019      	strbeq	r1, [r3, #0]
    if(lastRSpeed != RSpeed && RSpeed == 90){
   b4c58:	7803      	ldrb	r3, [r0, #0]
   b4c5a:	4293      	cmp	r3, r2
   b4c5c:	d005      	beq.n	b4c6a <_Z18manualMotorControlh+0xfe>
   b4c5e:	2a5a      	cmp	r2, #90	; 0x5a
        ctlSpeedDiff = true;
   b4c60:	bf01      	itttt	eq
   b4c62:	4b82      	ldreq	r3, [pc, #520]	; (b4e6c <_Z18manualMotorControlh+0x300>)
        lastRSpeed = RSpeed;
   b4c64:	7002      	strbeq	r2, [r0, #0]
        ctlSpeedDiff = true;
   b4c66:	2201      	moveq	r2, #1
   b4c68:	701a      	strbeq	r2, [r3, #0]
    if(!stopActive && ((millis() - rcTime > MTR_UPDATE_TIME) || (ctlSpeedDiff && millis() - rcTime > 75))){
   b4c6a:	4b82      	ldr	r3, [pc, #520]	; (b4e74 <_Z18manualMotorControlh+0x308>)
   b4c6c:	781b      	ldrb	r3, [r3, #0]
   b4c6e:	2b00      	cmp	r3, #0
   b4c70:	f040 80d4 	bne.w	b4e1c <_Z18manualMotorControlh+0x2b0>
   b4c74:	4e80      	ldr	r6, [pc, #512]	; (b4e78 <_Z18manualMotorControlh+0x30c>)
   b4c76:	f8df 81f4 	ldr.w	r8, [pc, #500]	; b4e6c <_Z18manualMotorControlh+0x300>
   b4c7a:	f005 f881 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4c7e:	6833      	ldr	r3, [r6, #0]
   b4c80:	1ac0      	subs	r0, r0, r3
   b4c82:	f240 23ee 	movw	r3, #750	; 0x2ee
   b4c86:	4298      	cmp	r0, r3
   b4c88:	f240 80be 	bls.w	b4e08 <_Z18manualMotorControlh+0x29c>
        ctlSpeedDiff = false;
   b4c8c:	2300      	movs	r3, #0
   b4c8e:	f888 3000 	strb.w	r3, [r8]
   b4c92:	f005 f875 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
      : _M_current(__i) { }
   b4c96:	4b79      	ldr	r3, [pc, #484]	; (b4e7c <_Z18manualMotorControlh+0x310>)
        rcTime = millis();                      //Capture last time a motor command was sent to limit traffic
   b4c98:	6030      	str	r0, [r6, #0]
   b4c9a:	685a      	ldr	r2, [r3, #4]
   b4c9c:	681e      	ldr	r6, [r3, #0]
                sprintf(mtrStr,"CCB%dmtr%03d%03d",commandedBot, LSpeed, RSpeed);        //Craft the command string to be transmitted out
   b4c9e:	f8df a1ec 	ldr.w	sl, [pc, #492]	; b4e8c <_Z18manualMotorControlh+0x320>
   b4ca2:	9204      	str	r2, [sp, #16]
        for(WaterBot wb: WaterBots){            //Loop over water bots in vector and check if this one is selected and being controlled
   b4ca4:	9b04      	ldr	r3, [sp, #16]
   b4ca6:	42b3      	cmp	r3, r6
   b4ca8:	f000 80b8 	beq.w	b4e1c <_Z18manualMotorControlh+0x2b0>
            if(wb.driveMode == 0 && wb.botNum == botSelect){
   b4cac:	89f3      	ldrh	r3, [r6, #14]
   b4cae:	bb0b      	cbnz	r3, b4cf4 <_Z18manualMotorControlh+0x188>
   b4cb0:	4b73      	ldr	r3, [pc, #460]	; (b4e80 <_Z18manualMotorControlh+0x314>)
   b4cb2:	781a      	ldrb	r2, [r3, #0]
   b4cb4:	78b3      	ldrb	r3, [r6, #2]
   b4cb6:	429a      	cmp	r2, r3
   b4cb8:	d11c      	bne.n	b4cf4 <_Z18manualMotorControlh+0x188>
        for(WaterBot wb: WaterBots){            //Loop over water bots in vector and check if this one is selected and being controlled
   b4cba:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
   b4cbc:	9303      	str	r3, [sp, #12]
                sprintf(mtrStr,"CCB%dmtr%03d%03d",commandedBot, LSpeed, RSpeed);        //Craft the command string to be transmitted out
   b4cbe:	782b      	ldrb	r3, [r5, #0]
        for(WaterBot wb: WaterBots){            //Loop over water bots in vector and check if this one is selected and being controlled
   b4cc0:	f896 9009 	ldrb.w	r9, [r6, #9]
   b4cc4:	f896 b007 	ldrb.w	fp, [r6, #7]
                sprintf(mtrStr,"CCB%dmtr%03d%03d",commandedBot, LSpeed, RSpeed);        //Craft the command string to be transmitted out
   b4cc8:	9300      	str	r3, [sp, #0]
   b4cca:	463a      	mov	r2, r7
   b4ccc:	7823      	ldrb	r3, [r4, #0]
   b4cce:	4651      	mov	r1, sl
   b4cd0:	a806      	add	r0, sp, #24
   b4cd2:	f005 fba3 	bl	ba41c <sprintf>
                if(!wb.XBeeAvail && !wb.BLEAvail && ctlSpeedDiff && (millis() - wb.LastMtrTime > MTR_LTE_PERIOD)){      //Check if XBee or BLE are available before trying to publish over LTE
   b4cd6:	f089 0201 	eor.w	r2, r9, #1
   b4cda:	f1b9 0f00 	cmp.w	r9, #0
   b4cde:	f000 80a0 	beq.w	b4e22 <_Z18manualMotorControlh+0x2b6>
                bool sendMTRLTE = false;                                                //Flag for limiting publish rate over LTE
   b4ce2:	f04f 0900 	mov.w	r9, #0
                sendData(mtrStr,0,!(wb.XBeeAvail), true, sendMTRLTE);       //Send data with priority of XBee, then Bluetooth, then LTE
   b4ce6:	f8cd 9000 	str.w	r9, [sp]
   b4cea:	2301      	movs	r3, #1
   b4cec:	2100      	movs	r1, #0
   b4cee:	a806      	add	r0, sp, #24
   b4cf0:	f7ff fed2 	bl	b4a98 <_Z8sendDataPKchbbb>
      operator++() _GLIBCXX_NOEXCEPT
   b4cf4:	3650      	adds	r6, #80	; 0x50
	return *this;
   b4cf6:	e7d5      	b.n	b4ca4 <_Z18manualMotorControlh+0x138>
    else if(VRead > JOY_MID + JOY_DEADZONE){
   b4cf8:	f640 0223 	movw	r2, #2083	; 0x823
   b4cfc:	4294      	cmp	r4, r2
   b4cfe:	dd09      	ble.n	b4d14 <_Z18manualMotorControlh+0x1a8>
        VSet = 90 * (VRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));    //Calculate a value between 0 and 90 when going up
   b4d00:	1b9b      	subs	r3, r3, r6
        if(VSet > 90) VSet = 90;                                                                //Place caps at upper end of joystick
   b4d02:	4a60      	ldr	r2, [pc, #384]	; (b4e84 <_Z18manualMotorControlh+0x318>)
        VSet = 90 * (VRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));    //Calculate a value between 0 and 90 when going up
   b4d04:	265a      	movs	r6, #90	; 0x5a
   b4d06:	4373      	muls	r3, r6
        if(VSet > 90) VSet = 90;                                                                //Place caps at upper end of joystick
   b4d08:	4293      	cmp	r3, r2
   b4d0a:	f73f af4f 	bgt.w	b4bac <_Z18manualMotorControlh+0x40>
        VSet = 90 * (VRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));    //Calculate a value between 0 and 90 when going up
   b4d0e:	f240 76db 	movw	r6, #2011	; 0x7db
   b4d12:	e749      	b.n	b4ba8 <_Z18manualMotorControlh+0x3c>
        VSet = 0;
   b4d14:	2600      	movs	r6, #0
   b4d16:	e749      	b.n	b4bac <_Z18manualMotorControlh+0x40>
    else if(HRead > JOY_MID + JOY_DEADZONE){
   b4d18:	f640 0323 	movw	r3, #2083	; 0x823
   b4d1c:	4298      	cmp	r0, r3
   b4d1e:	dd0e      	ble.n	b4d3e <_Z18manualMotorControlh+0x1d2>
        if(HSet > 90) HSet = 90;
   b4d20:	4b58      	ldr	r3, [pc, #352]	; (b4e84 <_Z18manualMotorControlh+0x318>)
        HSet = 90 * (HRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));
   b4d22:	f6a0 0023 	subw	r0, r0, #2083	; 0x823
   b4d26:	f04f 0a5a 	mov.w	sl, #90	; 0x5a
   b4d2a:	fb0a f000 	mul.w	r0, sl, r0
        if(HSet > 90) HSet = 90;
   b4d2e:	4298      	cmp	r0, r3
   b4d30:	f73f af4d 	bgt.w	b4bce <_Z18manualMotorControlh+0x62>
        HSet = 90 * (HRead - (JOY_MID + JOY_DEADZONE))/(JOY_MAX - (JOY_MID + JOY_DEADZONE));
   b4d34:	f240 7adb 	movw	sl, #2011	; 0x7db
   b4d38:	fbb0 fafa 	udiv	sl, r0, sl
   b4d3c:	e747      	b.n	b4bce <_Z18manualMotorControlh+0x62>
        HSet = 0;
   b4d3e:	f04f 0a00 	mov.w	sl, #0
   b4d42:	e744      	b.n	b4bce <_Z18manualMotorControlh+0x62>
            if((0-HSet) > VSet){    //Below the y = -x line on the graph
   b4d44:	f1ca 0a00 	rsb	sl, sl, #0
   b4d48:	45b2      	cmp	sl, r6
                LSpeed = 90 + HSet/2 + VSet;
   b4d4a:	ea4f 0063 	mov.w	r0, r3, asr #1
                RSpeed = 90 - HSet/2 + VSet/2;
   b4d4e:	bfc8      	it	gt
   b4d50:	1a12      	subgt	r2, r2, r0
                LSpeed = 90 + HSet/2 + VSet;
   b4d52:	eb01 0363 	add.w	r3, r1, r3, asr #1
   b4d56:	b2db      	uxtb	r3, r3
                RSpeed = 90 - HSet/2 + VSet/2;
   b4d58:	bfcc      	ite	gt
   b4d5a:	702a      	strbgt	r2, [r5, #0]
                RSpeed = 90 + VSet;
   b4d5c:	7029      	strble	r1, [r5, #0]
                LSpeed = 90 + HSet/2;
   b4d5e:	7023      	strb	r3, [r4, #0]
   b4d60:	e753      	b.n	b4c0a <_Z18manualMotorControlh+0x9e>
        if(HSet > 0){               //In the bottom right quadrant
   b4d62:	f1ba 0f00 	cmp.w	sl, #0
   b4d66:	dd28      	ble.n	b4dba <_Z18manualMotorControlh+0x24e>
            if(HSet > (0-VSet)){        // H = 90, V = 0 -> LS = 135, RS = 45, H = 90, V = -90 -> LS = 0; RS = 45
   b4d68:	4273      	negs	r3, r6
   b4d6a:	4553      	cmp	r3, sl
                LSpeed = 90 + HSet/2 + VSet/2;
   b4d6c:	ea4f 006a 	mov.w	r0, sl, asr #1
            if(HSet > (0-VSet)){        // H = 90, V = 0 -> LS = 135, RS = 45, H = 90, V = -90 -> LS = 0; RS = 45
   b4d70:	da1d      	bge.n	b4dae <_Z18manualMotorControlh+0x242>
                LSpeed = (90 + HSet/2 + VSet*1.5 );
   b4d72:	305a      	adds	r0, #90	; 0x5a
   b4d74:	f009 fcea 	bl	be74c <__aeabi_i2d>
   b4d78:	4680      	mov	r8, r0
   b4d7a:	4630      	mov	r0, r6
   b4d7c:	4689      	mov	r9, r1
   b4d7e:	f009 fce5 	bl	be74c <__aeabi_i2d>
   b4d82:	4b41      	ldr	r3, [pc, #260]	; (b4e88 <_Z18manualMotorControlh+0x31c>)
   b4d84:	2200      	movs	r2, #0
   b4d86:	f009 fd4b 	bl	be820 <__aeabi_dmul>
   b4d8a:	4602      	mov	r2, r0
   b4d8c:	460b      	mov	r3, r1
   b4d8e:	4640      	mov	r0, r8
   b4d90:	4649      	mov	r1, r9
   b4d92:	f009 fb8f 	bl	be4b4 <__adddf3>
   b4d96:	f009 ffdd 	bl	bed54 <__aeabi_d2uiz>
                RSpeed = (90 - HSet/2);      
   b4d9a:	eb0a 7ada 	add.w	sl, sl, sl, lsr #31
   b4d9e:	ea4f 0a6a 	mov.w	sl, sl, asr #1
   b4da2:	f1ca 0a5a 	rsb	sl, sl, #90	; 0x5a
                LSpeed = (90 + HSet/2 + VSet*1.5 );
   b4da6:	7020      	strb	r0, [r4, #0]
                RSpeed = (90 - HSet/2);      
   b4da8:	f885 a000 	strb.w	sl, [r5]
   b4dac:	e72d      	b.n	b4c0a <_Z18manualMotorControlh+0x9e>
                LSpeed = 90 + VSet;
   b4dae:	365a      	adds	r6, #90	; 0x5a
   b4db0:	b2f6      	uxtb	r6, r6
   b4db2:	7026      	strb	r6, [r4, #0]
                RSpeed = 90 + HSet/2 + VSet;
   b4db4:	4406      	add	r6, r0
   b4db6:	702e      	strb	r6, [r5, #0]
   b4db8:	e727      	b.n	b4c0a <_Z18manualMotorControlh+0x9e>
                RSpeed = 90 - HSet/2 + VSet;
   b4dba:	eb0a 73da 	add.w	r3, sl, sl, lsr #31
   b4dbe:	1058      	asrs	r0, r3, #1
            if((0-HSet) > (0-VSet)){    //H = -90, V = 0 -> LS = 45, RS = 135, H = -90, V = -90 -> LS = 45, RS = 0
   b4dc0:	4556      	cmp	r6, sl
                RSpeed = 90 - HSet/2 + VSet;
   b4dc2:	f1c0 0000 	rsb	r0, r0, #0
   b4dc6:	ea4f 0a63 	mov.w	sl, r3, asr #1
            if((0-HSet) > (0-VSet)){    //H = -90, V = 0 -> LS = 45, RS = 135, H = -90, V = -90 -> LS = 45, RS = 0
   b4dca:	dd17      	ble.n	b4dfc <_Z18manualMotorControlh+0x290>
                RSpeed = 90 - HSet/2 + (VSet*1.5);
   b4dcc:	305a      	adds	r0, #90	; 0x5a
   b4dce:	f009 fcbd 	bl	be74c <__aeabi_i2d>
   b4dd2:	4680      	mov	r8, r0
   b4dd4:	4630      	mov	r0, r6
   b4dd6:	4689      	mov	r9, r1
   b4dd8:	f009 fcb8 	bl	be74c <__aeabi_i2d>
   b4ddc:	4b2a      	ldr	r3, [pc, #168]	; (b4e88 <_Z18manualMotorControlh+0x31c>)
   b4dde:	2200      	movs	r2, #0
   b4de0:	f009 fd1e 	bl	be820 <__aeabi_dmul>
   b4de4:	460b      	mov	r3, r1
   b4de6:	4602      	mov	r2, r0
   b4de8:	4649      	mov	r1, r9
   b4dea:	4640      	mov	r0, r8
   b4dec:	f009 fb62 	bl	be4b4 <__adddf3>
   b4df0:	f009 ffb0 	bl	bed54 <__aeabi_d2uiz>
                LSpeed = 90 + HSet/2;
   b4df4:	f10a 035a 	add.w	r3, sl, #90	; 0x5a
                RSpeed = 90 - HSet/2 + (VSet*1.5);
   b4df8:	7028      	strb	r0, [r5, #0]
                LSpeed = 90 + HSet/2;
   b4dfa:	e7b0      	b.n	b4d5e <_Z18manualMotorControlh+0x1f2>
                RSpeed = 90 + VSet;
   b4dfc:	365a      	adds	r6, #90	; 0x5a
   b4dfe:	b2f6      	uxtb	r6, r6
   b4e00:	702e      	strb	r6, [r5, #0]
                LSpeed = 90 - HSet/2 + VSet;
   b4e02:	4406      	add	r6, r0
   b4e04:	7026      	strb	r6, [r4, #0]
   b4e06:	e700      	b.n	b4c0a <_Z18manualMotorControlh+0x9e>
    if(!stopActive && ((millis() - rcTime > MTR_UPDATE_TIME) || (ctlSpeedDiff && millis() - rcTime > 75))){
   b4e08:	f898 3000 	ldrb.w	r3, [r8]
   b4e0c:	b133      	cbz	r3, b4e1c <_Z18manualMotorControlh+0x2b0>
   b4e0e:	f004 ffb7 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4e12:	6833      	ldr	r3, [r6, #0]
   b4e14:	1ac0      	subs	r0, r0, r3
   b4e16:	284b      	cmp	r0, #75	; 0x4b
   b4e18:	f63f af38 	bhi.w	b4c8c <_Z18manualMotorControlh+0x120>
}
   b4e1c:	b00b      	add	sp, #44	; 0x2c
   b4e1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if(!wb.XBeeAvail && !wb.BLEAvail && ctlSpeedDiff && (millis() - wb.LastMtrTime > MTR_LTE_PERIOD)){      //Check if XBee or BLE are available before trying to publish over LTE
   b4e22:	f1bb 0f00 	cmp.w	fp, #0
   b4e26:	f47f af5c 	bne.w	b4ce2 <_Z18manualMotorControlh+0x176>
   b4e2a:	f898 9000 	ldrb.w	r9, [r8]
   b4e2e:	f1b9 0f00 	cmp.w	r9, #0
   b4e32:	f43f af56 	beq.w	b4ce2 <_Z18manualMotorControlh+0x176>
   b4e36:	9205      	str	r2, [sp, #20]
   b4e38:	f004 ffa2 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4e3c:	9b03      	ldr	r3, [sp, #12]
   b4e3e:	9a05      	ldr	r2, [sp, #20]
   b4e40:	1ac0      	subs	r0, r0, r3
   b4e42:	f640 33b8 	movw	r3, #3000	; 0xbb8
   b4e46:	4298      	cmp	r0, r3
   b4e48:	f67f af4b 	bls.w	b4ce2 <_Z18manualMotorControlh+0x176>
   b4e4c:	9203      	str	r2, [sp, #12]
   b4e4e:	f004 ff97 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4e52:	9a03      	ldr	r2, [sp, #12]
                    sendMTRLTE = true;
   b4e54:	e747      	b.n	b4ce6 <_Z18manualMotorControlh+0x17a>
   b4e56:	bf00      	nop
   b4e58:	0002cb33 	.word	0x0002cb33
   b4e5c:	fffff824 	.word	0xfffff824
   b4e60:	2003dca8 	.word	0x2003dca8
   b4e64:	2003dcd0 	.word	0x2003dcd0
   b4e68:	2003dd44 	.word	0x2003dd44
   b4e6c:	2003dd70 	.word	0x2003dd70
   b4e70:	2003dd45 	.word	0x2003dd45
   b4e74:	2003e631 	.word	0x2003e631
   b4e78:	2003ded8 	.word	0x2003ded8
   b4e7c:	2003dce4 	.word	0x2003dce4
   b4e80:	2003dd64 	.word	0x2003dd64
   b4e84:	0002cad8 	.word	0x0002cad8
   b4e88:	3ff80000 	.word	0x3ff80000
   b4e8c:	000c10d0 	.word	0x000c10d0

000b4e90 <_Z14XBeeLTEPairSetv>:
void XBeeLTEPairSet(){                                                          //Function to send hello-world acknowledge string to bots when a hello world message has been received
   b4e90:	b5f0      	push	{r4, r5, r6, r7, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b4e92:	4c12      	ldr	r4, [pc, #72]	; (b4edc <_Z14XBeeLTEPairSetv+0x4c>)
   b4e94:	4f12      	ldr	r7, [pc, #72]	; (b4ee0 <_Z14XBeeLTEPairSetv+0x50>)
        sprintf(replyStr,"CCB%dhwa",PairBots.back().botNum);                    //Bot will stop periodically sending "Hello World" after receiving the acknowledge
   b4e96:	4e13      	ldr	r6, [pc, #76]	; (b4ee4 <_Z14XBeeLTEPairSetv+0x54>)
void XBeeLTEPairSet(){                                                          //Function to send hello-world acknowledge string to bots when a hello world message has been received
   b4e98:	b087      	sub	sp, #28
    for(int i = 0; i < PairBots.size(); i++){                                  //Loop over discovered bots, send the message, then pop it from the vector, since it will already be in the main WaterBots vector
   b4e9a:	2500      	movs	r5, #0
   b4e9c:	e9d4 3200 	ldrd	r3, r2, [r4]
   b4ea0:	1ad3      	subs	r3, r2, r3
   b4ea2:	111b      	asrs	r3, r3, #4
   b4ea4:	437b      	muls	r3, r7
   b4ea6:	42ab      	cmp	r3, r5
   b4ea8:	d915      	bls.n	b4ed6 <_Z14XBeeLTEPairSetv+0x46>
        sprintf(replyStr,"CCB%dhwa",PairBots.back().botNum);                    //Bot will stop periodically sending "Hello World" after receiving the acknowledge
   b4eaa:	f812 2c4e 	ldrb.w	r2, [r2, #-78]
   b4eae:	4631      	mov	r1, r6
   b4eb0:	a803      	add	r0, sp, #12
   b4eb2:	f005 fab3 	bl	ba41c <sprintf>
      : _M_current(__i) { }
   b4eb6:	6862      	ldr	r2, [r4, #4]
        sendData(replyStr,0,true,PairBots.back().XBeeAvail,PairBots.back().LTEAvail);
   b4eb8:	f812 3c47 	ldrb.w	r3, [r2, #-71]
   b4ebc:	f812 2c48 	ldrb.w	r2, [r2, #-72]
   b4ec0:	9200      	str	r2, [sp, #0]
   b4ec2:	2100      	movs	r1, #0
   b4ec4:	2201      	movs	r2, #1
   b4ec6:	a803      	add	r0, sp, #12
   b4ec8:	f7ff fde6 	bl	b4a98 <_Z8sendDataPKchbbb>
	--this->_M_impl._M_finish;
   b4ecc:	6863      	ldr	r3, [r4, #4]
   b4ece:	3b50      	subs	r3, #80	; 0x50
   b4ed0:	6063      	str	r3, [r4, #4]
    for(int i = 0; i < PairBots.size(); i++){                                  //Loop over discovered bots, send the message, then pop it from the vector, since it will already be in the main WaterBots vector
   b4ed2:	3501      	adds	r5, #1
   b4ed4:	e7e2      	b.n	b4e9c <_Z14XBeeLTEPairSetv+0xc>
}
   b4ed6:	b007      	add	sp, #28
   b4ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   b4eda:	bf00      	nop
   b4edc:	2003dcb8 	.word	0x2003dcb8
   b4ee0:	cccccccd 	.word	0xcccccccd
   b4ee4:	000c10e1 	.word	0x000c10e1

000b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>:
      at(size_type __n)
   b4ee8:	b510      	push	{r4, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b4eea:	e9d0 4200 	ldrd	r4, r2, [r0]
   b4eee:	4806      	ldr	r0, [pc, #24]	; (b4f08 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj+0x20>)
   b4ef0:	1b12      	subs	r2, r2, r4
   b4ef2:	1112      	asrs	r2, r2, #4
   b4ef4:	4342      	muls	r2, r0
	if (__n >= this->size())
   b4ef6:	4291      	cmp	r1, r2
   b4ef8:	d302      	bcc.n	b4f00 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj+0x18>
	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
   b4efa:	4804      	ldr	r0, [pc, #16]	; (b4f0c <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj+0x24>)
   b4efc:	f009 f911 	bl	be122 <_ZSt24__throw_out_of_range_fmtPKcz>
      }
   b4f00:	2050      	movs	r0, #80	; 0x50
   b4f02:	fb00 4001 	mla	r0, r0, r1, r4
   b4f06:	bd10      	pop	{r4, pc}
   b4f08:	cccccccd 	.word	0xcccccccd
   b4f0c:	000c10ea 	.word	0x000c10ea

000b4f10 <_Z16updateBotControlv>:
void updateBotControl(){                    //Function to send control packet to bot periodically and when updated by user. 
   b4f10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if(updateControl){                      //Check flag that is set when menu items are modified
   b4f14:	4b5b      	ldr	r3, [pc, #364]	; (b5084 <_Z16updateBotControlv+0x174>)
   b4f16:	781a      	ldrb	r2, [r3, #0]
void updateBotControl(){                    //Function to send control packet to bot periodically and when updated by user. 
   b4f18:	b097      	sub	sp, #92	; 0x5c
    if(updateControl){                      //Check flag that is set when menu items are modified
   b4f1a:	2a00      	cmp	r2, #0
   b4f1c:	d040      	beq.n	b4fa0 <_Z16updateBotControlv+0x90>
        updateControl = false;              //Clear flag to not constantly publish updates
   b4f1e:	2500      	movs	r5, #0
   b4f20:	701d      	strb	r5, [r3, #0]
   b4f22:	4b59      	ldr	r3, [pc, #356]	; (b5088 <_Z16updateBotControlv+0x178>)
                sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum, wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);     //Print characteristics to string
   b4f24:	f8df 8170 	ldr.w	r8, [pc, #368]	; b5098 <_Z16updateBotControlv+0x188>
                if(!wb.XBeeAvail && !wb.BLEAvail && LTEStatuses && wb.LTEInitialStatus){    //Don't publish LTE when XBee or BLE are available
   b4f28:	4e58      	ldr	r6, [pc, #352]	; (b508c <_Z16updateBotControlv+0x17c>)
   b4f2a:	e9d3 4700 	ldrd	r4, r7, [r3]
        for(WaterBot &wb: WaterBots){       //Loop over discovered water bots and check if this bot has had one of its assets changed
   b4f2e:	42a7      	cmp	r7, r4
   b4f30:	d036      	beq.n	b4fa0 <_Z16updateBotControlv+0x90>
            if(wb.updatedControl){          //Flag represents a change of at least one modified asset - re-send control packet
   b4f32:	7863      	ldrb	r3, [r4, #1]
   b4f34:	2b00      	cmp	r3, #0
   b4f36:	d02d      	beq.n	b4f94 <_Z16updateBotControlv+0x84>
                wb.updatedControl = false;  //Clear flags for this bot
   b4f38:	7065      	strb	r5, [r4, #1]
   b4f3a:	f004 ff21 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
                sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum, wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);     //Print characteristics to string
   b4f3e:	7c23      	ldrb	r3, [r4, #16]
   b4f40:	78a2      	ldrb	r2, [r4, #2]
                wb.publishTime = millis();  //Inidicate the last time this bot had its control packet sent
   b4f42:	6460      	str	r0, [r4, #68]	; 0x44
                sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum, wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);     //Print characteristics to string
   b4f44:	9306      	str	r3, [sp, #24]
   b4f46:	7d63      	ldrb	r3, [r4, #21]
   b4f48:	9305      	str	r3, [sp, #20]
   b4f4a:	89e3      	ldrh	r3, [r4, #14]
   b4f4c:	9304      	str	r3, [sp, #16]
   b4f4e:	69e0      	ldr	r0, [r4, #28]
   b4f50:	9209      	str	r2, [sp, #36]	; 0x24
   b4f52:	f009 fc0d 	bl	be770 <__aeabi_f2d>
   b4f56:	e9cd 0102 	strd	r0, r1, [sp, #8]
   b4f5a:	69a0      	ldr	r0, [r4, #24]
   b4f5c:	f009 fc08 	bl	be770 <__aeabi_f2d>
   b4f60:	9a09      	ldr	r2, [sp, #36]	; 0x24
   b4f62:	e9cd 0100 	strd	r0, r1, [sp]
   b4f66:	4641      	mov	r1, r8
   b4f68:	a80b      	add	r0, sp, #44	; 0x2c
   b4f6a:	f005 fa57 	bl	ba41c <sprintf>
                if(!wb.XBeeAvail && !wb.BLEAvail && LTEStatuses && wb.LTEInitialStatus){    //Don't publish LTE when XBee or BLE are available
   b4f6e:	7a61      	ldrb	r1, [r4, #9]
   b4f70:	f081 0201 	eor.w	r2, r1, #1
   b4f74:	b981      	cbnz	r1, b4f98 <_Z16updateBotControlv+0x88>
   b4f76:	79e3      	ldrb	r3, [r4, #7]
   b4f78:	b983      	cbnz	r3, b4f9c <_Z16updateBotControlv+0x8c>
   b4f7a:	8831      	ldrh	r1, [r6, #0]
   b4f7c:	b119      	cbz	r1, b4f86 <_Z16updateBotControlv+0x76>
   b4f7e:	79a3      	ldrb	r3, [r4, #6]
   b4f80:	b10b      	cbz	r3, b4f86 <_Z16updateBotControlv+0x76>
                    LTEStatuses--;              //Counter to limit number of LTE messages sent per power-up of this bot. Limits LTE usage over long periods
   b4f82:	3901      	subs	r1, #1
   b4f84:	8031      	strh	r1, [r6, #0]
                sendData(statusStr,0,!(wb.XBeeAvail),true,rpiLTEStatus);    //Send out data over the available method
   b4f86:	9300      	str	r3, [sp, #0]
   b4f88:	2100      	movs	r1, #0
   b4f8a:	2301      	movs	r3, #1
   b4f8c:	a80b      	add	r0, sp, #44	; 0x2c
   b4f8e:	f7ff fd83 	bl	b4a98 <_Z8sendDataPKchbbb>
                wb.LTEInitialStatus = false;    //Flag set true when a status has been changed - don't send status if something hasn't been changed
   b4f92:	71a5      	strb	r5, [r4, #6]
      operator++() _GLIBCXX_NOEXCEPT
   b4f94:	3450      	adds	r4, #80	; 0x50
	return *this;
   b4f96:	e7ca      	b.n	b4f2e <_Z16updateBotControlv+0x1e>
                bool rpiLTEStatus = false;      //Flag to determine if LTE status should be sent
   b4f98:	2300      	movs	r3, #0
   b4f9a:	e7f4      	b.n	b4f86 <_Z16updateBotControlv+0x76>
   b4f9c:	460b      	mov	r3, r1
   b4f9e:	e7f2      	b.n	b4f86 <_Z16updateBotControlv+0x76>
    if(millis() - controlUpdateTime > CONTROL_PUB_TIME){        //Periodically send out the control packet - fixes problem when packets are missed
   b4fa0:	4c3b      	ldr	r4, [pc, #236]	; (b5090 <_Z16updateBotControlv+0x180>)
   b4fa2:	f004 feed 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4fa6:	6823      	ldr	r3, [r4, #0]
   b4fa8:	1ac0      	subs	r0, r0, r3
   b4faa:	f241 3388 	movw	r3, #5000	; 0x1388
   b4fae:	4298      	cmp	r0, r3
   b4fb0:	d946      	bls.n	b5040 <_Z16updateBotControlv+0x130>
        if(controlUpdateID == -1){                              //Check if this is the first status update
   b4fb2:	4d38      	ldr	r5, [pc, #224]	; (b5094 <_Z16updateBotControlv+0x184>)
   b4fb4:	4e34      	ldr	r6, [pc, #208]	; (b5088 <_Z16updateBotControlv+0x178>)
   b4fb6:	f004 fee3 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b4fba:	682a      	ldr	r2, [r5, #0]
        controlUpdateTime = millis();                           //Update timer for sending status update
   b4fbc:	6020      	str	r0, [r4, #0]
        if(controlUpdateID == -1){                              //Check if this is the first status update
   b4fbe:	1c53      	adds	r3, r2, #1
   b4fc0:	d141      	bne.n	b5046 <_Z16updateBotControlv+0x136>
            if(WaterBots.size() != 0) controlUpdateID = 0;      //Make sure some bots have been discovered before trying to send periodic status updates
   b4fc2:	e9d6 3200 	ldrd	r3, r2, [r6]
   b4fc6:	429a      	cmp	r2, r3
   b4fc8:	d03a      	beq.n	b5040 <_Z16updateBotControlv+0x130>
   b4fca:	2300      	movs	r3, #0
   b4fcc:	602b      	str	r3, [r5, #0]
        WaterBot wb = WaterBots.at(controlUpdateID);                    //Get a copy of the water bot in the vector that is at the circular pointer location
   b4fce:	6829      	ldr	r1, [r5, #0]
   b4fd0:	482d      	ldr	r0, [pc, #180]	; (b5088 <_Z16updateBotControlv+0x178>)
   b4fd2:	f7ff ff89 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
        sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum,wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);  //Populate string with command packet
   b4fd6:	7c03      	ldrb	r3, [r0, #16]
   b4fd8:	7882      	ldrb	r2, [r0, #2]
        WaterBot wb = WaterBots.at(controlUpdateID);                    //Get a copy of the water bot in the vector that is at the circular pointer location
   b4fda:	f890 9009 	ldrb.w	r9, [r0, #9]
   b4fde:	f890 8007 	ldrb.w	r8, [r0, #7]
   b4fe2:	6c87      	ldr	r7, [r0, #72]	; 0x48
        sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum,wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);  //Populate string with command packet
   b4fe4:	9306      	str	r3, [sp, #24]
   b4fe6:	7d43      	ldrb	r3, [r0, #21]
   b4fe8:	9305      	str	r3, [sp, #20]
   b4fea:	89c3      	ldrh	r3, [r0, #14]
   b4fec:	9304      	str	r3, [sp, #16]
        WaterBot wb = WaterBots.at(controlUpdateID);                    //Get a copy of the water bot in the vector that is at the circular pointer location
   b4fee:	4604      	mov	r4, r0
        sprintf(statusStr,"CCB%dctl%0.6f %0.6f %d %d %d",wb.botNum,wb.TargetLat, wb.TargetLon, wb.driveMode, wb.dataRecording, wb.signal);  //Populate string with command packet
   b4ff0:	69c0      	ldr	r0, [r0, #28]
   b4ff2:	9209      	str	r2, [sp, #36]	; 0x24
   b4ff4:	f009 fbbc 	bl	be770 <__aeabi_f2d>
   b4ff8:	e9cd 0102 	strd	r0, r1, [sp, #8]
   b4ffc:	69a0      	ldr	r0, [r4, #24]
   b4ffe:	f009 fbb7 	bl	be770 <__aeabi_f2d>
   b5002:	9a09      	ldr	r2, [sp, #36]	; 0x24
   b5004:	e9cd 0100 	strd	r0, r1, [sp]
   b5008:	4923      	ldr	r1, [pc, #140]	; (b5098 <_Z16updateBotControlv+0x188>)
   b500a:	a80b      	add	r0, sp, #44	; 0x2c
   b500c:	f005 fa06 	bl	ba41c <sprintf>
        if(!wb.XBeeAvail && !wb.BLEAvail && (millis() - wb.LTELastStatTime > LTE_CTL_PERIOD)){  //Determine if LTE should be used based on the availability of other communication modes
   b5010:	f1b9 0f00 	cmp.w	r9, #0
   b5014:	d021      	beq.n	b505a <_Z16updateBotControlv+0x14a>
        bool sendLTEStat = false;                               //Determine if we should send LTE on this go-around, limits periodic publishing over LTE to reduce usage
   b5016:	2300      	movs	r3, #0
        sendData(statusStr,0,false,true,sendLTEStat);           //Send out the data over the determined communication mode
   b5018:	2200      	movs	r2, #0
   b501a:	4611      	mov	r1, r2
   b501c:	9300      	str	r3, [sp, #0]
   b501e:	a80b      	add	r0, sp, #44	; 0x2c
   b5020:	2301      	movs	r3, #1
   b5022:	f7ff fd39 	bl	b4a98 <_Z8sendDataPKchbbb>
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5026:	e9d6 1300 	ldrd	r1, r3, [r6]
   b502a:	1a5b      	subs	r3, r3, r1
   b502c:	491b      	ldr	r1, [pc, #108]	; (b509c <_Z16updateBotControlv+0x18c>)
        if(controlUpdateID < WaterBots.size()-1) controlUpdateID++; //Advance the pointer for the circular buffer so the next bot in the vector is sent next time
   b502e:	682a      	ldr	r2, [r5, #0]
   b5030:	111b      	asrs	r3, r3, #4
   b5032:	434b      	muls	r3, r1
   b5034:	3b01      	subs	r3, #1
   b5036:	4293      	cmp	r3, r2
   b5038:	bf8c      	ite	hi
   b503a:	3201      	addhi	r2, #1
        else controlUpdateID = 0;
   b503c:	2200      	movls	r2, #0
   b503e:	602a      	str	r2, [r5, #0]
}
   b5040:	b017      	add	sp, #92	; 0x5c
   b5042:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   b5046:	e9d6 1300 	ldrd	r1, r3, [r6]
   b504a:	1a5b      	subs	r3, r3, r1
   b504c:	4913      	ldr	r1, [pc, #76]	; (b509c <_Z16updateBotControlv+0x18c>)
   b504e:	111b      	asrs	r3, r3, #4
   b5050:	434b      	muls	r3, r1
        if(controlUpdateID > WaterBots.size()-1) controlUpdateID = 0;   //Go around the vector of water bots circularly so each one is published at some point.
   b5052:	3b01      	subs	r3, #1
   b5054:	4293      	cmp	r3, r2
   b5056:	d3b8      	bcc.n	b4fca <_Z16updateBotControlv+0xba>
   b5058:	e7b9      	b.n	b4fce <_Z16updateBotControlv+0xbe>
        if(!wb.XBeeAvail && !wb.BLEAvail && (millis() - wb.LTELastStatTime > LTE_CTL_PERIOD)){  //Determine if LTE should be used based on the availability of other communication modes
   b505a:	f1b8 0f00 	cmp.w	r8, #0
   b505e:	d1da      	bne.n	b5016 <_Z16updateBotControlv+0x106>
   b5060:	f004 fe8e 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b5064:	f247 1348 	movw	r3, #29000	; 0x7148
   b5068:	1bc0      	subs	r0, r0, r7
   b506a:	4298      	cmp	r0, r3
   b506c:	d9d3      	bls.n	b5016 <_Z16updateBotControlv+0x106>
   b506e:	f004 fe87 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
            WaterBots.at(controlUpdateID).LTELastStatTime = millis();   //Set the timer for this water bot to indicate the last time LTE status was sent for it
   b5072:	6829      	ldr	r1, [r5, #0]
   b5074:	4604      	mov	r4, r0
   b5076:	4804      	ldr	r0, [pc, #16]	; (b5088 <_Z16updateBotControlv+0x178>)
   b5078:	f7ff ff36 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
            sendLTEStat = true;                                 //Set flag true if we should use LTE
   b507c:	2301      	movs	r3, #1
            WaterBots.at(controlUpdateID).LTELastStatTime = millis();   //Set the timer for this water bot to indicate the last time LTE status was sent for it
   b507e:	6484      	str	r4, [r0, #72]	; 0x48
   b5080:	e7ca      	b.n	b5018 <_Z16updateBotControlv+0x108>
   b5082:	bf00      	nop
   b5084:	2003e638 	.word	0x2003e638
   b5088:	2003dce4 	.word	0x2003dce4
   b508c:	2003daa8 	.word	0x2003daa8
   b5090:	2003dd6c 	.word	0x2003dd6c
   b5094:	2003dd68 	.word	0x2003dd68
   b5098:	000c1134 	.word	0x000c1134
   b509c:	cccccccd 	.word	0xcccccccd

000b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>:
      at(size_type __n)
   b50a0:	b510      	push	{r4, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b50a2:	e9d0 4200 	ldrd	r4, r2, [r0]
   b50a6:	4806      	ldr	r0, [pc, #24]	; (b50c0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj+0x20>)
   b50a8:	1b12      	subs	r2, r2, r4
   b50aa:	10d2      	asrs	r2, r2, #3
   b50ac:	4342      	muls	r2, r0
	if (__n >= this->size())
   b50ae:	4291      	cmp	r1, r2
   b50b0:	d302      	bcc.n	b50b8 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj+0x18>
	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
   b50b2:	4804      	ldr	r0, [pc, #16]	; (b50c4 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj+0x24>)
   b50b4:	f009 f835 	bl	be122 <_ZSt24__throw_out_of_range_fmtPKcz>
      }
   b50b8:	2028      	movs	r0, #40	; 0x28
   b50ba:	fb00 4001 	mla	r0, r0, r1, r4
   b50be:	bd10      	pop	{r4, pc}
   b50c0:	cccccccd 	.word	0xcccccccd
   b50c4:	000c10ea 	.word	0x000c10ea

000b50c8 <_Z8uHandlerv>:
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b50c8:	4b0c      	ldr	r3, [pc, #48]	; (b50fc <_Z8uHandlerv+0x34>)
void uHandler(){
   b50ca:	b510      	push	{r4, lr}
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b50cc:	2201      	movs	r2, #1
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b50ce:	4c0c      	ldr	r4, [pc, #48]	; (b5100 <_Z8uHandlerv+0x38>)
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b50d0:	701a      	strb	r2, [r3, #0]
   b50d2:	f004 fe55 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b50d6:	6823      	ldr	r3, [r4, #0]
   b50d8:	1ac0      	subs	r0, r0, r3
   b50da:	2895      	cmp	r0, #149	; 0x95
   b50dc:	d90d      	bls.n	b50fa <_Z8uHandlerv+0x32>
   b50de:	f004 fe4f 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(menuItem) menuItem--;                                //Go up by one menu item by decrementing the counter by one, as long as we are not at the top already
   b50e2:	4a08      	ldr	r2, [pc, #32]	; (b5104 <_Z8uHandlerv+0x3c>)
    debounceTime = millis();
   b50e4:	6020      	str	r0, [r4, #0]
    if(menuItem) menuItem--;                                //Go up by one menu item by decrementing the counter by one, as long as we are not at the top already
   b50e6:	7813      	ldrb	r3, [r2, #0]
   b50e8:	b10b      	cbz	r3, b50ee <_Z8uHandlerv+0x26>
   b50ea:	3b01      	subs	r3, #1
   b50ec:	7013      	strb	r3, [r2, #0]
    SelectedItem = &MenuItems.at(menuItem);                 //Update which item is selected so the redraw function can use it
   b50ee:	7811      	ldrb	r1, [r2, #0]
   b50f0:	4805      	ldr	r0, [pc, #20]	; (b5108 <_Z8uHandlerv+0x40>)
   b50f2:	f7ff ffd5 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b50f6:	4b05      	ldr	r3, [pc, #20]	; (b510c <_Z8uHandlerv+0x44>)
   b50f8:	6018      	str	r0, [r3, #0]
}
   b50fa:	bd10      	pop	{r4, pc}
   b50fc:	2003daaa 	.word	0x2003daaa
   b5100:	2003dd74 	.word	0x2003dd74
   b5104:	2003de05 	.word	0x2003de05
   b5108:	2003dcac 	.word	0x2003dcac
   b510c:	2003dcd4 	.word	0x2003dcd4

000b5110 <_Z8dHandlerv>:
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b5110:	4b0d      	ldr	r3, [pc, #52]	; (b5148 <_Z8dHandlerv+0x38>)
void dHandler(){
   b5112:	b510      	push	{r4, lr}
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b5114:	2201      	movs	r2, #1
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b5116:	4c0d      	ldr	r4, [pc, #52]	; (b514c <_Z8dHandlerv+0x3c>)
    redrawMenu = true;                                      //Set redraw flag always so the display is updated with new highlighted item
   b5118:	701a      	strb	r2, [r3, #0]
   b511a:	f004 fe31 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b511e:	6823      	ldr	r3, [r4, #0]
   b5120:	1ac0      	subs	r0, r0, r3
   b5122:	2895      	cmp	r0, #149	; 0x95
   b5124:	d90e      	bls.n	b5144 <_Z8dHandlerv+0x34>
   b5126:	f004 fe2b 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(menuItem < MAX_MENU_ITEMS-1) menuItem++;             //Go down by one menu item by incrementing the counter by one, as long as we are not at the bottom already
   b512a:	4a09      	ldr	r2, [pc, #36]	; (b5150 <_Z8dHandlerv+0x40>)
    debounceTime = millis();
   b512c:	6020      	str	r0, [r4, #0]
    if(menuItem < MAX_MENU_ITEMS-1) menuItem++;             //Go down by one menu item by incrementing the counter by one, as long as we are not at the bottom already
   b512e:	7813      	ldrb	r3, [r2, #0]
    SelectedItem = &MenuItems.at(menuItem);                 //Update which item is selected so the redraw function can use it
   b5130:	4808      	ldr	r0, [pc, #32]	; (b5154 <_Z8dHandlerv+0x44>)
    if(menuItem < MAX_MENU_ITEMS-1) menuItem++;             //Go down by one menu item by incrementing the counter by one, as long as we are not at the bottom already
   b5132:	2b05      	cmp	r3, #5
   b5134:	bf9c      	itt	ls
   b5136:	3301      	addls	r3, #1
   b5138:	7013      	strbls	r3, [r2, #0]
    SelectedItem = &MenuItems.at(menuItem);                 //Update which item is selected so the redraw function can use it
   b513a:	7811      	ldrb	r1, [r2, #0]
   b513c:	f7ff ffb0 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b5140:	4b05      	ldr	r3, [pc, #20]	; (b5158 <_Z8dHandlerv+0x48>)
   b5142:	6018      	str	r0, [r3, #0]
}
   b5144:	bd10      	pop	{r4, pc}
   b5146:	bf00      	nop
   b5148:	2003daaa 	.word	0x2003daaa
   b514c:	2003dd74 	.word	0x2003dd74
   b5150:	2003de05 	.word	0x2003de05
   b5154:	2003dcac 	.word	0x2003dcac
   b5158:	2003dcd4 	.word	0x2003dcd4

000b515c <_ZNSt6vectorI6StringSaIS0_EE2atEj>:
      at(size_type __n)
   b515c:	b538      	push	{r3, r4, r5, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b515e:	e9d0 5400 	ldrd	r5, r4, [r0]
   b5162:	1b64      	subs	r4, r4, r5
	if (__n >= this->size())
   b5164:	ebb1 1f24 	cmp.w	r1, r4, asr #4
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5168:	ea4f 1224 	mov.w	r2, r4, asr #4
	if (__n >= this->size())
   b516c:	d302      	bcc.n	b5174 <_ZNSt6vectorI6StringSaIS0_EE2atEj+0x18>
	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
   b516e:	4803      	ldr	r0, [pc, #12]	; (b517c <_ZNSt6vectorI6StringSaIS0_EE2atEj+0x20>)
   b5170:	f008 ffd7 	bl	be122 <_ZSt24__throw_out_of_range_fmtPKcz>
      }
   b5174:	eb05 1001 	add.w	r0, r5, r1, lsl #4
   b5178:	bd38      	pop	{r3, r4, r5, pc}
   b517a:	bf00      	nop
   b517c:	000c10ea 	.word	0x000c10ea

000b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>:
      ~vector() _GLIBCXX_NOEXCEPT
   b5180:	b570      	push	{r4, r5, r6, lr}
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   b5182:	e9d0 5600 	ldrd	r5, r6, [r0]
      ~vector() _GLIBCXX_NOEXCEPT
   b5186:	4604      	mov	r4, r0
    {
      template<typename _ForwardIterator>
	static _GLIBCXX20_CONSTEXPR void
	__destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
   b5188:	42ae      	cmp	r6, r5
   b518a:	d004      	beq.n	b5196 <_ZNSt6vectorI6StringSaIS0_EED1Ev+0x16>
      __pointer->~_Tp();
   b518c:	4628      	mov	r0, r5
   b518e:	f005 faab 	bl	ba6e8 <_ZN6StringD1Ev>
	  for (; __first != __last; ++__first)
   b5192:	3510      	adds	r5, #16
   b5194:	e7f8      	b.n	b5188 <_ZNSt6vectorI6StringSaIS0_EED1Ev+0x8>
	_M_deallocate(_M_impl._M_start,
   b5196:	6820      	ldr	r0, [r4, #0]
	if (__p)
   b5198:	b118      	cbz	r0, b51a2 <_ZNSt6vectorI6StringSaIS0_EED1Ev+0x22>
		      _M_impl._M_end_of_storage - _M_impl._M_start);
   b519a:	68a1      	ldr	r1, [r4, #8]
# endif
			      std::align_val_t(alignof(_Tp)));
	    return;
	  }
#endif
	::operator delete(__p
   b519c:	1a09      	subs	r1, r1, r0
   b519e:	f7fe ff7e 	bl	b409e <_ZdlPvj>
      }
   b51a2:	4620      	mov	r0, r4
   b51a4:	bd70      	pop	{r4, r5, r6, pc}

000b51a6 <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0>:
    }

  template <typename _InputIterator, typename _ForwardIterator,
	    typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
   b51a6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b51a8:	4604      	mov	r4, r0
   b51aa:	460e      	mov	r6, r1
   b51ac:	4615      	mov	r5, r2
	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
   b51ae:	2700      	movs	r7, #0
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
	  "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
   b51b0:	42b4      	cmp	r4, r6
   b51b2:	d029      	beq.n	b5208 <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0+0x62>
#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
	void
	construct(_Up* __p, _Args&&... __args)
	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b51b4:	b315      	cbz	r5, b51fc <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0+0x56>
	: _M_start(__x._M_start), _M_finish(__x._M_finish),
   b51b6:	6823      	ldr	r3, [r4, #0]
	  _M_end_of_storage(__x._M_end_of_storage)
   b51b8:	602b      	str	r3, [r5, #0]
	: _M_start(__x._M_start), _M_finish(__x._M_finish),
   b51ba:	6863      	ldr	r3, [r4, #4]
	  _M_end_of_storage(__x._M_end_of_storage)
   b51bc:	606b      	str	r3, [r5, #4]
   b51be:	68a3      	ldr	r3, [r4, #8]
   b51c0:	60ab      	str	r3, [r5, #8]
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b51c2:	68e3      	ldr	r3, [r4, #12]
	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
   b51c4:	6027      	str	r7, [r4, #0]
   b51c6:	e9c4 7701 	strd	r7, r7, [r4, #4]
   b51ca:	60eb      	str	r3, [r5, #12]
   b51cc:	6923      	ldr	r3, [r4, #16]
   b51ce:	612b      	str	r3, [r5, #16]
   b51d0:	8aa3      	ldrh	r3, [r4, #20]
   b51d2:	82ab      	strh	r3, [r5, #20]
   b51d4:	7da3      	ldrb	r3, [r4, #22]
   b51d6:	75ab      	strb	r3, [r5, #22]
   b51d8:	7de3      	ldrb	r3, [r4, #23]
   b51da:	75eb      	strb	r3, [r5, #23]
   b51dc:	7e23      	ldrb	r3, [r4, #24]
   b51de:	762b      	strb	r3, [r5, #24]
   b51e0:	8b63      	ldrh	r3, [r4, #26]
   b51e2:	836b      	strh	r3, [r5, #26]
   b51e4:	8ba3      	ldrh	r3, [r4, #28]
   b51e6:	83ab      	strh	r3, [r5, #28]
   b51e8:	f8d4 301e 	ldr.w	r3, [r4, #30]
   b51ec:	f8c5 301e 	str.w	r3, [r5, #30]
   b51f0:	f8d4 3022 	ldr.w	r3, [r4, #34]	; 0x22
   b51f4:	f8c5 3022 	str.w	r3, [r5, #34]	; 0x22
   b51f8:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   b51fa:	84eb      	strh	r3, [r5, #38]	; 0x26
   b51fc:	4620      	mov	r0, r4
   b51fe:	f7ff ffbf 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b5202:	3428      	adds	r4, #40	; 0x28
   b5204:	3528      	adds	r5, #40	; 0x28
   b5206:	e7d3      	b.n	b51b0 <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0+0xa>
	std::__relocate_object_a(std::__addressof(*__cur),
				 std::__addressof(*__first), __alloc);
      return __cur;
    }
   b5208:	4628      	mov	r0, r5
   b520a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b520c <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>:

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
   b520c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5210:	e9d0 8a00 	ldrd	r8, sl, [r0]
   b5214:	4b2f      	ldr	r3, [pc, #188]	; (b52d4 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xc8>)
   b5216:	ebaa 0408 	sub.w	r4, sl, r8
   b521a:	435c      	muls	r4, r3

      // Called by _M_fill_insert, _M_insert_aux etc.
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
   b521c:	4b2e      	ldr	r3, [pc, #184]	; (b52d8 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xcc>)
   b521e:	429c      	cmp	r4, r3
   b5220:	4689      	mov	r9, r1
   b5222:	4607      	mov	r7, r0
   b5224:	4611      	mov	r1, r2
   b5226:	d102      	bne.n	b522e <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x22>
	  __throw_length_error(__N(__s));
   b5228:	482c      	ldr	r0, [pc, #176]	; (b52dc <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xd0>)
   b522a:	f008 ff77 	bl	be11c <_ZSt20__throw_length_errorPKc>
   b522e:	2c01      	cmp	r4, #1
   b5230:	4622      	mov	r2, r4
   b5232:	bf38      	it	cc
   b5234:	2201      	movcc	r2, #1
   b5236:	18a4      	adds	r4, r4, r2
    _GLIBCXX20_CONSTEXPR
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() - __rhs.base(); }
   b5238:	eba9 0508 	sub.w	r5, r9, r8

	const size_type __len = size() + (std::max)(size(), __n);
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b523c:	d21d      	bcs.n	b527a <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x6e>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b523e:	b1f4      	cbz	r4, b527e <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x72>
   b5240:	429c      	cmp	r4, r3
   b5242:	bf28      	it	cs
   b5244:	461c      	movcs	r4, r3
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   b5246:	2049      	movs	r0, #73	; 0x49
   b5248:	4360      	muls	r0, r4
   b524a:	9101      	str	r1, [sp, #4]
   b524c:	f7fe ff23 	bl	b4096 <_Znwj>
   b5250:	9901      	ldr	r1, [sp, #4]
   b5252:	4606      	mov	r6, r0
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b5254:	1970      	adds	r0, r6, r5
   b5256:	d002      	beq.n	b525e <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x52>
   b5258:	2249      	movs	r2, #73	; 0x49
   b525a:	f009 fe26 	bl	beeaa <memcpy>
   b525e:	4633      	mov	r3, r6
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5260:	4645      	mov	r5, r8
      for (; __first != __last; ++__first, (void)++__cur)
   b5262:	45a9      	cmp	r9, r5
   b5264:	d00d      	beq.n	b5282 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x76>
   b5266:	b12b      	cbz	r3, b5274 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x68>
   b5268:	4618      	mov	r0, r3
   b526a:	2249      	movs	r2, #73	; 0x49
   b526c:	4629      	mov	r1, r5
   b526e:	f009 fe1c 	bl	beeaa <memcpy>
   b5272:	4603      	mov	r3, r0
   b5274:	3549      	adds	r5, #73	; 0x49
   b5276:	3349      	adds	r3, #73	; 0x49
   b5278:	e7f3      	b.n	b5262 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x56>
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b527a:	461c      	mov	r4, r3
   b527c:	e7e3      	b.n	b5246 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x3a>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b527e:	4626      	mov	r6, r4
   b5280:	e7e8      	b.n	b5254 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x48>
	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
	    {
	      __new_finish = _S_relocate(__old_start, __position.base(),
					 __new_start, _M_get_Tp_allocator());

	      ++__new_finish;
   b5282:	eba5 0908 	sub.w	r9, r5, r8
   b5286:	f109 0949 	add.w	r9, r9, #73	; 0x49
   b528a:	44b1      	add	r9, r6
   b528c:	462b      	mov	r3, r5
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
   b528e:	46cb      	mov	fp, r9
      for (; __first != __last; ++__first, (void)++__cur)
   b5290:	4555      	cmp	r5, sl
   b5292:	f10b 0b49 	add.w	fp, fp, #73	; 0x49
   b5296:	d009      	beq.n	b52ac <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xa0>
   b5298:	4629      	mov	r1, r5
   b529a:	2249      	movs	r2, #73	; 0x49
   b529c:	f1ab 0049 	sub.w	r0, fp, #73	; 0x49
   b52a0:	9301      	str	r3, [sp, #4]
   b52a2:	3549      	adds	r5, #73	; 0x49
   b52a4:	f009 fe01 	bl	beeaa <memcpy>
   b52a8:	9b01      	ldr	r3, [sp, #4]
   b52aa:	e7f1      	b.n	b5290 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x84>
   b52ac:	1aed      	subs	r5, r5, r3
   b52ae:	444d      	add	r5, r9
	if (__p)
   b52b0:	f1b8 0f00 	cmp.w	r8, #0
   b52b4:	d005      	beq.n	b52c2 <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xb6>
      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
#endif
	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      _GLIBCXX_ASAN_ANNOTATE_REINIT;
      _M_deallocate(__old_start,
		    this->_M_impl._M_end_of_storage - __old_start);
   b52b6:	68b9      	ldr	r1, [r7, #8]
	::operator delete(__p
   b52b8:	4640      	mov	r0, r8
   b52ba:	eba1 0108 	sub.w	r1, r1, r8
   b52be:	f7fe feee 	bl	b409e <_ZdlPvj>
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b52c2:	2049      	movs	r0, #73	; 0x49
   b52c4:	fb00 6404 	mla	r4, r0, r4, r6
      this->_M_impl._M_finish = __new_finish;
   b52c8:	e9c7 6500 	strd	r6, r5, [r7]
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b52cc:	60bc      	str	r4, [r7, #8]
    }
   b52ce:	b003      	add	sp, #12
   b52d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b52d4:	c7e3f1f9 	.word	0xc7e3f1f9
   b52d8:	01c0e070 	.word	0x01c0e070
   b52dc:	000c1151 	.word	0x000c1151

000b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>:
      push_back(const value_type& __x)
   b52e0:	b538      	push	{r3, r4, r5, lr}
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b52e2:	e9d0 3501 	ldrd	r3, r5, [r0, #4]
   b52e6:	42ab      	cmp	r3, r5
      push_back(const value_type& __x)
   b52e8:	4604      	mov	r4, r0
   b52ea:	460a      	mov	r2, r1
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b52ec:	d008      	beq.n	b5300 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_+0x20>
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b52ee:	b11b      	cbz	r3, b52f8 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_+0x18>
   b52f0:	2249      	movs	r2, #73	; 0x49
   b52f2:	4618      	mov	r0, r3
   b52f4:	f009 fdd9 	bl	beeaa <memcpy>
	    ++this->_M_impl._M_finish;
   b52f8:	6863      	ldr	r3, [r4, #4]
   b52fa:	3349      	adds	r3, #73	; 0x49
   b52fc:	6063      	str	r3, [r4, #4]
      }
   b52fe:	bd38      	pop	{r3, r4, r5, pc}
	  _M_realloc_insert(end(), __x);
   b5300:	4619      	mov	r1, r3
   b5302:	f7ff ff83 	bl	b520c <_ZNSt6vectorI9MenuPopUpSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>
      }
   b5306:	e7fa      	b.n	b52fe <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_+0x1e>

000b5308 <_Z8sHandlerv>:

//Stop button interrupt handler - sets stop flag for all bots and creates a pop-up showing that a stop was set or cleared
void sHandler(){    
   b5308:	b530      	push	{r4, r5, lr}
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b530a:	4c26      	ldr	r4, [pc, #152]	; (b53a4 <_Z8sHandlerv+0x9c>)
void sHandler(){    
   b530c:	b095      	sub	sp, #84	; 0x54
   b530e:	f004 fd37 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis()-debounceTime < DEBOUNCE_MS) return;         //debounce this button, to make sure only one trigger is registered per press
   b5312:	6823      	ldr	r3, [r4, #0]
   b5314:	1ac0      	subs	r0, r0, r3
   b5316:	2895      	cmp	r0, #149	; 0x95
   b5318:	d925      	bls.n	b5366 <_Z8sHandlerv+0x5e>
   b531a:	f004 fd31 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    debounceTime = millis();
   b531e:	6020      	str	r0, [r4, #0]
    if(stopActive){                                         //Check if the user has initiated a stop, if so, then exit stop mode
   b5320:	4c21      	ldr	r4, [pc, #132]	; (b53a8 <_Z8sHandlerv+0xa0>)
   b5322:	4d22      	ldr	r5, [pc, #136]	; (b53ac <_Z8sHandlerv+0xa4>)
   b5324:	7823      	ldrb	r3, [r4, #0]
   b5326:	b303      	cbz	r3, b536a <_Z8sHandlerv+0x62>
        MenuPopUp m;                                        //Create pop-up to indicate to user that we are exiting stop mode
        sprintf(m.primaryLine,"CLEARED\0");                 //Main display line
   b5328:	4921      	ldr	r1, [pc, #132]	; (b53b0 <_Z8sHandlerv+0xa8>)
   b532a:	a801      	add	r0, sp, #4
   b532c:	f009 fe35 	bl	bef9a <strcpy>
        sprintf(m.secondaryLine,"Motors Resuming");         //Secondary display line
   b5330:	4920      	ldr	r1, [pc, #128]	; (b53b4 <_Z8sHandlerv+0xac>)
   b5332:	f10d 000e 	add.w	r0, sp, #14
   b5336:	f009 fe30 	bl	bef9a <strcpy>
        sprintf(m.tertiaryLine, "Press again to stop");     //Tertiary display line
   b533a:	491f      	ldr	r1, [pc, #124]	; (b53b8 <_Z8sHandlerv+0xb0>)
   b533c:	a80b      	add	r0, sp, #44	; 0x2c
   b533e:	f009 fe2c 	bl	bef9a <strcpy>
        m.primaryStart = 20;                                //Horizontal pixel that the main line starts at
   b5342:	2314      	movs	r3, #20
   b5344:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
        m.secondaryStart = 20;                              //Horizontal pixel that the secondary line starts at
   b5348:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
        m.tertiaryStart = 7;                                //Horizontal pixel that the tertiary line starts at
        PopUps.push_back(m);                                //Push the warning item onto the stack of pop-ups
   b534c:	481b      	ldr	r0, [pc, #108]	; (b53bc <_Z8sHandlerv+0xb4>)
        m.tertiaryStart = 7;                                //Horizontal pixel that the tertiary line starts at
   b534e:	2307      	movs	r3, #7
        PopUps.push_back(m);                                //Push the warning item onto the stack of pop-ups
   b5350:	a901      	add	r1, sp, #4
        m.tertiaryStart = 7;                                //Horizontal pixel that the tertiary line starts at
   b5352:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
        PopUps.push_back(m);                                //Push the warning item onto the stack of pop-ups
   b5356:	f7ff ffc3 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
        redrawMenu = true;                                  //Set flag for redraw so main loop will display pop-up
   b535a:	2301      	movs	r3, #1
        stopActive = false;                                 //Clear global flag so main loop will stop sending the stop command (can't do that here because it's an ISR)
        LTEStopSent = false;                                //Every time there is a stop, use LTE one time
   b535c:	4a18      	ldr	r2, [pc, #96]	; (b53c0 <_Z8sHandlerv+0xb8>)
        redrawMenu = true;                                  //Set flag for redraw so main loop will display pop-up
   b535e:	702b      	strb	r3, [r5, #0]
        stopActive = false;                                 //Clear global flag so main loop will stop sending the stop command (can't do that here because it's an ISR)
   b5360:	2300      	movs	r3, #0
   b5362:	7023      	strb	r3, [r4, #0]
        LTEStopSent = false;                                //Every time there is a stop, use LTE one time
   b5364:	7013      	strb	r3, [r2, #0]
        m.tertiaryStart = 5;                                //Horizontal pixel that the tertiary line starts at
        PopUps.push_back(m);                                //Set flag for redraw so main loop will display pop-up
        redrawMenu = true;                                  //Set global flag so main loop will send the stop command (can't do that here because it's an ISR)
        stopActive = true;                                  //Set global flag so main loop will send the stop command (can't do that here because it's an ISR)
    }
}
   b5366:	b015      	add	sp, #84	; 0x54
   b5368:	bd30      	pop	{r4, r5, pc}
        sprintf(m.primaryLine,"STOPPED\0");                 //Main display line
   b536a:	4916      	ldr	r1, [pc, #88]	; (b53c4 <_Z8sHandlerv+0xbc>)
   b536c:	a801      	add	r0, sp, #4
   b536e:	f009 fe14 	bl	bef9a <strcpy>
        sprintf(m.secondaryLine,"Motors Stopped!");         //Secondary display line
   b5372:	4915      	ldr	r1, [pc, #84]	; (b53c8 <_Z8sHandlerv+0xc0>)
   b5374:	f10d 000e 	add.w	r0, sp, #14
   b5378:	f009 fe0f 	bl	bef9a <strcpy>
        sprintf(m.tertiaryLine, "Press again to start");    //Tertiary display line
   b537c:	4913      	ldr	r1, [pc, #76]	; (b53cc <_Z8sHandlerv+0xc4>)
   b537e:	a80b      	add	r0, sp, #44	; 0x2c
   b5380:	f009 fe0b 	bl	bef9a <strcpy>
        m.primaryStart = 20;                                //Horizontal pixel that the main line starts at
   b5384:	2314      	movs	r3, #20
   b5386:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
        m.secondaryStart = 20;                              //Horizontal pixel that the secondary line starts at
   b538a:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
        PopUps.push_back(m);                                //Set flag for redraw so main loop will display pop-up
   b538e:	480b      	ldr	r0, [pc, #44]	; (b53bc <_Z8sHandlerv+0xb4>)
        m.tertiaryStart = 5;                                //Horizontal pixel that the tertiary line starts at
   b5390:	2305      	movs	r3, #5
        PopUps.push_back(m);                                //Set flag for redraw so main loop will display pop-up
   b5392:	a901      	add	r1, sp, #4
        m.tertiaryStart = 5;                                //Horizontal pixel that the tertiary line starts at
   b5394:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
        PopUps.push_back(m);                                //Set flag for redraw so main loop will display pop-up
   b5398:	f7ff ffa2 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
        redrawMenu = true;                                  //Set global flag so main loop will send the stop command (can't do that here because it's an ISR)
   b539c:	2301      	movs	r3, #1
   b539e:	702b      	strb	r3, [r5, #0]
        stopActive = true;                                  //Set global flag so main loop will send the stop command (can't do that here because it's an ISR)
   b53a0:	7023      	strb	r3, [r4, #0]
   b53a2:	e7e0      	b.n	b5366 <_Z8sHandlerv+0x5e>
   b53a4:	2003dd74 	.word	0x2003dd74
   b53a8:	2003e631 	.word	0x2003e631
   b53ac:	2003daaa 	.word	0x2003daaa
   b53b0:	000c1460 	.word	0x000c1460
   b53b4:	000c116b 	.word	0x000c116b
   b53b8:	000c117b 	.word	0x000c117b
   b53bc:	2003dcc4 	.word	0x2003dcc4
   b53c0:	2003dca9 	.word	0x2003dca9
   b53c4:	000c1469 	.word	0x000c1469
   b53c8:	000c118f 	.word	0x000c118f
   b53cc:	000c119f 	.word	0x000c119f

000b53d0 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>:
      vector<_Tp, _Alloc>::
   b53d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b53d4:	e9d0 8900 	ldrd	r8, r9, [r0]
   b53d8:	4b39      	ldr	r3, [pc, #228]	; (b54c0 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xf0>)
   b53da:	eba9 0408 	sub.w	r4, r9, r8
   b53de:	1124      	asrs	r4, r4, #4
   b53e0:	435c      	muls	r4, r3
	if (max_size() - size() < __n)
   b53e2:	4b38      	ldr	r3, [pc, #224]	; (b54c4 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xf4>)
   b53e4:	429c      	cmp	r4, r3
   b53e6:	468a      	mov	sl, r1
   b53e8:	4607      	mov	r7, r0
   b53ea:	4611      	mov	r1, r2
   b53ec:	d102      	bne.n	b53f4 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x24>
	  __throw_length_error(__N(__s));
   b53ee:	4836      	ldr	r0, [pc, #216]	; (b54c8 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xf8>)
   b53f0:	f008 fe94 	bl	be11c <_ZSt20__throw_length_errorPKc>
   b53f4:	2c01      	cmp	r4, #1
   b53f6:	4622      	mov	r2, r4
   b53f8:	bf38      	it	cc
   b53fa:	2201      	movcc	r2, #1
   b53fc:	18a4      	adds	r4, r4, r2
   b53fe:	ebaa 0508 	sub.w	r5, sl, r8
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b5402:	d21e      	bcs.n	b5442 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x72>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b5404:	b1fc      	cbz	r4, b5446 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x76>
   b5406:	429c      	cmp	r4, r3
   b5408:	bf28      	it	cs
   b540a:	461c      	movcs	r4, r3
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   b540c:	2050      	movs	r0, #80	; 0x50
   b540e:	4360      	muls	r0, r4
   b5410:	9100      	str	r1, [sp, #0]
   b5412:	f7fe fe40 	bl	b4096 <_Znwj>
   b5416:	9900      	ldr	r1, [sp, #0]
   b5418:	4606      	mov	r6, r0
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b541a:	1970      	adds	r0, r6, r5
   b541c:	d002      	beq.n	b5424 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x54>
   b541e:	2250      	movs	r2, #80	; 0x50
   b5420:	f009 fd43 	bl	beeaa <memcpy>
   b5424:	4633      	mov	r3, r6
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5426:	46c3      	mov	fp, r8
   b5428:	45da      	cmp	sl, fp
   b542a:	d00e      	beq.n	b544a <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x7a>
   b542c:	b12b      	cbz	r3, b543a <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x6a>
   b542e:	4618      	mov	r0, r3
   b5430:	2250      	movs	r2, #80	; 0x50
   b5432:	4659      	mov	r1, fp
   b5434:	f009 fd39 	bl	beeaa <memcpy>
   b5438:	4603      	mov	r3, r0
   b543a:	f10b 0b50 	add.w	fp, fp, #80	; 0x50
   b543e:	3350      	adds	r3, #80	; 0x50
   b5440:	e7f2      	b.n	b5428 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x58>
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b5442:	461c      	mov	r4, r3
   b5444:	e7e2      	b.n	b540c <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x3c>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b5446:	4626      	mov	r6, r4
   b5448:	e7e7      	b.n	b541a <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x4a>
   b544a:	f8df a080 	ldr.w	sl, [pc, #128]	; b54cc <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xfc>
   b544e:	092d      	lsrs	r5, r5, #4
   b5450:	fb0a f505 	mul.w	r5, sl, r5
   b5454:	2350      	movs	r3, #80	; 0x50
   b5456:	f025 4570 	bic.w	r5, r5, #4026531840	; 0xf0000000
   b545a:	435d      	muls	r5, r3
   b545c:	eb08 0b05 	add.w	fp, r8, r5
	      ++__new_finish;
   b5460:	441d      	add	r5, r3
   b5462:	4435      	add	r5, r6
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
   b5464:	462b      	mov	r3, r5
   b5466:	4659      	mov	r1, fp
      for (; __first != __last; ++__first, (void)++__cur)
   b5468:	4549      	cmp	r1, r9
   b546a:	f103 0350 	add.w	r3, r3, #80	; 0x50
   b546e:	d00a      	beq.n	b5486 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xb6>
   b5470:	f1a3 0050 	sub.w	r0, r3, #80	; 0x50
   b5474:	2250      	movs	r2, #80	; 0x50
   b5476:	9101      	str	r1, [sp, #4]
   b5478:	9300      	str	r3, [sp, #0]
   b547a:	f009 fd16 	bl	beeaa <memcpy>
   b547e:	9901      	ldr	r1, [sp, #4]
   b5480:	9b00      	ldr	r3, [sp, #0]
   b5482:	3150      	adds	r1, #80	; 0x50
   b5484:	e7f0      	b.n	b5468 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x98>
   b5486:	eba1 010b 	sub.w	r1, r1, fp
   b548a:	0909      	lsrs	r1, r1, #4
   b548c:	fb0a fa01 	mul.w	sl, sl, r1
   b5490:	f02a 4a70 	bic.w	sl, sl, #4026531840	; 0xf0000000
   b5494:	2350      	movs	r3, #80	; 0x50
   b5496:	fb03 550a 	mla	r5, r3, sl, r5
	if (__p)
   b549a:	f1b8 0f00 	cmp.w	r8, #0
   b549e:	d005      	beq.n	b54ac <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xdc>
		    this->_M_impl._M_end_of_storage - __old_start);
   b54a0:	68b9      	ldr	r1, [r7, #8]
	::operator delete(__p
   b54a2:	4640      	mov	r0, r8
   b54a4:	eba1 0108 	sub.w	r1, r1, r8
   b54a8:	f7fe fdf9 	bl	b409e <_ZdlPvj>
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b54ac:	2050      	movs	r0, #80	; 0x50
   b54ae:	fb00 6404 	mla	r4, r0, r4, r6
      this->_M_impl._M_finish = __new_finish;
   b54b2:	e9c7 6500 	strd	r6, r5, [r7]
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b54b6:	60bc      	str	r4, [r7, #8]
    }
   b54b8:	b003      	add	sp, #12
   b54ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b54be:	bf00      	nop
   b54c0:	cccccccd 	.word	0xcccccccd
   b54c4:	01999999 	.word	0x01999999
   b54c8:	000c1151 	.word	0x000c1151
   b54cc:	0ccccccd 	.word	0x0ccccccd

000b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>:
      push_back(const value_type& __x)
   b54d0:	b538      	push	{r3, r4, r5, lr}
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b54d2:	e9d0 3501 	ldrd	r3, r5, [r0, #4]
   b54d6:	42ab      	cmp	r3, r5
      push_back(const value_type& __x)
   b54d8:	4604      	mov	r4, r0
   b54da:	460a      	mov	r2, r1
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b54dc:	d008      	beq.n	b54f0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_+0x20>
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b54de:	b11b      	cbz	r3, b54e8 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_+0x18>
   b54e0:	2250      	movs	r2, #80	; 0x50
   b54e2:	4618      	mov	r0, r3
   b54e4:	f009 fce1 	bl	beeaa <memcpy>
	    ++this->_M_impl._M_finish;
   b54e8:	6863      	ldr	r3, [r4, #4]
   b54ea:	3350      	adds	r3, #80	; 0x50
   b54ec:	6063      	str	r3, [r4, #4]
      }
   b54ee:	bd38      	pop	{r3, r4, r5, pc}
	  _M_realloc_insert(end(), __x);
   b54f0:	4619      	mov	r1, r3
   b54f2:	f7ff ff6d 	bl	b53d0 <_ZNSt6vectorI8WaterBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>
      }
   b54f6:	e7fa      	b.n	b54ee <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_+0x1e>

000b54f8 <_Z14processCommandPKchb.part.0>:
void processCommand(const char *command, uint8_t mode, bool sendAck){
   b54f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b54fc:	b0ad      	sub	sp, #180	; 0xb4
   b54fe:	af06      	add	r7, sp, #24
        rxIDBuf[0] = command[1];                                    //Convert the source bot to a single character
   b5500:	7843      	ldrb	r3, [r0, #1]
void processCommand(const char *command, uint8_t mode, bool sendAck){
   b5502:	60f9      	str	r1, [r7, #12]
   b5504:	4604      	mov	r4, r0
        uint8_t rxBotID = atoi(rxIDBuf);                            //Convert the character to an integer for comparison
   b5506:	f107 0014 	add.w	r0, r7, #20
        rxIDBuf[0] = command[1];                                    //Convert the source bot to a single character
   b550a:	753b      	strb	r3, [r7, #20]
        uint8_t rxBotID = atoi(rxIDBuf);                            //Convert the character to an integer for comparison
   b550c:	f009 fcb9 	bl	bee82 <atoi>
   b5510:	60b8      	str	r0, [r7, #8]
   b5512:	f897 8008 	ldrb.w	r8, [r7, #8]
        if(rxBotID > 9) return;                                     //Only accept bot ids between 0 and 9
   b5516:	f1b8 0f09 	cmp.w	r8, #9
        }
   b551a:	46eb      	mov	fp, sp
        if(rxBotID > 9) return;                                     //Only accept bot ids between 0 and 9
   b551c:	d846      	bhi.n	b55ac <_Z14processCommandPKchb.part.0+0xb4>
        char dataStr[strlen(command)-8];                            //Create array to hold the data portion of the received message
   b551e:	4620      	mov	r0, r4
   b5520:	f009 fd61 	bl	befe6 <strlen>
   b5524:	3801      	subs	r0, #1
   b5526:	f020 0007 	bic.w	r0, r0, #7
   b552a:	ebad 0d00 	sub.w	sp, sp, r0
        dataStr[strlen(command)-9] = '\0';                          //Set null character to allow use of string compare functions (causes a nasty bug of flowing to surrounding memory otherwise)
   b552e:	4620      	mov	r0, r4
   b5530:	f009 fd59 	bl	befe6 <strlen>
        char dataStr[strlen(command)-8];                            //Create array to hold the data portion of the received message
   b5534:	ae06      	add	r6, sp, #24
        dataStr[strlen(command)-9] = '\0';                          //Set null character to allow use of string compare functions (causes a nasty bug of flowing to surrounding memory otherwise)
   b5536:	4430      	add	r0, r6
   b5538:	2500      	movs	r5, #0
   b553a:	f800 5c09 	strb.w	r5, [r0, #-9]
        checkStr[0] = command[strlen(command)-2];                   //Copy in the last 2 characters from the end of the message
   b553e:	4620      	mov	r0, r4
        cmdStr[3] = '\0';                                           //Set null character to allow use of string compare functions (causes a nasty bug of flowing to surrounding memory otherwise)
   b5540:	77fd      	strb	r5, [r7, #31]
        checkStr[0] = command[strlen(command)-2];                   //Copy in the last 2 characters from the end of the message
   b5542:	f009 fd50 	bl	befe6 <strlen>
   b5546:	4420      	add	r0, r4
   b5548:	f810 3c02 	ldrb.w	r3, [r0, #-2]
   b554c:	763b      	strb	r3, [r7, #24]
        checkStr[1] = command[strlen(command)-1];                   //Copy in the last 2 characters from the end of the message
   b554e:	4620      	mov	r0, r4
   b5550:	f009 fd49 	bl	befe6 <strlen>
   b5554:	4420      	add	r0, r4
        checksum = (uint8_t)strtol(checkStr, NULL, 16);             //Convert to number base 16
   b5556:	4629      	mov	r1, r5
        checkStr[1] = command[strlen(command)-1];                   //Copy in the last 2 characters from the end of the message
   b5558:	f810 3c01 	ldrb.w	r3, [r0, #-1]
        checkStr[2] = '\0';                                         //Null terminator for string compare
   b555c:	76bd      	strb	r5, [r7, #26]
        checksum = (uint8_t)strtol(checkStr, NULL, 16);             //Convert to number base 16
   b555e:	2210      	movs	r2, #16
   b5560:	f107 0018 	add.w	r0, r7, #24
        checkStr[1] = command[strlen(command)-1];                   //Copy in the last 2 characters from the end of the message
   b5564:	767b      	strb	r3, [r7, #25]
        checksum = (uint8_t)strtol(checkStr, NULL, 16);             //Convert to number base 16
   b5566:	f00a fc2b 	bl	bfdc0 <strtol>
        for(uint8_t i = 4; i < strlen(command)-2;i++){              //Copy in the data portion to the data string
   b556a:	2504      	movs	r5, #4
        checksum = (uint8_t)strtol(checkStr, NULL, 16);             //Convert to number base 16
   b556c:	4681      	mov	r9, r0
        for(uint8_t i = 4; i < strlen(command)-2;i++){              //Copy in the data portion to the data string
   b556e:	4620      	mov	r0, r4
   b5570:	f009 fd39 	bl	befe6 <strlen>
   b5574:	3802      	subs	r0, #2
   b5576:	4285      	cmp	r5, r0
   b5578:	d211      	bcs.n	b559e <_Z14processCommandPKchb.part.0+0xa6>
            if(i < 7) cmdStr[i-4] = command[i];
   b557a:	2d06      	cmp	r5, #6
   b557c:	bf9b      	ittet	ls
   b557e:	f107 0398 	addls.w	r3, r7, #152	; 0x98
   b5582:	195b      	addls	r3, r3, r5
            else dataStr[i-7] = command[i];
   b5584:	1973      	addhi	r3, r6, r5
            if(i < 7) cmdStr[i-4] = command[i];
   b5586:	5d62      	ldrbls	r2, [r4, r5]
            else dataStr[i-7] = command[i];
   b5588:	bf8c      	ite	hi
   b558a:	5d62      	ldrbhi	r2, [r4, r5]
            if(i < 7) cmdStr[i-4] = command[i];
   b558c:	f803 2c80 	strbls.w	r2, [r3, #-128]
        for(uint8_t i = 4; i < strlen(command)-2;i++){              //Copy in the data portion to the data string
   b5590:	f105 0501 	add.w	r5, r5, #1
            else dataStr[i-7] = command[i];
   b5594:	bf88      	it	hi
   b5596:	f803 2c07 	strbhi.w	r2, [r3, #-7]
        for(uint8_t i = 4; i < strlen(command)-2;i++){              //Copy in the data portion to the data string
   b559a:	b2ed      	uxtb	r5, r5
   b559c:	e7e7      	b.n	b556e <_Z14processCommandPKchb.part.0+0x76>
        if(checksum != strlen(command)-2){                          //Compare the checksum to the string length and return if they don't match (reject this message, wait for the next periodic broadcast)
   b559e:	fa5f f989 	uxtb.w	r9, r9
   b55a2:	4548      	cmp	r0, r9
   b55a4:	d007      	beq.n	b55b6 <_Z14processCommandPKchb.part.0+0xbe>
            logMessage("[WARN] Warning, checksum does not match!"); //Log warning to SD card
   b55a6:	48c2      	ldr	r0, [pc, #776]	; (b58b0 <_Z14processCommandPKchb.part.0+0x3b8>)
   b55a8:	f7ff f878 	bl	b469c <_Z10logMessagePKc>
}
   b55ac:	379c      	adds	r7, #156	; 0x9c
   b55ae:	46dd      	mov	sp, fp
   b55b0:	46bd      	mov	sp, r7
   b55b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      : _M_current(__i) { }
   b55b6:	f8df a2fc 	ldr.w	sl, [pc, #764]	; b58b4 <_Z14processCommandPKchb.part.0+0x3bc>
   b55ba:	f8da 4000 	ldr.w	r4, [sl]
   b55be:	f8da 3004 	ldr.w	r3, [sl, #4]
   b55c2:	607b      	str	r3, [r7, #4]
        int index = 0;                                              //Index in the vector for the water bot this message was received from
   b55c4:	2100      	movs	r1, #0
   b55c6:	46a1      	mov	r9, r4
        WaterBot *TargetWB = nullptr;                               //Pointer in the Water Bot vector to the bot this message was received from - makes updating assets easier
   b55c8:	460d      	mov	r5, r1
        bool newBot = true;                                         //Flag set true if a new bot id has been discovered from the command
   b55ca:	2301      	movs	r3, #1
        for(WaterBot w: WaterBots){                                 //Loop over the discovered Water Bots in the vector
   b55cc:	687a      	ldr	r2, [r7, #4]
   b55ce:	454a      	cmp	r2, r9
   b55d0:	d00e      	beq.n	b55f0 <_Z14processCommandPKchb.part.0+0xf8>
            if(rxBotID == w.botNum){                                //Check if the received ID matches this one in the vector, if it does, then it's not a new bot - get the pointer to it
   b55d2:	f899 2002 	ldrb.w	r2, [r9, #2]
   b55d6:	4542      	cmp	r2, r8
   b55d8:	d106      	bne.n	b55e8 <_Z14processCommandPKchb.part.0+0xf0>
                TargetWB = &WaterBots.at(index);
   b55da:	4650      	mov	r0, sl
   b55dc:	6039      	str	r1, [r7, #0]
   b55de:	f7ff fc83 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
                newBot = false;
   b55e2:	6839      	ldr	r1, [r7, #0]
                TargetWB = &WaterBots.at(index);
   b55e4:	4605      	mov	r5, r0
                newBot = false;
   b55e6:	2300      	movs	r3, #0
            index++;
   b55e8:	3101      	adds	r1, #1
      operator++() _GLIBCXX_NOEXCEPT
   b55ea:	f109 0950 	add.w	r9, r9, #80	; 0x50
	return *this;
   b55ee:	e7ed      	b.n	b55cc <_Z14processCommandPKchb.part.0+0xd4>
        if(newBot){                                                 //If we've received a new ID in the command source register, create a new bot object for it and push it into the main vector
   b55f0:	2b00      	cmp	r3, #0
   b55f2:	d05a      	beq.n	b56aa <_Z14processCommandPKchb.part.0+0x1b2>
            WaterBot newWaterbot;                                   //Create new object to put in vector    
   b55f4:	f107 0048 	add.w	r0, r7, #72	; 0x48
   b55f8:	f7ff f870 	bl	b46dc <_ZN8WaterBotC1Ev>
            WaterBots.push_back(newWaterbot);                       //Push it into the vector of Water Bots
   b55fc:	48ad      	ldr	r0, [pc, #692]	; (b58b4 <_Z14processCommandPKchb.part.0+0x3bc>)
            newWaterbot.botNum = rxBotID;                           //Update the object with the new bot's ID 
   b55fe:	f887 804a 	strb.w	r8, [r7, #74]	; 0x4a
            WaterBots.push_back(newWaterbot);                       //Push it into the vector of Water Bots
   b5602:	f107 0148 	add.w	r1, r7, #72	; 0x48
   b5606:	f7ff ff63 	bl	b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>
      { return __normal_iterator(_M_current - __n); }
   b560a:	f8da 5004 	ldr.w	r5, [sl, #4]
            redrawMenu = true;                                      //Set the menu redraw flag so the list of available bots will show this one on the next refresh
   b560e:	4baa      	ldr	r3, [pc, #680]	; (b58b8 <_Z14processCommandPKchb.part.0+0x3c0>)
   b5610:	2201      	movs	r2, #1
   b5612:	3d50      	subs	r5, #80	; 0x50
   b5614:	701a      	strb	r2, [r3, #0]
        if(!strcmp(cmdStr,"sns")){      //Sensor reading command - sent out from the bot upon request and contains a single-sample measurement of all water quality sensors
   b5616:	49a9      	ldr	r1, [pc, #676]	; (b58bc <_Z14processCommandPKchb.part.0+0x3c4>)
   b5618:	f107 001c 	add.w	r0, r7, #28
   b561c:	f009 fcb3 	bl	bef86 <strcmp>
   b5620:	2800      	cmp	r0, #0
   b5622:	f040 8165 	bne.w	b58f0 <_Z14processCommandPKchb.part.0+0x3f8>
            sscanf(dataStr,"%s %s %d %d %d %d %d",GPSLatstr,GPSLonstr,&do_in,&pH_in,&cond_in,&mcond_in,&temp_in);       //Scan in the sensor readings and the GPS locations
   b5626:	f107 0330 	add.w	r3, r7, #48	; 0x30
   b562a:	9304      	str	r3, [sp, #16]
   b562c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   b5630:	9303      	str	r3, [sp, #12]
   b5632:	f107 0328 	add.w	r3, r7, #40	; 0x28
   b5636:	9302      	str	r3, [sp, #8]
   b5638:	f107 0324 	add.w	r3, r7, #36	; 0x24
   b563c:	9301      	str	r3, [sp, #4]
   b563e:	f107 0320 	add.w	r3, r7, #32
   b5642:	9300      	str	r3, [sp, #0]
   b5644:	499e      	ldr	r1, [pc, #632]	; (b58c0 <_Z14processCommandPKchb.part.0+0x3c8>)
   b5646:	f107 0348 	add.w	r3, r7, #72	; 0x48
   b564a:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   b564e:	4630      	mov	r0, r6
   b5650:	f004 feec 	bl	ba42c <sscanf>
            TargetWB->DO = ((float)do_in)/1000.0;               //Update the bot object with the sensor readings - divide by 1000 to shift back the decimal
   b5654:	edd7 7a08 	vldr	s15, [r7, #32]
   b5658:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   b565c:	eddf 7a99 	vldr	s15, [pc, #612]	; b58c4 <_Z14processCommandPKchb.part.0+0x3cc>
   b5660:	eec7 6a27 	vdiv.f32	s13, s14, s15
   b5664:	edc5 6a0d 	vstr	s13, [r5, #52]	; 0x34
            TargetWB->pH = ((float)pH_in)/1000.0;
   b5668:	ed97 7a09 	vldr	s14, [r7, #36]	; 0x24
   b566c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   b5670:	eec7 6a27 	vdiv.f32	s13, s14, s15
   b5674:	edc5 6a0b 	vstr	s13, [r5, #44]	; 0x2c
            TargetWB->Cond = ((float)cond_in)/1000.0;
   b5678:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
   b567c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   b5680:	eec7 6a27 	vdiv.f32	s13, s14, s15
   b5684:	edc5 6a0e 	vstr	s13, [r5, #56]	; 0x38
            TargetWB->MCond = ((float)mcond_in)/1000.0;
   b5688:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
   b568c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   b5690:	eec7 6a27 	vdiv.f32	s13, s14, s15
   b5694:	edc5 6a0f 	vstr	s13, [r5, #60]	; 0x3c
            TargetWB->temp = ((float)temp_in)/1000.0;
   b5698:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
   b569c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
   b56a0:	eec7 6a27 	vdiv.f32	s13, s14, s15
   b56a4:	edc5 6a0c 	vstr	s13, [r5, #48]	; 0x30
   b56a8:	e780      	b.n	b55ac <_Z14processCommandPKchb.part.0+0xb4>
        else if(!strcmp(cmdStr,"sup")){                             //Status update command, this is sent out by the bot periodically to give details about available communication methods, power data and location
   b56aa:	4987      	ldr	r1, [pc, #540]	; (b58c8 <_Z14processCommandPKchb.part.0+0x3d0>)
   b56ac:	f107 001c 	add.w	r0, r7, #28
   b56b0:	f009 fc69 	bl	bef86 <strcmp>
   b56b4:	2800      	cmp	r0, #0
   b56b6:	d1ae      	bne.n	b5616 <_Z14processCommandPKchb.part.0+0x11e>
            for(WaterBot &w: WaterBots){                            //Loop over available bots in the Water Bot vector
   b56b8:	45a1      	cmp	r9, r4
   b56ba:	d0ac      	beq.n	b5616 <_Z14processCommandPKchb.part.0+0x11e>
                if(rxBotID == w.botNum){                            //Find the bot in the vector that matches the source of the status update
   b56bc:	78a3      	ldrb	r3, [r4, #2]
   b56be:	4543      	cmp	r3, r8
   b56c0:	f040 80f4 	bne.w	b58ac <_Z14processCommandPKchb.part.0+0x3b4>
                    sscanf(dataStr,"%u %u %s %s %d %d",&battpct,&statflags,testLat,testLon, &battPwr, &panelPwr);       //Parse out the various pieced of data from the data string an put them in the local variables
   b56c4:	f107 0328 	add.w	r3, r7, #40	; 0x28
   b56c8:	9303      	str	r3, [sp, #12]
   b56ca:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   b56ce:	9302      	str	r3, [sp, #8]
   b56d0:	f107 0a3c 	add.w	sl, r7, #60	; 0x3c
   b56d4:	f107 0330 	add.w	r3, r7, #48	; 0x30
   b56d8:	497c      	ldr	r1, [pc, #496]	; (b58cc <_Z14processCommandPKchb.part.0+0x3d4>)
   b56da:	9300      	str	r3, [sp, #0]
   b56dc:	f107 0220 	add.w	r2, r7, #32
   b56e0:	f107 0324 	add.w	r3, r7, #36	; 0x24
   b56e4:	f8cd a004 	str.w	sl, [sp, #4]
   b56e8:	4630      	mov	r0, r6
   b56ea:	f004 fe9f 	bl	ba42c <sscanf>
                    w.battPercent = battpct;                        //Copy in battery percent from the status update
   b56ee:	f897 3020 	ldrb.w	r3, [r7, #32]
   b56f2:	80a3      	strh	r3, [r4, #4]
                    w.LTEAvail = statflags & 1;                     //Statflags is a bit-masked number to transmit multiple booleans using an integer. Bit 0 in the number represents if LTE is available
   b56f4:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
   b56f8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   b56fa:	f002 0201 	and.w	r2, r2, #1
   b56fe:	7222      	strb	r2, [r4, #8]
                    w.XBeeAvail = (statflags >> 1) & 1;             //Bit 1 represents if XBee is available
   b5700:	f3c3 0240 	ubfx	r2, r3, #1, #1
   b5704:	7262      	strb	r2, [r4, #9]
                    w.BLEAvail = (statflags >> 2) & 1;              //Bit 2 represents if BLE is available
   b5706:	f3c3 0280 	ubfx	r2, r3, #2, #1
   b570a:	71e2      	strb	r2, [r4, #7]
                    w.lowBatt = (statflags >> 6) & 1;               //Bit 6 represents if this bot has low battery
   b570c:	f3c3 1280 	ubfx	r2, r3, #6, #1
   b5710:	7462      	strb	r2, [r4, #17]
                    w.GPSAvail = (statflags >> 8) & 1;              //Bit 8 represents if the GPS module is functional
   b5712:	f3c3 2200 	ubfx	r2, r3, #8, #1
   b5716:	72a2      	strb	r2, [r4, #10]
                    w.CompassAvail = (statflags >> 9) & 1;          //Bit 9 represents if the Compass module is functional
   b5718:	f3c3 2240 	ubfx	r2, r3, #9, #1
                    w.SDAvail = (statflags >> 10) & 1;              //Bit 10 represents if the SD card is functional
   b571c:	f3c3 2380 	ubfx	r3, r3, #10, #1
                    w.CompassAvail = (statflags >> 9) & 1;          //Bit 9 represents if the Compass module is functional
   b5720:	72e2      	strb	r2, [r4, #11]
                    w.SDAvail = (statflags >> 10) & 1;              //Bit 10 represents if the SD card is functional
   b5722:	7323      	strb	r3, [r4, #12]
                    w.GPSLat = atof(testLat);                       //Convert the decimal in string form to a floating point number for latitude
   b5724:	f107 0030 	add.w	r0, r7, #48	; 0x30
   b5728:	f009 fba8 	bl	bee7c <atof>
   b572c:	ec51 0b10 	vmov	r0, r1, d0
   b5730:	f009 fb30 	bl	bed94 <__aeabi_d2f>
   b5734:	6220      	str	r0, [r4, #32]
                    w.GPSLon = atof(testLon);                       //Convert the decimal in string form to a floating point number for longitude
   b5736:	4650      	mov	r0, sl
   b5738:	f009 fba0 	bl	bee7c <atof>
   b573c:	ec51 0b10 	vmov	r0, r1, d0
   b5740:	f009 fb28 	bl	bed94 <__aeabi_d2f>
   b5744:	6260      	str	r0, [r4, #36]	; 0x24
                    w.panelPower = panelPwr;                        //Copy in the solar panel power measurement
   b5746:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   b5748:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
                    w.battPower = battPwr;                          //Copy in the battery power measurement
   b574c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
   b574e:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
                    w.updatedStatus = true;                         //Indicate that this bot has received new data for printing to menu
   b5752:	2301      	movs	r3, #1
   b5754:	7023      	strb	r3, [r4, #0]
   b5756:	f004 fb13 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
                    if(millis() - w.publishTime > WB_MOD_UPDATE_TIME){      //Check the last time a status change was published to this bot, this prevents a status update from reverting a change the user made due to latency, ignore a status update for modifiable fields for some time
   b575a:	6c63      	ldr	r3, [r4, #68]	; 0x44
   b575c:	1ac0      	subs	r0, r0, r3
   b575e:	f64e 2360 	movw	r3, #60000	; 0xea60
   b5762:	4298      	cmp	r0, r3
   b5764:	d909      	bls.n	b577a <_Z14processCommandPKchb.part.0+0x282>
                        w.offloading = (statflags >> 3) & 1;                //Copy in offloading, drive mode and sensor data recording if it hasn't been sent out too recently
   b5766:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   b5768:	f3c3 02c0 	ubfx	r2, r3, #3, #1
   b576c:	75a2      	strb	r2, [r4, #22]
                        w.driveMode = (statflags >> 4) & 3;
   b576e:	f3c3 1201 	ubfx	r2, r3, #4, #2
                        w.dataRecording = (statflags >> 7) & 1;
   b5772:	f3c3 13c0 	ubfx	r3, r3, #7, #1
                        w.driveMode = (statflags >> 4) & 3;
   b5776:	81e2      	strh	r2, [r4, #14]
                        w.dataRecording = (statflags >> 7) & 1;
   b5778:	7563      	strb	r3, [r4, #21]
                    if(w.lowBatt && !w.warnedLowBatt){              //Check the status of the power system for low battery, warn the user if this bot's battery is low
   b577a:	7c63      	ldrb	r3, [r4, #17]
   b577c:	b363      	cbz	r3, b57d8 <_Z14processCommandPKchb.part.0+0x2e0>
   b577e:	7ca3      	ldrb	r3, [r4, #18]
   b5780:	bb53      	cbnz	r3, b57d8 <_Z14processCommandPKchb.part.0+0x2e0>
                        w.warnedLowBatt = true;                     //Set this flag after the user has been warned so they don't get spammed every status update
   b5782:	f04f 0a01 	mov.w	sl, #1
   b5786:	f884 a012 	strb.w	sl, [r4, #18]
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the low battery warning with the bot number
   b578a:	4951      	ldr	r1, [pc, #324]	; (b58d0 <_Z14processCommandPKchb.part.0+0x3d8>)
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b578c:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the low battery warning with the bot number
   b5790:	f107 0048 	add.w	r0, r7, #72	; 0x48
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b5794:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
   b5798:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the low battery warning with the bot number
   b579c:	f009 fbfd 	bl	bef9a <strcpy>
                        sprintf(m.secondaryLine,"Bot %d\0", w.botNum);
   b57a0:	78a2      	ldrb	r2, [r4, #2]
   b57a2:	494c      	ldr	r1, [pc, #304]	; (b58d4 <_Z14processCommandPKchb.part.0+0x3dc>)
   b57a4:	f107 0052 	add.w	r0, r7, #82	; 0x52
   b57a8:	f004 fe38 	bl	ba41c <sprintf>
                        sprintf(m.tertiaryLine, "Low Battery: %d\0",w.battPercent);
   b57ac:	88a2      	ldrh	r2, [r4, #4]
   b57ae:	494a      	ldr	r1, [pc, #296]	; (b58d8 <_Z14processCommandPKchb.part.0+0x3e0>)
   b57b0:	f107 0070 	add.w	r0, r7, #112	; 0x70
   b57b4:	f004 fe32 	bl	ba41c <sprintf>
                        m.primaryStart = 20;                        //Calculated offsets so the strings are centered in the box - determined from experimentation
   b57b8:	2314      	movs	r3, #20
                        m.secondaryStart = 40;
   b57ba:	2228      	movs	r2, #40	; 0x28
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b57bc:	4847      	ldr	r0, [pc, #284]	; (b58dc <_Z14processCommandPKchb.part.0+0x3e4>)
                        m.primaryStart = 20;                        //Calculated offsets so the strings are centered in the box - determined from experimentation
   b57be:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b57c2:	f107 0148 	add.w	r1, r7, #72	; 0x48
                        m.tertiaryStart = 20;
   b57c6:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        m.secondaryStart = 40;
   b57ca:	f887 208f 	strb.w	r2, [r7, #143]	; 0x8f
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b57ce:	f7ff fd87 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
                        redrawMenu = true;                          //Set flag so the menu item updater draws it in
   b57d2:	4b39      	ldr	r3, [pc, #228]	; (b58b8 <_Z14processCommandPKchb.part.0+0x3c0>)
   b57d4:	f883 a000 	strb.w	sl, [r3]
                    if(!w.SDAvail && !w.warnedSDCard){              //Check if the SD card had a warning
   b57d8:	7b23      	ldrb	r3, [r4, #12]
   b57da:	bb5b      	cbnz	r3, b5834 <_Z14processCommandPKchb.part.0+0x33c>
   b57dc:	7ce3      	ldrb	r3, [r4, #19]
   b57de:	bb4b      	cbnz	r3, b5834 <_Z14processCommandPKchb.part.0+0x33c>
                        w.warnedSDCard = true;                      //Set this flag after the user has been warned so they don't get spammed every status update
   b57e0:	f04f 0a01 	mov.w	sl, #1
   b57e4:	f884 a013 	strb.w	sl, [r4, #19]
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the SD card warning
   b57e8:	4939      	ldr	r1, [pc, #228]	; (b58d0 <_Z14processCommandPKchb.part.0+0x3d8>)
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b57ea:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the SD card warning
   b57ee:	f107 0048 	add.w	r0, r7, #72	; 0x48
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b57f2:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
   b57f6:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        sprintf(m.primaryLine,"Warning\0");         //Populate strings of the SD card warning
   b57fa:	f009 fbce 	bl	bef9a <strcpy>
                        sprintf(m.secondaryLine,"Bot %d\0", w.botNum);
   b57fe:	78a2      	ldrb	r2, [r4, #2]
   b5800:	4934      	ldr	r1, [pc, #208]	; (b58d4 <_Z14processCommandPKchb.part.0+0x3dc>)
   b5802:	f107 0052 	add.w	r0, r7, #82	; 0x52
   b5806:	f004 fe09 	bl	ba41c <sprintf>
                        sprintf(m.tertiaryLine, "SD Card Failed\0");
   b580a:	4935      	ldr	r1, [pc, #212]	; (b58e0 <_Z14processCommandPKchb.part.0+0x3e8>)
   b580c:	f107 0070 	add.w	r0, r7, #112	; 0x70
   b5810:	f009 fbc3 	bl	bef9a <strcpy>
                        m.primaryStart = 20;                        //Calculated offsets so the text is centered in the box - determined by experimentation
   b5814:	2314      	movs	r3, #20
                        m.secondaryStart = 40;
   b5816:	2228      	movs	r2, #40	; 0x28
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b5818:	4830      	ldr	r0, [pc, #192]	; (b58dc <_Z14processCommandPKchb.part.0+0x3e4>)
                        m.primaryStart = 20;                        //Calculated offsets so the text is centered in the box - determined by experimentation
   b581a:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b581e:	f107 0148 	add.w	r1, r7, #72	; 0x48
                        m.tertiaryStart = 20;
   b5822:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        m.secondaryStart = 40;
   b5826:	f887 208f 	strb.w	r2, [r7, #143]	; 0x8f
                        PopUps.push_back(m);                        //Push the pop-up item onto the vector so the menu updater prints it
   b582a:	f7ff fd59 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
                        redrawMenu = true;                          //Set flag so the menu item updater draws it in
   b582e:	4b22      	ldr	r3, [pc, #136]	; (b58b8 <_Z14processCommandPKchb.part.0+0x3c0>)
   b5830:	f883 a000 	strb.w	sl, [r3]
                    if((!w.CompassAvail || !w.GPSAvail) && !w.warnedTelem){     //Check if the compass or GPS had an error
   b5834:	7ae3      	ldrb	r3, [r4, #11]
   b5836:	b10b      	cbz	r3, b583c <_Z14processCommandPKchb.part.0+0x344>
   b5838:	7aa3      	ldrb	r3, [r4, #10]
   b583a:	bb63      	cbnz	r3, b5896 <_Z14processCommandPKchb.part.0+0x39e>
   b583c:	7d23      	ldrb	r3, [r4, #20]
   b583e:	bb53      	cbnz	r3, b5896 <_Z14processCommandPKchb.part.0+0x39e>
                        w.warnedTelem = true;
   b5840:	f04f 0a01 	mov.w	sl, #1
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b5844:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
   b5848:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
   b584c:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        sprintf(m.primaryLine,"Warning\0");
   b5850:	491f      	ldr	r1, [pc, #124]	; (b58d0 <_Z14processCommandPKchb.part.0+0x3d8>)
                        w.warnedTelem = true;
   b5852:	f884 a014 	strb.w	sl, [r4, #20]
                        sprintf(m.primaryLine,"Warning\0");
   b5856:	f107 0048 	add.w	r0, r7, #72	; 0x48
   b585a:	f009 fb9e 	bl	bef9a <strcpy>
                        sprintf(m.secondaryLine,"Bot %d\0", w.botNum);
   b585e:	78a2      	ldrb	r2, [r4, #2]
   b5860:	491c      	ldr	r1, [pc, #112]	; (b58d4 <_Z14processCommandPKchb.part.0+0x3dc>)
   b5862:	f107 0052 	add.w	r0, r7, #82	; 0x52
   b5866:	f004 fdd9 	bl	ba41c <sprintf>
                        sprintf(m.tertiaryLine, "GPS/Compass Error\0");
   b586a:	491e      	ldr	r1, [pc, #120]	; (b58e4 <_Z14processCommandPKchb.part.0+0x3ec>)
   b586c:	f107 0070 	add.w	r0, r7, #112	; 0x70
   b5870:	f009 fb93 	bl	bef9a <strcpy>
                        m.primaryStart = 20;
   b5874:	2314      	movs	r3, #20
   b5876:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                        m.secondaryStart = 40;
   b587a:	2328      	movs	r3, #40	; 0x28
   b587c:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                        PopUps.push_back(m);
   b5880:	4816      	ldr	r0, [pc, #88]	; (b58dc <_Z14processCommandPKchb.part.0+0x3e4>)
                        m.tertiaryStart = 10;
   b5882:	230a      	movs	r3, #10
                        PopUps.push_back(m);
   b5884:	f107 0148 	add.w	r1, r7, #72	; 0x48
                        m.tertiaryStart = 10;
   b5888:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
                        PopUps.push_back(m);
   b588c:	f7ff fd28 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
                        redrawMenu = true;
   b5890:	4b09      	ldr	r3, [pc, #36]	; (b58b8 <_Z14processCommandPKchb.part.0+0x3c0>)
   b5892:	f883 a000 	strb.w	sl, [r3]
                    if(botSelect == w.botNum) redrawMenu = true;        //Redraw the menu if the selected bot got the status update because it's telemetry got refreshed
   b5896:	4b14      	ldr	r3, [pc, #80]	; (b58e8 <_Z14processCommandPKchb.part.0+0x3f0>)
   b5898:	78a2      	ldrb	r2, [r4, #2]
   b589a:	781b      	ldrb	r3, [r3, #0]
                    logMessage("Status Update!");
   b589c:	4813      	ldr	r0, [pc, #76]	; (b58ec <_Z14processCommandPKchb.part.0+0x3f4>)
                    if(botSelect == w.botNum) redrawMenu = true;        //Redraw the menu if the selected bot got the status update because it's telemetry got refreshed
   b589e:	429a      	cmp	r2, r3
   b58a0:	bf02      	ittt	eq
   b58a2:	4b05      	ldreq	r3, [pc, #20]	; (b58b8 <_Z14processCommandPKchb.part.0+0x3c0>)
   b58a4:	2201      	moveq	r2, #1
   b58a6:	701a      	strbeq	r2, [r3, #0]
                    logMessage("Status Update!");
   b58a8:	f7fe fef8 	bl	b469c <_Z10logMessagePKc>
      operator++() _GLIBCXX_NOEXCEPT
   b58ac:	3450      	adds	r4, #80	; 0x50
	return *this;
   b58ae:	e703      	b.n	b56b8 <_Z14processCommandPKchb.part.0+0x1c0>
   b58b0:	000c11b4 	.word	0x000c11b4
   b58b4:	2003dce4 	.word	0x2003dce4
   b58b8:	2003daaa 	.word	0x2003daaa
   b58bc:	000c1404 	.word	0x000c1404
   b58c0:	000c1202 	.word	0x000c1202
   b58c4:	447a0000 	.word	0x447a0000
   b58c8:	000c11dd 	.word	0x000c11dd
   b58cc:	000c11e1 	.word	0x000c11e1
   b58d0:	000c1472 	.word	0x000c1472
   b58d4:	000c147b 	.word	0x000c147b
   b58d8:	000c1483 	.word	0x000c1483
   b58dc:	2003dcc4 	.word	0x2003dcc4
   b58e0:	000c1494 	.word	0x000c1494
   b58e4:	000c14a4 	.word	0x000c14a4
   b58e8:	2003dd64 	.word	0x2003dd64
   b58ec:	000c11f3 	.word	0x000c11f3
        else if(!strcmp(cmdStr,"hwd")){  //Hello World! - Received startup pairing message
   b58f0:	495d      	ldr	r1, [pc, #372]	; (b5a68 <_Z14processCommandPKchb.part.0+0x570>)
   b58f2:	f107 001c 	add.w	r0, r7, #28
   b58f6:	f009 fb46 	bl	bef86 <strcmp>
   b58fa:	2800      	cmp	r0, #0
   b58fc:	d135      	bne.n	b596a <_Z14processCommandPKchb.part.0+0x472>
      : _M_current(__i) { }
   b58fe:	4b5b      	ldr	r3, [pc, #364]	; (b5a6c <_Z14processCommandPKchb.part.0+0x574>)
   b5900:	e9d3 3000 	ldrd	r3, r0, [r3]
            bool newBot = true;          //Assumming this is probably a new bot since it should be on startup
   b5904:	2201      	movs	r2, #1
            for(WaterBot w: WaterBots){  //Just in case, check if this bot was already discovered, as the bot could have restarted somehow
   b5906:	4283      	cmp	r3, r0
   b5908:	d005      	beq.n	b5916 <_Z14processCommandPKchb.part.0+0x41e>
                if(rxBotID == w.botNum) newBot = false;     //Don't create a new bot if it was already discovered
   b590a:	7899      	ldrb	r1, [r3, #2]
   b590c:	3350      	adds	r3, #80	; 0x50
   b590e:	4541      	cmp	r1, r8
   b5910:	bf08      	it	eq
   b5912:	2200      	moveq	r2, #0
	return *this;
   b5914:	e7f7      	b.n	b5906 <_Z14processCommandPKchb.part.0+0x40e>
            if(newBot){
   b5916:	2a00      	cmp	r2, #0
   b5918:	f43f ae48 	beq.w	b55ac <_Z14processCommandPKchb.part.0+0xb4>
                WaterBot newWaterbot;                           //Create a new object for the discovered water bot
   b591c:	f107 0048 	add.w	r0, r7, #72	; 0x48
   b5920:	f7fe fedc 	bl	b46dc <_ZN8WaterBotC1Ev>
                if(mode == 1) newWaterbot.BLEAvail = true;      //Check which mode of communication the hello world message was received over, assume that mode is available
   b5924:	68fb      	ldr	r3, [r7, #12]
   b5926:	2b01      	cmp	r3, #1
   b5928:	d111      	bne.n	b594e <_Z14processCommandPKchb.part.0+0x456>
   b592a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
                WaterBots.push_back(newWaterbot);               //Push this bot onto the main vector of bots since it's now discovered and set-up
   b592e:	484f      	ldr	r0, [pc, #316]	; (b5a6c <_Z14processCommandPKchb.part.0+0x574>)
                newWaterbot.botNum = rxBotID;                   //Copy in the bot number for display on the list
   b5930:	f887 804a 	strb.w	r8, [r7, #74]	; 0x4a
                WaterBots.push_back(newWaterbot);               //Push this bot onto the main vector of bots since it's now discovered and set-up
   b5934:	f107 0148 	add.w	r1, r7, #72	; 0x48
   b5938:	f7ff fdca 	bl	b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>
                PairBots.push_back(newWaterbot);
   b593c:	484c      	ldr	r0, [pc, #304]	; (b5a70 <_Z14processCommandPKchb.part.0+0x578>)
   b593e:	f107 0148 	add.w	r1, r7, #72	; 0x48
   b5942:	f7ff fdc5 	bl	b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>
            redrawMenu = true;                                      //Indicate to the menu drawer that we should update now
   b5946:	4b4b      	ldr	r3, [pc, #300]	; (b5a74 <_Z14processCommandPKchb.part.0+0x57c>)
   b5948:	2201      	movs	r2, #1
   b594a:	701a      	strb	r2, [r3, #0]
   b594c:	e62e      	b.n	b55ac <_Z14processCommandPKchb.part.0+0xb4>
                else if(mode == 2) newWaterbot.XBeeAvail = true;
   b594e:	68fb      	ldr	r3, [r7, #12]
   b5950:	2b02      	cmp	r3, #2
   b5952:	f04f 0301 	mov.w	r3, #1
   b5956:	d102      	bne.n	b595e <_Z14processCommandPKchb.part.0+0x466>
   b5958:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
   b595c:	e7e7      	b.n	b592e <_Z14processCommandPKchb.part.0+0x436>
                else if(mode == 3) newWaterbot.LTEAvail = true;
   b595e:	68fa      	ldr	r2, [r7, #12]
   b5960:	2a03      	cmp	r2, #3
   b5962:	bf08      	it	eq
   b5964:	f887 3050 	strbeq.w	r3, [r7, #80]	; 0x50
   b5968:	e7e1      	b.n	b592e <_Z14processCommandPKchb.part.0+0x436>
        else if(!strcmp(cmdStr,"pts")){                         //Debug command - put string. Prints out a string to the SD card log file to test communication
   b596a:	4943      	ldr	r1, [pc, #268]	; (b5a78 <_Z14processCommandPKchb.part.0+0x580>)
   b596c:	f107 001c 	add.w	r0, r7, #28
   b5970:	f009 fb09 	bl	bef86 <strcmp>
   b5974:	b9c8      	cbnz	r0, b59aa <_Z14processCommandPKchb.part.0+0x4b2>
   b5976:	4c41      	ldr	r4, [pc, #260]	; (b5a7c <_Z14processCommandPKchb.part.0+0x584>)
            if(!logFile.isOpen()){
   b5978:	7c23      	ldrb	r3, [r4, #16]
   b597a:	b983      	cbnz	r3, b599e <_Z14processCommandPKchb.part.0+0x4a6>
                logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b597c:	4940      	ldr	r1, [pc, #256]	; (b5a80 <_Z14processCommandPKchb.part.0+0x588>)
   b597e:	f244 2202 	movw	r2, #16898	; 0x4202
   b5982:	f104 0010 	add.w	r0, r4, #16
   b5986:	f7fe fdbd 	bl	b4504 <_ZN7FatFile4openEPKci>
                logFile.printlnf("[PUTS] Received String Command: %s",dataStr);
   b598a:	493e      	ldr	r1, [pc, #248]	; (b5a84 <_Z14processCommandPKchb.part.0+0x58c>)
   b598c:	4632      	mov	r2, r6
   b598e:	4620      	mov	r0, r4
   b5990:	f7fe fd58 	bl	b4444 <_ZN5Print8printlnfEPKcz>
                logFile.close();
   b5994:	f104 0010 	add.w	r0, r4, #16
   b5998:	f003 fa70 	bl	b8e7c <_ZN7FatFile5closeEv>
   b599c:	e606      	b.n	b55ac <_Z14processCommandPKchb.part.0+0xb4>
            else logFile.printlnf("[PUTS] Received String Command: %s",dataStr);
   b599e:	4939      	ldr	r1, [pc, #228]	; (b5a84 <_Z14processCommandPKchb.part.0+0x58c>)
   b59a0:	4632      	mov	r2, r6
   b59a2:	4620      	mov	r0, r4
   b59a4:	f7fe fd4e 	bl	b4444 <_ZN5Print8printlnfEPKcz>
   b59a8:	e600      	b.n	b55ac <_Z14processCommandPKchb.part.0+0xb4>
        else if(!strcmp(cmdStr,"ldt") || !strcmp(cmdStr,"ldb")){    //Command for leak detection or battery detection shutoff - ldb = battery leak, ldt = main leak detect. Causes shutoff
   b59aa:	4937      	ldr	r1, [pc, #220]	; (b5a88 <_Z14processCommandPKchb.part.0+0x590>)
   b59ac:	f107 001c 	add.w	r0, r7, #28
   b59b0:	f009 fae9 	bl	bef86 <strcmp>
   b59b4:	b128      	cbz	r0, b59c2 <_Z14processCommandPKchb.part.0+0x4ca>
   b59b6:	4935      	ldr	r1, [pc, #212]	; (b5a8c <_Z14processCommandPKchb.part.0+0x594>)
   b59b8:	f107 001c 	add.w	r0, r7, #28
   b59bc:	f009 fae3 	bl	bef86 <strcmp>
   b59c0:	bb28      	cbnz	r0, b5a0e <_Z14processCommandPKchb.part.0+0x516>
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b59c2:	2300      	movs	r3, #0
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b59c4:	4932      	ldr	r1, [pc, #200]	; (b5a90 <_Z14processCommandPKchb.part.0+0x598>)
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b59c6:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b59ca:	f107 0048 	add.w	r0, r7, #72	; 0x48
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b59ce:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
   b59d2:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b59d6:	f009 fae0 	bl	bef9a <strcpy>
            sprintf(m.secondaryLine,"Bot %d\0", rxBotID);
   b59da:	7a3a      	ldrb	r2, [r7, #8]
   b59dc:	492d      	ldr	r1, [pc, #180]	; (b5a94 <_Z14processCommandPKchb.part.0+0x59c>)
   b59de:	f107 0052 	add.w	r0, r7, #82	; 0x52
   b59e2:	f004 fd1b 	bl	ba41c <sprintf>
            sprintf(m.tertiaryLine, "Leak shutoff\0");
   b59e6:	492c      	ldr	r1, [pc, #176]	; (b5a98 <_Z14processCommandPKchb.part.0+0x5a0>)
   b59e8:	f107 0070 	add.w	r0, r7, #112	; 0x70
   b59ec:	f009 fad5 	bl	bef9a <strcpy>
            m.primaryStart = 20;                                    //Calculated offsets to center the text in the box
   b59f0:	2314      	movs	r3, #20
   b59f2:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
            m.secondaryStart = 40;
   b59f6:	2328      	movs	r3, #40	; 0x28
   b59f8:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
            m.tertiaryStart = 30;
   b59fc:	231e      	movs	r3, #30
            PopUps.push_back(m);                                    //Push onto the queue of warnings to be displayed
   b59fe:	4827      	ldr	r0, [pc, #156]	; (b5a9c <_Z14processCommandPKchb.part.0+0x5a4>)
            m.tertiaryStart = 25;
   b5a00:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
            PopUps.push_back(m);                                    //Push onto the queue of warnings to be displayed
   b5a04:	f107 0148 	add.w	r1, r7, #72	; 0x48
   b5a08:	f7ff fc6a 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
   b5a0c:	e79b      	b.n	b5946 <_Z14processCommandPKchb.part.0+0x44e>
        else if(!strcmp(cmdStr,"wld") || !strcmp(cmdStr,"wlb")){    //Command for leak detection - like ltd but is only a warning, shutoff has been disabled on this bot
   b5a0e:	4924      	ldr	r1, [pc, #144]	; (b5aa0 <_Z14processCommandPKchb.part.0+0x5a8>)
   b5a10:	f107 001c 	add.w	r0, r7, #28
   b5a14:	f009 fab7 	bl	bef86 <strcmp>
   b5a18:	b138      	cbz	r0, b5a2a <_Z14processCommandPKchb.part.0+0x532>
   b5a1a:	4922      	ldr	r1, [pc, #136]	; (b5aa4 <_Z14processCommandPKchb.part.0+0x5ac>)
   b5a1c:	f107 001c 	add.w	r0, r7, #28
   b5a20:	f009 fab1 	bl	bef86 <strcmp>
   b5a24:	2800      	cmp	r0, #0
   b5a26:	f47f adc1 	bne.w	b55ac <_Z14processCommandPKchb.part.0+0xb4>
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b5a2a:	2300      	movs	r3, #0
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b5a2c:	4918      	ldr	r1, [pc, #96]	; (b5a90 <_Z14processCommandPKchb.part.0+0x598>)
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b5a2e:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b5a32:	f107 0048 	add.w	r0, r7, #72	; 0x48
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b5a36:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
   b5a3a:	f887 3090 	strb.w	r3, [r7, #144]	; 0x90
            sprintf(m.primaryLine,"Warning\0");                     //Print warning strings into the pop-up item
   b5a3e:	f009 faac 	bl	bef9a <strcpy>
            sprintf(m.secondaryLine,"Bot %d\0", rxBotID);
   b5a42:	7a3a      	ldrb	r2, [r7, #8]
   b5a44:	4913      	ldr	r1, [pc, #76]	; (b5a94 <_Z14processCommandPKchb.part.0+0x59c>)
   b5a46:	f107 0052 	add.w	r0, r7, #82	; 0x52
   b5a4a:	f004 fce7 	bl	ba41c <sprintf>
            sprintf(m.tertiaryLine, "Leak detected\0");
   b5a4e:	4916      	ldr	r1, [pc, #88]	; (b5aa8 <_Z14processCommandPKchb.part.0+0x5b0>)
   b5a50:	f107 0070 	add.w	r0, r7, #112	; 0x70
   b5a54:	f009 faa1 	bl	bef9a <strcpy>
            m.primaryStart = 20;                                    //Calculated offsets to center the text in the box
   b5a58:	2314      	movs	r3, #20
   b5a5a:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
            m.secondaryStart = 40;
   b5a5e:	2328      	movs	r3, #40	; 0x28
   b5a60:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
            m.tertiaryStart = 25;
   b5a64:	2319      	movs	r3, #25
   b5a66:	e7ca      	b.n	b59fe <_Z14processCommandPKchb.part.0+0x506>
   b5a68:	000c1217 	.word	0x000c1217
   b5a6c:	2003dce4 	.word	0x2003dce4
   b5a70:	2003dcb8 	.word	0x2003dcb8
   b5a74:	2003daaa 	.word	0x2003daaa
   b5a78:	000c121b 	.word	0x000c121b
   b5a7c:	2003ddd0 	.word	0x2003ddd0
   b5a80:	2003dd78 	.word	0x2003dd78
   b5a84:	000c121f 	.word	0x000c121f
   b5a88:	000c1242 	.word	0x000c1242
   b5a8c:	000c1246 	.word	0x000c1246
   b5a90:	000c1472 	.word	0x000c1472
   b5a94:	000c147b 	.word	0x000c147b
   b5a98:	000c14b7 	.word	0x000c14b7
   b5a9c:	2003dcc4 	.word	0x2003dcc4
   b5aa0:	000c124a 	.word	0x000c124a
   b5aa4:	000c124e 	.word	0x000c124e
   b5aa8:	000c14c5 	.word	0x000c14c5

000b5aac <_Z14processCommandPKchb>:
    if((command[2] == 'A' && command[3] == 'B') || (command[2] == 'C' && command[3] == 'C')){   //Check if the message was addressed to the CChub or all bots (as a broadcast)
   b5aac:	7883      	ldrb	r3, [r0, #2]
   b5aae:	2b41      	cmp	r3, #65	; 0x41
   b5ab0:	d104      	bne.n	b5abc <_Z14processCommandPKchb+0x10>
   b5ab2:	78c3      	ldrb	r3, [r0, #3]
   b5ab4:	2b42      	cmp	r3, #66	; 0x42
   b5ab6:	d106      	bne.n	b5ac6 <_Z14processCommandPKchb+0x1a>
   b5ab8:	f7ff bd1e 	b.w	b54f8 <_Z14processCommandPKchb.part.0>
   b5abc:	2b43      	cmp	r3, #67	; 0x43
   b5abe:	d102      	bne.n	b5ac6 <_Z14processCommandPKchb+0x1a>
   b5ac0:	78c3      	ldrb	r3, [r0, #3]
   b5ac2:	2b43      	cmp	r3, #67	; 0x43
   b5ac4:	e7f7      	b.n	b5ab6 <_Z14processCommandPKchb+0xa>
}
   b5ac6:	4770      	bx	lr

000b5ac8 <_Z14dataLTEHandlerPKcS0_>:
void dataLTEHandler(const char *event, const char *data){           //Interrupt handler called anytime a message is received from a bot over LTE.
   b5ac8:	b510      	push	{r4, lr}
   b5aca:	460c      	mov	r4, r1
    processCommand(data, 4,false);                                  //Send the command to the dictionary function for processing
   b5acc:	2200      	movs	r2, #0
   b5ace:	2104      	movs	r1, #4
   b5ad0:	4620      	mov	r0, r4
   b5ad2:	f7ff ffeb 	bl	b5aac <_Z14processCommandPKchb>
    if(logMessages){                                                //Log the incoming message to the SD card if enabled
   b5ad6:	4b0b      	ldr	r3, [pc, #44]	; (b5b04 <_Z14dataLTEHandlerPKcS0_+0x3c>)
   b5ad8:	781b      	ldrb	r3, [r3, #0]
   b5ada:	b193      	cbz	r3, b5b02 <_Z14dataLTEHandlerPKcS0_+0x3a>
   b5adc:	480a      	ldr	r0, [pc, #40]	; (b5b08 <_Z14dataLTEHandlerPKcS0_+0x40>)
        if(!logFile.isOpen()) logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b5ade:	7c03      	ldrb	r3, [r0, #16]
   b5ae0:	b92b      	cbnz	r3, b5aee <_Z14dataLTEHandlerPKcS0_+0x26>
   b5ae2:	490a      	ldr	r1, [pc, #40]	; (b5b0c <_Z14dataLTEHandlerPKcS0_+0x44>)
   b5ae4:	f244 2202 	movw	r2, #16898	; 0x4202
   b5ae8:	3010      	adds	r0, #16
   b5aea:	f7fe fd0b 	bl	b4504 <_ZN7FatFile4openEPKci>
        logFile.printlnf("[INFO] Received LTE Message: %s",data);   //Print the message as an info function
   b5aee:	4622      	mov	r2, r4
   b5af0:	4907      	ldr	r1, [pc, #28]	; (b5b10 <_Z14dataLTEHandlerPKcS0_+0x48>)
   b5af2:	4805      	ldr	r0, [pc, #20]	; (b5b08 <_Z14dataLTEHandlerPKcS0_+0x40>)
   b5af4:	f7fe fca6 	bl	b4444 <_ZN5Print8printlnfEPKcz>
}
   b5af8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        logFile.close();
   b5afc:	4805      	ldr	r0, [pc, #20]	; (b5b14 <_Z14dataLTEHandlerPKcS0_+0x4c>)
   b5afe:	f003 b9bd 	b.w	b8e7c <_ZN7FatFile5closeEv>
}
   b5b02:	bd10      	pop	{r4, pc}
   b5b04:	2003de04 	.word	0x2003de04
   b5b08:	2003ddd0 	.word	0x2003ddd0
   b5b0c:	2003dd78 	.word	0x2003dd78
   b5b10:	000c1252 	.word	0x000c1252
   b5b14:	2003dde0 	.word	0x2003dde0

000b5b18 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv>:
static void BLEDataReceived(const uint8_t* data, size_t len, const BlePeerDevice& peer, void* context) {
   b5b18:	b5b0      	push	{r4, r5, r7, lr}
    char btBuf[len+1];      //Received as a byte array over BLE, take and convert to a char array for string operations
   b5b1a:	f101 0308 	add.w	r3, r1, #8
   b5b1e:	f023 0307 	bic.w	r3, r3, #7
static void BLEDataReceived(const uint8_t* data, size_t len, const BlePeerDevice& peer, void* context) {
   b5b22:	af00      	add	r7, sp, #0
    char btBuf[len+1];      //Received as a byte array over BLE, take and convert to a char array for string operations
   b5b24:	ebad 0d03 	sub.w	sp, sp, r3
static void BLEDataReceived(const uint8_t* data, size_t len, const BlePeerDevice& peer, void* context) {
   b5b28:	460c      	mov	r4, r1
    for (size_t ii = 0; ii < len; ii++) btBuf[ii] = data[ii];   //Loop and copy each character
   b5b2a:	460a      	mov	r2, r1
   b5b2c:	4601      	mov	r1, r0
   b5b2e:	4668      	mov	r0, sp
   b5b30:	f009 f9bb 	bl	beeaa <memcpy>
    if(btBuf[len-1] != '\0') btBuf[len] = '\0';                 //Put null terminator at end to ensure no memory overflow to surrounding regions (trust me, you'll see funky stuff come from random memory)
   b5b34:	eb0d 0304 	add.w	r3, sp, r4
    char btBuf[len+1];      //Received as a byte array over BLE, take and convert to a char array for string operations
   b5b38:	466d      	mov	r5, sp
    if(btBuf[len-1] != '\0') btBuf[len] = '\0';                 //Put null terminator at end to ensure no memory overflow to surrounding regions (trust me, you'll see funky stuff come from random memory)
   b5b3a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   b5b3e:	b113      	cbz	r3, b5b46 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x2e>
   b5b40:	2300      	movs	r3, #0
   b5b42:	f80d 3004 	strb.w	r3, [sp, r4]
    processCommand(btBuf,1,true);                               //Send command to the dictionary for processing
   b5b46:	2201      	movs	r2, #1
   b5b48:	4611      	mov	r1, r2
   b5b4a:	4628      	mov	r0, r5
   b5b4c:	f7ff ffae 	bl	b5aac <_Z14processCommandPKchb>
    if(logMessages){
   b5b50:	4b0a      	ldr	r3, [pc, #40]	; (b5b7c <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x64>)
   b5b52:	781b      	ldrb	r3, [r3, #0]
   b5b54:	b183      	cbz	r3, b5b78 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x60>
   b5b56:	480a      	ldr	r0, [pc, #40]	; (b5b80 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x68>)
        if(!logFile.isOpen()) logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b5b58:	7c03      	ldrb	r3, [r0, #16]
   b5b5a:	b92b      	cbnz	r3, b5b68 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x50>
   b5b5c:	4909      	ldr	r1, [pc, #36]	; (b5b84 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x6c>)
   b5b5e:	f244 2202 	movw	r2, #16898	; 0x4202
   b5b62:	3010      	adds	r0, #16
   b5b64:	f7fe fcce 	bl	b4504 <_ZN7FatFile4openEPKci>
        logFile.printlnf("[INFO] Received BLE Message: %s",btBuf);
   b5b68:	4907      	ldr	r1, [pc, #28]	; (b5b88 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x70>)
   b5b6a:	4805      	ldr	r0, [pc, #20]	; (b5b80 <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x68>)
   b5b6c:	462a      	mov	r2, r5
   b5b6e:	f7fe fc69 	bl	b4444 <_ZN5Print8printlnfEPKcz>
        logFile.close();
   b5b72:	4806      	ldr	r0, [pc, #24]	; (b5b8c <_ZL15BLEDataReceivedPKhjRKN8particle13BlePeerDeviceEPv+0x74>)
   b5b74:	f003 f982 	bl	b8e7c <_ZN7FatFile5closeEv>
}
   b5b78:	46bd      	mov	sp, r7
   b5b7a:	bdb0      	pop	{r4, r5, r7, pc}
   b5b7c:	2003de04 	.word	0x2003de04
   b5b80:	2003ddd0 	.word	0x2003ddd0
   b5b84:	2003dd78 	.word	0x2003dd78
   b5b88:	000c1272 	.word	0x000c1272
   b5b8c:	2003dde0 	.word	0x2003dde0

000b5b90 <_Z11XBeeHandlerv>:
void XBeeHandler(){                                         //Function similar to the Pi handler, but reads from the serial buffer attached to the XBee radio
   b5b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if(logMessages){
   b5b94:	f8df 80d4 	ldr.w	r8, [pc, #212]	; b5c6c <_Z11XBeeHandlerv+0xdc>
   b5b98:	4d31      	ldr	r5, [pc, #196]	; (b5c60 <_Z11XBeeHandlerv+0xd0>)
            logFile.printlnf("[INFO] Received XBee Message: %s",data);
   b5b9a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; b5c70 <_Z11XBeeHandlerv+0xe0>
void XBeeHandler(){                                         //Function similar to the Pi handler, but reads from the serial buffer attached to the XBee radio
   b5b9e:	b089      	sub	sp, #36	; 0x24
   b5ba0:	af00      	add	r7, sp, #0
    while(Serial1.available()){                             //Check if a string has been received from XBee
   b5ba2:	f008 fa53 	bl	be04c <_Z22__fetch_global_Serial1v>
   b5ba6:	6803      	ldr	r3, [r0, #0]
   b5ba8:	691b      	ldr	r3, [r3, #16]
   b5baa:	4798      	blx	r3
   b5bac:	2800      	cmp	r0, #0
   b5bae:	d052      	beq.n	b5c56 <_Z11XBeeHandlerv+0xc6>
        String data = Serial1.readStringUntil('\n');        //Read up to end of the string which always hass null terminator character
   b5bb0:	f008 fa4c 	bl	be04c <_Z22__fetch_global_Serial1v>
   b5bb4:	220a      	movs	r2, #10
   b5bb6:	4601      	mov	r1, r0
   b5bb8:	4638      	mov	r0, r7
   b5bba:	f007 fa63 	bl	bd084 <_ZN6Stream15readStringUntilEc>
        char buffer[data.length()];                         //Create a buffer for copying data from the string data type
   b5bbe:	68bb      	ldr	r3, [r7, #8]
   b5bc0:	3307      	adds	r3, #7
   b5bc2:	f023 0307 	bic.w	r3, r3, #7
    }
   b5bc6:	466e      	mov	r6, sp
        char buffer[data.length()];                         //Create a buffer for copying data from the string data type
   b5bc8:	ebad 0d03 	sub.w	sp, sp, r3
   b5bcc:	46ea      	mov	sl, sp
   b5bce:	2300      	movs	r3, #0
	inline unsigned int length(void) const {return len;}
   b5bd0:	68b9      	ldr	r1, [r7, #8]
   b5bd2:	fa1f fb83 	uxth.w	fp, r3
        for(uint16_t i = 0 ; i < data.length(); i++) buffer[i] = data.charAt(i);        //Copy over the characters from the string type
   b5bd6:	458b      	cmp	fp, r1
   b5bd8:	f103 0401 	add.w	r4, r3, #1
   b5bdc:	d207      	bcs.n	b5bee <_Z11XBeeHandlerv+0x5e>
   b5bde:	4659      	mov	r1, fp
   b5be0:	4638      	mov	r0, r7
   b5be2:	f004 fe83 	bl	ba8ec <_ZNK6String6charAtEj>
   b5be6:	4623      	mov	r3, r4
   b5be8:	f80a 000b 	strb.w	r0, [sl, fp]
   b5bec:	e7f0      	b.n	b5bd0 <_Z11XBeeHandlerv+0x40>
        if(data.length() > 1 && data.charAt(data.length()-1) == '\r') buffer[data.length()-1] = 0;      //Set the last character to a null to allow sting processing functions to work
   b5bee:	2901      	cmp	r1, #1
   b5bf0:	d90a      	bls.n	b5c08 <_Z11XBeeHandlerv+0x78>
   b5bf2:	3901      	subs	r1, #1
   b5bf4:	4638      	mov	r0, r7
   b5bf6:	f004 fe79 	bl	ba8ec <_ZNK6String6charAtEj>
   b5bfa:	280d      	cmp	r0, #13
   b5bfc:	bf01      	itttt	eq
   b5bfe:	68bb      	ldreq	r3, [r7, #8]
   b5c00:	4453      	addeq	r3, sl
   b5c02:	2200      	moveq	r2, #0
   b5c04:	f803 2c01 	strbeq.w	r2, [r3, #-1]
        processCommand(buffer,2,true);                      //Process the command using the dictionary
   b5c08:	2201      	movs	r2, #1
   b5c0a:	2102      	movs	r1, #2
   b5c0c:	4650      	mov	r0, sl
   b5c0e:	f7ff ff4d 	bl	b5aac <_Z14processCommandPKchb>
        if(logMessages){
   b5c12:	f898 3000 	ldrb.w	r3, [r8]
   b5c16:	b1cb      	cbz	r3, b5c4c <_Z11XBeeHandlerv+0xbc>
            if(!logFile.isOpen()) logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b5c18:	7c2b      	ldrb	r3, [r5, #16]
   b5c1a:	b92b      	cbnz	r3, b5c28 <_Z11XBeeHandlerv+0x98>
   b5c1c:	4911      	ldr	r1, [pc, #68]	; (b5c64 <_Z11XBeeHandlerv+0xd4>)
   b5c1e:	4812      	ldr	r0, [pc, #72]	; (b5c68 <_Z11XBeeHandlerv+0xd8>)
   b5c20:	f244 2202 	movw	r2, #16898	; 0x4202
   b5c24:	f7fe fc6e 	bl	b4504 <_ZN7FatFile4openEPKci>
            logFile.printlnf("[INFO] Received XBee Message: %s",data);
   b5c28:	4639      	mov	r1, r7
   b5c2a:	f107 0010 	add.w	r0, r7, #16
   b5c2e:	f004 fdf1 	bl	ba814 <_ZN6StringC1ERKS_>
   b5c32:	f107 0210 	add.w	r2, r7, #16
   b5c36:	4649      	mov	r1, r9
   b5c38:	4628      	mov	r0, r5
   b5c3a:	f7fe fc03 	bl	b4444 <_ZN5Print8printlnfEPKcz>
   b5c3e:	f107 0010 	add.w	r0, r7, #16
   b5c42:	f004 fd51 	bl	ba6e8 <_ZN6StringD1Ev>
            logFile.close();
   b5c46:	4808      	ldr	r0, [pc, #32]	; (b5c68 <_Z11XBeeHandlerv+0xd8>)
   b5c48:	f003 f918 	bl	b8e7c <_ZN7FatFile5closeEv>
        String data = Serial1.readStringUntil('\n');        //Read up to end of the string which always hass null terminator character
   b5c4c:	4638      	mov	r0, r7
   b5c4e:	f004 fd4b 	bl	ba6e8 <_ZN6StringD1Ev>
   b5c52:	46b5      	mov	sp, r6
    while(Serial1.available()){                             //Check if a string has been received from XBee
   b5c54:	e7a5      	b.n	b5ba2 <_Z11XBeeHandlerv+0x12>
}
   b5c56:	3724      	adds	r7, #36	; 0x24
   b5c58:	46bd      	mov	sp, r7
   b5c5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b5c5e:	bf00      	nop
   b5c60:	2003ddd0 	.word	0x2003ddd0
   b5c64:	2003dd78 	.word	0x2003dd78
   b5c68:	2003dde0 	.word	0x2003dde0
   b5c6c:	2003de04 	.word	0x2003de04
   b5c70:	000c1292 	.word	0x000c1292

000b5c74 <_Z15LTEInputCommand6String>:

int LTEInputCommand(String cmd){
   b5c74:	b500      	push	{lr}
   b5c76:	b09b      	sub	sp, #108	; 0x6c
		{getBytes((unsigned char *)buf, bufsize, index);}
   b5c78:	2300      	movs	r3, #0
   b5c7a:	2264      	movs	r2, #100	; 0x64
   b5c7c:	a901      	add	r1, sp, #4
   b5c7e:	f004 fe37 	bl	ba8f0 <_ZNK6String8getBytesEPhjj>
    char cmdBuf[100];
    cmd.toCharArray(cmdBuf, 100);
    processCommand(cmdBuf, 4,false);
   b5c82:	2104      	movs	r1, #4
   b5c84:	2200      	movs	r2, #0
   b5c86:	eb0d 0001 	add.w	r0, sp, r1
   b5c8a:	f7ff ff0f 	bl	b5aac <_Z14processCommandPKchb>
    if(logMessages){
   b5c8e:	4b0c      	ldr	r3, [pc, #48]	; (b5cc0 <_Z15LTEInputCommand6String+0x4c>)
   b5c90:	781b      	ldrb	r3, [r3, #0]
   b5c92:	b183      	cbz	r3, b5cb6 <_Z15LTEInputCommand6String+0x42>
   b5c94:	480b      	ldr	r0, [pc, #44]	; (b5cc4 <_Z15LTEInputCommand6String+0x50>)
        if(!logFile.isOpen()) logFile.open(filenameMessages, O_RDWR | O_CREAT | O_AT_END);
   b5c96:	7c03      	ldrb	r3, [r0, #16]
   b5c98:	b92b      	cbnz	r3, b5ca6 <_Z15LTEInputCommand6String+0x32>
   b5c9a:	490b      	ldr	r1, [pc, #44]	; (b5cc8 <_Z15LTEInputCommand6String+0x54>)
   b5c9c:	f244 2202 	movw	r2, #16898	; 0x4202
   b5ca0:	3010      	adds	r0, #16
   b5ca2:	f7fe fc2f 	bl	b4504 <_ZN7FatFile4openEPKci>
        logFile.printlnf("[INFO] Received LTE Message: %s",cmdBuf);
   b5ca6:	4909      	ldr	r1, [pc, #36]	; (b5ccc <_Z15LTEInputCommand6String+0x58>)
   b5ca8:	4806      	ldr	r0, [pc, #24]	; (b5cc4 <_Z15LTEInputCommand6String+0x50>)
   b5caa:	aa01      	add	r2, sp, #4
   b5cac:	f7fe fbca 	bl	b4444 <_ZN5Print8printlnfEPKcz>
        logFile.close();
   b5cb0:	4807      	ldr	r0, [pc, #28]	; (b5cd0 <_Z15LTEInputCommand6String+0x5c>)
   b5cb2:	f003 f8e3 	bl	b8e7c <_ZN7FatFile5closeEv>
    }
    return 1;
   b5cb6:	2001      	movs	r0, #1
   b5cb8:	b01b      	add	sp, #108	; 0x6c
   b5cba:	f85d fb04 	ldr.w	pc, [sp], #4
   b5cbe:	bf00      	nop
   b5cc0:	2003de04 	.word	0x2003de04
   b5cc4:	2003ddd0 	.word	0x2003ddd0
   b5cc8:	2003dd78 	.word	0x2003dd78
   b5ccc:	000c1252 	.word	0x000c1252
   b5cd0:	2003dde0 	.word	0x2003dde0

000b5cd4 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>:
      vector<_Tp, _Alloc>::
   b5cd4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5cd8:	e9d0 8900 	ldrd	r8, r9, [r0]
   b5cdc:	4693      	mov	fp, r2
	if (max_size() - size() < __n)
   b5cde:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5ce2:	eba9 0208 	sub.w	r2, r9, r8
	if (max_size() - size() < __n)
   b5ce6:	ebb3 0fe2 	cmp.w	r3, r2, asr #3
   b5cea:	4607      	mov	r7, r0
   b5cec:	468a      	mov	sl, r1
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b5cee:	ea4f 04e2 	mov.w	r4, r2, asr #3
	if (max_size() - size() < __n)
   b5cf2:	d102      	bne.n	b5cfa <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x26>
	  __throw_length_error(__N(__s));
   b5cf4:	4820      	ldr	r0, [pc, #128]	; (b5d78 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xa4>)
   b5cf6:	f008 fa11 	bl	be11c <_ZSt20__throw_length_errorPKc>
   b5cfa:	2c01      	cmp	r4, #1
   b5cfc:	4622      	mov	r2, r4
   b5cfe:	bf38      	it	cc
   b5d00:	2201      	movcc	r2, #1
   b5d02:	18a4      	adds	r4, r4, r2
    { return __lhs.base() - __rhs.base(); }
   b5d04:	eba1 0508 	sub.w	r5, r1, r8
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b5d08:	d231      	bcs.n	b5d6e <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x9a>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b5d0a:	b394      	cbz	r4, b5d72 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x9e>
   b5d0c:	429c      	cmp	r4, r3
   b5d0e:	bf28      	it	cs
   b5d10:	461c      	movcs	r4, r3
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   b5d12:	00e0      	lsls	r0, r4, #3
   b5d14:	f7fe f9bf 	bl	b4096 <_Znwj>
   b5d18:	4606      	mov	r6, r0
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b5d1a:	1973      	adds	r3, r6, r5
   b5d1c:	bf1c      	itt	ne
   b5d1e:	e9db 0100 	ldrdne	r0, r1, [fp]
   b5d22:	e9c3 0100 	strdne	r0, r1, [r3]
      if (__count > 0)
   b5d26:	2d00      	cmp	r5, #0
   b5d28:	dd04      	ble.n	b5d34 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x60>
	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
   b5d2a:	462a      	mov	r2, r5
   b5d2c:	4641      	mov	r1, r8
   b5d2e:	4630      	mov	r0, r6
   b5d30:	f009 f8c9 	bl	beec6 <memmove>
      ptrdiff_t __count = __last - __first;
   b5d34:	eba9 090a 	sub.w	r9, r9, sl
	      ++__new_finish;
   b5d38:	3508      	adds	r5, #8
      if (__count > 0)
   b5d3a:	f1b9 0f00 	cmp.w	r9, #0
   b5d3e:	4435      	add	r5, r6
   b5d40:	dd04      	ble.n	b5d4c <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x78>
	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
   b5d42:	464a      	mov	r2, r9
   b5d44:	4651      	mov	r1, sl
   b5d46:	4628      	mov	r0, r5
   b5d48:	f009 f8af 	bl	beeaa <memcpy>
      return __result + __count;
   b5d4c:	444d      	add	r5, r9
	if (__p)
   b5d4e:	f1b8 0f00 	cmp.w	r8, #0
   b5d52:	d005      	beq.n	b5d60 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x8c>
		    this->_M_impl._M_end_of_storage - __old_start);
   b5d54:	68b9      	ldr	r1, [r7, #8]
	::operator delete(__p
   b5d56:	4640      	mov	r0, r8
   b5d58:	eba1 0108 	sub.w	r1, r1, r8
   b5d5c:	f7fe f99f 	bl	b409e <_ZdlPvj>
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b5d60:	eb06 04c4 	add.w	r4, r6, r4, lsl #3
      this->_M_impl._M_finish = __new_finish;
   b5d64:	e9c7 6500 	strd	r6, r5, [r7]
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b5d68:	60bc      	str	r4, [r7, #8]
    }
   b5d6a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b5d6e:	461c      	mov	r4, r3
   b5d70:	e7cf      	b.n	b5d12 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x3e>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b5d72:	4626      	mov	r6, r4
   b5d74:	e7d1      	b.n	b5d1a <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x46>
   b5d76:	bf00      	nop
   b5d78:	000c1151 	.word	0x000c1151

000b5d7c <_Z7BLEScani>:
void BLEScan(int BotNumber){        //Function to scan for nearby bots advertising over BLE or connect to a specific one.
   b5d7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b5d80:	b0a5      	sub	sp, #148	; 0x94
   b5d82:	4606      	mov	r6, r0
    size_t count = BLE.scan(scanResults, SCAN_RESULT_COUNT);                //Get number of found BLE devices
   b5d84:	f005 face 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b5d88:	4963      	ldr	r1, [pc, #396]	; (b5f18 <_Z7BLEScani+0x19c>)
   b5d8a:	2214      	movs	r2, #20
   b5d8c:	f005 fbc2 	bl	bb514 <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj>
	if (count > 0) {                                                        //Check if any were found
   b5d90:	4680      	mov	r8, r0
   b5d92:	2800      	cmp	r0, #0
   b5d94:	f000 80bd 	beq.w	b5f12 <_Z7BLEScani+0x196>
    const BleAddress& address() const {
        return address_;
    }

    const BleAdvertisingData& advertisingData() const {
        return advertisingData_;
   b5d98:	f8df 917c 	ldr.w	r9, [pc, #380]	; b5f18 <_Z7BLEScani+0x19c>
            if (svcCount > 0 && foundServiceUuid == serviceUuid) {          //If this fevice has services and has a UUID that matches the water bot service, look at it's custom data to see what bot ID it is
   b5d9c:	f8df a1b0 	ldr.w	sl, [pc, #432]	; b5f50 <_Z7BLEScani+0x1d4>
		for (uint8_t ii = 0; ii < count; ii++) {                            //Loop over discovered bots
   b5da0:	2400      	movs	r4, #0
			BleUuid foundServiceUuid;                                       //Check the UUID of the advertisement (Unique ID provided to each bot - see if it matches the water bot service)
   b5da2:	eb04 0bc4 	add.w	fp, r4, r4, lsl #3
   b5da6:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
   b5daa:	f10b 0708 	add.w	r7, fp, #8
   b5dae:	a803      	add	r0, sp, #12
   b5db0:	444f      	add	r7, r9
   b5db2:	f004 ff1b 	bl	babec <_ZN8particle7BleUuidC1Ev>
			size_t svcCount = scanResults[ii].advertisingData().serviceUUID(&foundServiceUuid, 1);      //Get the number of bluetooth services this device has, makes it easier to filter out devices
   b5db6:	2201      	movs	r2, #1
   b5db8:	a903      	add	r1, sp, #12
   b5dba:	4638      	mov	r0, r7
   b5dbc:	f006 fa4e 	bl	bc25c <_ZNK8particle18BleAdvertisingData11serviceUUIDEPNS_7BleUuidEj>
            if (svcCount > 0 && foundServiceUuid == serviceUuid) {          //If this fevice has services and has a UUID that matches the water bot service, look at it's custom data to see what bot ID it is
   b5dc0:	b368      	cbz	r0, b5e1e <_Z7BLEScani+0xa2>
   b5dc2:	4651      	mov	r1, sl
   b5dc4:	a803      	add	r0, sp, #12
   b5dc6:	f004 ff6c 	bl	baca2 <_ZNK8particle7BleUuideqERKS0_>
   b5dca:	4605      	mov	r5, r0
   b5dcc:	b338      	cbz	r0, b5e1e <_Z7BLEScani+0xa2>
                scanResults[ii].advertisingData().customData(BLECustomData,CUSTOM_DATA_LEN);    //Retrieve the custom data from the advertisement
   b5dce:	2208      	movs	r2, #8
   b5dd0:	a901      	add	r1, sp, #4
   b5dd2:	4638      	mov	r0, r7
   b5dd4:	f005 f8c2 	bl	baf5c <_ZNK8particle18BleAdvertisingData10customDataEPhj>
                if(BotNumber == -2){                                        //If -2 was fed as an argument to the function, we are just scanning for nearby bots and looking for the nearest one
   b5dd8:	1cb2      	adds	r2, r6, #2
   b5dda:	d12b      	bne.n	b5e34 <_Z7BLEScani+0xb8>
      : _M_current(__i) { }
   b5ddc:	4a4f      	ldr	r2, [pc, #316]	; (b5f1c <_Z7BLEScani+0x1a0>)
                        if(BLECustomData[0] == p.botNum){
   b5dde:	f89d 0004 	ldrb.w	r0, [sp, #4]
   b5de2:	6857      	ldr	r7, [r2, #4]
   b5de4:	6813      	ldr	r3, [r2, #0]
                    for(PairBot p: BLEPair){                                //Create a new pair item if we haven't seen this bot before
   b5de6:	42bb      	cmp	r3, r7
   b5de8:	d005      	beq.n	b5df6 <_Z7BLEScani+0x7a>
                        if(BLECustomData[0] == p.botNum){
   b5dea:	f813 1b08 	ldrb.w	r1, [r3], #8
                            newBot = false;
   b5dee:	4281      	cmp	r1, r0
   b5df0:	bf08      	it	eq
   b5df2:	2500      	moveq	r5, #0
	return *this;
   b5df4:	e7f7      	b.n	b5de6 <_Z7BLEScani+0x6a>
                    if(newBot){
   b5df6:	b195      	cbz	r5, b5e1e <_Z7BLEScani+0xa2>
    const BleAdvertisingData& scanResponse() const {
        return scanResponse_;
    }

    int8_t rssi() const {
        return rssi_;
   b5df8:	2124      	movs	r1, #36	; 0x24
   b5dfa:	fb01 9104 	mla	r1, r1, r4, r9
                        NewBot.botNum = BLECustomData[0];                   //Copy in the Bot ID to keep track of who is closest 
   b5dfe:	f88d 0040 	strb.w	r0, [sp, #64]	; 0x40
                        NewBot.rssi = scanResults[ii].rssi();               //Store the signal strength of this bot relative to the CChub to determine which one in the list is the closest
   b5e02:	f991 1020 	ldrsb.w	r1, [r1, #32]
   b5e06:	9111      	str	r1, [sp, #68]	; 0x44
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b5e08:	6891      	ldr	r1, [r2, #8]
   b5e0a:	428b      	cmp	r3, r1
   b5e0c:	d00c      	beq.n	b5e28 <_Z7BLEScani+0xac>
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b5e0e:	b11b      	cbz	r3, b5e18 <_Z7BLEScani+0x9c>
   b5e10:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   b5e14:	e883 0003 	stmia.w	r3, {r0, r1}
	    ++this->_M_impl._M_finish;
   b5e18:	6853      	ldr	r3, [r2, #4]
   b5e1a:	3308      	adds	r3, #8
   b5e1c:	6053      	str	r3, [r2, #4]
		for (uint8_t ii = 0; ii < count; ii++) {                            //Loop over discovered bots
   b5e1e:	3401      	adds	r4, #1
   b5e20:	b2e4      	uxtb	r4, r4
   b5e22:	4544      	cmp	r4, r8
   b5e24:	d3bd      	bcc.n	b5da2 <_Z7BLEScani+0x26>
   b5e26:	e074      	b.n	b5f12 <_Z7BLEScani+0x196>
	  _M_realloc_insert(end(), __x);
   b5e28:	483c      	ldr	r0, [pc, #240]	; (b5f1c <_Z7BLEScani+0x1a0>)
   b5e2a:	aa10      	add	r2, sp, #64	; 0x40
   b5e2c:	4619      	mov	r1, r3
   b5e2e:	f7ff ff51 	bl	b5cd4 <_ZNSt6vectorI7PairBotSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>
   b5e32:	e7f4      	b.n	b5e1e <_Z7BLEScani+0xa2>
                if(BotNumber == -1 || BotNumber == BLECustomData[0]){   //Check if a particular bot number was specified, or -1 if we should automatically connect to the closest one
   b5e34:	1c73      	adds	r3, r6, #1
   b5e36:	d003      	beq.n	b5e40 <_Z7BLEScani+0xc4>
   b5e38:	f89d 3004 	ldrb.w	r3, [sp, #4]
   b5e3c:	42b3      	cmp	r3, r6
   b5e3e:	d1ee      	bne.n	b5e1e <_Z7BLEScani+0xa2>
                    peer = BLE.connect(scanResults[ii].address());      //Try to connect to the one we just scanned in
   b5e40:	f005 fa70 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
	  _M_refcount._M_swap(__r._M_refcount);
	  __r._M_ptr = 0;
	}

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
   b5e44:	4d36      	ldr	r5, [pc, #216]	; (b5f20 <_Z7BLEScani+0x1a4>)
   b5e46:	4601      	mov	r1, r0
   b5e48:	2301      	movs	r3, #1
   b5e4a:	eb09 020b 	add.w	r2, r9, fp
   b5e4e:	a810      	add	r0, sp, #64	; 0x40
   b5e50:	f006 fe3c 	bl	bcacc <_ZNK8particle14BleLocalDevice7connectERKNS_10BleAddressEb>
   b5e54:	9b10      	ldr	r3, [sp, #64]	; 0x40
   b5e56:	9c11      	ldr	r4, [sp, #68]	; 0x44
   b5e58:	602b      	str	r3, [r5, #0]
	if (__tmp != _M_pi)
   b5e5a:	686b      	ldr	r3, [r5, #4]
   b5e5c:	429c      	cmp	r4, r3
   b5e5e:	d008      	beq.n	b5e72 <_Z7BLEScani+0xf6>
	    if (__tmp != 0)
   b5e60:	b114      	cbz	r4, b5e68 <_Z7BLEScani+0xec>
    { ++_M_use_count; }
   b5e62:	6863      	ldr	r3, [r4, #4]
   b5e64:	3301      	adds	r3, #1
   b5e66:	6063      	str	r3, [r4, #4]
	    if (_M_pi != 0)
   b5e68:	6868      	ldr	r0, [r5, #4]
   b5e6a:	b108      	cbz	r0, b5e70 <_Z7BLEScani+0xf4>
	      _M_pi->_M_release();
   b5e6c:	f7fe fb36 	bl	b44dc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
	    _M_pi = __tmp;
   b5e70:	606c      	str	r4, [r5, #4]
   b5e72:	a810      	add	r0, sp, #64	; 0x40
   b5e74:	f005 fbc5 	bl	bb602 <_ZN8particle13BlePeerDeviceD1Ev>
				    if (peer.connected()) {                             //If we connected properly
   b5e78:	4829      	ldr	r0, [pc, #164]	; (b5f20 <_Z7BLEScani+0x1a4>)
   b5e7a:	f005 f9c5 	bl	bb208 <_ZNK8particle13BlePeerDevice9connectedEv>
   b5e7e:	4604      	mov	r4, r0
   b5e80:	2800      	cmp	r0, #0
   b5e82:	d046      	beq.n	b5f12 <_Z7BLEScani+0x196>
                        startConnect = true;                            //Indicate to the setup function (that may be waiting) that we have discovered a bot over BLE
   b5e84:	4b27      	ldr	r3, [pc, #156]	; (b5f24 <_Z7BLEScani+0x1a8>)
   b5e86:	4d28      	ldr	r5, [pc, #160]	; (b5f28 <_Z7BLEScani+0x1ac>)
   b5e88:	2601      	movs	r6, #1
                        scanResults[ii].advertisingData().customData(bufName, BLE_MAX_ADV_DATA_LEN);        //Get the custom data and put it in the buffer
   b5e8a:	221f      	movs	r2, #31
   b5e8c:	a908      	add	r1, sp, #32
   b5e8e:	4638      	mov	r0, r7
                        startConnect = true;                            //Indicate to the setup function (that may be waiting) that we have discovered a bot over BLE
   b5e90:	701e      	strb	r6, [r3, #0]
                        scanResults[ii].advertisingData().customData(bufName, BLE_MAX_ADV_DATA_LEN);        //Get the custom data and put it in the buffer
   b5e92:	f005 f863 	bl	baf5c <_ZNK8particle18BleAdvertisingData10customDataEPhj>
					    peer.getCharacteristicByUUID(peerTxCharacteristic, txUuid);             //Get all of the service characteristics - tx is the characteristic the bot transmits data from 
   b5e96:	4a25      	ldr	r2, [pc, #148]	; (b5f2c <_Z7BLEScani+0x1b0>)
   b5e98:	4925      	ldr	r1, [pc, #148]	; (b5f30 <_Z7BLEScani+0x1b4>)
   b5e9a:	4821      	ldr	r0, [pc, #132]	; (b5f20 <_Z7BLEScani+0x1a4>)
   b5e9c:	f006 faaa 	bl	bc3f4 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE>
					    peer.getCharacteristicByUUID(peerRxCharacteristic, rxUuid);             //Characteristic the bot received data in on
   b5ea0:	4a24      	ldr	r2, [pc, #144]	; (b5f34 <_Z7BLEScani+0x1b8>)
   b5ea2:	4925      	ldr	r1, [pc, #148]	; (b5f38 <_Z7BLEScani+0x1bc>)
   b5ea4:	481e      	ldr	r0, [pc, #120]	; (b5f20 <_Z7BLEScani+0x1a4>)
   b5ea6:	f006 faa5 	bl	bc3f4 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE>
                        peer.getCharacteristicByUUID(peerOffloadCharacteristic, offldUuid);     //Characteristic the bot sends strings from the SD card on
   b5eaa:	4a24      	ldr	r2, [pc, #144]	; (b5f3c <_Z7BLEScani+0x1c0>)
   b5eac:	4924      	ldr	r1, [pc, #144]	; (b5f40 <_Z7BLEScani+0x1c4>)
   b5eae:	481c      	ldr	r0, [pc, #112]	; (b5f20 <_Z7BLEScani+0x1a4>)
   b5eb0:	f006 faa0 	bl	bc3f4 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE>
                        WaterBot newWaterbot;                           //Create a new water bot object with the bot id seen in the advertisement packet
   b5eb4:	a810      	add	r0, sp, #64	; 0x40
   b5eb6:	f7fe fc11 	bl	b46dc <_ZN8WaterBotC1Ev>
                        newWaterbot.botNum = bufName[0];                //Copy bot ID
   b5eba:	f89d 3020 	ldrb.w	r3, [sp, #32]
                        PairBots.push_back(newWaterbot);                //Push into the pairing vector
   b5ebe:	4821      	ldr	r0, [pc, #132]	; (b5f44 <_Z7BLEScani+0x1c8>)
                        newWaterbot.botNum = bufName[0];                //Copy bot ID
   b5ec0:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
                        PairBots.push_back(newWaterbot);                //Push into the pairing vector
   b5ec4:	a910      	add	r1, sp, #64	; 0x40
                        newWaterbot.BLEAvail = true;                    //Assuming BLE is available since we just connected to it
   b5ec6:	f88d 6047 	strb.w	r6, [sp, #71]	; 0x47
                        PairBots.push_back(newWaterbot);                //Push into the pairing vector
   b5eca:	f7ff fb01 	bl	b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>
      : _M_current(__i) { }
   b5ece:	4b1e      	ldr	r3, [pc, #120]	; (b5f48 <_Z7BLEScani+0x1cc>)
                            if(bufName[0] == w.botNum){                 //Check if this water bot already has been discovered by some other means (XBee, LTE), don't add another copy if we already have one
   b5ed0:	f89d 7020 	ldrb.w	r7, [sp, #32]
   b5ed4:	f8d3 c004 	ldr.w	ip, [r3, #4]
   b5ed8:	7829      	ldrb	r1, [r5, #0]
   b5eda:	681b      	ldr	r3, [r3, #0]
                        bool newBot = true;                             //Flag to check if we have seen this bot before and should add to the main WaterBots vector
   b5edc:	4622      	mov	r2, r4
                            if(bufName[0] == w.botNum){                 //Check if this water bot already has been discovered by some other means (XBee, LTE), don't add another copy if we already have one
   b5ede:	2000      	movs	r0, #0
                        for(WaterBot &w: WaterBots){                    //Loop over the water bots already discovered
   b5ee0:	459c      	cmp	ip, r3
   b5ee2:	d009      	beq.n	b5ef8 <_Z7BLEScani+0x17c>
                            if(bufName[0] == w.botNum){                 //Check if this water bot already has been discovered by some other means (XBee, LTE), don't add another copy if we already have one
   b5ee4:	f893 e002 	ldrb.w	lr, [r3, #2]
   b5ee8:	4577      	cmp	r7, lr
                                w.BLEAvail = true;                      //Indicate in the existing bot that BLE is available
   b5eea:	bf01      	itttt	eq
   b5eec:	71de      	strbeq	r6, [r3, #7]
                                BLEBotNum = w.botNum;
   b5eee:	4620      	moveq	r0, r4
   b5ef0:	4639      	moveq	r1, r7
                                newBot = false;                         //Don't add a new bot
   b5ef2:	2200      	moveq	r2, #0
      operator++() _GLIBCXX_NOEXCEPT
   b5ef4:	3350      	adds	r3, #80	; 0x50
	return *this;
   b5ef6:	e7f3      	b.n	b5ee0 <_Z7BLEScani+0x164>
   b5ef8:	b100      	cbz	r0, b5efc <_Z7BLEScani+0x180>
   b5efa:	7029      	strb	r1, [r5, #0]
                        if(newBot){                                     //If we need to create a new bot, then do so. Copy in the bot ID
   b5efc:	b14a      	cbz	r2, b5f12 <_Z7BLEScani+0x196>
                            WaterBots.push_back(newWaterbot);
   b5efe:	4812      	ldr	r0, [pc, #72]	; (b5f48 <_Z7BLEScani+0x1cc>)
   b5f00:	a910      	add	r1, sp, #64	; 0x40
   b5f02:	f7ff fae5 	bl	b54d0 <_ZNSt6vectorI8WaterBotSaIS0_EE9push_backERKS0_>
                            BLEBotNum = newWaterbot.botNum;
   b5f06:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   b5f0a:	702b      	strb	r3, [r5, #0]
                            redrawMenu = true;                          //Indicate to menu function to redraw so the bot pops up in the list of discovered bots
   b5f0c:	4b0f      	ldr	r3, [pc, #60]	; (b5f4c <_Z7BLEScani+0x1d0>)
   b5f0e:	2201      	movs	r2, #1
   b5f10:	701a      	strb	r2, [r3, #0]
}
   b5f12:	b025      	add	sp, #148	; 0x94
   b5f14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b5f18:	2003dedc 	.word	0x2003dedc
   b5f1c:	2003dc98 	.word	0x2003dc98
   b5f20:	2003deb4 	.word	0x2003deb4
   b5f24:	2003e630 	.word	0x2003e630
   b5f28:	2003dc94 	.word	0x2003dc94
   b5f2c:	2003dd18 	.word	0x2003dd18
   b5f30:	2003decc 	.word	0x2003decc
   b5f34:	2003dd04 	.word	0x2003dd04
   b5f38:	2003dec4 	.word	0x2003dec4
   b5f3c:	2003dd30 	.word	0x2003dd30
   b5f40:	2003debc 	.word	0x2003debc
   b5f44:	2003dcb8 	.word	0x2003dcb8
   b5f48:	2003dce4 	.word	0x2003dce4
   b5f4c:	2003daaa 	.word	0x2003daaa
   b5f50:	2003dcf0 	.word	0x2003dcf0

000b5f54 <_Z13DataOffloaderh>:
void DataOffloader(uint8_t bot_id){         //Function to copy all .txt and .csv files from the bot SD card and place them on the CCHub SD card
   b5f54:	b570      	push	{r4, r5, r6, lr}
    if (!logDir.open("/")) {                //Open the root directory of the SD card on the controller here
   b5f56:	4954      	ldr	r1, [pc, #336]	; (b60a8 <_Z13DataOffloaderh+0x154>)
void DataOffloader(uint8_t bot_id){         //Function to copy all .txt and .csv files from the bot SD card and place them on the CCHub SD card
   b5f58:	b098      	sub	sp, #96	; 0x60
   b5f5a:	4604      	mov	r4, r0
    if (!logDir.open("/")) {                //Open the root directory of the SD card on the controller here
   b5f5c:	2200      	movs	r2, #0
   b5f5e:	4853      	ldr	r0, [pc, #332]	; (b60ac <_Z13DataOffloaderh+0x158>)
   b5f60:	f7fe fad0 	bl	b4504 <_ZN7FatFile4openEPKci>
   b5f64:	bb00      	cbnz	r0, b5fa8 <_Z13DataOffloaderh+0x54>
        offloadingDone = true;              //If we couldn't open the root directory, then break from the offload operation
   b5f66:	4b52      	ldr	r3, [pc, #328]	; (b60b0 <_Z13DataOffloaderh+0x15c>)
        sprintf(m.primaryLine,"Warning\0"); //Print warning strings to the po-up item
   b5f68:	4952      	ldr	r1, [pc, #328]	; (b60b4 <_Z13DataOffloaderh+0x160>)
        offloadingDone = true;              //If we couldn't open the root directory, then break from the offload operation
   b5f6a:	2401      	movs	r4, #1
        sprintf(m.primaryLine,"Warning\0"); //Print warning strings to the po-up item
   b5f6c:	a805      	add	r0, sp, #20
        offloadingDone = true;              //If we couldn't open the root directory, then break from the offload operation
   b5f6e:	701c      	strb	r4, [r3, #0]
        sprintf(m.primaryLine,"Warning\0"); //Print warning strings to the po-up item
   b5f70:	f009 f813 	bl	bef9a <strcpy>
        sprintf(m.secondaryLine,"CCHub");
   b5f74:	4950      	ldr	r1, [pc, #320]	; (b60b8 <_Z13DataOffloaderh+0x164>)
   b5f76:	f10d 001e 	add.w	r0, sp, #30
   b5f7a:	f009 f80e 	bl	bef9a <strcpy>
        sprintf(m.tertiaryLine, "SD Card Failed\0");
   b5f7e:	494f      	ldr	r1, [pc, #316]	; (b60bc <_Z13DataOffloaderh+0x168>)
   b5f80:	a80f      	add	r0, sp, #60	; 0x3c
   b5f82:	f009 f80a 	bl	bef9a <strcpy>
        m.primaryStart = 20;                //Calculated offsets to center the text in the warning box
   b5f86:	2314      	movs	r3, #20
        m.secondaryStart = 60;
   b5f88:	223c      	movs	r2, #60	; 0x3c
        PopUps.push_back(m);                //Push the warning onto the pop-up queue so it is displayed on top
   b5f8a:	eb0d 0103 	add.w	r1, sp, r3
   b5f8e:	484c      	ldr	r0, [pc, #304]	; (b60c0 <_Z13DataOffloaderh+0x16c>)
        m.primaryStart = 20;                //Calculated offsets to center the text in the warning box
   b5f90:	f88d 305a 	strb.w	r3, [sp, #90]	; 0x5a
        m.tertiaryStart = 20;
   b5f94:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
        m.secondaryStart = 60;
   b5f98:	f88d 205b 	strb.w	r2, [sp, #91]	; 0x5b
        PopUps.push_back(m);                //Push the warning onto the pop-up queue so it is displayed on top
   b5f9c:	f7ff f9a0 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
        redrawMenu = true;                  //Indicate to the main loop draw function that there is new data to be displayed
   b5fa0:	4b48      	ldr	r3, [pc, #288]	; (b60c4 <_Z13DataOffloaderh+0x170>)
   b5fa2:	701c      	strb	r4, [r3, #0]
}
   b5fa4:	b018      	add	sp, #96	; 0x60
   b5fa6:	bd70      	pop	{r4, r5, r6, pc}
   b5fa8:	f003 feea 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(BLEBotNum != bot_id){                //In the case of multiple bots, it's possible to not be connected to the target over BLE. Disconnect from the current guy in that case and scan for the target guy
   b5fac:	4b46      	ldr	r3, [pc, #280]	; (b60c8 <_Z13DataOffloaderh+0x174>)
   b5fae:	781b      	ldrb	r3, [r3, #0]
   b5fb0:	42a3      	cmp	r3, r4
   b5fb2:	4605      	mov	r5, r0
   b5fb4:	d054      	beq.n	b6060 <_Z13DataOffloaderh+0x10c>
        offloadingDone = true;              
   b5fb6:	4b3e      	ldr	r3, [pc, #248]	; (b60b0 <_Z13DataOffloaderh+0x15c>)
        sprintf(m.primaryLine,"Info\0");    //Print warning string to the pop-up
   b5fb8:	4944      	ldr	r1, [pc, #272]	; (b60cc <_Z13DataOffloaderh+0x178>)
        offloadingDone = true;              
   b5fba:	2601      	movs	r6, #1
        sprintf(m.primaryLine,"Info\0");    //Print warning string to the pop-up
   b5fbc:	a805      	add	r0, sp, #20
        offloadingDone = true;              
   b5fbe:	701e      	strb	r6, [r3, #0]
        sprintf(m.primaryLine,"Info\0");    //Print warning string to the pop-up
   b5fc0:	f008 ffeb 	bl	bef9a <strcpy>
        sprintf(m.secondaryLine,"Not connected to BLE\0");
   b5fc4:	4942      	ldr	r1, [pc, #264]	; (b60d0 <_Z13DataOffloaderh+0x17c>)
   b5fc6:	f10d 001e 	add.w	r0, sp, #30
   b5fca:	f008 ffe6 	bl	bef9a <strcpy>
        sprintf(m.tertiaryLine, "Switching BLE conn\0");
   b5fce:	4941      	ldr	r1, [pc, #260]	; (b60d4 <_Z13DataOffloaderh+0x180>)
   b5fd0:	a80f      	add	r0, sp, #60	; 0x3c
   b5fd2:	f008 ffe2 	bl	bef9a <strcpy>
        m.primaryStart = 30;                //Offsets for centering text in the pop-up box
   b5fd6:	231e      	movs	r3, #30
   b5fd8:	f88d 305a 	strb.w	r3, [sp, #90]	; 0x5a
        m.secondaryStart = 5;
   b5fdc:	2305      	movs	r3, #5
        PopUps.push_back(m);                //Push onto the pop-up queue
   b5fde:	a905      	add	r1, sp, #20
   b5fe0:	4837      	ldr	r0, [pc, #220]	; (b60c0 <_Z13DataOffloaderh+0x16c>)
        m.secondaryStart = 5;
   b5fe2:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
        m.tertiaryStart = 10;
   b5fe6:	230a      	movs	r3, #10
   b5fe8:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
        PopUps.push_back(m);                //Push onto the pop-up queue
   b5fec:	f7ff f978 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
        redrawMenu = true;
   b5ff0:	4b34      	ldr	r3, [pc, #208]	; (b60c4 <_Z13DataOffloaderh+0x170>)
   b5ff2:	701e      	strb	r6, [r3, #0]
        BLE.disconnect(peer);               //Disconnect from the currently connected guy
   b5ff4:	f005 f996 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b5ff8:	4937      	ldr	r1, [pc, #220]	; (b60d8 <_Z13DataOffloaderh+0x184>)
   b5ffa:	f005 ffd4 	bl	bbfa6 <_ZNK8particle14BleLocalDevice10disconnectERKNS_13BlePeerDeviceE>
        while(!BLE.connected() && millis() - startScanTime < 15000){        //Try to connect to the target bot for offloading, but time out after 15 seconds. Probably out further than the bluetooth range or the bot has been powered off
   b5ffe:	f643 2697 	movw	r6, #14999	; 0x3a97
   b6002:	f005 f98f 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b6006:	f005 fa3a 	bl	bb47e <_ZNK8particle14BleLocalDevice9connectedEv>
   b600a:	b958      	cbnz	r0, b6024 <_Z13DataOffloaderh+0xd0>
   b600c:	f003 feb8 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b6010:	1b40      	subs	r0, r0, r5
   b6012:	42b0      	cmp	r0, r6
   b6014:	d806      	bhi.n	b6024 <_Z13DataOffloaderh+0xd0>
            BLEScan(bot_id);                //Scan for that particular bot ID
   b6016:	4620      	mov	r0, r4
   b6018:	f7ff feb0 	bl	b5d7c <_Z7BLEScani>
            delay(50);                      //Short pause between scans
   b601c:	2032      	movs	r0, #50	; 0x32
   b601e:	f007 f91b 	bl	bd258 <delay>
        while(!BLE.connected() && millis() - startScanTime < 15000){        //Try to connect to the target bot for offloading, but time out after 15 seconds. Probably out further than the bluetooth range or the bot has been powered off
   b6022:	e7ee      	b.n	b6002 <_Z13DataOffloaderh+0xae>
        snprintf(OffloadCommand,10,"CCB%ddmp",OffloadingBot);       //Create start command for offloading
   b6024:	4a2d      	ldr	r2, [pc, #180]	; (b60dc <_Z13DataOffloaderh+0x188>)
   b6026:	4623      	mov	r3, r4
   b6028:	210a      	movs	r1, #10
   b602a:	a802      	add	r0, sp, #8
   b602c:	f004 fa06 	bl	ba43c <snprintf>
        sendData(OffloadCommand,0,true,false,false);                //Send it to the now-connected bot over BLE to have it enter offloading mode
   b6030:	2300      	movs	r3, #0
   b6032:	9300      	str	r3, [sp, #0]
   b6034:	2201      	movs	r2, #1
   b6036:	4619      	mov	r1, r3
   b6038:	a802      	add	r0, sp, #8
        sendData(OffloadCommand,0,true,false,false);        //Send the offloading command to the bot to start the process
   b603a:	f7fe fd2d 	bl	b4a98 <_Z8sendDataPKchbbb>
   b603e:	f003 fe9f 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    if(millis() - startScanTime > 15000){   //Check the timeout for if we actually connected to the target, if we didn't connect then cancel, as we can't reach the target
   b6042:	f643 2398 	movw	r3, #15000	; 0x3a98
   b6046:	1b40      	subs	r0, r0, r5
   b6048:	4298      	cmp	r0, r3
   b604a:	d914      	bls.n	b6076 <_Z13DataOffloaderh+0x122>
   b604c:	4824      	ldr	r0, [pc, #144]	; (b60e0 <_Z13DataOffloaderh+0x18c>)
        if(logDir.isOpen()) logDir.close(); //Close the root directory if it's open as cleanup
   b604e:	7c03      	ldrb	r3, [r0, #16]
   b6050:	2b00      	cmp	r3, #0
   b6052:	d0a7      	beq.n	b5fa4 <_Z13DataOffloaderh+0x50>
   b6054:	3010      	adds	r0, #16
}
   b6056:	b018      	add	sp, #96	; 0x60
   b6058:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if(logDir.isOpen()) logDir.close(); //Close the root directory if it's open as cleanup
   b605c:	f002 bf0e 	b.w	b8e7c <_ZN7FatFile5closeEv>
        snprintf(OffloadCommand,10,"CCB%ddmp",OffloadingBot); 
   b6060:	4a1e      	ldr	r2, [pc, #120]	; (b60dc <_Z13DataOffloaderh+0x188>)
   b6062:	210a      	movs	r1, #10
   b6064:	a805      	add	r0, sp, #20
   b6066:	f004 f9e9 	bl	ba43c <snprintf>
        sendData(OffloadCommand,0,true,false,false);        //Send the offloading command to the bot to start the process
   b606a:	2300      	movs	r3, #0
   b606c:	9300      	str	r3, [sp, #0]
   b606e:	2201      	movs	r2, #1
   b6070:	4619      	mov	r1, r3
   b6072:	a805      	add	r0, sp, #20
   b6074:	e7e1      	b.n	b603a <_Z13DataOffloaderh+0xe6>
    if(BLE.connected()) offloadingDone = false; //Set flag to show that offloading is not complete. Will sit in a loop until the target indicates that it's done copying. Everything else handled in the offload received interrupt
   b6076:	f005 f955 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b607a:	f005 fa00 	bl	bb47e <_ZNK8particle14BleLocalDevice9connectedEv>
   b607e:	4c0c      	ldr	r4, [pc, #48]	; (b60b0 <_Z13DataOffloaderh+0x15c>)
   b6080:	b108      	cbz	r0, b6086 <_Z13DataOffloaderh+0x132>
   b6082:	2300      	movs	r3, #0
   b6084:	7023      	strb	r3, [r4, #0]
    while(!offloadingDone) delay(100);          //Wait for the bot to indicate it's done with the copy
   b6086:	7823      	ldrb	r3, [r4, #0]
   b6088:	b91b      	cbnz	r3, b6092 <_Z13DataOffloaderh+0x13e>
   b608a:	2064      	movs	r0, #100	; 0x64
   b608c:	f007 f8e4 	bl	bd258 <delay>
   b6090:	e7f9      	b.n	b6086 <_Z13DataOffloaderh+0x132>
   b6092:	4813      	ldr	r0, [pc, #76]	; (b60e0 <_Z13DataOffloaderh+0x18c>)
    if(logDir.isOpen()) logDir.close();         //Release the root directory of the SD card
   b6094:	7c03      	ldrb	r3, [r0, #16]
   b6096:	b113      	cbz	r3, b609e <_Z13DataOffloaderh+0x14a>
   b6098:	3010      	adds	r0, #16
   b609a:	f002 feef 	bl	b8e7c <_ZN7FatFile5closeEv>
    offloadingMode = false;                     //Set flag to false to show we're done offloading (at least for this bot)5
   b609e:	4b11      	ldr	r3, [pc, #68]	; (b60e4 <_Z13DataOffloaderh+0x190>)
   b60a0:	2200      	movs	r2, #0
   b60a2:	701a      	strb	r2, [r3, #0]
   b60a4:	e77e      	b.n	b5fa4 <_Z13DataOffloaderh+0x50>
   b60a6:	bf00      	nop
   b60a8:	000c12b3 	.word	0x000c12b3
   b60ac:	2003ddac 	.word	0x2003ddac
   b60b0:	2003de5a 	.word	0x2003de5a
   b60b4:	000c1472 	.word	0x000c1472
   b60b8:	000c10ca 	.word	0x000c10ca
   b60bc:	000c1494 	.word	0x000c1494
   b60c0:	2003dcc4 	.word	0x2003dcc4
   b60c4:	2003daaa 	.word	0x2003daaa
   b60c8:	2003dc94 	.word	0x2003dc94
   b60cc:	000c14d4 	.word	0x000c14d4
   b60d0:	000c14da 	.word	0x000c14da
   b60d4:	000c14f0 	.word	0x000c14f0
   b60d8:	2003deb4 	.word	0x2003deb4
   b60dc:	000c12b5 	.word	0x000c12b5
   b60e0:	2003dd9c 	.word	0x2003dd9c
   b60e4:	2003de5b 	.word	0x2003de5b

000b60e8 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>:
      vector<_Tp, _Alloc>::
   b60e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b60ec:	e9d0 9a00 	ldrd	r9, sl, [r0]
   b60f0:	468b      	mov	fp, r1
	if (max_size() - size() < __n)
   b60f2:	f06f 4378 	mvn.w	r3, #4160749568	; 0xf8000000
   b60f6:	4611      	mov	r1, r2
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b60f8:	ebaa 0209 	sub.w	r2, sl, r9
	if (max_size() - size() < __n)
   b60fc:	ebb3 1f22 	cmp.w	r3, r2, asr #4
   b6100:	4680      	mov	r8, r0
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b6102:	ea4f 1422 	mov.w	r4, r2, asr #4
	if (max_size() - size() < __n)
   b6106:	d102      	bne.n	b610e <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x26>
	  __throw_length_error(__N(__s));
   b6108:	4826      	ldr	r0, [pc, #152]	; (b61a4 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xbc>)
   b610a:	f008 f807 	bl	be11c <_ZSt20__throw_length_errorPKc>
   b610e:	2c01      	cmp	r4, #1
   b6110:	4622      	mov	r2, r4
   b6112:	bf38      	it	cc
   b6114:	2201      	movcc	r2, #1
   b6116:	18a4      	adds	r4, r4, r2
    { return __lhs.base() - __rhs.base(); }
   b6118:	ebab 0609 	sub.w	r6, fp, r9
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b611c:	d21a      	bcs.n	b6154 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x6c>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b611e:	b1dc      	cbz	r4, b6158 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x70>
   b6120:	429c      	cmp	r4, r3
   b6122:	bf28      	it	cs
   b6124:	461c      	movcs	r4, r3
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   b6126:	0120      	lsls	r0, r4, #4
   b6128:	9101      	str	r1, [sp, #4]
   b612a:	f7fd ffb4 	bl	b4096 <_Znwj>
   b612e:	9901      	ldr	r1, [sp, #4]
   b6130:	4605      	mov	r5, r0
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b6132:	19a8      	adds	r0, r5, r6
   b6134:	d001      	beq.n	b613a <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x52>
   b6136:	f004 fb53 	bl	ba7e0 <_ZN6StringC1EOS_>
   b613a:	4628      	mov	r0, r5
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b613c:	464e      	mov	r6, r9
	      for (; __first != __last; ++__first, (void)++__cur)
   b613e:	45b3      	cmp	fp, r6
   b6140:	f100 0710 	add.w	r7, r0, #16
   b6144:	d00a      	beq.n	b615c <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x74>
    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
   b6146:	b110      	cbz	r0, b614e <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x66>
   b6148:	4631      	mov	r1, r6
   b614a:	f004 fb63 	bl	ba814 <_ZN6StringC1ERKS_>
   b614e:	3610      	adds	r6, #16
   b6150:	4638      	mov	r0, r7
   b6152:	e7f4      	b.n	b613e <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x56>
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b6154:	461c      	mov	r4, r3
   b6156:	e7e6      	b.n	b6126 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x3e>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b6158:	4625      	mov	r5, r4
   b615a:	e7ea      	b.n	b6132 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x4a>
   b615c:	4556      	cmp	r6, sl
   b615e:	d006      	beq.n	b616e <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x86>
   b6160:	4631      	mov	r1, r6
   b6162:	4638      	mov	r0, r7
   b6164:	f004 fb56 	bl	ba814 <_ZN6StringC1ERKS_>
   b6168:	3610      	adds	r6, #16
   b616a:	3710      	adds	r7, #16
   b616c:	e7f6      	b.n	b615c <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x74>
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b616e:	464e      	mov	r6, r9
	  for (; __first != __last; ++__first)
   b6170:	4556      	cmp	r6, sl
   b6172:	d004      	beq.n	b617e <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x96>
      __pointer->~_Tp();
   b6174:	4630      	mov	r0, r6
   b6176:	f004 fab7 	bl	ba6e8 <_ZN6StringD1Ev>
	  for (; __first != __last; ++__first)
   b617a:	3610      	adds	r6, #16
   b617c:	e7f8      	b.n	b6170 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x88>
	if (__p)
   b617e:	f1b9 0f00 	cmp.w	r9, #0
   b6182:	d006      	beq.n	b6192 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xaa>
		    this->_M_impl._M_end_of_storage - __old_start);
   b6184:	f8d8 1008 	ldr.w	r1, [r8, #8]
	::operator delete(__p
   b6188:	4648      	mov	r0, r9
   b618a:	eba1 0109 	sub.w	r1, r1, r9
   b618e:	f7fd ff86 	bl	b409e <_ZdlPvj>
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b6192:	eb05 1404 	add.w	r4, r5, r4, lsl #4
      this->_M_impl._M_finish = __new_finish;
   b6196:	e9c8 5700 	strd	r5, r7, [r8]
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b619a:	f8c8 4008 	str.w	r4, [r8, #8]
    }
   b619e:	b003      	add	sp, #12
   b61a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b61a4:	000c1151 	.word	0x000c1151

000b61a8 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0>:
      vector<_Tp, _Alloc>::
   b61a8:	b538      	push	{r3, r4, r5, lr}
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b61aa:	e9d0 3501 	ldrd	r3, r5, [r0, #4]
   b61ae:	42ab      	cmp	r3, r5
      vector<_Tp, _Alloc>::
   b61b0:	4604      	mov	r4, r0
   b61b2:	460a      	mov	r2, r1
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b61b4:	d007      	beq.n	b61c6 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0+0x1e>
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b61b6:	b113      	cbz	r3, b61be <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0+0x16>
   b61b8:	4618      	mov	r0, r3
   b61ba:	f004 fb11 	bl	ba7e0 <_ZN6StringC1EOS_>
	    ++this->_M_impl._M_finish;
   b61be:	6863      	ldr	r3, [r4, #4]
   b61c0:	3310      	adds	r3, #16
   b61c2:	6063      	str	r3, [r4, #4]
      }
   b61c4:	bd38      	pop	{r3, r4, r5, pc}
	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
   b61c6:	4619      	mov	r1, r3
   b61c8:	f7ff ff8e 	bl	b60e8 <_ZNSt6vectorI6StringSaIS0_EE17_M_realloc_insertIJS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>
	return back();
   b61cc:	e7fa      	b.n	b61c4 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0+0x1c>
	...

000b61d0 <_ZN8MenuItemC1ERKS_>:
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b61d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b61d4:	e9d1 2700 	ldrd	r2, r7, [r1]
	: _M_start(), _M_finish(), _M_end_of_storage()
   b61d8:	2300      	movs	r3, #0
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b61da:	1abf      	subs	r7, r7, r2
	: _M_start(), _M_finish(), _M_end_of_storage()
   b61dc:	e9c0 3300 	strd	r3, r3, [r0]
   b61e0:	4604      	mov	r4, r0
   b61e2:	460d      	mov	r5, r1
   b61e4:	6083      	str	r3, [r0, #8]
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b61e6:	d018      	beq.n	b621a <_ZN8MenuItemC1ERKS_+0x4a>
	if (__n > this->_M_max_size())
   b61e8:	4b1a      	ldr	r3, [pc, #104]	; (b6254 <_ZN8MenuItemC1ERKS_+0x84>)
   b61ea:	429f      	cmp	r7, r3
   b61ec:	d901      	bls.n	b61f2 <_ZN8MenuItemC1ERKS_+0x22>
	  std::__throw_bad_alloc();
   b61ee:	f007 ff8f 	bl	be110 <_ZSt17__throw_bad_allocv>
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   b61f2:	4638      	mov	r0, r7
   b61f4:	f7fd ff4f 	bl	b4096 <_Znwj>
   b61f8:	4606      	mov	r6, r0
	this->_M_impl._M_finish = this->_M_impl._M_start;
   b61fa:	e9c4 6600 	strd	r6, r6, [r4]
	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   b61fe:	4437      	add	r7, r6
   b6200:	60a7      	str	r7, [r4, #8]
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
   b6202:	e9d5 7800 	ldrd	r7, r8, [r5]
   b6206:	45b8      	cmp	r8, r7
   b6208:	d009      	beq.n	b621e <_ZN8MenuItemC1ERKS_+0x4e>
    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
   b620a:	b11e      	cbz	r6, b6214 <_ZN8MenuItemC1ERKS_+0x44>
   b620c:	4639      	mov	r1, r7
   b620e:	4630      	mov	r0, r6
   b6210:	f004 fb00 	bl	ba814 <_ZN6StringC1ERKS_>
   b6214:	3610      	adds	r6, #16
   b6216:	3710      	adds	r7, #16
   b6218:	e7f5      	b.n	b6206 <_ZN8MenuItemC1ERKS_+0x36>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b621a:	463e      	mov	r6, r7
   b621c:	e7ed      	b.n	b61fa <_ZN8MenuItemC1ERKS_+0x2a>
	this->_M_impl._M_finish =
   b621e:	6066      	str	r6, [r4, #4]
   b6220:	7e2b      	ldrb	r3, [r5, #24]
   b6222:	7623      	strb	r3, [r4, #24]
   b6224:	8b6b      	ldrh	r3, [r5, #26]
   b6226:	8363      	strh	r3, [r4, #26]
   b6228:	8bab      	ldrh	r3, [r5, #28]
   b622a:	692a      	ldr	r2, [r5, #16]
   b622c:	68e9      	ldr	r1, [r5, #12]
   b622e:	83a3      	strh	r3, [r4, #28]
   b6230:	f8d5 301e 	ldr.w	r3, [r5, #30]
   b6234:	f8c4 301e 	str.w	r3, [r4, #30]
   b6238:	f8d5 3022 	ldr.w	r3, [r5, #34]	; 0x22
   b623c:	f8c4 3022 	str.w	r3, [r4, #34]	; 0x22
   b6240:	e9c4 1203 	strd	r1, r2, [r4, #12]
   b6244:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
   b6246:	696a      	ldr	r2, [r5, #20]
   b6248:	6162      	str	r2, [r4, #20]
   b624a:	84e3      	strh	r3, [r4, #38]	; 0x26
   b624c:	4620      	mov	r0, r4
   b624e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   b6252:	bf00      	nop
   b6254:	7ffffff0 	.word	0x7ffffff0

000b6258 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>:
      vector<_Tp, _Alloc>::
   b6258:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b625c:	e9d0 8700 	ldrd	r8, r7, [r0]
   b6260:	4b23      	ldr	r3, [pc, #140]	; (b62f0 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x98>)
   b6262:	eba7 0408 	sub.w	r4, r7, r8
   b6266:	10e4      	asrs	r4, r4, #3
   b6268:	435c      	muls	r4, r3
	if (max_size() - size() < __n)
   b626a:	4b22      	ldr	r3, [pc, #136]	; (b62f4 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x9c>)
   b626c:	429c      	cmp	r4, r3
   b626e:	460e      	mov	r6, r1
   b6270:	4605      	mov	r5, r0
   b6272:	4611      	mov	r1, r2
   b6274:	d102      	bne.n	b627c <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x24>
	  __throw_length_error(__N(__s));
   b6276:	4820      	ldr	r0, [pc, #128]	; (b62f8 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0xa0>)
   b6278:	f007 ff50 	bl	be11c <_ZSt20__throw_length_errorPKc>
   b627c:	2c01      	cmp	r4, #1
   b627e:	4622      	mov	r2, r4
   b6280:	bf38      	it	cc
   b6282:	2201      	movcc	r2, #1
   b6284:	18a4      	adds	r4, r4, r2
    { return __lhs.base() - __rhs.base(); }
   b6286:	eba6 0a08 	sub.w	sl, r6, r8
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b628a:	d22d      	bcs.n	b62e8 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x90>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b628c:	b374      	cbz	r4, b62ec <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x94>
   b628e:	429c      	cmp	r4, r3
   b6290:	bf28      	it	cs
   b6292:	461c      	movcs	r4, r3
   b6294:	2028      	movs	r0, #40	; 0x28
   b6296:	4360      	muls	r0, r4
   b6298:	9101      	str	r1, [sp, #4]
   b629a:	f7fd fefc 	bl	b4096 <_Znwj>
   b629e:	9901      	ldr	r1, [sp, #4]
   b62a0:	4681      	mov	r9, r0
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b62a2:	eb19 000a 	adds.w	r0, r9, sl
   b62a6:	d001      	beq.n	b62ac <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x54>
   b62a8:	f7ff ff92 	bl	b61d0 <_ZN8MenuItemC1ERKS_>
		 _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
				     std::__niter_base(__last),
				     std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
   b62ac:	4631      	mov	r1, r6
   b62ae:	464a      	mov	r2, r9
   b62b0:	4640      	mov	r0, r8
   b62b2:	f7fe ff78 	bl	b51a6 <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0>
   b62b6:	4639      	mov	r1, r7
   b62b8:	f100 0228 	add.w	r2, r0, #40	; 0x28
   b62bc:	4630      	mov	r0, r6
   b62be:	f7fe ff72 	bl	b51a6 <_ZSt14__relocate_a_1IP8MenuItemS1_SaIS0_EET0_T_S4_S3_RT1_.isra.0>
   b62c2:	4606      	mov	r6, r0
	if (__p)
   b62c4:	f1b8 0f00 	cmp.w	r8, #0
   b62c8:	d005      	beq.n	b62d6 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x7e>
		    this->_M_impl._M_end_of_storage - __old_start);
   b62ca:	68a9      	ldr	r1, [r5, #8]
	::operator delete(__p
   b62cc:	4640      	mov	r0, r8
   b62ce:	eba1 0108 	sub.w	r1, r1, r8
   b62d2:	f7fd fee4 	bl	b409e <_ZdlPvj>
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b62d6:	2028      	movs	r0, #40	; 0x28
   b62d8:	fb00 9404 	mla	r4, r0, r4, r9
      this->_M_impl._M_finish = __new_finish;
   b62dc:	e9c5 9600 	strd	r9, r6, [r5]
      this->_M_impl._M_end_of_storage = __new_start + __len;
   b62e0:	60ac      	str	r4, [r5, #8]
    }
   b62e2:	b002      	add	sp, #8
   b62e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return (__len < size() || __len > max_size()) ? max_size() : __len;
   b62e8:	461c      	mov	r4, r3
   b62ea:	e7d3      	b.n	b6294 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x3c>
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
   b62ec:	46a1      	mov	r9, r4
   b62ee:	e7d8      	b.n	b62a2 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_+0x4a>
   b62f0:	cccccccd 	.word	0xcccccccd
   b62f4:	03333333 	.word	0x03333333
   b62f8:	000c1151 	.word	0x000c1151

000b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>:
      push_back(const value_type& __x)
   b62fc:	b538      	push	{r3, r4, r5, lr}
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b62fe:	e9d0 3501 	ldrd	r3, r5, [r0, #4]
   b6302:	42ab      	cmp	r3, r5
      push_back(const value_type& __x)
   b6304:	4604      	mov	r4, r0
   b6306:	460a      	mov	r2, r1
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   b6308:	d007      	beq.n	b631a <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_+0x1e>
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   b630a:	b113      	cbz	r3, b6312 <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_+0x16>
   b630c:	4618      	mov	r0, r3
   b630e:	f7ff ff5f 	bl	b61d0 <_ZN8MenuItemC1ERKS_>
	    ++this->_M_impl._M_finish;
   b6312:	6863      	ldr	r3, [r4, #4]
   b6314:	3328      	adds	r3, #40	; 0x28
   b6316:	6063      	str	r3, [r4, #4]
      }
   b6318:	bd38      	pop	{r3, r4, r5, pc}
	  _M_realloc_insert(end(), __x);
   b631a:	4619      	mov	r1, r3
   b631c:	f7ff ff9c 	bl	b6258 <_ZNSt6vectorI8MenuItemSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_>
      }
   b6320:	e7fa      	b.n	b6318 <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_+0x1c>
	...

000b6324 <_Z10createMenuv>:
void createMenu(){
   b6324:	b570      	push	{r4, r5, r6, lr}
   b6326:	b0c6      	sub	sp, #280	; 0x118
	: _M_start(), _M_finish(), _M_end_of_storage()
   b6328:	2400      	movs	r4, #0
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b632a:	2501      	movs	r5, #1
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b632c:	496c      	ldr	r1, [pc, #432]	; (b64e0 <_Z10createMenuv+0x1bc>)
   b632e:	9402      	str	r4, [sp, #8]
   b6330:	f10d 001e 	add.w	r0, sp, #30
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b6334:	f04f 1601 	mov.w	r6, #65537	; 0x10001
   b6338:	e9cd 4400 	strd	r4, r4, [sp]
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b633c:	f8ad 401a 	strh.w	r4, [sp, #26]
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6340:	f8ad 501c 	strh.w	r5, [sp, #28]
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6344:	f008 fe29 	bl	bef9a <strcpy>
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b6348:	2315      	movs	r3, #21
   b634a:	e9cd 3604 	strd	r3, r6, [sp, #16]
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b634e:	4965      	ldr	r1, [pc, #404]	; (b64e4 <_Z10createMenuv+0x1c0>)
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b6350:	f88d 4018 	strb.w	r4, [sp, #24]
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6354:	2364      	movs	r3, #100	; 0x64
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6356:	f10d 0046 	add.w	r0, sp, #70	; 0x46
   b635a:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
   b635e:	940c      	str	r4, [sp, #48]	; 0x30
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b6360:	f8ad 4042 	strh.w	r4, [sp, #66]	; 0x42
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6364:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6368:	f008 fe17 	bl	bef9a <strcpy>
    battStat.MethodPointer = &WaterBot::battPercent;        //Get the data from the battery percentage variable of the selected bot
   b636c:	2304      	movs	r3, #4
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b636e:	495e      	ldr	r1, [pc, #376]	; (b64e8 <_Z10createMenuv+0x1c4>)
    battStat.MethodPointer = &WaterBot::battPercent;        //Get the data from the battery percentage variable of the selected bot
   b6370:	930d      	str	r3, [sp, #52]	; 0x34
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6372:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
   b6376:	e9cd 4414 	strd	r4, r4, [sp, #80]	; 0x50
   b637a:	9416      	str	r4, [sp, #88]	; 0x58
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b637c:	f8ad 406a 	strh.w	r4, [sp, #106]	; 0x6a
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b6380:	950f      	str	r5, [sp, #60]	; 0x3c
    battStat.statOnly = true;                               //Only a statistic, don't allow modification from the left or right buttons
   b6382:	f88d 5040 	strb.w	r5, [sp, #64]	; 0x40
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6386:	f8ad 506c 	strh.w	r5, [sp, #108]	; 0x6c
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b638a:	f008 fe06 	bl	bef9a <strcpy>
    offloadItem.MethodPointerBool = &WaterBot::offloading;  //Modify the offloading variable in the water bot object when pressing left or right button
   b638e:	2316      	movs	r3, #22
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b6390:	e9cd 3618 	strd	r3, r6, [sp, #96]	; 0x60
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6394:	4955      	ldr	r1, [pc, #340]	; (b64ec <_Z10createMenuv+0x1c8>)
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b6396:	f88d 4068 	strb.w	r4, [sp, #104]	; 0x68
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b639a:	2302      	movs	r3, #2
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b639c:	f10d 0096 	add.w	r0, sp, #150	; 0x96
   b63a0:	e9cd 441e 	strd	r4, r4, [sp, #120]	; 0x78
   b63a4:	9420      	str	r4, [sp, #128]	; 0x80
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b63a6:	f8ad 4092 	strh.w	r4, [sp, #146]	; 0x92
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b63aa:	f8ad 3094 	strh.w	r3, [sp, #148]	; 0x94
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b63ae:	f008 fdf4 	bl	bef9a <strcpy>
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b63b2:	4b4f      	ldr	r3, [pc, #316]	; (b64f0 <_Z10createMenuv+0x1cc>)
    sentryToggle.labels.push_back("Rem");                   //Copy in the custom data labels to display in the data section
   b63b4:	494f      	ldr	r1, [pc, #316]	; (b64f4 <_Z10createMenuv+0x1d0>)
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b63b6:	9323      	str	r3, [sp, #140]	; 0x8c
    sentryToggle.labels.push_back("Rem");                   //Copy in the custom data labels to display in the data section
   b63b8:	a83c      	add	r0, sp, #240	; 0xf0
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b63ba:	f88d 4090 	strb.w	r4, [sp, #144]	; 0x90
    sentryToggle.labels.push_back("Rem");                   //Copy in the custom data labels to display in the data section
   b63be:	f004 f9de 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
      { emplace_back(std::move(__x)); }
   b63c2:	a93c      	add	r1, sp, #240	; 0xf0
   b63c4:	a81e      	add	r0, sp, #120	; 0x78
   b63c6:	f7ff feef 	bl	b61a8 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0>
   b63ca:	a83c      	add	r0, sp, #240	; 0xf0
   b63cc:	f004 f98c 	bl	ba6e8 <_ZN6StringD1Ev>
    sentryToggle.labels.push_back("Sen");
   b63d0:	4949      	ldr	r1, [pc, #292]	; (b64f8 <_Z10createMenuv+0x1d4>)
   b63d2:	a83c      	add	r0, sp, #240	; 0xf0
   b63d4:	f004 f9d3 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
   b63d8:	a93c      	add	r1, sp, #240	; 0xf0
   b63da:	a81e      	add	r0, sp, #120	; 0x78
   b63dc:	f7ff fee4 	bl	b61a8 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0>
   b63e0:	a83c      	add	r0, sp, #240	; 0xf0
   b63e2:	f004 f981 	bl	ba6e8 <_ZN6StringD1Ev>
    sentryToggle.labels.push_back("Aut");
   b63e6:	4945      	ldr	r1, [pc, #276]	; (b64fc <_Z10createMenuv+0x1d8>)
   b63e8:	a83c      	add	r0, sp, #240	; 0xf0
   b63ea:	f004 f9c8 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
   b63ee:	a93c      	add	r1, sp, #240	; 0xf0
   b63f0:	a81e      	add	r0, sp, #120	; 0x78
   b63f2:	f7ff fed9 	bl	b61a8 <_ZNSt6vectorI6StringSaIS0_EE12emplace_backIJS0_EEERS0_DpOT_.isra.0>
   b63f6:	a83c      	add	r0, sp, #240	; 0xf0
   b63f8:	f004 f976 	bl	ba6e8 <_ZN6StringD1Ev>
    sentryToggle.MethodPointer = &WaterBot::driveMode;      //Modify the driveMode variable in the wateer bot object for the selected bot when pressing left or right button
   b63fc:	230e      	movs	r3, #14
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b63fe:	4940      	ldr	r1, [pc, #256]	; (b6500 <_Z10createMenuv+0x1dc>)
    sentryToggle.MethodPointer = &WaterBot::driveMode;      //Modify the driveMode variable in the wateer bot object for the selected bot when pressing left or right button
   b6400:	9321      	str	r3, [sp, #132]	; 0x84
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6402:	f10d 00be 	add.w	r0, sp, #190	; 0xbe
	: _M_start(), _M_finish(), _M_end_of_storage()
   b6406:	e9cd 4428 	strd	r4, r4, [sp, #160]	; 0xa0
   b640a:	942a      	str	r4, [sp, #168]	; 0xa8
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b640c:	f8ad 40ba 	strh.w	r4, [sp, #186]	; 0xba
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6410:	f8ad 50bc 	strh.w	r5, [sp, #188]	; 0xbc
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6414:	f008 fdc1 	bl	bef9a <strcpy>
    signalToggle.MethodPointerBool = &WaterBot::signal;     //Modify the signal variable in the water bot object for the selected bot when pressing the left or right object
   b6418:	2310      	movs	r3, #16
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b641a:	e9cd 362c 	strd	r3, r6, [sp, #176]	; 0xb0
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b641e:	4939      	ldr	r1, [pc, #228]	; (b6504 <_Z10createMenuv+0x1e0>)
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b6420:	f88d 40b8 	strb.w	r4, [sp, #184]	; 0xb8
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6424:	f240 36e7 	movw	r6, #999	; 0x3e7
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6428:	f10d 00e6 	add.w	r0, sp, #230	; 0xe6
   b642c:	e9cd 4432 	strd	r4, r4, [sp, #200]	; 0xc8
   b6430:	9434      	str	r4, [sp, #208]	; 0xd0
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b6432:	f8ad 40e2 	strh.w	r4, [sp, #226]	; 0xe2
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b6436:	f8ad 60e4 	strh.w	r6, [sp, #228]	; 0xe4
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b643a:	f008 fdae 	bl	bef9a <strcpy>
   b643e:	e9cd 443c 	strd	r4, r4, [sp, #240]	; 0xf0
   b6442:	943e      	str	r4, [sp, #248]	; 0xf8
            minVal = minV;                      //Minimum value to decrement to when pressing the left button
   b6444:	f8ad 410a 	strh.w	r4, [sp, #266]	; 0x10a
    MenuItems.push_back(dataRecord);                        //Push all the generated menu items into the menu items vector and they will be automatically printed by the menu function
   b6448:	4c2f      	ldr	r4, [pc, #188]	; (b6508 <_Z10createMenuv+0x1e4>)
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b644a:	4930      	ldr	r1, [pc, #192]	; (b650c <_Z10createMenuv+0x1e8>)
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b644c:	9537      	str	r5, [sp, #220]	; 0xdc
    solStat.MethodPointer = &WaterBot::panelPower;          //Source data from the panelPower variable for the selected bot
   b644e:	2340      	movs	r3, #64	; 0x40
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b6450:	f50d 7087 	add.w	r0, sp, #270	; 0x10e
    solStat.MethodPointer = &WaterBot::panelPower;          //Source data from the panelPower variable for the selected bot
   b6454:	9335      	str	r3, [sp, #212]	; 0xd4
    solStat.statOnly = true;                                //Only a statistic, not modifiable
   b6456:	f88d 50e0 	strb.w	r5, [sp, #224]	; 0xe0
            maxVal = maxV;                      //Maximum value to increment to when pressing the right button
   b645a:	f8ad 610c 	strh.w	r6, [sp, #268]	; 0x10c
            strcpy(itemName,itemString);        //Copy in the string displayed as the label of the menu item liike "Signal" or "Battery"
   b645e:	f008 fd9c 	bl	bef9a <strcpy>
    battPwr.MethodPointer = &WaterBot::battPower;           //Source data from the battPower variable for the selected bot
   b6462:	2342      	movs	r3, #66	; 0x42
    MenuItems.push_back(dataRecord);                        //Push all the generated menu items into the menu items vector and they will be automatically printed by the menu function
   b6464:	4669      	mov	r1, sp
   b6466:	4620      	mov	r0, r4
    battPwr.MethodPointer = &WaterBot::battPower;           //Source data from the battPower variable for the selected bot
   b6468:	933f      	str	r3, [sp, #252]	; 0xfc
            stepSize = inStep;                  //Number of values to step up or down by when pressing left or right button
   b646a:	9541      	str	r5, [sp, #260]	; 0x104
    battPwr.statOnly = true;                                //Only a statistic, not modifiable
   b646c:	f88d 5108 	strb.w	r5, [sp, #264]	; 0x108
    MenuItems.push_back(dataRecord);                        //Push all the generated menu items into the menu items vector and they will be automatically printed by the menu function
   b6470:	f7ff ff44 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(battStat);
   b6474:	a90a      	add	r1, sp, #40	; 0x28
   b6476:	4620      	mov	r0, r4
   b6478:	f7ff ff40 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(sentryToggle);
   b647c:	a91e      	add	r1, sp, #120	; 0x78
   b647e:	4620      	mov	r0, r4
   b6480:	f7ff ff3c 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(offloadItem);
   b6484:	a914      	add	r1, sp, #80	; 0x50
   b6486:	4620      	mov	r0, r4
   b6488:	f7ff ff38 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(signalToggle);
   b648c:	a928      	add	r1, sp, #160	; 0xa0
   b648e:	4620      	mov	r0, r4
   b6490:	f7ff ff34 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(solStat);
   b6494:	a932      	add	r1, sp, #200	; 0xc8
   b6496:	4620      	mov	r0, r4
   b6498:	f7ff ff30 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    MenuItems.push_back(battPwr);
   b649c:	a93c      	add	r1, sp, #240	; 0xf0
   b649e:	4620      	mov	r0, r4
   b64a0:	f7ff ff2c 	bl	b62fc <_ZNSt6vectorI8MenuItemSaIS0_EE9push_backERKS0_>
    SelectedItem = &MenuItems.at(menuItem);                 //Select the first menu item
   b64a4:	4b1a      	ldr	r3, [pc, #104]	; (b6510 <_Z10createMenuv+0x1ec>)
   b64a6:	4620      	mov	r0, r4
   b64a8:	7819      	ldrb	r1, [r3, #0]
   b64aa:	f7fe fdf9 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b64ae:	4b19      	ldr	r3, [pc, #100]	; (b6514 <_Z10createMenuv+0x1f0>)
   b64b0:	6018      	str	r0, [r3, #0]
class MenuItem{                                 //Class for displaying menu on the mini OLED. Can have different label types. Takes a pointer to a variable type in the WaterBot class
   b64b2:	a83c      	add	r0, sp, #240	; 0xf0
   b64b4:	f7fe fe64 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64b8:	a832      	add	r0, sp, #200	; 0xc8
   b64ba:	f7fe fe61 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64be:	a828      	add	r0, sp, #160	; 0xa0
   b64c0:	f7fe fe5e 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64c4:	a81e      	add	r0, sp, #120	; 0x78
   b64c6:	f7fe fe5b 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64ca:	a814      	add	r0, sp, #80	; 0x50
   b64cc:	f7fe fe58 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64d0:	a80a      	add	r0, sp, #40	; 0x28
   b64d2:	f7fe fe55 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
   b64d6:	4668      	mov	r0, sp
   b64d8:	f7fe fe52 	bl	b5180 <_ZNSt6vectorI6StringSaIS0_EED1Ev>
}
   b64dc:	b046      	add	sp, #280	; 0x118
   b64de:	bd70      	pop	{r4, r5, r6, pc}
   b64e0:	000c12be 	.word	0x000c12be
   b64e4:	000c12c5 	.word	0x000c12c5
   b64e8:	000c12cd 	.word	0x000c12cd
   b64ec:	000c12d5 	.word	0x000c12d5
   b64f0:	01000001 	.word	0x01000001
   b64f4:	000c12dc 	.word	0x000c12dc
   b64f8:	000c12e0 	.word	0x000c12e0
   b64fc:	000c12e4 	.word	0x000c12e4
   b6500:	000c12e8 	.word	0x000c12e8
   b6504:	000c12ef 	.word	0x000c12ef
   b6508:	2003dcac 	.word	0x2003dcac
   b650c:	000c12f6 	.word	0x000c12f6
   b6510:	2003de05 	.word	0x2003de05
   b6514:	2003dcd4 	.word	0x2003dcd4

000b6518 <_GLOBAL__sub_I_SystemMode>:
   b6518:	b570      	push	{r4, r5, r6, lr}
        val_(val) {
   b651a:	4b63      	ldr	r3, [pc, #396]	; (b66a8 <_GLOBAL__sub_I_SystemMode+0x190>)
   b651c:	4c63      	ldr	r4, [pc, #396]	; (b66ac <_GLOBAL__sub_I_SystemMode+0x194>)
   b651e:	2201      	movs	r2, #1
   b6520:	701a      	strb	r2, [r3, #0]

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   b6522:	4b63      	ldr	r3, [pc, #396]	; (b66b0 <_GLOBAL__sub_I_SystemMode+0x198>)
   b6524:	2200      	movs	r2, #0
   b6526:	e9c3 2200 	strd	r2, r2, [r3]
    SleepResult() {}
   b652a:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
   b652e:	b08a      	sub	sp, #40	; 0x28
   b6530:	609a      	str	r2, [r3, #8]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   b6532:	2002      	movs	r0, #2
   b6534:	f003 fe7e 	bl	ba234 <set_system_mode>
const BleUuid serviceUuid("b4206910-dc4b-5743-c8b1-92d0e75182b0");
   b6538:	495e      	ldr	r1, [pc, #376]	; (b66b4 <_GLOBAL__sub_I_SystemMode+0x19c>)
   b653a:	485f      	ldr	r0, [pc, #380]	; (b66b8 <_GLOBAL__sub_I_SystemMode+0x1a0>)
   b653c:	f004 fc30 	bl	bada0 <_ZN8particle7BleUuidC1EPKc>
const BleUuid rxUuid("b4206912-dc4b-5743-c8b1-92d0e75182b0");
   b6540:	495e      	ldr	r1, [pc, #376]	; (b66bc <_GLOBAL__sub_I_SystemMode+0x1a4>)
   b6542:	485f      	ldr	r0, [pc, #380]	; (b66c0 <_GLOBAL__sub_I_SystemMode+0x1a8>)
   b6544:	f004 fc2c 	bl	bada0 <_ZN8particle7BleUuidC1EPKc>
const BleUuid txUuid("b4206913-dc4b-5743-c8b1-92d0e75182b0");
   b6548:	495e      	ldr	r1, [pc, #376]	; (b66c4 <_GLOBAL__sub_I_SystemMode+0x1ac>)
   b654a:	485f      	ldr	r0, [pc, #380]	; (b66c8 <_GLOBAL__sub_I_SystemMode+0x1b0>)
   b654c:	f004 fc28 	bl	bada0 <_ZN8particle7BleUuidC1EPKc>
const BleUuid offldUuid("b4206914-dc4b-5743-c8b1-92d0e75182b0");
   b6550:	495e      	ldr	r1, [pc, #376]	; (b66cc <_GLOBAL__sub_I_SystemMode+0x1b4>)
   b6552:	485f      	ldr	r0, [pc, #380]	; (b66d0 <_GLOBAL__sub_I_SystemMode+0x1b8>)
   b6554:	f004 fc24 	bl	bada0 <_ZN8particle7BleUuidC1EPKc>
   b6558:	2514      	movs	r5, #20
            : rssi_(BLE_RSSI_INVALID) {
   b655a:	267f      	movs	r6, #127	; 0x7f
   b655c:	4620      	mov	r0, r4
   b655e:	f004 fb3a 	bl	babd6 <_ZN8particle10BleAddressC1Ev>
   b6562:	f104 0008 	add.w	r0, r4, #8
   b6566:	f005 fb66 	bl	bbc36 <_ZN8particle18BleAdvertisingDataC1Ev>
   b656a:	f104 0014 	add.w	r0, r4, #20
   b656e:	f005 fb62 	bl	bbc36 <_ZN8particle18BleAdvertisingDataC1Ev>
BleScanResult scanResults[SCAN_RESULT_COUNT];
   b6572:	3d01      	subs	r5, #1
   b6574:	f884 6020 	strb.w	r6, [r4, #32]
   b6578:	f104 0424 	add.w	r4, r4, #36	; 0x24
   b657c:	d1ee      	bne.n	b655c <_GLOBAL__sub_I_SystemMode+0x44>
BleCharacteristic peerTxCharacteristic;         //Characteristic to receive data from the bot
   b657e:	4855      	ldr	r0, [pc, #340]	; (b66d4 <_GLOBAL__sub_I_SystemMode+0x1bc>)

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   b6580:	4c55      	ldr	r4, [pc, #340]	; (b66d8 <_GLOBAL__sub_I_SystemMode+0x1c0>)
   b6582:	f004 fd43 	bl	bb00c <_ZN8particle17BleCharacteristicC1Ev>
BleCharacteristic peerRxCharacteristic;         //Characteristic to send data too the bot
   b6586:	4855      	ldr	r0, [pc, #340]	; (b66dc <_GLOBAL__sub_I_SystemMode+0x1c4>)
   b6588:	f004 fd40 	bl	bb00c <_ZN8particle17BleCharacteristicC1Ev>
BleCharacteristic peerOffloadCharacteristic;    //Characteristic to receive SD card data from bot
   b658c:	4854      	ldr	r0, [pc, #336]	; (b66e0 <_GLOBAL__sub_I_SystemMode+0x1c8>)
   b658e:	f004 fd3d 	bl	bb00c <_ZN8particle17BleCharacteristicC1Ev>
BlePeerDevice peer;                             //Bluetooth peer device that is currently connected
   b6592:	4854      	ldr	r0, [pc, #336]	; (b66e4 <_GLOBAL__sub_I_SystemMode+0x1cc>)
   b6594:	f004 fe16 	bl	bb1c4 <_ZN8particle13BlePeerDeviceC1Ev>
Adafruit_SH1107 oled = Adafruit_SH1107(64, 128, &Wire, OLED_RESET);
   b6598:	f007 fd94 	bl	be0c4 <_Z19__fetch_global_Wirev>
   b659c:	4a52      	ldr	r2, [pc, #328]	; (b66e8 <_GLOBAL__sub_I_SystemMode+0x1d0>)
   b659e:	4953      	ldr	r1, [pc, #332]	; (b66ec <_GLOBAL__sub_I_SystemMode+0x1d4>)
   b65a0:	e9cd 2101 	strd	r2, r1, [sp, #4]
   b65a4:	2213      	movs	r2, #19
   b65a6:	4603      	mov	r3, r0
   b65a8:	9200      	str	r2, [sp, #0]
   b65aa:	4851      	ldr	r0, [pc, #324]	; (b66f0 <_GLOBAL__sub_I_SystemMode+0x1d8>)
   b65ac:	2280      	movs	r2, #128	; 0x80
   b65ae:	2140      	movs	r1, #64	; 0x40
   b65b0:	f003 faf8 	bl	b9ba4 <_ZN15Adafruit_SH1107C1EttP7TwoWireamm>
   b65b4:	7823      	ldrb	r3, [r4, #0]
   b65b6:	f3bf 8f5b 	dmb	ish
   b65ba:	07d8      	lsls	r0, r3, #31
   b65bc:	d40a      	bmi.n	b65d4 <_GLOBAL__sub_I_SystemMode+0xbc>
   b65be:	4620      	mov	r0, r4
   b65c0:	f7fd fd7c 	bl	b40bc <__cxa_guard_acquire>
   b65c4:	b130      	cbz	r0, b65d4 <_GLOBAL__sub_I_SystemMode+0xbc>
   b65c6:	484b      	ldr	r0, [pc, #300]	; (b66f4 <_GLOBAL__sub_I_SystemMode+0x1dc>)
   b65c8:	2101      	movs	r1, #1
   b65ca:	f003 ffbb 	bl	ba544 <_ZN8SPIClassC1E19hal_spi_interface_t>
   b65ce:	4620      	mov	r0, r4
   b65d0:	f7fd fd79 	bl	b40c6 <__cxa_guard_release>
  explicit SdFat(SPIClass* spiPort) {
   b65d4:	4b48      	ldr	r3, [pc, #288]	; (b66f8 <_GLOBAL__sub_I_SystemMode+0x1e0>)
   b65d6:	2264      	movs	r2, #100	; 0x64
   b65d8:	f8c3 2460 	str.w	r2, [r3, #1120]	; 0x460
  {
   b65dc:	4a47      	ldr	r2, [pc, #284]	; (b66fc <_GLOBAL__sub_I_SystemMode+0x1e4>)
   b65de:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
   b65e2:	2201      	movs	r2, #1
   b65e4:	2400      	movs	r4, #0
   b65e6:	f883 2474 	strb.w	r2, [r3, #1140]	; 0x474
#if IMPLEMENT_SPI_PORT_SELECTION || defined(DOXYGEN)
  /** Set SPI port number.
   * \param[in] spiPort Hardware SPI port.
   */
  void setPort(SPIClass* spiPort) {
    m_spi = spiPort ? spiPort : &SDCARD_SPI;
   b65ea:	4a42      	ldr	r2, [pc, #264]	; (b66f4 <_GLOBAL__sub_I_SystemMode+0x1dc>)
   b65ec:	605c      	str	r4, [r3, #4]
   b65ee:	f8c3 443c 	str.w	r4, [r3, #1084]	; 0x43c
   b65f2:	f8c3 4468 	str.w	r4, [r3, #1128]	; 0x468
   b65f6:	f8c3 4478 	str.w	r4, [r3, #1144]	; 0x478
   b65fa:	f8a3 447c 	strh.w	r4, [r3, #1148]	; 0x47c
   b65fe:	f8c3 246c 	str.w	r2, [r3, #1132]	; 0x46c
    Print() : write_error(0) {}
   b6602:	4b3f      	ldr	r3, [pc, #252]	; (b6700 <_GLOBAL__sub_I_SystemMode+0x1e8>)
  File() {}
   b6604:	4a3f      	ldr	r2, [pc, #252]	; (b6704 <_GLOBAL__sub_I_SystemMode+0x1ec>)
   b6606:	605c      	str	r4, [r3, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   b6608:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   b660c:	601a      	str	r2, [r3, #0]
   b660e:	6099      	str	r1, [r3, #8]
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b6610:	611c      	str	r4, [r3, #16]
   b6612:	4b3d      	ldr	r3, [pc, #244]	; (b6708 <_GLOBAL__sub_I_SystemMode+0x1f0>)
   b6614:	e9c3 4101 	strd	r4, r1, [r3, #4]
   b6618:	601a      	str	r2, [r3, #0]
   b661a:	611c      	str	r4, [r3, #16]
   b661c:	4b3b      	ldr	r3, [pc, #236]	; (b670c <_GLOBAL__sub_I_SystemMode+0x1f4>)
   b661e:	e9c3 4101 	strd	r4, r1, [r3, #4]
   b6622:	601a      	str	r2, [r3, #0]
   b6624:	611c      	str	r4, [r3, #16]
   b6626:	4b3a      	ldr	r3, [pc, #232]	; (b6710 <_GLOBAL__sub_I_SystemMode+0x1f8>)
    Timer(unsigned period, timer_callback_fn callback_, bool one_shot=false) : running(false), handle(nullptr), callback(std::move(callback_)) {
   b6628:	4a3a      	ldr	r2, [pc, #232]	; (b6714 <_GLOBAL__sub_I_SystemMode+0x1fc>)
   b662a:	609c      	str	r4, [r3, #8]
   b662c:	e9c3 4400 	strd	r4, r4, [r3]
   b6630:	4b39      	ldr	r3, [pc, #228]	; (b6718 <_GLOBAL__sub_I_SystemMode+0x200>)
   b6632:	e9c3 4400 	strd	r4, r4, [r3]
   b6636:	609c      	str	r4, [r3, #8]
   b6638:	4b38      	ldr	r3, [pc, #224]	; (b671c <_GLOBAL__sub_I_SystemMode+0x204>)
   b663a:	e9c3 4400 	strd	r4, r4, [r3]
   b663e:	609c      	str	r4, [r3, #8]
   b6640:	4b37      	ldr	r3, [pc, #220]	; (b6720 <_GLOBAL__sub_I_SystemMode+0x208>)
   b6642:	e9c3 4400 	strd	r4, r4, [r3]
   b6646:	609c      	str	r4, [r3, #8]
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
   b6648:	4b36      	ldr	r3, [pc, #216]	; (b6724 <_GLOBAL__sub_I_SystemMode+0x20c>)
   b664a:	9306      	str	r3, [sp, #24]
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b664c:	ad06      	add	r5, sp, #24
   b664e:	4b36      	ldr	r3, [pc, #216]	; (b6728 <_GLOBAL__sub_I_SystemMode+0x210>)
   b6650:	e895 0003 	ldmia.w	r5, {r0, r1}
   b6654:	601a      	str	r2, [r3, #0]
   b6656:	ae04      	add	r6, sp, #16
      __a = _GLIBCXX_MOVE(__b);
   b6658:	f103 020c 	add.w	r2, r3, #12
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   b665c:	e886 0003 	stmia.w	r6, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
   b6660:	e892 0003 	ldmia.w	r2, {r0, r1}
   b6664:	e885 0003 	stmia.w	r5, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
   b6668:	e896 0003 	ldmia.w	r6, {r0, r1}
   b666c:	e882 0003 	stmia.w	r2, {r0, r1}
   b6670:	4a2e      	ldr	r2, [pc, #184]	; (b672c <_GLOBAL__sub_I_SystemMode+0x214>)
   b6672:	615a      	str	r2, [r3, #20]
      __a = _GLIBCXX_MOVE(__b);
   b6674:	699a      	ldr	r2, [r3, #24]
   b6676:	9209      	str	r2, [sp, #36]	; 0x24
      __b = _GLIBCXX_MOVE(__tmp);
   b6678:	4a2d      	ldr	r2, [pc, #180]	; (b6730 <_GLOBAL__sub_I_SystemMode+0x218>)
   b667a:	711c      	strb	r4, [r3, #4]
   b667c:	609c      	str	r4, [r3, #8]
   b667e:	619a      	str	r2, [r3, #24]
        os_timer_create(&handle, period, invoke_timer, this, one_shot, nullptr);
   b6680:	f241 3188 	movw	r1, #5000	; 0x1388
   b6684:	4a2b      	ldr	r2, [pc, #172]	; (b6734 <_GLOBAL__sub_I_SystemMode+0x21c>)
      __a = _GLIBCXX_MOVE(__b);
   b6686:	9408      	str	r4, [sp, #32]
   b6688:	f103 0008 	add.w	r0, r3, #8
   b668c:	e9cd 4400 	strd	r4, r4, [sp]
   b6690:	f003 fc48 	bl	b9f24 <os_timer_create>
    class function<_Res(_ArgTypes...)>
   b6694:	4628      	mov	r0, r5
   b6696:	f7fd fee3 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   b669a:	4b27      	ldr	r3, [pc, #156]	; (b6738 <_GLOBAL__sub_I_SystemMode+0x220>)
   b669c:	e9c3 4400 	strd	r4, r4, [r3]
   b66a0:	609c      	str	r4, [r3, #8]
   b66a2:	b00a      	add	sp, #40	; 0x28
   b66a4:	bd70      	pop	{r4, r5, r6, pc}
   b66a6:	bf00      	nop
   b66a8:	2003dd2c 	.word	0x2003dd2c
   b66ac:	2003dedc 	.word	0x2003dedc
   b66b0:	2003dcd8 	.word	0x2003dcd8
   b66b4:	000c12fd 	.word	0x000c12fd
   b66b8:	2003dcf0 	.word	0x2003dcf0
   b66bc:	000c1322 	.word	0x000c1322
   b66c0:	2003dd04 	.word	0x2003dd04
   b66c4:	000c1347 	.word	0x000c1347
   b66c8:	2003dd18 	.word	0x2003dd18
   b66cc:	000c136c 	.word	0x000c136c
   b66d0:	2003dd30 	.word	0x2003dd30
   b66d4:	2003decc 	.word	0x2003decc
   b66d8:	2003dc88 	.word	0x2003dc88
   b66dc:	2003dec4 	.word	0x2003dec4
   b66e0:	2003debc 	.word	0x2003debc
   b66e4:	2003deb4 	.word	0x2003deb4
   b66e8:	00061a80 	.word	0x00061a80
   b66ec:	000186a0 	.word	0x000186a0
   b66f0:	2003de5c 	.word	0x2003de5c
   b66f4:	2003dc8c 	.word	0x2003dc8c
   b66f8:	2003e1ac 	.word	0x2003e1ac
   b66fc:	000c1418 	.word	0x000c1418
   b6700:	2003de08 	.word	0x2003de08
   b6704:	000c1440 	.word	0x000c1440
   b6708:	2003ddd0 	.word	0x2003ddd0
   b670c:	2003dd9c 	.word	0x2003dd9c
   b6710:	2003dce4 	.word	0x2003dce4
   b6714:	000c142c 	.word	0x000c142c
   b6718:	2003dcb8 	.word	0x2003dcb8
   b671c:	2003dc98 	.word	0x2003dc98
   b6720:	2003dcc4 	.word	0x2003dcc4
   b6724:	000b40e9 	.word	0x000b40e9
   b6728:	2003dd48 	.word	0x2003dd48
   b672c:	000b43bd 	.word	0x000b43bd
   b6730:	000b43d1 	.word	0x000b43d1
   b6734:	000b4185 	.word	0x000b4185
   b6738:	2003dcac 	.word	0x2003dcac

000b673c <_Z11startupPairv>:
void startupPair(){                                             //Function to run on startup to display how many bots have been discovered and wait until at least on is discovered
   b673c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    oled.clearDisplay();                                        //Empty the display for the new startup item
   b6740:	4d3b      	ldr	r5, [pc, #236]	; (b6830 <_Z11startupPairv+0xf4>)
    startConnect = false;                                       //Flag set true while scanning for bots, cleared upon bluetooth connection or a 
   b6742:	f8df 8108 	ldr.w	r8, [pc, #264]	; b684c <_Z11startupPairv+0x110>
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   b6746:	4e3b      	ldr	r6, [pc, #236]	; (b6834 <_Z11startupPairv+0xf8>)
   b6748:	2400      	movs	r4, #0
    oled.clearDisplay();                                        //Empty the display for the new startup item
   b674a:	4628      	mov	r0, r5
    startConnect = false;                                       //Flag set true while scanning for bots, cleared upon bluetooth connection or a 
   b674c:	f888 4000 	strb.w	r4, [r8]
    oled.clearDisplay();                                        //Empty the display for the new startup item
   b6750:	f000 fe3c 	bl	b73cc <_ZN17Adafruit_GrayOLED12clearDisplayEv>
    oled.print("Scanning ");
   b6754:	4938      	ldr	r1, [pc, #224]	; (b6838 <_Z11startupPairv+0xfc>)
    @brief  Set text cursor location
    @param  x    X coordinate in pixels
    @param  y    Y coordinate in pixels
  */
  /**********************************************************************/
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6756:	612c      	str	r4, [r5, #16]
   b6758:	4628      	mov	r0, r5
   b675a:	f006 fc11 	bl	bcf80 <_ZN5Print5printEPKc>
    oled.fillCircle(115,7,3,SH110X_WHITE);                      //Fill initial circle for animation
   b675e:	2301      	movs	r3, #1
   b6760:	9300      	str	r3, [sp, #0]
   b6762:	2207      	movs	r2, #7
   b6764:	2303      	movs	r3, #3
   b6766:	2173      	movs	r1, #115	; 0x73
   b6768:	4628      	mov	r0, r5
   b676a:	f001 f9bc 	bl	b7ae6 <_ZN12Adafruit_GFX10fillCircleEssst>
    oled.display();
   b676e:	4628      	mov	r0, r5
   b6770:	f003 f936 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
    while(!startConnect){                                       //Loop until bots are found. Wait for user to press the enter button
   b6774:	f898 7000 	ldrb.w	r7, [r8]
   b6778:	2f00      	cmp	r7, #0
   b677a:	d156      	bne.n	b682a <_Z11startupPairv+0xee>
   b677c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   b6780:	612b      	str	r3, [r5, #16]
        oled.fillRect(72,16,35,15,0);
   b6782:	230f      	movs	r3, #15
   b6784:	9300      	str	r3, [sp, #0]
   b6786:	2210      	movs	r2, #16
   b6788:	2323      	movs	r3, #35	; 0x23
   b678a:	2148      	movs	r1, #72	; 0x48
   b678c:	4628      	mov	r0, r5
   b678e:	9701      	str	r7, [sp, #4]
   b6790:	f000 ff6f 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
   b6794:	e9d6 3200 	ldrd	r3, r2, [r6]
   b6798:	1ad2      	subs	r2, r2, r3
        oled.printlnf("Bots: %d",WaterBots.size());             //Notify user of how many bots have been discovered
   b679a:	4b28      	ldr	r3, [pc, #160]	; (b683c <_Z11startupPairv+0x100>)
   b679c:	4928      	ldr	r1, [pc, #160]	; (b6840 <_Z11startupPairv+0x104>)
   b679e:	1112      	asrs	r2, r2, #4
   b67a0:	435a      	muls	r2, r3
   b67a2:	4628      	mov	r0, r5
   b67a4:	f7fd fe4e 	bl	b4444 <_ZN5Print8printlnfEPKcz>
        oled.drawCircle(115,7,loadAnim,SH110X_WHITE);           //Draw the circle with varying circle radius for animation
   b67a8:	2301      	movs	r3, #1
   b67aa:	9300      	str	r3, [sp, #0]
   b67ac:	2207      	movs	r2, #7
   b67ae:	4623      	mov	r3, r4
   b67b0:	2173      	movs	r1, #115	; 0x73
   b67b2:	4628      	mov	r0, r5
   b67b4:	f001 f836 	bl	b7824 <_ZN12Adafruit_GFX10drawCircleEssst>
        if(loadAnim-1) oled.fillCircle(115,7,loadAnim-1,0);     //Erase the previous circle
   b67b8:	2c01      	cmp	r4, #1
   b67ba:	d006      	beq.n	b67ca <_Z11startupPairv+0x8e>
   b67bc:	9700      	str	r7, [sp, #0]
   b67be:	1e63      	subs	r3, r4, #1
   b67c0:	2207      	movs	r2, #7
   b67c2:	2173      	movs	r1, #115	; 0x73
   b67c4:	4628      	mov	r0, r5
   b67c6:	f001 f98e 	bl	b7ae6 <_ZN12Adafruit_GFX10fillCircleEssst>
        loadAnim++;                                             //Increment the counter so the next loop displays the circle
   b67ca:	3401      	adds	r4, #1
        oled.display();                                         //Display the animated circle
   b67cc:	4628      	mov	r0, r5
        loadAnim++;                                             //Increment the counter so the next loop displays the circle
   b67ce:	b2e4      	uxtb	r4, r4
        oled.display();                                         //Display the animated circle
   b67d0:	f003 f906 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
        if(loadAnim > 7){                                       //Loop back to center for animation
   b67d4:	2c07      	cmp	r4, #7
   b67d6:	d907      	bls.n	b67e8 <_Z11startupPairv+0xac>
            oled.drawCircle(115,7,7,0);                         //Erase last circle
   b67d8:	2400      	movs	r4, #0
   b67da:	2307      	movs	r3, #7
   b67dc:	9400      	str	r4, [sp, #0]
   b67de:	461a      	mov	r2, r3
   b67e0:	2173      	movs	r1, #115	; 0x73
   b67e2:	4628      	mov	r0, r5
   b67e4:	f001 f81e 	bl	b7824 <_ZN12Adafruit_GFX10drawCircleEssst>
        XBeeHandler();                                          //Check XBee radio for hello world message received from bot
   b67e8:	f7ff f9d2 	bl	b5b90 <_Z11XBeeHandlerv>
        XBeeLTEPairSet();                                       //Add XBee and LTE discovered bots to the Pair Bot vector
   b67ec:	f7fe fb50 	bl	b4e90 <_Z14XBeeLTEPairSetv>
        delay(50);
   b67f0:	2032      	movs	r0, #50	; 0x32
   b67f2:	f006 fd31 	bl	bd258 <delay>
        if(digitalRead(E_DPAD) == HIGH && WaterBots.size() > 0){    //When the enter button is pressed, check if there are any discovered bots. Continue to main program if there are discovered bots
   b67f6:	201c      	movs	r0, #28
   b67f8:	f007 fbe2 	bl	bdfc0 <digitalRead>
   b67fc:	2801      	cmp	r0, #1
   b67fe:	4607      	mov	r7, r0
   b6800:	d1b8      	bne.n	b6774 <_Z11startupPairv+0x38>
   b6802:	e9d6 3200 	ldrd	r3, r2, [r6]
   b6806:	429a      	cmp	r2, r3
   b6808:	d0b4      	beq.n	b6774 <_Z11startupPairv+0x38>
            botSelect = WaterBots.at(0).botNum;                     //Update bot select to select the first-found bot on the list
   b680a:	2100      	movs	r1, #0
   b680c:	4630      	mov	r0, r6
   b680e:	f7fe fb6b 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6812:	4b0c      	ldr	r3, [pc, #48]	; (b6844 <_Z11startupPairv+0x108>)
   b6814:	7882      	ldrb	r2, [r0, #2]
   b6816:	701a      	strb	r2, [r3, #0]
            oled.clearDisplay();
   b6818:	4628      	mov	r0, r5
   b681a:	f000 fdd7 	bl	b73cc <_ZN17Adafruit_GrayOLED12clearDisplayEv>
            oled.display();
   b681e:	4628      	mov	r0, r5
   b6820:	f003 f8de 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
            selectingBots = true;                                   //By default, we are choosing bots, not modifying a menu item
   b6824:	4b08      	ldr	r3, [pc, #32]	; (b6848 <_Z11startupPairv+0x10c>)
   b6826:	701f      	strb	r7, [r3, #0]
   b6828:	e7a4      	b.n	b6774 <_Z11startupPairv+0x38>
}
   b682a:	b002      	add	sp, #8
   b682c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   b6830:	2003de5c 	.word	0x2003de5c
   b6834:	2003dce4 	.word	0x2003dce4
   b6838:	000c1391 	.word	0x000c1391
   b683c:	cccccccd 	.word	0xcccccccd
   b6840:	000c139b 	.word	0x000c139b
   b6844:	2003dd64 	.word	0x2003dd64
   b6848:	2003daab 	.word	0x2003daab
   b684c:	2003e630 	.word	0x2003e630

000b6850 <_Z13printMenuItemhbbtt8WaterBot>:
void printMenuItem(uint8_t id, bool highlighted, bool selected, uint16_t x, uint16_t y, WaterBot wb){
   b6850:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   b6854:	f8bd 5030 	ldrh.w	r5, [sp, #48]	; 0x30
   b6858:	4c4e      	ldr	r4, [pc, #312]	; (b6994 <_Z13printMenuItemhbbtt8WaterBot+0x144>)
   b685a:	460f      	mov	r7, r1
        oled.setCursor(x+1,y+1);                                //Set cursor for text
   b685c:	3501      	adds	r5, #1
        oled.fillRect(x,y,OLED_MAX_X - 40,16,1);                //Draw white rectangle, then write black text to show "highlighted" state
   b685e:	b219      	sxth	r1, r3
        oled.setCursor(x+1,y+1);                                //Set cursor for text
   b6860:	3301      	adds	r3, #1
void printMenuItem(uint8_t id, bool highlighted, bool selected, uint16_t x, uint16_t y, WaterBot wb){
   b6862:	4690      	mov	r8, r2
   b6864:	4606      	mov	r6, r0
        oled.fillRect(x,y,OLED_MAX_X - 40,16,1);                //Draw white rectangle, then write black text to show "highlighted" state
   b6866:	f9bd 2030 	ldrsh.w	r2, [sp, #48]	; 0x30
        oled.setCursor(x+1,y+1);                                //Set cursor for text
   b686a:	fa0f f983 	sxth.w	r9, r3
   b686e:	b22d      	sxth	r5, r5
   b6870:	f04f 0a10 	mov.w	sl, #16
    if(highlighted){                                            //Check if this menu item should be highlighted
   b6874:	2f00      	cmp	r7, #0
   b6876:	d052      	beq.n	b691e <_Z13printMenuItemhbbtt8WaterBot+0xce>
        oled.fillRect(x,y,OLED_MAX_X - 40,16,1);                //Draw white rectangle, then write black text to show "highlighted" state
   b6878:	2701      	movs	r7, #1
   b687a:	2358      	movs	r3, #88	; 0x58
   b687c:	4620      	mov	r0, r4
   b687e:	e9cd a700 	strd	sl, r7, [sp]
   b6882:	9203      	str	r2, [sp, #12]
   b6884:	f000 fef5 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
        oled.setTextSize(2);                                    //Set size to 2 for standard menu items
   b6888:	2102      	movs	r1, #2
   b688a:	4620      	mov	r0, r4
   b688c:	f8a4 9010 	strh.w	r9, [r4, #16]
   b6890:	8265      	strh	r5, [r4, #18]
    @param   c   16-bit 5-6-5 Color to draw text with
    @note    For 'transparent' background, background and foreground
             are set to same color rather than using a separate flag.
  */
  /**********************************************************************/
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6892:	f04f 0900 	mov.w	r9, #0
   b6896:	f001 fb94 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
        oled.print(MenuItems.at(id).itemName);                  //Print out the name associated with the menu item at the "id" location in the menu vector
   b689a:	4631      	mov	r1, r6
   b689c:	483e      	ldr	r0, [pc, #248]	; (b6998 <_Z13printMenuItemhbbtt8WaterBot+0x148>)
   b689e:	f8c4 9014 	str.w	r9, [r4, #20]
   b68a2:	f7fe fbfd 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b68a6:	f100 011e 	add.w	r1, r0, #30
   b68aa:	4620      	mov	r0, r4
   b68ac:	f006 fb68 	bl	bcf80 <_ZN5Print5printEPKc>
        if(selected){                                           //If this item is selected, then draw box to indicate to the user
   b68b0:	9a03      	ldr	r2, [sp, #12]
   b68b2:	f1b8 0f00 	cmp.w	r8, #0
   b68b6:	d024      	beq.n	b6902 <_Z13printMenuItemhbbtt8WaterBot+0xb2>
            oled.fillRect(OLED_MAX_X - 40,y,OLED_MAX_X-1,16,1); //Fill area with white rectangle 
   b68b8:	237f      	movs	r3, #127	; 0x7f
   b68ba:	e9cd a700 	strd	sl, r7, [sp]
   b68be:	2158      	movs	r1, #88	; 0x58
   b68c0:	4620      	mov	r0, r4
   b68c2:	f000 fed6 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b68c6:	2359      	movs	r3, #89	; 0x59
   b68c8:	8223      	strh	r3, [r4, #16]
   b68ca:	8265      	strh	r5, [r4, #18]
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b68cc:	f8c4 9014 	str.w	r9, [r4, #20]
            if(MenuItems.at(id).onOffSetting){                  //Determine where to source the label for the value, when true, display "On" or "Off"
   b68d0:	4831      	ldr	r0, [pc, #196]	; (b6998 <_Z13printMenuItemhbbtt8WaterBot+0x148>)
   b68d2:	4631      	mov	r1, r6
   b68d4:	f7fe fbe4 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b68d8:	7d82      	ldrb	r2, [r0, #22]
   b68da:	2a00      	cmp	r2, #0
   b68dc:	d048      	beq.n	b6970 <_Z13printMenuItemhbbtt8WaterBot+0x120>
                if(wb.*(MenuItems.at(id).MethodPointerBool))  oled.printf("On");    //Check if the value this menu item modifies for this waterbot is true, print "On" if true, "Off" if false
   b68de:	6903      	ldr	r3, [r0, #16]
   b68e0:	aa0c      	add	r2, sp, #48	; 0x30
   b68e2:	4413      	add	r3, r2
   b68e4:	791b      	ldrb	r3, [r3, #4]
   b68e6:	b153      	cbz	r3, b68fe <_Z13printMenuItemhbbtt8WaterBot+0xae>
   b68e8:	492c      	ldr	r1, [pc, #176]	; (b699c <_Z13printMenuItemhbbtt8WaterBot+0x14c>)
                else oled.printf("Off");
   b68ea:	482a      	ldr	r0, [pc, #168]	; (b6994 <_Z13printMenuItemhbbtt8WaterBot+0x144>)
   b68ec:	f7fd fd72 	bl	b43d4 <_ZN5Print6printfEPKcz>
    MenuItems.at(id);
   b68f0:	4631      	mov	r1, r6
   b68f2:	4829      	ldr	r0, [pc, #164]	; (b6998 <_Z13printMenuItemhbbtt8WaterBot+0x148>)
   b68f4:	f7fe fbd4 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
}
   b68f8:	b004      	add	sp, #16
   b68fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                else oled.printf("Off");
   b68fe:	4928      	ldr	r1, [pc, #160]	; (b69a0 <_Z13printMenuItemhbbtt8WaterBot+0x150>)
   b6900:	e7f3      	b.n	b68ea <_Z13printMenuItemhbbtt8WaterBot+0x9a>
            oled.fillRect(OLED_MAX_X - 40,y,OLED_MAX_X-1,16,0);             //Draw black rectangle to erase text, then write white text to show "unhighlighted" state
   b6902:	237f      	movs	r3, #127	; 0x7f
   b6904:	e9cd a800 	strd	sl, r8, [sp]
   b6908:	2158      	movs	r1, #88	; 0x58
   b690a:	4620      	mov	r0, r4
   b690c:	f000 feb1 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6910:	2359      	movs	r3, #89	; 0x59
   b6912:	8223      	strh	r3, [r4, #16]
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6914:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6918:	8265      	strh	r5, [r4, #18]
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b691a:	6163      	str	r3, [r4, #20]
            if(MenuItems.at(id).onOffSetting){                              //Determine where to source the label for the value, when true, display "On" or "Off"
   b691c:	e7d8      	b.n	b68d0 <_Z13printMenuItemhbbtt8WaterBot+0x80>
        oled.fillRect(x,y,OLED_MAX_X - 40,16,0);                //Draw black rectangle to erase any previous contents
   b691e:	2358      	movs	r3, #88	; 0x58
   b6920:	4620      	mov	r0, r4
   b6922:	e9cd a700 	strd	sl, r7, [sp]
   b6926:	9203      	str	r2, [sp, #12]
   b6928:	f000 fea3 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
        oled.setTextSize(2);                                    //Set standard size for text of menu
   b692c:	2102      	movs	r1, #2
   b692e:	4620      	mov	r0, r4
   b6930:	f04f 1801 	mov.w	r8, #65537	; 0x10001
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6934:	f8a4 9010 	strh.w	r9, [r4, #16]
   b6938:	8265      	strh	r5, [r4, #18]
   b693a:	f001 fb42 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
        oled.print(MenuItems.at(id).itemName);                  //Print out the name associated with the menu item at the "id" location in the menu vector
   b693e:	4631      	mov	r1, r6
   b6940:	4815      	ldr	r0, [pc, #84]	; (b6998 <_Z13printMenuItemhbbtt8WaterBot+0x148>)
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6942:	f8c4 8014 	str.w	r8, [r4, #20]
   b6946:	f7fe fbab 	bl	b50a0 <_ZNSt6vectorI8MenuItemSaIS0_EE2atEj>
   b694a:	f100 011e 	add.w	r1, r0, #30
   b694e:	4620      	mov	r0, r4
   b6950:	f006 fb16 	bl	bcf80 <_ZN5Print5printEPKc>
        oled.fillRect(OLED_MAX_X - 40,y,OLED_MAX_X-1,16,0);
   b6954:	237f      	movs	r3, #127	; 0x7f
   b6956:	e9cd a700 	strd	sl, r7, [sp]
   b695a:	9a03      	ldr	r2, [sp, #12]
   b695c:	2158      	movs	r1, #88	; 0x58
   b695e:	4620      	mov	r0, r4
   b6960:	f000 fe87 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6964:	2359      	movs	r3, #89	; 0x59
   b6966:	8223      	strh	r3, [r4, #16]
   b6968:	8265      	strh	r5, [r4, #18]
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b696a:	f8c4 8014 	str.w	r8, [r4, #20]
        if(MenuItems.at(id).onOffSetting){                      //Determine where to source the label for the value, when true, display "On" or "Off"
   b696e:	e7af      	b.n	b68d0 <_Z13printMenuItemhbbtt8WaterBot+0x80>
            oled.printf(MenuItems.at(id).labels.at(wb.*MenuItems.at(id).MethodPointer));
   b6970:	68c2      	ldr	r2, [r0, #12]
        else if(MenuItems.at(id).customLabel){                  //Otherwise, check if we are using custom labels, like those for the drive mode. Source the label text from the Menu item label vector
   b6972:	7dc3      	ldrb	r3, [r0, #23]
            oled.printf(MenuItems.at(id).labels.at(wb.*MenuItems.at(id).MethodPointer));
   b6974:	a90c      	add	r1, sp, #48	; 0x30
   b6976:	440a      	add	r2, r1
   b6978:	8892      	ldrh	r2, [r2, #4]
        else if(MenuItems.at(id).customLabel){                  //Otherwise, check if we are using custom labels, like those for the drive mode. Source the label text from the Menu item label vector
   b697a:	b12b      	cbz	r3, b6988 <_Z13printMenuItemhbbtt8WaterBot+0x138>
            oled.printf(MenuItems.at(id).labels.at(wb.*MenuItems.at(id).MethodPointer));
   b697c:	4611      	mov	r1, r2
   b697e:	f7fe fbed 	bl	b515c <_ZNSt6vectorI6StringSaIS0_EE2atEj>
   b6982:	6801      	ldr	r1, [r0, #0]
   b6984:	4620      	mov	r0, r4
   b6986:	e7b1      	b.n	b68ec <_Z13printMenuItemhbbtt8WaterBot+0x9c>
        else oled.printf("%d",wb.*(MenuItems.at(id).MethodPointer));    //Otherwise, just print the number in the unsigned integer location
   b6988:	4906      	ldr	r1, [pc, #24]	; (b69a4 <_Z13printMenuItemhbbtt8WaterBot+0x154>)
   b698a:	4620      	mov	r0, r4
   b698c:	f7fd fd22 	bl	b43d4 <_ZN5Print6printfEPKcz>
   b6990:	e7ae      	b.n	b68f0 <_Z13printMenuItemhbbtt8WaterBot+0xa0>
   b6992:	bf00      	nop
   b6994:	2003de5c 	.word	0x2003de5c
   b6998:	2003dcac 	.word	0x2003dcac
   b699c:	000c13a4 	.word	0x000c13a4
   b69a0:	000c13a7 	.word	0x000c13a7
   b69a4:	000c13a1 	.word	0x000c13a1

000b69a8 <setup>:
void setup() {
   b69a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    pinMode(E_DPAD,INPUT_PULLDOWN);                 //Enter Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69ac:	2103      	movs	r1, #3
void setup() {
   b69ae:	b0a0      	sub	sp, #128	; 0x80
    pinMode(E_DPAD,INPUT_PULLDOWN);                 //Enter Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69b0:	201c      	movs	r0, #28
   b69b2:	f007 fadb 	bl	bdf6c <pinMode>
    pinMode(U_DPAD,INPUT_PULLDOWN);                 //Up Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69b6:	2103      	movs	r1, #3
   b69b8:	200e      	movs	r0, #14
   b69ba:	f007 fad7 	bl	bdf6c <pinMode>
    pinMode(D_DPAD,INPUT_PULLDOWN);                 //Down Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69be:	2103      	movs	r1, #3
   b69c0:	2007      	movs	r0, #7
   b69c2:	f007 fad3 	bl	bdf6c <pinMode>
    pinMode(L_DPAD,INPUT_PULLDOWN);                 //Left Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69c6:	2103      	movs	r1, #3
   b69c8:	200f      	movs	r0, #15
   b69ca:	f007 facf 	bl	bdf6c <pinMode>
    pinMode(R_DPAD,INPUT_PULLDOWN);                 //Right Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69ce:	2103      	movs	r1, #3
   b69d0:	2012      	movs	r0, #18
   b69d2:	f007 facb 	bl	bdf6c <pinMode>
    pinMode(JOY_BTN,INPUT_PULLDOWN);                //Joystick click Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69d6:	2103      	movs	r1, #3
   b69d8:	201d      	movs	r0, #29
    attachInterrupt(E_DPAD,entHandler,RISING);      //Create an interrupt triggered whenever the enter button is pressed
   b69da:	2400      	movs	r4, #0
    pinMode(JOY_BTN,INPUT_PULLDOWN);                //Joystick click Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69dc:	f007 fac6 	bl	bdf6c <pinMode>
    pinMode(STOP_BTN, INPUT_PULLDOWN);              //Stop Button - Configure each of the buttons used on the controller to be pulldowns, as they are pulled to 3.3V when pressed
   b69e0:	2103      	movs	r1, #3
   b69e2:	2014      	movs	r0, #20
   b69e4:	f007 fac2 	bl	bdf6c <pinMode>
    attachInterrupt(E_DPAD,entHandler,RISING);      //Create an interrupt triggered whenever the enter button is pressed
   b69e8:	499c      	ldr	r1, [pc, #624]	; (b6c5c <setup+0x2b4>)
   b69ea:	9400      	str	r4, [sp, #0]
   b69ec:	f04f 33ff 	mov.w	r3, #4294967295
   b69f0:	2201      	movs	r2, #1
   b69f2:	201c      	movs	r0, #28
   b69f4:	f007 f892 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(U_DPAD,uHandler,RISING);        //Create an interrupt triggered whenever the up button is pressed
   b69f8:	4999      	ldr	r1, [pc, #612]	; (b6c60 <setup+0x2b8>)
   b69fa:	9400      	str	r4, [sp, #0]
   b69fc:	f04f 33ff 	mov.w	r3, #4294967295
   b6a00:	2201      	movs	r2, #1
   b6a02:	200e      	movs	r0, #14
   b6a04:	f007 f88a 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(D_DPAD,dHandler,RISING);        //Create an interrupt triggered whenever the down button is pressed
   b6a08:	4996      	ldr	r1, [pc, #600]	; (b6c64 <setup+0x2bc>)
   b6a0a:	9400      	str	r4, [sp, #0]
   b6a0c:	f04f 33ff 	mov.w	r3, #4294967295
   b6a10:	2201      	movs	r2, #1
   b6a12:	2007      	movs	r0, #7
   b6a14:	f007 f882 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(L_DPAD,lHandler,RISING);        //Create an interrupt triggered whenever the left button is pressed
   b6a18:	4993      	ldr	r1, [pc, #588]	; (b6c68 <setup+0x2c0>)
   b6a1a:	9400      	str	r4, [sp, #0]
   b6a1c:	f04f 33ff 	mov.w	r3, #4294967295
   b6a20:	2201      	movs	r2, #1
   b6a22:	200f      	movs	r0, #15
   b6a24:	f007 f87a 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(R_DPAD,rHandler,RISING);        //Create an interrupt triggered whenever the right button is pressed
   b6a28:	4990      	ldr	r1, [pc, #576]	; (b6c6c <setup+0x2c4>)
   b6a2a:	9400      	str	r4, [sp, #0]
   b6a2c:	f04f 33ff 	mov.w	r3, #4294967295
   b6a30:	2201      	movs	r2, #1
   b6a32:	2012      	movs	r0, #18
   b6a34:	f007 f872 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(JOY_BTN,jHandler,RISING);       //Create an interrupt triggered whenever the joystick button is pressed
   b6a38:	498d      	ldr	r1, [pc, #564]	; (b6c70 <setup+0x2c8>)
   b6a3a:	9400      	str	r4, [sp, #0]
   b6a3c:	f04f 33ff 	mov.w	r3, #4294967295
   b6a40:	2201      	movs	r2, #1
   b6a42:	201d      	movs	r0, #29
   b6a44:	f007 f86a 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(STOP_BTN,sHandler,RISING);      //Create an interrupt triggered whenever the stop button is pressed
   b6a48:	498a      	ldr	r1, [pc, #552]	; (b6c74 <setup+0x2cc>)
   b6a4a:	9400      	str	r4, [sp, #0]
   b6a4c:	f04f 33ff 	mov.w	r3, #4294967295
   b6a50:	2201      	movs	r2, #1
   b6a52:	2014      	movs	r0, #20
   b6a54:	f007 f862 	bl	bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>
    delay(5);
   b6a58:	2005      	movs	r0, #5
   b6a5a:	f006 fbfd 	bl	bd258 <delay>
    if(digitalRead(U_DPAD) == LOW || digitalRead(D_DPAD) == LOW) Particle.connect();    //Debug function, disables LTE if both up and down are held when first plugged in to not wait for cell tower connection
   b6a5e:	200e      	movs	r0, #14
   b6a60:	f007 faae 	bl	bdfc0 <digitalRead>
   b6a64:	2800      	cmp	r0, #0
   b6a66:	f040 80f2 	bne.w	b6c4e <setup+0x2a6>
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
   b6a6a:	f003 fc8f 	bl	ba38c <spark_cloud_flag_connect>
   b6a6e:	f003 f987 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    debounceTime = millis();                        //Initialize timers to current startup time so they are accuracte when the program starts
   b6a72:	4b81      	ldr	r3, [pc, #516]	; (b6c78 <setup+0x2d0>)
    logMessages = true;                             //Default settings for certain actions - enable SD card logging by default
   b6a74:	f8df 8284 	ldr.w	r8, [pc, #644]	; b6cfc <setup+0x354>
    debounceTime = millis();                        //Initialize timers to current startup time so they are accuracte when the program starts
   b6a78:	6018      	str	r0, [r3, #0]
   b6a7a:	f003 f981 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    controlUpdateTime = millis();
   b6a7e:	4b7f      	ldr	r3, [pc, #508]	; (b6c7c <setup+0x2d4>)
   b6a80:	6018      	str	r0, [r3, #0]
   b6a82:	f003 f97d 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    rcTime = millis();
   b6a86:	4b7e      	ldr	r3, [pc, #504]	; (b6c80 <setup+0x2d8>)
   b6a88:	6018      	str	r0, [r3, #0]
    controlUpdateID = -1;
   b6a8a:	4b7e      	ldr	r3, [pc, #504]	; (b6c84 <setup+0x2dc>)
   b6a8c:	f04f 32ff 	mov.w	r2, #4294967295
   b6a90:	601a      	str	r2, [r3, #0]
    Serial.begin(115200);                           //Set debug output serial port to use 115200 baud
   b6a92:	f007 f81b 	bl	bdacc <_Z16_fetch_usbserialv>
   b6a96:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
   b6a9a:	f007 f80b 	bl	bdab4 <_ZN9USBSerial5beginEl>
    Serial1.begin(9600);                            //Start serial for XBee module, using 9600 baud for long range
   b6a9e:	f007 fad5 	bl	be04c <_Z22__fetch_global_Serial1v>
   b6aa2:	f44f 5116 	mov.w	r1, #9600	; 0x2580
   b6aa6:	f007 f905 	bl	bdcb4 <_ZN11USARTSerial5beginEm>
    setupXBee();                                    //Setup XBee by sending bypass characters for XBee modules which have the integrated controller
   b6aaa:	f7fd ff1b 	bl	b48e4 <_Z9setupXBeev>
	BLE.on();                                       //Make sure bluetooth is on for the controller
   b6aae:	f004 fc39 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b6ab2:	f004 fc81 	bl	bb3b8 <_ZNK8particle14BleLocalDevice2onEv>
    BLE.setScanTimeout(50);                         //100ms scan
   b6ab6:	f004 fc35 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b6aba:	2132      	movs	r1, #50	; 0x32
   b6abc:	f004 fcc6 	bl	bb44c <_ZNK8particle14BleLocalDevice14setScanTimeoutEt>
    BLE.setTxPower(8);                              //Use highest power to get longest range
   b6ac0:	f004 fc30 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b6ac4:	2108      	movs	r1, #8
   b6ac6:	f004 fc7e 	bl	bb3c6 <_ZNK8particle14BleLocalDevice10setTxPowerEa>
    peerTxCharacteristic.onDataReceived(BLEDataReceived, &peerTxCharacteristic);        //Create bluetooth characteristic which triggers the BLEDataReceived function whenever the connected bot publishes a command over BLE
   b6aca:	4a6f      	ldr	r2, [pc, #444]	; (b6c88 <setup+0x2e0>)
   b6acc:	496f      	ldr	r1, [pc, #444]	; (b6c8c <setup+0x2e4>)
   b6ace:	4610      	mov	r0, r2
   b6ad0:	f005 fcba 	bl	bc448 <_ZN8particle17BleCharacteristic14onDataReceivedEPFvPKhjRKNS_13BlePeerDeviceEPvES6_>
    peerOffloadCharacteristic.onDataReceived(offloadDataReceived, &peerOffloadCharacteristic);
   b6ad4:	4a6e      	ldr	r2, [pc, #440]	; (b6c90 <setup+0x2e8>)
   b6ad6:	496f      	ldr	r1, [pc, #444]	; (b6c94 <setup+0x2ec>)
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
   b6ad8:	2400      	movs	r4, #0
   b6ada:	4610      	mov	r0, r2
   b6adc:	f005 fcb4 	bl	bc448 <_ZN8particle17BleCharacteristic14onDataReceivedEPFvPKhjRKNS_13BlePeerDeviceEPvES6_>
   b6ae0:	2301      	movs	r3, #1
   b6ae2:	496d      	ldr	r1, [pc, #436]	; (b6c98 <setup+0x2f0>)
   b6ae4:	486d      	ldr	r0, [pc, #436]	; (b6c9c <setup+0x2f4>)
   b6ae6:	4622      	mov	r2, r4
   b6ae8:	e9cd 4400 	strd	r4, r4, [sp]
   b6aec:	f003 fc66 	bl	ba3bc <spark_subscribe>
        return register_function(call_raw_user_function, (void*)func, funcKey);
   b6af0:	4a6b      	ldr	r2, [pc, #428]	; (b6ca0 <setup+0x2f8>)
   b6af2:	496c      	ldr	r1, [pc, #432]	; (b6ca4 <setup+0x2fc>)
   b6af4:	486c      	ldr	r0, [pc, #432]	; (b6ca8 <setup+0x300>)
   b6af6:	f006 fcb0 	bl	bd45a <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
    offloadingMode = false;                         //Initialize flags for offloading so we don't initially start offloading data from the SD card
   b6afa:	4b6c      	ldr	r3, [pc, #432]	; (b6cac <setup+0x304>)
   b6afc:	701c      	strb	r4, [r3, #0]
    offloadingDone = false;
   b6afe:	4b6c      	ldr	r3, [pc, #432]	; (b6cb0 <setup+0x308>)
   b6b00:	701c      	strb	r4, [r3, #0]
    postStatus = false;                             //Don't post status until after the first timer expires so we have time to sample the system
   b6b02:	4b6c      	ldr	r3, [pc, #432]	; (b6cb4 <setup+0x30c>)
   b6b04:	701c      	strb	r4, [r3, #0]
    stopActive = false;                             //Flag set true whenever the stop button is hit, cleared when hit again. By default we should not stop the bot motors, or the user could be confused
   b6b06:	4b6c      	ldr	r3, [pc, #432]	; (b6cb8 <setup+0x310>)
   b6b08:	701c      	strb	r4, [r3, #0]
    LTEStopSent = false;                            //Flag set true when a stop command has been sent already, limits publishing rate
   b6b0a:	4b6c      	ldr	r3, [pc, #432]	; (b6cbc <setup+0x314>)
   b6b0c:	701c      	strb	r4, [r3, #0]
    stopTime = 0;                                   //Timer for periodically sending stop signal when stop is active
   b6b0e:	4b6c      	ldr	r3, [pc, #432]	; (b6cc0 <setup+0x318>)
    logMessages = true;                             //Default settings for certain actions - enable SD card logging by default
   b6b10:	2601      	movs	r6, #1
    stopTime = 0;                                   //Timer for periodically sending stop signal when stop is active
   b6b12:	601c      	str	r4, [r3, #0]
    logMessages = true;                             //Default settings for certain actions - enable SD card logging by default
   b6b14:	f888 6000 	strb.w	r6, [r8]
    snprintf(timestamp,16,"%02d%02d%04d%02d%02d%02d",Time.month(),Time.day(),Time.year(),Time.hour(),Time.minute(),Time.second());
   b6b18:	f006 fb80 	bl	bd21c <_ZN9TimeClass5monthEv>
   b6b1c:	9007      	str	r0, [sp, #28]
   b6b1e:	f006 fb71 	bl	bd204 <_ZN9TimeClass3dayEv>
   b6b22:	4605      	mov	r5, r0
   b6b24:	f006 fb82 	bl	bd22c <_ZN9TimeClass4yearEv>
   b6b28:	4607      	mov	r7, r0
   b6b2a:	f006 fb47 	bl	bd1bc <_ZN9TimeClass4hourEv>
   b6b2e:	4681      	mov	r9, r0
   b6b30:	f006 fb50 	bl	bd1d4 <_ZN9TimeClass6minuteEv>
   b6b34:	4682      	mov	sl, r0
   b6b36:	f006 fb59 	bl	bd1ec <_ZN9TimeClass6secondEv>
   b6b3a:	9b07      	ldr	r3, [sp, #28]
   b6b3c:	4a61      	ldr	r2, [pc, #388]	; (b6cc4 <setup+0x31c>)
   b6b3e:	9500      	str	r5, [sp, #0]
   b6b40:	e9cd a003 	strd	sl, r0, [sp, #12]
   b6b44:	2110      	movs	r1, #16
   b6b46:	e9cd 7901 	strd	r7, r9, [sp, #4]
   b6b4a:	a809      	add	r0, sp, #36	; 0x24
   b6b4c:	f003 fc76 	bl	ba43c <snprintf>
    strcpy(filenameMessages,DEF_FILENAME);          //Create the filename using the current time as well as the label in the macro
   b6b50:	495d      	ldr	r1, [pc, #372]	; (b6cc8 <setup+0x320>)
   b6b52:	485e      	ldr	r0, [pc, #376]	; (b6ccc <setup+0x324>)
    oled.begin(i2c_Address, true);                  // Address 0x3C default for display
   b6b54:	4d5e      	ldr	r5, [pc, #376]	; (b6cd0 <setup+0x328>)
    strcpy(filenameMessages,DEF_FILENAME);          //Create the filename using the current time as well as the label in the macro
   b6b56:	f008 fa20 	bl	bef9a <strcpy>
    strcat(filenameMessages,timestamp);
   b6b5a:	a909      	add	r1, sp, #36	; 0x24
   b6b5c:	485b      	ldr	r0, [pc, #364]	; (b6ccc <setup+0x324>)
   b6b5e:	f008 fa03 	bl	bef68 <strcat>
    strcat(filenameMessages,"_LOG.txt");
   b6b62:	495c      	ldr	r1, [pc, #368]	; (b6cd4 <setup+0x32c>)
   b6b64:	4859      	ldr	r0, [pc, #356]	; (b6ccc <setup+0x324>)
   b6b66:	f008 f9ff 	bl	bef68 <strcat>
    createMenu();                                   //Function to initialize the menu items by creating menu objects and pushing them to the menu item vector
   b6b6a:	f7ff fbdb 	bl	b6324 <_Z10createMenuv>
    delay(250);
   b6b6e:	20fa      	movs	r0, #250	; 0xfa
   b6b70:	f006 fb72 	bl	bd258 <delay>
    oled.begin(i2c_Address, true);                  // Address 0x3C default for display
   b6b74:	4632      	mov	r2, r6
   b6b76:	213c      	movs	r1, #60	; 0x3c
   b6b78:	4628      	mov	r0, r5
   b6b7a:	f003 f827 	bl	b9bcc <_ZN15Adafruit_SH11075beginEhb>
    oled.clearDisplay();                            //Clear display in case it had something from a reset
   b6b7e:	4628      	mov	r0, r5
   b6b80:	f000 fc24 	bl	b73cc <_ZN17Adafruit_GrayOLED12clearDisplayEv>
    oled.display();                                 //Apply changes to display
   b6b84:	4628      	mov	r0, r5
   b6b86:	f002 ff2b 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
    oled.setRotation(1);                            //Standard rotation
   b6b8a:	4631      	mov	r1, r6
   b6b8c:	4628      	mov	r0, r5
   b6b8e:	f000 fe24 	bl	b77da <_ZN12Adafruit_GFX11setRotationEh>
    oled.setTextSize(2);                            //Set text size of the "Starting" prompt
   b6b92:	2102      	movs	r1, #2
   b6b94:	4628      	mov	r0, r5
   b6b96:	f001 fa14 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
   b6b9a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    oled.print(" Starting ");                       //Print label to tell user the system is starting
   b6b9e:	494e      	ldr	r1, [pc, #312]	; (b6cd8 <setup+0x330>)
   b6ba0:	616b      	str	r3, [r5, #20]
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6ba2:	612c      	str	r4, [r5, #16]
   b6ba4:	4628      	mov	r0, r5
   b6ba6:	f006 f9eb 	bl	bcf80 <_ZN5Print5printEPKc>
    oled.display();
   b6baa:	4628      	mov	r0, r5
   b6bac:	f002 ff18 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
    delay(250);
   b6bb0:	20fa      	movs	r0, #250	; 0xfa
   b6bb2:	f006 fb51 	bl	bd258 <delay>
      dataMode_{dataMode}
   b6bb6:	4b49      	ldr	r3, [pc, #292]	; (b6cdc <setup+0x334>)
   b6bb8:	930d      	str	r3, [sp, #52]	; 0x34
    if (!sd.begin(chipSelect, SD_SCK_MHZ(8))) {     //Begin communication with the SD card at 8MHz, using chipSelect as the GPIO for selecting this SPI device
   b6bba:	4849      	ldr	r0, [pc, #292]	; (b6ce0 <setup+0x338>)
   b6bbc:	4b49      	ldr	r3, [pc, #292]	; (b6ce4 <setup+0x33c>)
   b6bbe:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
   b6bc2:	aa0d      	add	r2, sp, #52	; 0x34
   b6bc4:	2108      	movs	r1, #8
   b6bc6:	930f      	str	r3, [sp, #60]	; 0x3c
   b6bc8:	f8ad 6040 	strh.w	r6, [sp, #64]	; 0x40
   b6bcc:	f7fd fd28 	bl	b4620 <_ZN5SdFat5beginEhN8particle11SPISettingsE>
   b6bd0:	b908      	cbnz	r0, b6bd6 <setup+0x22e>
        logMessages = false;
   b6bd2:	f888 4000 	strb.w	r4, [r8]
    sprintf(m.primaryLine,"Hello!\0");                  //Display hello as the main text
   b6bd6:	4944      	ldr	r1, [pc, #272]	; (b6ce8 <setup+0x340>)
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b6bd8:	f88d 407a 	strb.w	r4, [sp, #122]	; 0x7a
    sprintf(m.primaryLine,"Hello!\0");                  //Display hello as the main text
   b6bdc:	a80d      	add	r0, sp, #52	; 0x34
class MenuPopUp{                                //Class for displaying a pop up on the mini OLED. Has various lines for displaying text to the user with warnings
   b6bde:	f88d 407b 	strb.w	r4, [sp, #123]	; 0x7b
   b6be2:	f88d 407c 	strb.w	r4, [sp, #124]	; 0x7c
    sprintf(m.primaryLine,"Hello!\0");                  //Display hello as the main text
   b6be6:	f008 f9d8 	bl	bef9a <strcpy>
    sprintf(m.secondaryLine,"Scanning for Bots\0", 1);  //Second line for information
   b6bea:	4940      	ldr	r1, [pc, #256]	; (b6cec <setup+0x344>)
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
   b6bec:	4d40      	ldr	r5, [pc, #256]	; (b6cf0 <setup+0x348>)
   b6bee:	2201      	movs	r2, #1
   b6bf0:	f10d 003e 	add.w	r0, sp, #62	; 0x3e
   b6bf4:	f003 fc12 	bl	ba41c <sprintf>
    sprintf(m.tertiaryLine, "OK when bots ready\0",15); //Third line for information
   b6bf8:	220f      	movs	r2, #15
   b6bfa:	493e      	ldr	r1, [pc, #248]	; (b6cf4 <setup+0x34c>)
   b6bfc:	a817      	add	r0, sp, #92	; 0x5c
   b6bfe:	f003 fc0d 	bl	ba41c <sprintf>
    m.primaryStart = 32;                                //Values to center the text found by experimentation
   b6c02:	2320      	movs	r3, #32
   b6c04:	f88d 307a 	strb.w	r3, [sp, #122]	; 0x7a
    m.secondaryStart = 12;
   b6c08:	230c      	movs	r3, #12
    PopUps.push_back(m);
   b6c0a:	483b      	ldr	r0, [pc, #236]	; (b6cf8 <setup+0x350>)
    m.secondaryStart = 12;
   b6c0c:	f88d 307b 	strb.w	r3, [sp, #123]	; 0x7b
    PopUps.push_back(m);
   b6c10:	a90d      	add	r1, sp, #52	; 0x34
    m.tertiaryStart = 10;
   b6c12:	230a      	movs	r3, #10
   b6c14:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
    PopUps.push_back(m);
   b6c18:	f7fe fb62 	bl	b52e0 <_ZNSt6vectorI9MenuPopUpSaIS0_EE9push_backERKS0_>
    startupPair();                                      //Not significantly tested - Disable if using an emulated bot id or if the program is crashing on startup
   b6c1c:	f7ff fd8e 	bl	b673c <_Z11startupPairv>
   b6c20:	68a8      	ldr	r0, [r5, #8]
   b6c22:	b130      	cbz	r0, b6c32 <setup+0x28a>
   b6c24:	2300      	movs	r3, #0
   b6c26:	e9cd 4400 	strd	r4, r4, [sp]
   b6c2a:	461a      	mov	r2, r3
   b6c2c:	2102      	movs	r1, #2
   b6c2e:	f003 f991 	bl	b9f54 <os_timer_change>
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
   b6c32:	68a8      	ldr	r0, [r5, #8]
   b6c34:	b140      	cbz	r0, b6c48 <setup+0x2a0>
   b6c36:	2300      	movs	r3, #0
   b6c38:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   b6c3c:	e9cd 2300 	strd	r2, r3, [sp]
   b6c40:	4619      	mov	r1, r3
   b6c42:	461a      	mov	r2, r3
   b6c44:	f003 f986 	bl	b9f54 <os_timer_change>
}
   b6c48:	b020      	add	sp, #128	; 0x80
   b6c4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(digitalRead(U_DPAD) == LOW || digitalRead(D_DPAD) == LOW) Particle.connect();    //Debug function, disables LTE if both up and down are held when first plugged in to not wait for cell tower connection
   b6c4e:	2007      	movs	r0, #7
   b6c50:	f007 f9b6 	bl	bdfc0 <digitalRead>
   b6c54:	2800      	cmp	r0, #0
   b6c56:	f43f af08 	beq.w	b6a6a <setup+0xc2>
   b6c5a:	e708      	b.n	b6a6e <setup+0xc6>
   b6c5c:	000b435d 	.word	0x000b435d
   b6c60:	000b50c9 	.word	0x000b50c9
   b6c64:	000b5111 	.word	0x000b5111
   b6c68:	000b429d 	.word	0x000b429d
   b6c6c:	000b41dd 	.word	0x000b41dd
   b6c70:	000b41c1 	.word	0x000b41c1
   b6c74:	000b5309 	.word	0x000b5309
   b6c78:	2003dd74 	.word	0x2003dd74
   b6c7c:	2003dd6c 	.word	0x2003dd6c
   b6c80:	2003ded8 	.word	0x2003ded8
   b6c84:	2003dd68 	.word	0x2003dd68
   b6c88:	2003decc 	.word	0x2003decc
   b6c8c:	000b5b19 	.word	0x000b5b19
   b6c90:	2003debc 	.word	0x2003debc
   b6c94:	000b4515 	.word	0x000b4515
   b6c98:	000b5ac9 	.word	0x000b5ac9
   b6c9c:	000c13ab 	.word	0x000c13ab
   b6ca0:	000c13b3 	.word	0x000c13b3
   b6ca4:	000b5c75 	.word	0x000b5c75
   b6ca8:	000bd42f 	.word	0x000bd42f
   b6cac:	2003de5b 	.word	0x2003de5b
   b6cb0:	2003de5a 	.word	0x2003de5a
   b6cb4:	2003ded4 	.word	0x2003ded4
   b6cb8:	2003e631 	.word	0x2003e631
   b6cbc:	2003dca9 	.word	0x2003dca9
   b6cc0:	2003e634 	.word	0x2003e634
   b6cc4:	000c13c1 	.word	0x000c13c1
   b6cc8:	000c13da 	.word	0x000c13da
   b6ccc:	2003dd78 	.word	0x2003dd78
   b6cd0:	2003de5c 	.word	0x2003de5c
   b6cd4:	000c13e0 	.word	0x000c13e0
   b6cd8:	000c13e9 	.word	0x000c13e9
   b6cdc:	000c1418 	.word	0x000c1418
   b6ce0:	2003e1ac 	.word	0x2003e1ac
   b6ce4:	007a1200 	.word	0x007a1200
   b6ce8:	000c1504 	.word	0x000c1504
   b6cec:	000c150c 	.word	0x000c150c
   b6cf0:	2003dd48 	.word	0x2003dd48
   b6cf4:	000c151f 	.word	0x000c151f
   b6cf8:	2003dcc4 	.word	0x2003dcc4
   b6cfc:	2003de04 	.word	0x2003de04

000b6d00 <_Z10updateMenuv>:
void updateMenu(){
   b6d00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(redrawMenu){
   b6d04:	f8df a35c 	ldr.w	sl, [pc, #860]	; b7064 <_Z10updateMenuv+0x364>
   b6d08:	f89a 3000 	ldrb.w	r3, [sl]
void updateMenu(){
   b6d0c:	b097      	sub	sp, #92	; 0x5c
    if(redrawMenu){
   b6d0e:	2b00      	cmp	r3, #0
   b6d10:	d06d      	beq.n	b6dee <_Z10updateMenuv+0xee>
        oled.fillRect(0,0,OLED_MAX_X,OLED_MAX_Y,0);             //Erase full screen
   b6d12:	4cca      	ldr	r4, [pc, #808]	; (b703c <_Z10updateMenuv+0x33c>)
   b6d14:	4eca      	ldr	r6, [pc, #808]	; (b7040 <_Z10updateMenuv+0x340>)
   b6d16:	2500      	movs	r5, #0
   b6d18:	2340      	movs	r3, #64	; 0x40
   b6d1a:	e9cd 3500 	strd	r3, r5, [sp]
   b6d1e:	462a      	mov	r2, r5
   b6d20:	2380      	movs	r3, #128	; 0x80
   b6d22:	4629      	mov	r1, r5
   b6d24:	4620      	mov	r0, r4
   b6d26:	f000 fca4 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
        if(PopUps.size() != 0){                                 //Check if there is a queue of pop-ups to be displayed, print out the most-recent (back of vector) if any
   b6d2a:	e9d6 3200 	ldrd	r3, r2, [r6]
   b6d2e:	429a      	cmp	r2, r3
   b6d30:	d060      	beq.n	b6df4 <_Z10updateMenuv+0xf4>
            oled.drawRect(1,1,126,62,1);                        //Draw outer rectangle of warning box
   b6d32:	2701      	movs	r7, #1
   b6d34:	233e      	movs	r3, #62	; 0x3e
   b6d36:	e9cd 3700 	strd	r3, r7, [sp]
   b6d3a:	463a      	mov	r2, r7
   b6d3c:	237e      	movs	r3, #126	; 0x7e
   b6d3e:	4639      	mov	r1, r7
   b6d40:	4620      	mov	r0, r4
   b6d42:	f000 fd09 	bl	b7758 <_ZN12Adafruit_GFX8drawRectEsssst>
            oled.drawRect(2,2,124,60,1);                        //Draw inner rectangle of warning box
   b6d46:	2202      	movs	r2, #2
   b6d48:	233c      	movs	r3, #60	; 0x3c
   b6d4a:	4611      	mov	r1, r2
   b6d4c:	9300      	str	r3, [sp, #0]
   b6d4e:	4620      	mov	r0, r4
   b6d50:	237c      	movs	r3, #124	; 0x7c
   b6d52:	9701      	str	r7, [sp, #4]
   b6d54:	f000 fd00 	bl	b7758 <_ZN12Adafruit_GFX8drawRectEsssst>
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6d58:	f04f 1301 	mov.w	r3, #65537	; 0x10001
   b6d5c:	6163      	str	r3, [r4, #20]
            oled.setCursor(PopUps.back().primaryStart,4);       //Move cursor to the location for the main warning line of the top pop-up
   b6d5e:	6873      	ldr	r3, [r6, #4]
   b6d60:	f813 3c03 	ldrb.w	r3, [r3, #-3]
   b6d64:	8223      	strh	r3, [r4, #16]
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6d66:	2304      	movs	r3, #4
   b6d68:	8263      	strh	r3, [r4, #18]
            oled.setTextSize(2);                                //Use larger text for main warning
   b6d6a:	2102      	movs	r1, #2
   b6d6c:	4620      	mov	r0, r4
   b6d6e:	f001 f928 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
            oled.printf(PopUps.back().primaryLine);             //Print main warning text from the top pop-up string
   b6d72:	6871      	ldr	r1, [r6, #4]
   b6d74:	4620      	mov	r0, r4
   b6d76:	3949      	subs	r1, #73	; 0x49
   b6d78:	f7fd fb2c 	bl	b43d4 <_ZN5Print6printfEPKcz>
            oled.setCursor(PopUps.back().secondaryStart,22);    //Move cursor for second text line
   b6d7c:	6873      	ldr	r3, [r6, #4]
   b6d7e:	f813 3c02 	ldrb.w	r3, [r3, #-2]
   b6d82:	8223      	strh	r3, [r4, #16]
   b6d84:	2316      	movs	r3, #22
   b6d86:	8263      	strh	r3, [r4, #18]
            oled.setTextSize(1);                                //Use smaller text for next two lines
   b6d88:	4639      	mov	r1, r7
   b6d8a:	4620      	mov	r0, r4
   b6d8c:	f001 f919 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
            oled.printf(PopUps.back().secondaryLine);           //Print out second warning text from top pop-up string
   b6d90:	6871      	ldr	r1, [r6, #4]
   b6d92:	4620      	mov	r0, r4
   b6d94:	393f      	subs	r1, #63	; 0x3f
   b6d96:	f7fd fb1d 	bl	b43d4 <_ZN5Print6printfEPKcz>
            oled.setCursor(PopUps.back().tertiaryStart,32);     //Move cursor for third line
   b6d9a:	6873      	ldr	r3, [r6, #4]
   b6d9c:	f04f 0820 	mov.w	r8, #32
   b6da0:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   b6da4:	8223      	strh	r3, [r4, #16]
            oled.setTextSize(1);                                //Continue using smaller text
   b6da6:	4639      	mov	r1, r7
   b6da8:	4620      	mov	r0, r4
   b6daa:	f8a4 8012 	strh.w	r8, [r4, #18]
   b6dae:	f001 f908 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
            oled.printf(PopUps.back().tertiaryLine);            //Print third line
   b6db2:	6871      	ldr	r1, [r6, #4]
   b6db4:	4620      	mov	r0, r4
   b6db6:	3921      	subs	r1, #33	; 0x21
   b6db8:	f7fd fb0c 	bl	b43d4 <_ZN5Print6printfEPKcz>
   b6dbc:	4ba1      	ldr	r3, [pc, #644]	; (b7044 <_Z10updateMenuv+0x344>)
   b6dbe:	6123      	str	r3, [r4, #16]
            oled.setTextSize(2);                                //Use large text for "OK" prompt
   b6dc0:	2102      	movs	r1, #2
   b6dc2:	4620      	mov	r0, r4
   b6dc4:	f001 f8fd 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
            oled.fillRect(45,44,32,16,1);                       //Create a white rectangle to highlight the "OK" text
   b6dc8:	2310      	movs	r3, #16
   b6dca:	222c      	movs	r2, #44	; 0x2c
   b6dcc:	9300      	str	r3, [sp, #0]
   b6dce:	212d      	movs	r1, #45	; 0x2d
   b6dd0:	4643      	mov	r3, r8
   b6dd2:	4620      	mov	r0, r4
   b6dd4:	9701      	str	r7, [sp, #4]
   b6dd6:	f000 fc4c 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
            oled.printf("OK");                                  //Print "OK" to indicate the user should hit enter to dismiss this prompt
   b6dda:	499b      	ldr	r1, [pc, #620]	; (b7048 <_Z10updateMenuv+0x348>)
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6ddc:	6165      	str	r5, [r4, #20]
   b6dde:	4620      	mov	r0, r4
   b6de0:	f7fd faf8 	bl	b43d4 <_ZN5Print6printfEPKcz>
            oled.display();                                     //Commit update to OLED screen
   b6de4:	4620      	mov	r0, r4
   b6de6:	f002 fdfb 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
            redrawMenu = false;                                 //Set flag to false so it isn't redrawn every time
   b6dea:	f88a 5000 	strb.w	r5, [sl]
}
   b6dee:	b017      	add	sp, #92	; 0x5c
   b6df0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b6df4:	f8df 9264 	ldr.w	r9, [pc, #612]	; b705c <_Z10updateMenuv+0x35c>
            if(WaterBots.at(i).botNum == botSelect){            //If it is the selected one, print it with a highlighted rectangle
   b6df8:	f8df b26c 	ldr.w	fp, [pc, #620]	; b7068 <_Z10updateMenuv+0x368>
        uint8_t menuSelect = 0;                                 //Counter used to find which index in the Water Bot vector the currently selected bot is at
   b6dfc:	462e      	mov	r6, r5
   b6dfe:	e9d9 2300 	ldrd	r2, r3, [r9]
   b6e02:	1a9b      	subs	r3, r3, r2
   b6e04:	4a91      	ldr	r2, [pc, #580]	; (b704c <_Z10updateMenuv+0x34c>)
   b6e06:	111b      	asrs	r3, r3, #4
   b6e08:	b2ef      	uxtb	r7, r5
   b6e0a:	4353      	muls	r3, r2
        for(uint8_t i = 0; i < WaterBots.size(); i++){          //Loop over all of the water bots that have been discovered and check if they are the selected one
   b6e0c:	429f      	cmp	r7, r3
   b6e0e:	d247      	bcs.n	b6ea0 <_Z10updateMenuv+0x1a0>
            if(WaterBots.at(i).botNum == botSelect){            //If it is the selected one, print it with a highlighted rectangle
   b6e10:	4639      	mov	r1, r7
   b6e12:	4648      	mov	r0, r9
   b6e14:	f7fe f868 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
                oled.setCursor(5+18*i,4);                       //Set cursor to offset based on the item location in the list. Bots displayed in order they were discovered
   b6e18:	eb07 08c7 	add.w	r8, r7, r7, lsl #3
            if(WaterBots.at(i).botNum == botSelect){            //If it is the selected one, print it with a highlighted rectangle
   b6e1c:	7881      	ldrb	r1, [r0, #2]
   b6e1e:	f89b 3000 	ldrb.w	r3, [fp]
                oled.setTextSize(1);                            //Use small text for number inside of bot box
   b6e22:	4886      	ldr	r0, [pc, #536]	; (b703c <_Z10updateMenuv+0x33c>)
                oled.setCursor(5+18*i,4);                       //Set cursor to offset based on the item location in the list. Bots displayed in order they were discovered
   b6e24:	ea4f 0848 	mov.w	r8, r8, lsl #1
   b6e28:	f108 0205 	add.w	r2, r8, #5
            if(WaterBots.at(i).botNum == botSelect){            //If it is the selected one, print it with a highlighted rectangle
   b6e2c:	4299      	cmp	r1, r3
   b6e2e:	f04f 0304 	mov.w	r3, #4
                oled.fillRect(1+i*18,1,14,14,1);                //Fill rectangle with white background for selected bot
   b6e32:	f108 0801 	add.w	r8, r8, #1
  void setCursor(int16_t x, int16_t y) { cursor_x = x; cursor_y = y; }
   b6e36:	8222      	strh	r2, [r4, #16]
   b6e38:	8263      	strh	r3, [r4, #18]
                oled.setTextSize(1);                            //Use small text for number inside of bot box
   b6e3a:	f04f 0101 	mov.w	r1, #1
            if(WaterBots.at(i).botNum == botSelect){            //If it is the selected one, print it with a highlighted rectangle
   b6e3e:	d117      	bne.n	b6e70 <_Z10updateMenuv+0x170>
                oled.setTextSize(1);                            //Use small text for number inside of bot box
   b6e40:	f001 f8bf 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
  void setTextColor(uint16_t c) { textcolor = textbgcolor = c; }
   b6e44:	2300      	movs	r3, #0
                oled.fillRect(1+i*18,1,14,14,1);                //Fill rectangle with white background for selected bot
   b6e46:	2201      	movs	r2, #1
   b6e48:	6163      	str	r3, [r4, #20]
   b6e4a:	230e      	movs	r3, #14
   b6e4c:	e9cd 3200 	strd	r3, r2, [sp]
   b6e50:	487a      	ldr	r0, [pc, #488]	; (b703c <_Z10updateMenuv+0x33c>)
   b6e52:	4641      	mov	r1, r8
   b6e54:	f000 fc0d 	bl	b7672 <_ZN12Adafruit_GFX8fillRectEsssst>
                oled.printf("%d",WaterBots.at(i).botNum);       //Then print the bot ID inside the box in black text
   b6e58:	4639      	mov	r1, r7
   b6e5a:	4648      	mov	r0, r9
   b6e5c:	f7fe f844 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6e60:	497b      	ldr	r1, [pc, #492]	; (b7050 <_Z10updateMenuv+0x350>)
   b6e62:	7882      	ldrb	r2, [r0, #2]
   b6e64:	4875      	ldr	r0, [pc, #468]	; (b703c <_Z10updateMenuv+0x33c>)
   b6e66:	f7fd fab5 	bl	b43d4 <_ZN5Print6printfEPKcz>
        for(uint8_t i = 0; i < WaterBots.size(); i++){          //Loop over all of the water bots that have been discovered and check if they are the selected one
   b6e6a:	3501      	adds	r5, #1
   b6e6c:	463e      	mov	r6, r7
   b6e6e:	e7c6      	b.n	b6dfe <_Z10updateMenuv+0xfe>
                oled.setTextSize(1);                            //Use small text for bot ID printed in box
   b6e70:	f001 f8a7 	bl	b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>
   b6e74:	f04f 1301 	mov.w	r3, #65537	; 0x10001
                oled.drawRect(1+i*18,1,14,14,1);                //Only draw outside of rectangle as white since this bot is not selected
   b6e78:	2201      	movs	r2, #1
   b6e7a:	6163      	str	r3, [r4, #20]
   b6e7c:	230e      	movs	r3, #14
   b6e7e:	e9cd 3200 	strd	r3, r2, [sp]
   b6e82:	486e      	ldr	r0, [pc, #440]	; (b703c <_Z10updateMenuv+0x33c>)
   b6e84:	4641      	mov	r1, r8
   b6e86:	f000 fc67 	bl	b7758 <_ZN12Adafruit_GFX8drawRectEsssst>
                oled.printf("%d",WaterBots.at(i).botNum);       //Print out the bot number in the box
   b6e8a:	4639      	mov	r1, r7
   b6e8c:	4648      	mov	r0, r9
   b6e8e:	f7fe f82b 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6e92:	496f      	ldr	r1, [pc, #444]	; (b7050 <_Z10updateMenuv+0x350>)
   b6e94:	7882      	ldrb	r2, [r0, #2]
   b6e96:	4869      	ldr	r0, [pc, #420]	; (b703c <_Z10updateMenuv+0x33c>)
   b6e98:	f7fd fa9c 	bl	b43d4 <_ZN5Print6printfEPKcz>
   b6e9c:	4637      	mov	r7, r6
   b6e9e:	e7e4      	b.n	b6e6a <_Z10updateMenuv+0x16a>
        if(menuItem == 0){      //If we are selecting the first menu item in the list, print it first (highlighted), then print the next two unhighlighted
   b6ea0:	4f6c      	ldr	r7, [pc, #432]	; (b7054 <_Z10updateMenuv+0x354>)
   b6ea2:	783c      	ldrb	r4, [r7, #0]
   b6ea4:	2c00      	cmp	r4, #0
   b6ea6:	d144      	bne.n	b6f32 <_Z10updateMenuv+0x232>
   b6ea8:	4d6b      	ldr	r5, [pc, #428]	; (b7058 <_Z10updateMenuv+0x358>)
            if(MenuItems.size() != 0) printMenuItem(0,true,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as highlighted
   b6eaa:	e9d5 3200 	ldrd	r3, r2, [r5]
   b6eae:	429a      	cmp	r2, r3
   b6eb0:	d014      	beq.n	b6edc <_Z10updateMenuv+0x1dc>
   b6eb2:	4631      	mov	r1, r6
   b6eb4:	4869      	ldr	r0, [pc, #420]	; (b705c <_Z10updateMenuv+0x35c>)
   b6eb6:	f7fe f817 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6eba:	4b69      	ldr	r3, [pc, #420]	; (b7060 <_Z10updateMenuv+0x360>)
   b6ebc:	781f      	ldrb	r7, [r3, #0]
   b6ebe:	4601      	mov	r1, r0
   b6ec0:	2250      	movs	r2, #80	; 0x50
   b6ec2:	a801      	add	r0, sp, #4
   b6ec4:	f007 fff1 	bl	beeaa <memcpy>
   b6ec8:	f087 0701 	eor.w	r7, r7, #1
   b6ecc:	2310      	movs	r3, #16
   b6ece:	9300      	str	r3, [sp, #0]
   b6ed0:	463a      	mov	r2, r7
   b6ed2:	4623      	mov	r3, r4
   b6ed4:	2101      	movs	r1, #1
   b6ed6:	4620      	mov	r0, r4
   b6ed8:	f7ff fcba 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
   b6edc:	e9d5 3400 	ldrd	r3, r4, [r5]
   b6ee0:	1ae4      	subs	r4, r4, r3
   b6ee2:	4b5a      	ldr	r3, [pc, #360]	; (b704c <_Z10updateMenuv+0x34c>)
                printMenuItem(mi,false,!selectingBots,0,16+(16*mi),WaterBots.at(menuSelect));
   b6ee4:	f8df b174 	ldr.w	fp, [pc, #372]	; b705c <_Z10updateMenuv+0x35c>
   b6ee8:	10e4      	asrs	r4, r4, #3
   b6eea:	435c      	muls	r4, r3
            uint8_t loopIter = MenuItems.size();                                                            //Get size of menu items (check if there are < 2)
   b6eec:	b2e4      	uxtb	r4, r4
            if(loopIter > 2) loopIter = 2;                                                                  //Limit to max 3 printouts beyond first item
   b6eee:	2c02      	cmp	r4, #2
   b6ef0:	bf28      	it	cs
   b6ef2:	2402      	movcs	r4, #2
            for(int mi = 1; mi <= loopIter; mi++){                                                          //Print out the items below this
   b6ef4:	2501      	movs	r5, #1
                printMenuItem(mi,false,!selectingBots,0,16+(16*mi),WaterBots.at(menuSelect));
   b6ef6:	f10d 0904 	add.w	r9, sp, #4
            for(int mi = 1; mi <= loopIter; mi++){                                                          //Print out the items below this
   b6efa:	42ac      	cmp	r4, r5
   b6efc:	db63      	blt.n	b6fc6 <_Z10updateMenuv+0x2c6>
                printMenuItem(mi,false,!selectingBots,0,16+(16*mi),WaterBots.at(menuSelect));
   b6efe:	4631      	mov	r1, r6
   b6f00:	4658      	mov	r0, fp
   b6f02:	f7fd fff1 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6f06:	4b56      	ldr	r3, [pc, #344]	; (b7060 <_Z10updateMenuv+0x360>)
   b6f08:	fa5f f885 	uxtb.w	r8, r5
   b6f0c:	4601      	mov	r1, r0
   b6f0e:	3501      	adds	r5, #1
   b6f10:	2250      	movs	r2, #80	; 0x50
   b6f12:	4648      	mov	r0, r9
   b6f14:	781f      	ldrb	r7, [r3, #0]
   b6f16:	f007 ffc8 	bl	beeaa <memcpy>
   b6f1a:	012b      	lsls	r3, r5, #4
   b6f1c:	b29b      	uxth	r3, r3
   b6f1e:	f087 0701 	eor.w	r7, r7, #1
   b6f22:	9300      	str	r3, [sp, #0]
   b6f24:	2300      	movs	r3, #0
   b6f26:	463a      	mov	r2, r7
   b6f28:	4619      	mov	r1, r3
   b6f2a:	4640      	mov	r0, r8
   b6f2c:	f7ff fc90 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
            for(int mi = 1; mi <= loopIter; mi++){                                                          //Print out the items below this
   b6f30:	e7e3      	b.n	b6efa <_Z10updateMenuv+0x1fa>
            if(MenuItems.size() != 0) printMenuItem(0,true,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as highlighted
   b6f32:	f8df 812c 	ldr.w	r8, [pc, #300]	; b7060 <_Z10updateMenuv+0x360>
            printMenuItem(menuItem,true,!selectingBots,0,48,WaterBots.at(menuSelect));      //Print bottom menu item as highlighted
   b6f36:	4849      	ldr	r0, [pc, #292]	; (b705c <_Z10updateMenuv+0x35c>)
            if(MenuItems.size() != 0) printMenuItem(0,true,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as highlighted
   b6f38:	f898 9000 	ldrb.w	r9, [r8]
        else if(menuItem == MAX_MENU_ITEMS-1){  //If we are selecting the last menu item in the list, print it last (highlighted), then print the previous two unhighlighted
   b6f3c:	2c06      	cmp	r4, #6
            if(MenuItems.size() != 0) printMenuItem(0,true,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as highlighted
   b6f3e:	f089 0901 	eor.w	r9, r9, #1
            printMenuItem(menuItem,true,!selectingBots,0,48,WaterBots.at(menuSelect));      //Print bottom menu item as highlighted
   b6f42:	4631      	mov	r1, r6
   b6f44:	ad01      	add	r5, sp, #4
        else if(menuItem == MAX_MENU_ITEMS-1){  //If we are selecting the last menu item in the list, print it last (highlighted), then print the previous two unhighlighted
   b6f46:	d145      	bne.n	b6fd4 <_Z10updateMenuv+0x2d4>
            printMenuItem(menuItem,true,!selectingBots,0,48,WaterBots.at(menuSelect));      //Print bottom menu item as highlighted
   b6f48:	f7fd ffce 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6f4c:	2250      	movs	r2, #80	; 0x50
   b6f4e:	4601      	mov	r1, r0
   b6f50:	4628      	mov	r0, r5
   b6f52:	f007 ffaa 	bl	beeaa <memcpy>
   b6f56:	2330      	movs	r3, #48	; 0x30
   b6f58:	464a      	mov	r2, r9
   b6f5a:	4620      	mov	r0, r4
   b6f5c:	9300      	str	r3, [sp, #0]
   b6f5e:	2101      	movs	r1, #1
   b6f60:	2300      	movs	r3, #0
   b6f62:	f7ff fc75 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
            printMenuItem(menuItem-1,false,!selectingBots,0,32,WaterBots.at(menuSelect));   //Print middle menu item as unhighlighted
   b6f66:	4631      	mov	r1, r6
   b6f68:	483c      	ldr	r0, [pc, #240]	; (b705c <_Z10updateMenuv+0x35c>)
   b6f6a:	f7fd ffbd 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6f6e:	783c      	ldrb	r4, [r7, #0]
   b6f70:	f898 9000 	ldrb.w	r9, [r8]
   b6f74:	4601      	mov	r1, r0
   b6f76:	2250      	movs	r2, #80	; 0x50
   b6f78:	4628      	mov	r0, r5
   b6f7a:	f007 ff96 	bl	beeaa <memcpy>
   b6f7e:	3c01      	subs	r4, #1
   b6f80:	2320      	movs	r3, #32
   b6f82:	b2e4      	uxtb	r4, r4
   b6f84:	9300      	str	r3, [sp, #0]
   b6f86:	f089 0901 	eor.w	r9, r9, #1
   b6f8a:	2300      	movs	r3, #0
   b6f8c:	4619      	mov	r1, r3
   b6f8e:	4620      	mov	r0, r4
   b6f90:	464a      	mov	r2, r9
   b6f92:	f7ff fc5d 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
            printMenuItem(menuItem-2,false,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as unhighlighted
   b6f96:	4631      	mov	r1, r6
   b6f98:	4830      	ldr	r0, [pc, #192]	; (b705c <_Z10updateMenuv+0x35c>)
   b6f9a:	f7fd ffa5 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6f9e:	f898 6000 	ldrb.w	r6, [r8]
   b6fa2:	783c      	ldrb	r4, [r7, #0]
   b6fa4:	4601      	mov	r1, r0
   b6fa6:	f086 0601 	eor.w	r6, r6, #1
   b6faa:	3c02      	subs	r4, #2
            printMenuItem(menuItem-1,false,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as unhighlighted
   b6fac:	2250      	movs	r2, #80	; 0x50
   b6fae:	4628      	mov	r0, r5
   b6fb0:	f007 ff7b 	bl	beeaa <memcpy>
   b6fb4:	2310      	movs	r3, #16
   b6fb6:	b2e4      	uxtb	r4, r4
   b6fb8:	9300      	str	r3, [sp, #0]
   b6fba:	2300      	movs	r3, #0
   b6fbc:	4632      	mov	r2, r6
   b6fbe:	4619      	mov	r1, r3
   b6fc0:	4620      	mov	r0, r4
   b6fc2:	f7ff fc45 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
        oled.display();         //Commit drawn menu to the OLED
   b6fc6:	481d      	ldr	r0, [pc, #116]	; (b703c <_Z10updateMenuv+0x33c>)
   b6fc8:	f002 fd0a 	bl	b99e0 <_ZN15Adafruit_SH110X7displayEv>
        redrawMenu = false;     //Clear flag so it isn't redrawn every time
   b6fcc:	2300      	movs	r3, #0
   b6fce:	f88a 3000 	strb.w	r3, [sl]
   b6fd2:	e70c      	b.n	b6dee <_Z10updateMenuv+0xee>
            printMenuItem(menuItem+1,false,!selectingBots,0,48,WaterBots.at(menuSelect));   //Print bottom menu item as unhighlighted
   b6fd4:	f7fd ff88 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b6fd8:	2250      	movs	r2, #80	; 0x50
   b6fda:	4601      	mov	r1, r0
   b6fdc:	4628      	mov	r0, r5
   b6fde:	f007 ff64 	bl	beeaa <memcpy>
   b6fe2:	3401      	adds	r4, #1
   b6fe4:	2330      	movs	r3, #48	; 0x30
   b6fe6:	b2e4      	uxtb	r4, r4
   b6fe8:	9300      	str	r3, [sp, #0]
   b6fea:	2300      	movs	r3, #0
   b6fec:	4619      	mov	r1, r3
   b6fee:	464a      	mov	r2, r9
   b6ff0:	4620      	mov	r0, r4
   b6ff2:	f7ff fc2d 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
            printMenuItem(menuItem,true,!selectingBots,0,32,WaterBots.at(menuSelect));      //Print middle menu item as highlighted
   b6ff6:	4631      	mov	r1, r6
   b6ff8:	4818      	ldr	r0, [pc, #96]	; (b705c <_Z10updateMenuv+0x35c>)
   b6ffa:	f897 9000 	ldrb.w	r9, [r7]
   b6ffe:	f7fd ff73 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b7002:	f898 4000 	ldrb.w	r4, [r8]
   b7006:	4601      	mov	r1, r0
   b7008:	2250      	movs	r2, #80	; 0x50
   b700a:	4628      	mov	r0, r5
   b700c:	f007 ff4d 	bl	beeaa <memcpy>
   b7010:	f084 0401 	eor.w	r4, r4, #1
   b7014:	2320      	movs	r3, #32
   b7016:	4622      	mov	r2, r4
   b7018:	9300      	str	r3, [sp, #0]
   b701a:	2101      	movs	r1, #1
   b701c:	2300      	movs	r3, #0
   b701e:	4648      	mov	r0, r9
   b7020:	f7ff fc16 	bl	b6850 <_Z13printMenuItemhbbtt8WaterBot>
            printMenuItem(menuItem-1,false,!selectingBots,0,16,WaterBots.at(menuSelect));   //Print top menu item as unhighlighted
   b7024:	4631      	mov	r1, r6
   b7026:	480d      	ldr	r0, [pc, #52]	; (b705c <_Z10updateMenuv+0x35c>)
   b7028:	f7fd ff5e 	bl	b4ee8 <_ZNSt6vectorI8WaterBotSaIS0_EE2atEj>
   b702c:	f898 6000 	ldrb.w	r6, [r8]
   b7030:	783c      	ldrb	r4, [r7, #0]
   b7032:	4601      	mov	r1, r0
   b7034:	f086 0601 	eor.w	r6, r6, #1
   b7038:	3c01      	subs	r4, #1
   b703a:	e7b7      	b.n	b6fac <_Z10updateMenuv+0x2ac>
   b703c:	2003de5c 	.word	0x2003de5c
   b7040:	2003dcc4 	.word	0x2003dcc4
   b7044:	002d0030 	.word	0x002d0030
   b7048:	000c13f4 	.word	0x000c13f4
   b704c:	cccccccd 	.word	0xcccccccd
   b7050:	000c13a1 	.word	0x000c13a1
   b7054:	2003de05 	.word	0x2003de05
   b7058:	2003dcac 	.word	0x2003dcac
   b705c:	2003dce4 	.word	0x2003dce4
   b7060:	2003daab 	.word	0x2003daab
   b7064:	2003daaa 	.word	0x2003daaa
   b7068:	2003dd64 	.word	0x2003dd64

000b706c <loop>:
void loop() {
   b706c:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(postStatus){                                     //Check if the timer has indicated that a status update should be sent
   b706e:	4d3a      	ldr	r5, [pc, #232]	; (b7158 <loop+0xec>)
   b7070:	782b      	ldrb	r3, [r5, #0]
void loop() {
   b7072:	b087      	sub	sp, #28
    if(postStatus){                                     //Check if the timer has indicated that a status update should be sent
   b7074:	b143      	cbz	r3, b7088 <loop+0x1c>
        sendData("CCABspc",0,false,true,false);         //Call send data to send data over XBee, which helps to check if XBee is available
   b7076:	2400      	movs	r4, #0
   b7078:	4838      	ldr	r0, [pc, #224]	; (b715c <loop+0xf0>)
   b707a:	9400      	str	r4, [sp, #0]
   b707c:	2301      	movs	r3, #1
   b707e:	4622      	mov	r2, r4
   b7080:	4621      	mov	r1, r4
   b7082:	f7fd fd09 	bl	b4a98 <_Z8sendDataPKchbbb>
        postStatus = false;                             //Set flag false until time expires again
   b7086:	702c      	strb	r4, [r5, #0]
    updateMenu();                                       //Function to update all redrawing of the menu, triggered whenever buttons are pressed or an interrupt modifies something displayed on the menu
   b7088:	f7ff fe3a 	bl	b6d00 <_Z10updateMenuv>
    updateBotControl();                                 //Function to send out the control packet to each of the bots periodically. The control packet will set items like the drive mode and also change the LED state
   b708c:	f7fd ff40 	bl	b4f10 <_Z16updateBotControlv>
    manualMotorControl(botSelect);                      //Function to control motors from the joystick if the selected bot is in manual motor control mode
   b7090:	4b33      	ldr	r3, [pc, #204]	; (b7160 <loop+0xf4>)
   b7092:	7818      	ldrb	r0, [r3, #0]
   b7094:	f7fd fd6a 	bl	b4b6c <_Z18manualMotorControlh>
    if(!BLE.connected()) {                              //If bluetooth is not connected, then periodically scan for bots so at least one may have bluetooth
   b7098:	f004 f944 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   b709c:	f004 f9ef 	bl	bb47e <_ZNK8particle14BleLocalDevice9connectedEv>
   b70a0:	b970      	cbnz	r0, b70c0 <loop+0x54>
    	if (millis() - lastScan >= BLE_SCAN_PERIOD) {   //Check timer between scans to not scan too often
   b70a2:	4c30      	ldr	r4, [pc, #192]	; (b7164 <loop+0xf8>)
   b70a4:	f002 fe6c 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b70a8:	6823      	ldr	r3, [r4, #0]
   b70aa:	1ac0      	subs	r0, r0, r3
   b70ac:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
   b70b0:	d306      	bcc.n	b70c0 <loop+0x54>
   b70b2:	f002 fe65 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
    		lastScan = millis();
   b70b6:	6020      	str	r0, [r4, #0]
    		BLEScan(-1);                                //Scan for any bot
   b70b8:	f04f 30ff 	mov.w	r0, #4294967295
   b70bc:	f7fe fe5e 	bl	b5d7c <_Z7BLEScani>
      : _M_current(__i) { }
   b70c0:	4b29      	ldr	r3, [pc, #164]	; (b7168 <loop+0xfc>)
            sprintf(tempBuf,"CCB%dsns",wb.reqActive);   //Send sense command which makes the request
   b70c2:	4f2a      	ldr	r7, [pc, #168]	; (b716c <loop+0x100>)
   b70c4:	e9d3 4600 	ldrd	r4, r6, [r3]
            wb.offloading = false;                      //Set flag back to false for this bot to not immediately offload again
   b70c8:	2500      	movs	r5, #0
    for(WaterBot &wb: WaterBots){                       //Loop over all bots and check for offloading or sensor requests
   b70ca:	42a6      	cmp	r6, r4
   b70cc:	d019      	beq.n	b7102 <loop+0x96>
        if(wb.offloading){                              //Check if the user requested an offload from the menu items
   b70ce:	7da3      	ldrb	r3, [r4, #22]
   b70d0:	b11b      	cbz	r3, b70da <loop+0x6e>
            DataOffloader(wb.botNum);                   //Offload from this bot
   b70d2:	78a0      	ldrb	r0, [r4, #2]
   b70d4:	f7fe ff3e 	bl	b5f54 <_Z13DataOffloaderh>
            wb.offloading = false;                      //Set flag back to false for this bot to not immediately offload again
   b70d8:	75a5      	strb	r5, [r4, #22]
        if(wb.reqActive > 3){                           //Check if we should re-request the live sensor data from this bot
   b70da:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
   b70de:	2a03      	cmp	r2, #3
   b70e0:	d90d      	bls.n	b70fe <loop+0x92>
            sprintf(tempBuf,"CCB%dsns",wb.reqActive);   //Send sense command which makes the request
   b70e2:	4639      	mov	r1, r7
   b70e4:	a803      	add	r0, sp, #12
   b70e6:	f003 f999 	bl	ba41c <sprintf>
            sendData(tempBuf,0,!(wb.XBeeAvail), true, false);
   b70ea:	7a62      	ldrb	r2, [r4, #9]
   b70ec:	9500      	str	r5, [sp, #0]
   b70ee:	2301      	movs	r3, #1
   b70f0:	405a      	eors	r2, r3
   b70f2:	2100      	movs	r1, #0
   b70f4:	a803      	add	r0, sp, #12
   b70f6:	f7fd fccf 	bl	b4a98 <_Z8sendDataPKchbbb>
            wb.reqActive = 0;                           //Set the request active to false so it only happens at the timer intervals
   b70fa:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
      operator++() _GLIBCXX_NOEXCEPT
   b70fe:	3450      	adds	r4, #80	; 0x50
	return *this;
   b7100:	e7e3      	b.n	b70ca <loop+0x5e>
    XBeeHandler();                                      //Check XBee serial buffer and process serial data to the command dictionary if a command was received
   b7102:	f7fe fd45 	bl	b5b90 <_Z11XBeeHandlerv>
    RPiHandler();                                       //Check USB serial to see if Raspberry Pi or computer has sent a new control packet which contains the drive mode and target latitude and longitude
   b7106:	f7fd fc6b 	bl	b49e0 <_Z10RPiHandlerv>
    XBeeLTEPairSet();                                   //Call pair function to see if any bots have come online after the initial pair sequence
   b710a:	f7fd fec1 	bl	b4e90 <_Z14XBeeLTEPairSetv>
    RPiStatusUpdate();                                  //Periodically send a status update for all of the bots to the Raspberry Pi so the user interface is populated with recent data and status
   b710e:	f7fd fc01 	bl	b4914 <_Z15RPiStatusUpdatev>
    if(stopActive){                                     //If the user has pressed the stop button and has not yet cleared it, periodically publish the stop button in case the bot missed the previous message
   b7112:	4b17      	ldr	r3, [pc, #92]	; (b7170 <loop+0x104>)
   b7114:	781b      	ldrb	r3, [r3, #0]
   b7116:	b1c3      	cbz	r3, b714a <loop+0xde>
        if(millis() - stopTime > STOP_PUB_TIME){        //Check timer to publish periodically, stops sending periodically after being cleared by hitting stop again
   b7118:	4c16      	ldr	r4, [pc, #88]	; (b7174 <loop+0x108>)
   b711a:	f002 fe31 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b711e:	6823      	ldr	r3, [r4, #0]
   b7120:	1ac0      	subs	r0, r0, r3
   b7122:	f241 3388 	movw	r3, #5000	; 0x1388
   b7126:	4298      	cmp	r0, r3
   b7128:	d90f      	bls.n	b714a <loop+0xde>
   b712a:	f002 fe29 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
            stopTime = millis();
   b712e:	6020      	str	r0, [r4, #0]
            sendData("CCABstp",0,true,true,!LTEStopSent); 
   b7130:	4c11      	ldr	r4, [pc, #68]	; (b7178 <loop+0x10c>)
   b7132:	4812      	ldr	r0, [pc, #72]	; (b717c <loop+0x110>)
   b7134:	7823      	ldrb	r3, [r4, #0]
   b7136:	f083 0301 	eor.w	r3, r3, #1
   b713a:	9300      	str	r3, [sp, #0]
   b713c:	2301      	movs	r3, #1
   b713e:	461a      	mov	r2, r3
   b7140:	2100      	movs	r1, #0
   b7142:	f7fd fca9 	bl	b4a98 <_Z8sendDataPKchbbb>
            LTEStopSent = true;                         //Only send stop over LTE one time so we don't burn through cell data
   b7146:	2301      	movs	r3, #1
   b7148:	7023      	strb	r3, [r4, #0]
    delay(10);
   b714a:	200a      	movs	r0, #10
}
   b714c:	b007      	add	sp, #28
   b714e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    delay(10);
   b7152:	f006 b881 	b.w	bd258 <delay>
   b7156:	bf00      	nop
   b7158:	2003ded4 	.word	0x2003ded4
   b715c:	000c13f7 	.word	0x000c13f7
   b7160:	2003dd64 	.word	0x2003dd64
   b7164:	2003dd98 	.word	0x2003dd98
   b7168:	2003dce4 	.word	0x2003dce4
   b716c:	000c13ff 	.word	0x000c13ff
   b7170:	2003e631 	.word	0x2003e631
   b7174:	2003e634 	.word	0x2003e634
   b7178:	2003dca9 	.word	0x2003dca9
   b717c:	000c1408 	.word	0x000c1408

000b7180 <_ZN17Adafruit_GrayOLED9drawPixelEsst>:
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_GrayOLED::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
   b7180:	2900      	cmp	r1, #0
void Adafruit_GrayOLED::drawPixel(int16_t x, int16_t y, uint16_t color) {
   b7182:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
   b7184:	db66      	blt.n	b7254 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd4>
   b7186:	f9b0 400c 	ldrsh.w	r4, [r0, #12]
   b718a:	428c      	cmp	r4, r1
   b718c:	dd62      	ble.n	b7254 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd4>
   b718e:	2a00      	cmp	r2, #0
   b7190:	db60      	blt.n	b7254 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd4>
   b7192:	f9b0 400e 	ldrsh.w	r4, [r0, #14]
   b7196:	4294      	cmp	r4, r2
   b7198:	dd5c      	ble.n	b7254 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd4>
  /*!
    @brief      Get rotation setting for display
    @returns    0 thru 3 corresponding to 4 cardinal rotations
  */
  /************************************************************************/
  uint8_t getRotation(void) const { return rotation; }
   b719a:	7e84      	ldrb	r4, [r0, #26]
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
   b719c:	2c02      	cmp	r4, #2
   b719e:	d05a      	beq.n	b7256 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd6>
   b71a0:	2c03      	cmp	r4, #3
   b71a2:	d061      	beq.n	b7268 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xe8>
   b71a4:	2c01      	cmp	r4, #1
   b71a6:	d104      	bne.n	b71b2 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x32>
    case 1:
      grayoled_swap(x, y);
      x = WIDTH - x - 1;
   b71a8:	8904      	ldrh	r4, [r0, #8]
   b71aa:	43d2      	mvns	r2, r2
   b71ac:	4414      	add	r4, r2
      break;
   b71ae:	460a      	mov	r2, r1
      x = WIDTH - x - 1;
   b71b0:	b221      	sxth	r1, r4
      y = HEIGHT - y - 1;
      break;
    }

    // adjust dirty window
    window_x1 = min(window_x1, x);
   b71b2:	f9b0 4038 	ldrsh.w	r4, [r0, #56]	; 0x38
   b71b6:	428c      	cmp	r4, r1
   b71b8:	bfa8      	it	ge
   b71ba:	460c      	movge	r4, r1
   b71bc:	8704      	strh	r4, [r0, #56]	; 0x38
    window_y1 = min(window_y1, y);
   b71be:	f9b0 403a 	ldrsh.w	r4, [r0, #58]	; 0x3a
   b71c2:	4294      	cmp	r4, r2
   b71c4:	bfa8      	it	ge
   b71c6:	4614      	movge	r4, r2
   b71c8:	8744      	strh	r4, [r0, #58]	; 0x3a
    window_x2 = max(window_x2, x);
   b71ca:	f9b0 403c 	ldrsh.w	r4, [r0, #60]	; 0x3c
   b71ce:	428c      	cmp	r4, r1
   b71d0:	bfb8      	it	lt
   b71d2:	460c      	movlt	r4, r1
   b71d4:	8784      	strh	r4, [r0, #60]	; 0x3c
    window_y2 = max(window_y2, y);
   b71d6:	f9b0 403e 	ldrsh.w	r4, [r0, #62]	; 0x3e
   b71da:	4294      	cmp	r4, r2
   b71dc:	bfb8      	it	lt
   b71de:	4614      	movlt	r4, r2
   b71e0:	87c4      	strh	r4, [r0, #62]	; 0x3e

    if (_bpp == 1) {
   b71e2:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
   b71e6:	2c01      	cmp	r4, #1
   b71e8:	d116      	bne.n	b7218 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x98>
      switch (color) {
   b71ea:	2b01      	cmp	r3, #1
   b71ec:	d042      	beq.n	b7274 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xf4>
   b71ee:	2b02      	cmp	r3, #2
   b71f0:	d051      	beq.n	b7296 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x116>
   b71f2:	b98b      	cbnz	r3, b7218 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x98>
      case MONOOLED_WHITE:
        buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
        break;
      case MONOOLED_BLACK:
        buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));
   b71f4:	2a00      	cmp	r2, #0
   b71f6:	8905      	ldrh	r5, [r0, #8]
   b71f8:	6b47      	ldr	r7, [r0, #52]	; 0x34
   b71fa:	4614      	mov	r4, r2
   b71fc:	bfb8      	it	lt
   b71fe:	1dd4      	addlt	r4, r2, #7
   b7200:	10e4      	asrs	r4, r4, #3
   b7202:	fb14 1405 	smlabb	r4, r4, r5, r1
   b7206:	f002 0607 	and.w	r6, r2, #7
   b720a:	2501      	movs	r5, #1
   b720c:	fa05 f606 	lsl.w	r6, r5, r6
   b7210:	5d3d      	ldrb	r5, [r7, r4]
   b7212:	ea25 0506 	bic.w	r5, r5, r6
   b7216:	553d      	strb	r5, [r7, r4]
      case MONOOLED_INVERSE:
        buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
        break;
      }
    }
    if (_bpp == 4) {
   b7218:	f890 404c 	ldrb.w	r4, [r0, #76]	; 0x4c
   b721c:	2c04      	cmp	r4, #4
   b721e:	d119      	bne.n	b7254 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0xd4>
      uint8_t *pixelptr = &buffer[x / 2 + (y * WIDTH / 2)];
   b7220:	8904      	ldrh	r4, [r0, #8]
   b7222:	fb14 f202 	smulbb	r2, r4, r2
   b7226:	eb02 74d2 	add.w	r4, r2, r2, lsr #31
   b722a:	eb01 72d1 	add.w	r2, r1, r1, lsr #31
   b722e:	f342 024f 	sbfx	r2, r2, #1, #16
   b7232:	eb02 0264 	add.w	r2, r2, r4, asr #1
   b7236:	6b44      	ldr	r4, [r0, #52]	; 0x34
      // Serial.printf("(%d, %d) -> offset %d\n", x, y, x/2 + (y * WIDTH / 2));
      if (x % 2 == 0) { // even, left nibble
        uint8_t t = pixelptr[0] & 0x0F;
   b7238:	5ca0      	ldrb	r0, [r4, r2]
      if (x % 2 == 0) { // even, left nibble
   b723a:	07c9      	lsls	r1, r1, #31
        t |= (color & 0xF) << 4;
        pixelptr[0] = t;
      } else { // odd, right lower nibble
        uint8_t t = pixelptr[0] & 0xF0;
        t |= color & 0xF;
   b723c:	bf4b      	itete	mi
   b723e:	f003 030f 	andmi.w	r3, r3, #15
        uint8_t t = pixelptr[0] & 0x0F;
   b7242:	f000 000f 	andpl.w	r0, r0, #15
        uint8_t t = pixelptr[0] & 0xF0;
   b7246:	f020 000f 	bicmi.w	r0, r0, #15
        t |= (color & 0xF) << 4;
   b724a:	ea40 1303 	orrpl.w	r3, r0, r3, lsl #4
        t |= color & 0xF;
   b724e:	bf48      	it	mi
   b7250:	4303      	orrmi	r3, r0
        pixelptr[0] = t;
   b7252:	54a3      	strb	r3, [r4, r2]
      }
    }
  }
}
   b7254:	bdf0      	pop	{r4, r5, r6, r7, pc}
      x = WIDTH - x - 1;
   b7256:	8904      	ldrh	r4, [r0, #8]
   b7258:	3c01      	subs	r4, #1
   b725a:	1a61      	subs	r1, r4, r1
      y = HEIGHT - y - 1;
   b725c:	8944      	ldrh	r4, [r0, #10]
   b725e:	43d2      	mvns	r2, r2
   b7260:	4422      	add	r2, r4
      x = WIDTH - x - 1;
   b7262:	b209      	sxth	r1, r1
      y = HEIGHT - y - 1;
   b7264:	b212      	sxth	r2, r2
      break;
   b7266:	e7a4      	b.n	b71b2 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x32>
      y = HEIGHT - y - 1;
   b7268:	8944      	ldrh	r4, [r0, #10]
   b726a:	3c01      	subs	r4, #1
   b726c:	1a64      	subs	r4, r4, r1
      break;
   b726e:	4611      	mov	r1, r2
      y = HEIGHT - y - 1;
   b7270:	b222      	sxth	r2, r4
      break;
   b7272:	e79e      	b.n	b71b2 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x32>
        buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
   b7274:	2a00      	cmp	r2, #0
   b7276:	8905      	ldrh	r5, [r0, #8]
   b7278:	6b46      	ldr	r6, [r0, #52]	; 0x34
   b727a:	4614      	mov	r4, r2
   b727c:	bfb8      	it	lt
   b727e:	1dd4      	addlt	r4, r2, #7
   b7280:	10e4      	asrs	r4, r4, #3
   b7282:	fb14 1405 	smlabb	r4, r4, r5, r1
   b7286:	f002 0707 	and.w	r7, r2, #7
   b728a:	2501      	movs	r5, #1
   b728c:	40bd      	lsls	r5, r7
   b728e:	5d37      	ldrb	r7, [r6, r4]
   b7290:	433d      	orrs	r5, r7
        buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
   b7292:	5535      	strb	r5, [r6, r4]
        break;
   b7294:	e7c0      	b.n	b7218 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x98>
        buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
   b7296:	2a00      	cmp	r2, #0
   b7298:	8905      	ldrh	r5, [r0, #8]
   b729a:	6b46      	ldr	r6, [r0, #52]	; 0x34
   b729c:	4614      	mov	r4, r2
   b729e:	bfb8      	it	lt
   b72a0:	1dd4      	addlt	r4, r2, #7
   b72a2:	10e4      	asrs	r4, r4, #3
   b72a4:	fb14 1405 	smlabb	r4, r4, r5, r1
   b72a8:	f002 0707 	and.w	r7, r2, #7
   b72ac:	2501      	movs	r5, #1
   b72ae:	40bd      	lsls	r5, r7
   b72b0:	5d37      	ldrb	r7, [r6, r4]
   b72b2:	407d      	eors	r5, r7
   b72b4:	e7ed      	b.n	b7292 <_ZN17Adafruit_GrayOLED9drawPixelEsst+0x112>
	...

000b72b8 <_ZN17Adafruit_GrayOLEDC1EhttP7TwoWireamm>:
Adafruit_GrayOLED::Adafruit_GrayOLED(uint8_t bpp, uint16_t w, uint16_t h,
   b72b8:	b538      	push	{r3, r4, r5, lr}
   b72ba:	460d      	mov	r5, r1
   b72bc:	4611      	mov	r1, r2
   b72be:	4604      	mov	r4, r0
      buffer(NULL), dcPin(-1), csPin(-1), rstPin(rst_pin), _bpp(bpp) {
   b72c0:	b21a      	sxth	r2, r3
   b72c2:	b209      	sxth	r1, r1
   b72c4:	f000 fa98 	bl	b77f8 <_ZN12Adafruit_GFXC1Ess>
   b72c8:	9a06      	ldr	r2, [sp, #24]
   b72ca:	4b0b      	ldr	r3, [pc, #44]	; (b72f8 <_ZN17Adafruit_GrayOLEDC1EhttP7TwoWireamm+0x40>)
   b72cc:	62e2      	str	r2, [r4, #44]	; 0x2c
   b72ce:	9a07      	ldr	r2, [sp, #28]
   b72d0:	6023      	str	r3, [r4, #0]
   b72d2:	2300      	movs	r3, #0
   b72d4:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
   b72d8:	e9c4 230c 	strd	r2, r3, [r4, #48]	; 0x30
   b72dc:	f04f 33ff 	mov.w	r3, #4294967295
   b72e0:	e9c4 3310 	strd	r3, r3, [r4, #64]	; 0x40
   b72e4:	f99d 3014 	ldrsb.w	r3, [sp, #20]
   b72e8:	64a3      	str	r3, [r4, #72]	; 0x48
  _theWire = twi;
   b72ea:	9b04      	ldr	r3, [sp, #16]
      buffer(NULL), dcPin(-1), csPin(-1), rstPin(rst_pin), _bpp(bpp) {
   b72ec:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  _theWire = twi;
   b72f0:	6523      	str	r3, [r4, #80]	; 0x50
}
   b72f2:	4620      	mov	r0, r4
   b72f4:	bd38      	pop	{r3, r4, r5, pc}
   b72f6:	bf00      	nop
   b72f8:	000c153c 	.word	0x000c153c

000b72fc <_ZN17Adafruit_GrayOLEDD1Ev>:
Adafruit_GrayOLED::~Adafruit_GrayOLED(void) {
   b72fc:	b538      	push	{r3, r4, r5, lr}
   b72fe:	4b0c      	ldr	r3, [pc, #48]	; (b7330 <_ZN17Adafruit_GrayOLEDD1Ev+0x34>)
   b7300:	6003      	str	r3, [r0, #0]
   b7302:	4604      	mov	r4, r0
  if (buffer) {
   b7304:	6b40      	ldr	r0, [r0, #52]	; 0x34
   b7306:	b118      	cbz	r0, b7310 <_ZN17Adafruit_GrayOLEDD1Ev+0x14>
    free(buffer);
   b7308:	f003 f878 	bl	ba3fc <free>
    buffer = NULL;
   b730c:	2300      	movs	r3, #0
   b730e:	6363      	str	r3, [r4, #52]	; 0x34
  if (spi_dev)
   b7310:	6a65      	ldr	r5, [r4, #36]	; 0x24
   b7312:	b135      	cbz	r5, b7322 <_ZN17Adafruit_GrayOLEDD1Ev+0x26>
    delete spi_dev;
   b7314:	4628      	mov	r0, r5
   b7316:	f000 fe5a 	bl	b7fce <_ZN18Adafruit_SPIDeviceD1Ev>
   b731a:	2138      	movs	r1, #56	; 0x38
   b731c:	4628      	mov	r0, r5
   b731e:	f7fc febe 	bl	b409e <_ZdlPvj>
  if (i2c_dev)
   b7322:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   b7324:	b110      	cbz	r0, b732c <_ZN17Adafruit_GrayOLEDD1Ev+0x30>
    delete i2c_dev;
   b7326:	2110      	movs	r1, #16
   b7328:	f7fc feb9 	bl	b409e <_ZdlPvj>
}
   b732c:	4620      	mov	r0, r4
   b732e:	bd38      	pop	{r3, r4, r5, pc}
   b7330:	000c153c 	.word	0x000c153c

000b7334 <_ZN17Adafruit_GrayOLED12oled_commandEh>:
void Adafruit_GrayOLED::oled_command(uint8_t c) {
   b7334:	b530      	push	{r4, r5, lr}
   b7336:	b087      	sub	sp, #28
  if (i2c_dev) {                // I2C
   b7338:	6a85      	ldr	r5, [r0, #40]	; 0x28
void Adafruit_GrayOLED::oled_command(uint8_t c) {
   b733a:	f88d 100f 	strb.w	r1, [sp, #15]
   b733e:	4604      	mov	r4, r0
  if (i2c_dev) {                // I2C
   b7340:	b17d      	cbz	r5, b7362 <_ZN17Adafruit_GrayOLED12oled_commandEh+0x2e>
    uint8_t buf[2] = {0x00, c}; // Co = 0, D/C = 0
   b7342:	2300      	movs	r3, #0
   b7344:	b2ca      	uxtb	r2, r1
    i2c_dev->write(buf, 2);
   b7346:	e9cd 3300 	strd	r3, r3, [sp]
    uint8_t buf[2] = {0x00, c}; // Co = 0, D/C = 0
   b734a:	f88d 3014 	strb.w	r3, [sp, #20]
   b734e:	f88d 2015 	strb.w	r2, [sp, #21]
    i2c_dev->write(buf, 2);
   b7352:	2301      	movs	r3, #1
   b7354:	2202      	movs	r2, #2
   b7356:	a905      	add	r1, sp, #20
   b7358:	4628      	mov	r0, r5
   b735a:	f000 ff8f 	bl	b827c <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j>
}
   b735e:	b007      	add	sp, #28
   b7360:	bd30      	pop	{r4, r5, pc}
    digitalWrite(dcPin, LOW);
   b7362:	4629      	mov	r1, r5
   b7364:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
   b7368:	f006 fe11 	bl	bdf8e <digitalWrite>
    spi_dev->write(&c, 1);
   b736c:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b736e:	9500      	str	r5, [sp, #0]
   b7370:	462b      	mov	r3, r5
   b7372:	2201      	movs	r2, #1
   b7374:	f10d 010f 	add.w	r1, sp, #15
   b7378:	f000 ff23 	bl	b81c2 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j>
}
   b737c:	e7ef      	b.n	b735e <_ZN17Adafruit_GrayOLED12oled_commandEh+0x2a>

000b737e <_ZN17Adafruit_GrayOLED13invertDisplayEb>:
            different pixel mode of the display hardware is used. When
            enabled, drawing MONOOLED_BLACK (value 0) pixels will actually draw
   white, MONOOLED_WHITE (value 1) will draw black.
*/
void Adafruit_GrayOLED::invertDisplay(bool i) {
  oled_command(i ? GRAYOLED_INVERTDISPLAY : GRAYOLED_NORMALDISPLAY);
   b737e:	2900      	cmp	r1, #0
   b7380:	bf14      	ite	ne
   b7382:	21a7      	movne	r1, #167	; 0xa7
   b7384:	21a6      	moveq	r1, #166	; 0xa6
   b7386:	f7ff bfd5 	b.w	b7334 <_ZN17Adafruit_GrayOLED12oled_commandEh>

000b738a <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh>:
bool Adafruit_GrayOLED::oled_commandList(const uint8_t *c, uint8_t n) {
   b738a:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (i2c_dev) {            // I2C
   b738c:	6a85      	ldr	r5, [r0, #40]	; 0x28
bool Adafruit_GrayOLED::oled_commandList(const uint8_t *c, uint8_t n) {
   b738e:	b085      	sub	sp, #20
   b7390:	4604      	mov	r4, r0
   b7392:	460e      	mov	r6, r1
   b7394:	4617      	mov	r7, r2
  if (i2c_dev) {            // I2C
   b7396:	b165      	cbz	r5, b73b2 <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh+0x28>
    uint8_t dc_byte = 0x00; // Co = 0, D/C = 0
   b7398:	2300      	movs	r3, #0
    if (!i2c_dev->write((uint8_t *)c, n, true, &dc_byte, 1)) {
   b739a:	f10d 000f 	add.w	r0, sp, #15
    uint8_t dc_byte = 0x00; // Co = 0, D/C = 0
   b739e:	f88d 300f 	strb.w	r3, [sp, #15]
    if (!i2c_dev->write((uint8_t *)c, n, true, &dc_byte, 1)) {
   b73a2:	2301      	movs	r3, #1
   b73a4:	9000      	str	r0, [sp, #0]
   b73a6:	9301      	str	r3, [sp, #4]
   b73a8:	4628      	mov	r0, r5
   b73aa:	f000 ff67 	bl	b827c <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j>
}
   b73ae:	b005      	add	sp, #20
   b73b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    digitalWrite(dcPin, LOW);
   b73b2:	4629      	mov	r1, r5
   b73b4:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
   b73b8:	f006 fde9 	bl	bdf8e <digitalWrite>
    if (!spi_dev->write((uint8_t *)c, n)) {
   b73bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b73be:	9500      	str	r5, [sp, #0]
   b73c0:	462b      	mov	r3, r5
   b73c2:	463a      	mov	r2, r7
   b73c4:	4631      	mov	r1, r6
   b73c6:	f000 fefc 	bl	b81c2 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j>
   b73ca:	e7f0      	b.n	b73ae <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh+0x24>

000b73cc <_ZN17Adafruit_GrayOLED12clearDisplayEv>:
void Adafruit_GrayOLED::clearDisplay(void) {
   b73cc:	b510      	push	{r4, lr}
  memset(buffer, 0, _bpp * WIDTH * ((HEIGHT + 7) / 8));
   b73ce:	f9b0 100a 	ldrsh.w	r1, [r0, #10]
   b73d2:	8903      	ldrh	r3, [r0, #8]
   b73d4:	f890 204c 	ldrb.w	r2, [r0, #76]	; 0x4c
   b73d8:	fb12 f203 	smulbb	r2, r2, r3
   b73dc:	1dcb      	adds	r3, r1, #7
   b73de:	bf48      	it	mi
   b73e0:	f101 030e 	addmi.w	r3, r1, #14
   b73e4:	10db      	asrs	r3, r3, #3
void Adafruit_GrayOLED::clearDisplay(void) {
   b73e6:	4604      	mov	r4, r0
  memset(buffer, 0, _bpp * WIDTH * ((HEIGHT + 7) / 8));
   b73e8:	435a      	muls	r2, r3
   b73ea:	6b40      	ldr	r0, [r0, #52]	; 0x34
   b73ec:	2100      	movs	r1, #0
   b73ee:	f007 fd84 	bl	beefa <memset>
  window_x1 = 0;
   b73f2:	2300      	movs	r3, #0
   b73f4:	63a3      	str	r3, [r4, #56]	; 0x38
  window_x2 = WIDTH - 1;
   b73f6:	8923      	ldrh	r3, [r4, #8]
   b73f8:	3b01      	subs	r3, #1
   b73fa:	87a3      	strh	r3, [r4, #60]	; 0x3c
  window_y2 = HEIGHT - 1;
   b73fc:	8963      	ldrh	r3, [r4, #10]
   b73fe:	3b01      	subs	r3, #1
   b7400:	87e3      	strh	r3, [r4, #62]	; 0x3e
}
   b7402:	bd10      	pop	{r4, pc}

000b7404 <_ZN17Adafruit_GrayOLED5_initEhb>:
bool Adafruit_GrayOLED::_init(uint8_t addr, bool reset) {
   b7404:	b570      	push	{r4, r5, r6, lr}
  if ((!buffer) &&
   b7406:	6b43      	ldr	r3, [r0, #52]	; 0x34
bool Adafruit_GrayOLED::_init(uint8_t addr, bool reset) {
   b7408:	4604      	mov	r4, r0
   b740a:	460e      	mov	r6, r1
   b740c:	4615      	mov	r5, r2
  if ((!buffer) &&
   b740e:	b30b      	cbz	r3, b7454 <_ZN17Adafruit_GrayOLED5_initEhb+0x50>
  if (reset && (rstPin >= 0)) {
   b7410:	2d00      	cmp	r5, #0
   b7412:	d133      	bne.n	b747c <_ZN17Adafruit_GrayOLED5_initEhb+0x78>
  if (_theWire) { // using I2C
   b7414:	6d23      	ldr	r3, [r4, #80]	; 0x50
   b7416:	2b00      	cmp	r3, #0
   b7418:	d050      	beq.n	b74bc <_ZN17Adafruit_GrayOLED5_initEhb+0xb8>
    i2c_dev = new Adafruit_I2CDevice(addr, _theWire);
   b741a:	2010      	movs	r0, #16
   b741c:	f7fc fe3b 	bl	b4096 <_Znwj>
   b7420:	4605      	mov	r5, r0
   b7422:	b118      	cbz	r0, b742c <_ZN17Adafruit_GrayOLED5_initEhb+0x28>
   b7424:	6d22      	ldr	r2, [r4, #80]	; 0x50
   b7426:	4631      	mov	r1, r6
   b7428:	f000 fefd 	bl	b8226 <_ZN18Adafruit_I2CDeviceC1EhP7TwoWire>
   b742c:	62a5      	str	r5, [r4, #40]	; 0x28
    if (!i2c_dev || !i2c_dev->begin()) {
   b742e:	b31d      	cbz	r5, b7478 <_ZN17Adafruit_GrayOLED5_initEhb+0x74>
   b7430:	2101      	movs	r1, #1
   b7432:	4628      	mov	r0, r5
   b7434:	f000 ff13 	bl	b825e <_ZN18Adafruit_I2CDevice5beginEb>
   b7438:	b1f0      	cbz	r0, b7478 <_ZN17Adafruit_GrayOLED5_initEhb+0x74>
  clearDisplay();
   b743a:	4620      	mov	r0, r4
   b743c:	f7ff ffc6 	bl	b73cc <_ZN17Adafruit_GrayOLED12clearDisplayEv>
  window_x1 = 0;
   b7440:	2300      	movs	r3, #0
   b7442:	63a3      	str	r3, [r4, #56]	; 0x38
  window_x2 = WIDTH - 1;
   b7444:	8923      	ldrh	r3, [r4, #8]
   b7446:	3b01      	subs	r3, #1
   b7448:	87a3      	strh	r3, [r4, #60]	; 0x3c
  window_y2 = HEIGHT - 1;
   b744a:	8963      	ldrh	r3, [r4, #10]
   b744c:	3b01      	subs	r3, #1
   b744e:	87e3      	strh	r3, [r4, #62]	; 0x3e
  return true; // Success
   b7450:	2001      	movs	r0, #1
   b7452:	e012      	b.n	b747a <_ZN17Adafruit_GrayOLED5_initEhb+0x76>
      !(buffer = (uint8_t *)malloc(_bpp * WIDTH * ((HEIGHT + 7) / 8)))) {
   b7454:	8923      	ldrh	r3, [r4, #8]
   b7456:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
   b745a:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
   b745e:	fb10 f003 	smulbb	r0, r0, r3
   b7462:	1dd3      	adds	r3, r2, #7
   b7464:	bf48      	it	mi
   b7466:	f102 030e 	addmi.w	r3, r2, #14
   b746a:	10db      	asrs	r3, r3, #3
   b746c:	4358      	muls	r0, r3
   b746e:	f002 ffbd 	bl	ba3ec <malloc>
   b7472:	6360      	str	r0, [r4, #52]	; 0x34
  if ((!buffer) &&
   b7474:	2800      	cmp	r0, #0
   b7476:	d1cb      	bne.n	b7410 <_ZN17Adafruit_GrayOLED5_initEhb+0xc>
    return false;
   b7478:	2000      	movs	r0, #0
}
   b747a:	bd70      	pop	{r4, r5, r6, pc}
  if (reset && (rstPin >= 0)) {
   b747c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   b747e:	2800      	cmp	r0, #0
   b7480:	dbc8      	blt.n	b7414 <_ZN17Adafruit_GrayOLED5_initEhb+0x10>
    pinMode(rstPin, OUTPUT);
   b7482:	2101      	movs	r1, #1
   b7484:	b280      	uxth	r0, r0
   b7486:	f006 fd71 	bl	bdf6c <pinMode>
    digitalWrite(rstPin, HIGH);
   b748a:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
   b748e:	2101      	movs	r1, #1
   b7490:	f006 fd7d 	bl	bdf8e <digitalWrite>
    delay(10);                  // VDD goes high at start, pause
   b7494:	200a      	movs	r0, #10
   b7496:	f005 fedf 	bl	bd258 <delay>
    digitalWrite(rstPin, LOW);  // Bring reset low
   b749a:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
   b749e:	2100      	movs	r1, #0
   b74a0:	f006 fd75 	bl	bdf8e <digitalWrite>
    delay(10);                  // Wait 10 ms
   b74a4:	200a      	movs	r0, #10
   b74a6:	f005 fed7 	bl	bd258 <delay>
    digitalWrite(rstPin, HIGH); // Bring out of reset
   b74aa:	f8b4 0048 	ldrh.w	r0, [r4, #72]	; 0x48
   b74ae:	2101      	movs	r1, #1
   b74b0:	f006 fd6d 	bl	bdf8e <digitalWrite>
    delay(10);
   b74b4:	200a      	movs	r0, #10
   b74b6:	f005 fecf 	bl	bd258 <delay>
   b74ba:	e7ab      	b.n	b7414 <_ZN17Adafruit_GrayOLED5_initEhb+0x10>
    if (!spi_dev || !spi_dev->begin()) {
   b74bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b74be:	2800      	cmp	r0, #0
   b74c0:	d0da      	beq.n	b7478 <_ZN17Adafruit_GrayOLED5_initEhb+0x74>
   b74c2:	f000 fd8d 	bl	b7fe0 <_ZN18Adafruit_SPIDevice5beginEv>
   b74c6:	2800      	cmp	r0, #0
   b74c8:	d0d6      	beq.n	b7478 <_ZN17Adafruit_GrayOLED5_initEhb+0x74>
    pinMode(dcPin, OUTPUT); // Set data/command pin as output
   b74ca:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
   b74ce:	2101      	movs	r1, #1
   b74d0:	f006 fd4c 	bl	bdf6c <pinMode>
   b74d4:	e7b1      	b.n	b743a <_ZN17Adafruit_GrayOLED5_initEhb+0x36>

000b74d6 <_ZN17Adafruit_GrayOLED11setContrastEh>:
    @brief  Adjust the display contrast.
    @param  level The contrast level from 0 to 0x7F
    @note   This has an immediate effect on the display, no need to call the
            display() function -- buffer contents are not changed.
*/
void Adafruit_GrayOLED::setContrast(uint8_t level) {
   b74d6:	b507      	push	{r0, r1, r2, lr}
  uint8_t cmd[] = {GRAYOLED_SETCONTRAST, level};
   b74d8:	2381      	movs	r3, #129	; 0x81
   b74da:	f88d 1005 	strb.w	r1, [sp, #5]
  oled_commandList(cmd, 2);
   b74de:	2202      	movs	r2, #2
   b74e0:	a901      	add	r1, sp, #4
  uint8_t cmd[] = {GRAYOLED_SETCONTRAST, level};
   b74e2:	f88d 3004 	strb.w	r3, [sp, #4]
  oled_commandList(cmd, 2);
   b74e6:	f7ff ff50 	bl	b738a <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh>
}
   b74ea:	b003      	add	sp, #12
   b74ec:	f85d fb04 	ldr.w	pc, [sp], #4

000b74f0 <_ZN12Adafruit_GFX9writeLineEsssst>:
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
   b74f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b74f4:	b085      	sub	sp, #20
   b74f6:	461f      	mov	r7, r3
   b74f8:	f9bd 8038 	ldrsh.w	r8, [sp, #56]	; 0x38
   b74fc:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
#if defined(ESP8266)
    yield();
#endif
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
   b7500:	eba8 0902 	sub.w	r9, r8, r2
   b7504:	eba7 0a01 	sub.w	sl, r7, r1
   b7508:	f1b9 0f00 	cmp.w	r9, #0
   b750c:	bfb8      	it	lt
   b750e:	f1c9 0900 	rsblt	r9, r9, #0
   b7512:	f1ba 0f00 	cmp.w	sl, #0
   b7516:	bfb8      	it	lt
   b7518:	f1ca 0a00 	rsblt	sl, sl, #0
    if (steep) {
   b751c:	45d1      	cmp	r9, sl
        uint16_t color) {
   b751e:	4683      	mov	fp, r0
   b7520:	460c      	mov	r4, r1
   b7522:	4615      	mov	r5, r2
    if (steep) {
   b7524:	dd04      	ble.n	b7530 <_ZN12Adafruit_GFX9writeLineEsssst+0x40>
   b7526:	463a      	mov	r2, r7
        _swap_int16_t(x0, y0);
   b7528:	462c      	mov	r4, r5
        _swap_int16_t(x1, y1);
   b752a:	4647      	mov	r7, r8
        _swap_int16_t(x0, y0);
   b752c:	460d      	mov	r5, r1
        _swap_int16_t(x1, y1);
   b752e:	4690      	mov	r8, r2
    }

    if (x0 > x1) {
   b7530:	42bc      	cmp	r4, r7
   b7532:	dd05      	ble.n	b7540 <_ZN12Adafruit_GFX9writeLineEsssst+0x50>
   b7534:	462a      	mov	r2, r5
        _swap_int16_t(x0, x1);
        _swap_int16_t(y0, y1);
   b7536:	4645      	mov	r5, r8
   b7538:	4690      	mov	r8, r2
    if (x0 > x1) {
   b753a:	4622      	mov	r2, r4
   b753c:	463c      	mov	r4, r7
   b753e:	4617      	mov	r7, r2
    }

    int16_t dx, dy;
    dx = x1 - x0;
   b7540:	1b3e      	subs	r6, r7, r4
   b7542:	b2b2      	uxth	r2, r6
   b7544:	9200      	str	r2, [sp, #0]
    dy = abs(y1 - y0);
   b7546:	eba8 0205 	sub.w	r2, r8, r5
   b754a:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
   b754e:	eba1 71e2 	sub.w	r1, r1, r2, asr #31

    int16_t err = dx / 2;
   b7552:	f3c6 32c0 	ubfx	r2, r6, #15, #1
   b7556:	fa02 f686 	sxtah	r6, r2, r6
    int16_t ystep;

    if (y0 < y1) {
        ystep = 1;
    } else {
        ystep = -1;
   b755a:	4545      	cmp	r5, r8
   b755c:	bfb4      	ite	lt
   b755e:	2201      	movlt	r2, #1
   b7560:	f04f 32ff 	movge.w	r2, #4294967295
    dy = abs(y1 - y0);
   b7564:	9101      	str	r1, [sp, #4]
    int16_t err = dx / 2;
   b7566:	1076      	asrs	r6, r6, #1
        ystep = -1;
   b7568:	9202      	str	r2, [sp, #8]
    }

    for (; x0<=x1; x0++) {
   b756a:	42bc      	cmp	r4, r7
   b756c:	dc1c      	bgt.n	b75a8 <_ZN12Adafruit_GFX9writeLineEsssst+0xb8>
        if (steep) {
            writePixel(y0, x0, color);
   b756e:	f8db 2000 	ldr.w	r2, [fp]
   b7572:	9303      	str	r3, [sp, #12]
        if (steep) {
   b7574:	45d1      	cmp	r9, sl
            writePixel(y0, x0, color);
   b7576:	f8d2 8018 	ldr.w	r8, [r2, #24]
   b757a:	bfc7      	ittee	gt
   b757c:	4629      	movgt	r1, r5
   b757e:	4622      	movgt	r2, r4
        } else {
            writePixel(x0, y0, color);
   b7580:	462a      	movle	r2, r5
   b7582:	4621      	movle	r1, r4
   b7584:	4658      	mov	r0, fp
   b7586:	47c0      	blx	r8
        }
        err -= dy;
   b7588:	9a01      	ldr	r2, [sp, #4]
            writePixel(x0, y0, color);
   b758a:	9b03      	ldr	r3, [sp, #12]
        err -= dy;
   b758c:	1ab6      	subs	r6, r6, r2
   b758e:	b2b1      	uxth	r1, r6
   b7590:	b236      	sxth	r6, r6
        if (err < 0) {
   b7592:	2e00      	cmp	r6, #0
   b7594:	da05      	bge.n	b75a2 <_ZN12Adafruit_GFX9writeLineEsssst+0xb2>
            y0 += ystep;
   b7596:	9a02      	ldr	r2, [sp, #8]
   b7598:	4415      	add	r5, r2
            err += dx;
   b759a:	9a00      	ldr	r2, [sp, #0]
   b759c:	1856      	adds	r6, r2, r1
            y0 += ystep;
   b759e:	b22d      	sxth	r5, r5
            err += dx;
   b75a0:	b236      	sxth	r6, r6
    for (; x0<=x1; x0++) {
   b75a2:	3401      	adds	r4, #1
   b75a4:	b224      	sxth	r4, r4
   b75a6:	e7e0      	b.n	b756a <_ZN12Adafruit_GFX9writeLineEsssst+0x7a>
        }
    }
}
   b75a8:	b005      	add	sp, #20
   b75aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000b75ae <_ZN12Adafruit_GFX10startWriteEv>:
/*!
   @brief    Start a display-writing routine, overwrite in subclasses.
*/
/**************************************************************************/
void Adafruit_GFX::startWrite(){
}
   b75ae:	4770      	bx	lr

000b75b0 <_ZN12Adafruit_GFX10writePixelEsst>:
    @param   x   x coordinate
    @param   y   y coordinate
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color){
   b75b0:	b410      	push	{r4}
    drawPixel(x, y, color);
   b75b2:	6804      	ldr	r4, [r0, #0]
   b75b4:	6924      	ldr	r4, [r4, #16]
   b75b6:	46a4      	mov	ip, r4
}
   b75b8:	f85d 4b04 	ldr.w	r4, [sp], #4
    drawPixel(x, y, color);
   b75bc:	4760      	bx	ip

000b75be <_ZN12Adafruit_GFX14writeFastVLineEssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
   b75be:	b430      	push	{r4, r5}
    // Overwrite in subclasses if startWrite is defined!
    // Can be just writeLine(x, y, x, y+h-1, color);
    // or writeFillRect(x, y, 1, h, color);
    drawFastVLine(x, y, h, color);
   b75c0:	6804      	ldr	r4, [r0, #0]
        int16_t h, uint16_t color) {
   b75c2:	f8bd 5008 	ldrh.w	r5, [sp, #8]
    drawFastVLine(x, y, h, color);
   b75c6:	9502      	str	r5, [sp, #8]
   b75c8:	6ba4      	ldr	r4, [r4, #56]	; 0x38
   b75ca:	46a4      	mov	ip, r4
}
   b75cc:	bc30      	pop	{r4, r5}
    drawFastVLine(x, y, h, color);
   b75ce:	4760      	bx	ip

000b75d0 <_ZN12Adafruit_GFX14writeFastHLineEssst>:
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
   b75d0:	b430      	push	{r4, r5}
    // Overwrite in subclasses if startWrite is defined!
    // Example: writeLine(x, y, x+w-1, y, color);
    // or writeFillRect(x, y, w, 1, color);
    drawFastHLine(x, y, w, color);
   b75d2:	6804      	ldr	r4, [r0, #0]
        int16_t w, uint16_t color) {
   b75d4:	f8bd 5008 	ldrh.w	r5, [sp, #8]
    drawFastHLine(x, y, w, color);
   b75d8:	9502      	str	r5, [sp, #8]
   b75da:	6be4      	ldr	r4, [r4, #60]	; 0x3c
   b75dc:	46a4      	mov	ip, r4
}
   b75de:	bc30      	pop	{r4, r5}
    drawFastHLine(x, y, w, color);
   b75e0:	4760      	bx	ip

000b75e2 <_ZN12Adafruit_GFX13writeFillRectEsssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
   b75e2:	b470      	push	{r4, r5, r6}
   b75e4:	f9bd 500c 	ldrsh.w	r5, [sp, #12]
   b75e8:	f8bd 6010 	ldrh.w	r6, [sp, #16]
    // Overwrite in subclasses if desired!
    fillRect(x,y,w,h,color);
   b75ec:	6804      	ldr	r4, [r0, #0]
   b75ee:	e9cd 5603 	strd	r5, r6, [sp, #12]
   b75f2:	6c24      	ldr	r4, [r4, #64]	; 0x40
   b75f4:	46a4      	mov	ip, r4
}
   b75f6:	bc70      	pop	{r4, r5, r6}
    fillRect(x,y,w,h,color);
   b75f8:	4760      	bx	ip

000b75fa <_ZN12Adafruit_GFX13drawFastVLineEssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
        int16_t h, uint16_t color) {
   b75fa:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   b75fe:	461c      	mov	r4, r3
    startWrite();
   b7600:	6803      	ldr	r3, [r0, #0]
        int16_t h, uint16_t color) {
   b7602:	f8bd 8020 	ldrh.w	r8, [sp, #32]
    startWrite();
   b7606:	695b      	ldr	r3, [r3, #20]
        int16_t h, uint16_t color) {
   b7608:	4605      	mov	r5, r0
   b760a:	4616      	mov	r6, r2
    writeLine(x, y, x, y+h-1, color);
   b760c:	3c01      	subs	r4, #1
   b760e:	4434      	add	r4, r6
        int16_t h, uint16_t color) {
   b7610:	460f      	mov	r7, r1
    writeLine(x, y, x, y+h-1, color);
   b7612:	b224      	sxth	r4, r4
    startWrite();
   b7614:	4798      	blx	r3
    writeLine(x, y, x, y+h-1, color);
   b7616:	682b      	ldr	r3, [r5, #0]
   b7618:	f8cd 8004 	str.w	r8, [sp, #4]
   b761c:	9400      	str	r4, [sp, #0]
   b761e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   b7620:	4628      	mov	r0, r5
   b7622:	463b      	mov	r3, r7
   b7624:	4632      	mov	r2, r6
   b7626:	4639      	mov	r1, r7
   b7628:	47a0      	blx	r4
    endWrite();
   b762a:	682b      	ldr	r3, [r5, #0]
   b762c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b762e:	4628      	mov	r0, r5
}
   b7630:	b002      	add	sp, #8
   b7632:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    endWrite();
   b7636:	4718      	bx	r3

000b7638 <_ZN12Adafruit_GFX13drawFastHLineEssst>:
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
        int16_t w, uint16_t color) {
   b7638:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   b763c:	461d      	mov	r5, r3
    startWrite();
   b763e:	6803      	ldr	r3, [r0, #0]
        int16_t w, uint16_t color) {
   b7640:	f8bd 8020 	ldrh.w	r8, [sp, #32]
    startWrite();
   b7644:	695b      	ldr	r3, [r3, #20]
        int16_t w, uint16_t color) {
   b7646:	4604      	mov	r4, r0
   b7648:	4617      	mov	r7, r2
   b764a:	460e      	mov	r6, r1
    startWrite();
   b764c:	4798      	blx	r3
    writeLine(x, y, x+w-1, y, color);
   b764e:	e9cd 7800 	strd	r7, r8, [sp]
   b7652:	6822      	ldr	r2, [r4, #0]
   b7654:	1e6b      	subs	r3, r5, #1
   b7656:	4433      	add	r3, r6
   b7658:	6a95      	ldr	r5, [r2, #40]	; 0x28
   b765a:	4620      	mov	r0, r4
   b765c:	b21b      	sxth	r3, r3
   b765e:	463a      	mov	r2, r7
   b7660:	4631      	mov	r1, r6
   b7662:	47a8      	blx	r5
    endWrite();
   b7664:	6823      	ldr	r3, [r4, #0]
   b7666:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b7668:	4620      	mov	r0, r4
}
   b766a:	b002      	add	sp, #8
   b766c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    endWrite();
   b7670:	4718      	bx	r3

000b7672 <_ZN12Adafruit_GFX8fillRectEsssst>:
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
   b7672:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   b7676:	461e      	mov	r6, r3
    startWrite();
   b7678:	6803      	ldr	r3, [r0, #0]
        uint16_t color) {
   b767a:	f9bd 9028 	ldrsh.w	r9, [sp, #40]	; 0x28
    startWrite();
   b767e:	695b      	ldr	r3, [r3, #20]
        uint16_t color) {
   b7680:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
   b7684:	460c      	mov	r4, r1
   b7686:	4605      	mov	r5, r0
   b7688:	4617      	mov	r7, r2
    startWrite();
   b768a:	4798      	blx	r3
    for (int16_t i=x; i<x+w; i++) {
   b768c:	4426      	add	r6, r4
   b768e:	42b4      	cmp	r4, r6
        writeFastVLine(i, y, h, color);
   b7690:	682b      	ldr	r3, [r5, #0]
    for (int16_t i=x; i<x+w; i++) {
   b7692:	da0b      	bge.n	b76ac <_ZN12Adafruit_GFX8fillRectEsssst+0x3a>
        writeFastVLine(i, y, h, color);
   b7694:	f8cd 8000 	str.w	r8, [sp]
   b7698:	f8d3 a020 	ldr.w	sl, [r3, #32]
   b769c:	4621      	mov	r1, r4
   b769e:	464b      	mov	r3, r9
   b76a0:	463a      	mov	r2, r7
   b76a2:	4628      	mov	r0, r5
   b76a4:	3401      	adds	r4, #1
   b76a6:	47d0      	blx	sl
    for (int16_t i=x; i<x+w; i++) {
   b76a8:	b224      	sxth	r4, r4
   b76aa:	e7f0      	b.n	b768e <_ZN12Adafruit_GFX8fillRectEsssst+0x1c>
    }
    endWrite();
   b76ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b76ae:	4628      	mov	r0, r5
}
   b76b0:	b002      	add	sp, #8
   b76b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    endWrite();
   b76b6:	4718      	bx	r3

000b76b8 <_ZN12Adafruit_GFX10fillScreenEt>:
/*!
   @brief    Fill the screen completely with one color. Update in subclasses if desired!
    @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillScreen(uint16_t color) {
   b76b8:	b513      	push	{r0, r1, r4, lr}
    fillRect(0, 0, _width, _height, color);
   b76ba:	6802      	ldr	r2, [r0, #0]
   b76bc:	9101      	str	r1, [sp, #4]
   b76be:	f9b0 100e 	ldrsh.w	r1, [r0, #14]
   b76c2:	9100      	str	r1, [sp, #0]
   b76c4:	6c14      	ldr	r4, [r2, #64]	; 0x40
   b76c6:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
   b76ca:	2200      	movs	r2, #0
   b76cc:	4611      	mov	r1, r2
   b76ce:	47a0      	blx	r4
}
   b76d0:	b002      	add	sp, #8
   b76d2:	bd10      	pop	{r4, pc}

000b76d4 <_ZN12Adafruit_GFX8drawLineEsssst>:
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
        uint16_t color) {
   b76d4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    // Update in subclasses if desired!
    if(x0 == x1){
   b76d8:	4299      	cmp	r1, r3
        uint16_t color) {
   b76da:	4616      	mov	r6, r2
   b76dc:	f9bd 7028 	ldrsh.w	r7, [sp, #40]	; 0x28
   b76e0:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
        if(y0 > y1) _swap_int16_t(y0, y1);
        drawFastVLine(x0, y0, y1 - y0 + 1, color);
   b76e4:	6802      	ldr	r2, [r0, #0]
        uint16_t color) {
   b76e6:	4680      	mov	r8, r0
   b76e8:	460d      	mov	r5, r1
   b76ea:	461c      	mov	r4, r3
    if(x0 == x1){
   b76ec:	d113      	bne.n	b7716 <_ZN12Adafruit_GFX8drawLineEsssst+0x42>
        if(y0 > y1) _swap_int16_t(y0, y1);
   b76ee:	42be      	cmp	r6, r7
   b76f0:	bfc8      	it	gt
   b76f2:	4633      	movgt	r3, r6
        drawFastVLine(x0, y0, y1 - y0 + 1, color);
   b76f4:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
        if(y0 > y1) _swap_int16_t(y0, y1);
   b76f8:	bfc4      	itt	gt
   b76fa:	463e      	movgt	r6, r7
   b76fc:	461f      	movgt	r7, r3
        drawFastVLine(x0, y0, y1 - y0 + 1, color);
   b76fe:	1c7b      	adds	r3, r7, #1
   b7700:	6b94      	ldr	r4, [r2, #56]	; 0x38
   b7702:	1b9b      	subs	r3, r3, r6
    } else if(y0 == y1){
        if(x0 > x1) _swap_int16_t(x0, x1);
        drawFastHLine(x0, y0, x1 - x0 + 1, color);
   b7704:	b21b      	sxth	r3, r3
   b7706:	4632      	mov	r2, r6
   b7708:	4629      	mov	r1, r5
   b770a:	4640      	mov	r0, r8
   b770c:	46a4      	mov	ip, r4
    } else {
        startWrite();
        writeLine(x0, y0, x1, y1, color);
        endWrite();
    }
}
   b770e:	b003      	add	sp, #12
   b7710:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        drawFastHLine(x0, y0, x1 - x0 + 1, color);
   b7714:	4760      	bx	ip
    } else if(y0 == y1){
   b7716:	42be      	cmp	r6, r7
   b7718:	d10a      	bne.n	b7730 <_ZN12Adafruit_GFX8drawLineEsssst+0x5c>
        if(x0 > x1) _swap_int16_t(x0, x1);
   b771a:	4299      	cmp	r1, r3
   b771c:	bfc2      	ittt	gt
   b771e:	460b      	movgt	r3, r1
   b7720:	4625      	movgt	r5, r4
   b7722:	461c      	movgt	r4, r3
        drawFastHLine(x0, y0, x1 - x0 + 1, color);
   b7724:	1c63      	adds	r3, r4, #1
   b7726:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
   b772a:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
   b772c:	1b5b      	subs	r3, r3, r5
   b772e:	e7e9      	b.n	b7704 <_ZN12Adafruit_GFX8drawLineEsssst+0x30>
        startWrite();
   b7730:	6953      	ldr	r3, [r2, #20]
   b7732:	4798      	blx	r3
        writeLine(x0, y0, x1, y1, color);
   b7734:	e9cd 7900 	strd	r7, r9, [sp]
   b7738:	f8d8 3000 	ldr.w	r3, [r8]
   b773c:	4640      	mov	r0, r8
   b773e:	6a9f      	ldr	r7, [r3, #40]	; 0x28
   b7740:	4632      	mov	r2, r6
   b7742:	4623      	mov	r3, r4
   b7744:	4629      	mov	r1, r5
   b7746:	47b8      	blx	r7
        endWrite();
   b7748:	f8d8 3000 	ldr.w	r3, [r8]
   b774c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b774e:	4640      	mov	r0, r8
}
   b7750:	b003      	add	sp, #12
   b7752:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        endWrite();
   b7756:	4718      	bx	r3

000b7758 <_ZN12Adafruit_GFX8drawRectEsssst>:
    @param    h   Height in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
        uint16_t color) {
   b7758:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   b775c:	461d      	mov	r5, r3
    startWrite();
   b775e:	6803      	ldr	r3, [r0, #0]
        uint16_t color) {
   b7760:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
    startWrite();
   b7764:	695b      	ldr	r3, [r3, #20]
        uint16_t color) {
   b7766:	f9bd 9028 	ldrsh.w	r9, [sp, #40]	; 0x28
   b776a:	4604      	mov	r4, r0
   b776c:	460f      	mov	r7, r1
   b776e:	4616      	mov	r6, r2
    startWrite();
   b7770:	4798      	blx	r3
    writeFastHLine(x, y, w, color);
   b7772:	6823      	ldr	r3, [r4, #0]
   b7774:	f8cd 8000 	str.w	r8, [sp]
   b7778:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
   b777c:	4632      	mov	r2, r6
   b777e:	462b      	mov	r3, r5
   b7780:	4639      	mov	r1, r7
   b7782:	4620      	mov	r0, r4
   b7784:	47d0      	blx	sl
    writeFastHLine(x, y+h-1, w, color);
   b7786:	6823      	ldr	r3, [r4, #0]
   b7788:	f8cd 8000 	str.w	r8, [sp]
   b778c:	f109 32ff 	add.w	r2, r9, #4294967295
   b7790:	4432      	add	r2, r6
   b7792:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
   b7796:	4639      	mov	r1, r7
   b7798:	462b      	mov	r3, r5
   b779a:	4620      	mov	r0, r4
   b779c:	b212      	sxth	r2, r2
   b779e:	47d0      	blx	sl
    writeFastVLine(x, y, h, color);
   b77a0:	6823      	ldr	r3, [r4, #0]
   b77a2:	f8cd 8000 	str.w	r8, [sp]
   b77a6:	f8d3 a020 	ldr.w	sl, [r3, #32]
   b77aa:	4632      	mov	r2, r6
   b77ac:	464b      	mov	r3, r9
   b77ae:	4639      	mov	r1, r7
   b77b0:	4620      	mov	r0, r4
   b77b2:	47d0      	blx	sl
    writeFastVLine(x+w-1, y, h, color);
   b77b4:	1e6b      	subs	r3, r5, #1
   b77b6:	19d9      	adds	r1, r3, r7
   b77b8:	6823      	ldr	r3, [r4, #0]
   b77ba:	f8cd 8000 	str.w	r8, [sp]
   b77be:	6a1d      	ldr	r5, [r3, #32]
   b77c0:	4620      	mov	r0, r4
   b77c2:	464b      	mov	r3, r9
   b77c4:	4632      	mov	r2, r6
   b77c6:	b209      	sxth	r1, r1
   b77c8:	47a8      	blx	r5
    endWrite();
   b77ca:	6823      	ldr	r3, [r4, #0]
   b77cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b77ce:	4620      	mov	r0, r4
}
   b77d0:	b002      	add	sp, #8
   b77d2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    endWrite();
   b77d6:	4718      	bx	r3

000b77d8 <_ZN12Adafruit_GFX13invertDisplayEb>:
    @param   i  True if you want to invert, false to make 'normal'
*/
/**************************************************************************/
void Adafruit_GFX::invertDisplay(boolean i) {
    // Do nothing, must be subclassed if supported by hardware
}
   b77d8:	4770      	bx	lr

000b77da <_ZN12Adafruit_GFX11setRotationEh>:
    rotation = (x & 3);
   b77da:	f001 0303 	and.w	r3, r1, #3
            _height = HEIGHT;
   b77de:	f9b0 200a 	ldrsh.w	r2, [r0, #10]
    rotation = (x & 3);
   b77e2:	7683      	strb	r3, [r0, #26]
    switch(rotation) {
   b77e4:	07c9      	lsls	r1, r1, #31
            _width  = WIDTH;
   b77e6:	f9b0 3008 	ldrsh.w	r3, [r0, #8]
   b77ea:	bf59      	ittee	pl
   b77ec:	8183      	strhpl	r3, [r0, #12]
            _height = HEIGHT;
   b77ee:	81c2      	strhpl	r2, [r0, #14]
            _width  = HEIGHT;
   b77f0:	8182      	strhmi	r2, [r0, #12]
            _height = WIDTH;
   b77f2:	81c3      	strhmi	r3, [r0, #14]
}
   b77f4:	4770      	bx	lr
	...

000b77f8 <_ZN12Adafruit_GFXC1Ess>:
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
   b77f8:	b530      	push	{r4, r5, lr}
WIDTH(w), HEIGHT(h)
   b77fa:	8142      	strh	r2, [r0, #10]
    _height   = HEIGHT;
   b77fc:	81c2      	strh	r2, [r0, #14]
    textsize_x = textsize_y  = 1;
   b77fe:	4a07      	ldr	r2, [pc, #28]	; (b781c <_ZN12Adafruit_GFXC1Ess+0x24>)
WIDTH(w), HEIGHT(h)
   b7800:	4d07      	ldr	r5, [pc, #28]	; (b7820 <_ZN12Adafruit_GFXC1Ess+0x28>)
   b7802:	8101      	strh	r1, [r0, #8]
   b7804:	2400      	movs	r4, #0
    _width    = WIDTH;
   b7806:	8181      	strh	r1, [r0, #12]
    textsize_x = textsize_y  = 1;
   b7808:	f04f 31ff 	mov.w	r1, #4294967295
   b780c:	e9c0 1205 	strd	r1, r2, [r0, #20]
   b7810:	6044      	str	r4, [r0, #4]
WIDTH(w), HEIGHT(h)
   b7812:	6005      	str	r5, [r0, #0]
    cursor_y  = cursor_x    = 0;
   b7814:	6104      	str	r4, [r0, #16]
    _cp437    = false;
   b7816:	7704      	strb	r4, [r0, #28]
    gfxFont   = NULL;
   b7818:	6204      	str	r4, [r0, #32]
}
   b781a:	bd30      	pop	{r4, r5, pc}
   b781c:	01000101 	.word	0x01000101
   b7820:	000c1a98 	.word	0x000c1a98

000b7824 <_ZN12Adafruit_GFX10drawCircleEssst>:
        uint16_t color) {
   b7824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int16_t f = 1 - r;
   b7828:	b29d      	uxth	r5, r3
        uint16_t color) {
   b782a:	4616      	mov	r6, r2
    int16_t f = 1 - r;
   b782c:	f1c5 0201 	rsb	r2, r5, #1
        uint16_t color) {
   b7830:	b087      	sub	sp, #28
   b7832:	461f      	mov	r7, r3
    int16_t f = 1 - r;
   b7834:	b213      	sxth	r3, r2
    int16_t ddF_y = -2 * r;
   b7836:	ebc5 32c5 	rsb	r2, r5, r5, lsl #15
   b783a:	0052      	lsls	r2, r2, #1
    int16_t f = 1 - r;
   b783c:	9301      	str	r3, [sp, #4]
    int16_t ddF_y = -2 * r;
   b783e:	b213      	sxth	r3, r2
    startWrite();
   b7840:	6802      	ldr	r2, [r0, #0]
    int16_t ddF_y = -2 * r;
   b7842:	9304      	str	r3, [sp, #16]
        uint16_t color) {
   b7844:	4604      	mov	r4, r0
    startWrite();
   b7846:	6952      	ldr	r2, [r2, #20]
        uint16_t color) {
   b7848:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
   b784c:	4689      	mov	r9, r1
    startWrite();
   b784e:	4790      	blx	r2
    writePixel(x0  , y0+r, color);
   b7850:	6821      	ldr	r1, [r4, #0]
   b7852:	b2b3      	uxth	r3, r6
   b7854:	fa15 f286 	uxtah	r2, r5, r6
   b7858:	f8d1 8018 	ldr.w	r8, [r1, #24]
   b785c:	9300      	str	r3, [sp, #0]
   b785e:	4649      	mov	r1, r9
   b7860:	465b      	mov	r3, fp
   b7862:	b212      	sxth	r2, r2
   b7864:	4620      	mov	r0, r4
   b7866:	47c0      	blx	r8
    writePixel(x0  , y0-r, color);
   b7868:	9b00      	ldr	r3, [sp, #0]
   b786a:	6821      	ldr	r1, [r4, #0]
   b786c:	1b5a      	subs	r2, r3, r5
   b786e:	f8d1 8018 	ldr.w	r8, [r1, #24]
   b7872:	465b      	mov	r3, fp
   b7874:	4649      	mov	r1, r9
   b7876:	b212      	sxth	r2, r2
   b7878:	4620      	mov	r0, r4
   b787a:	47c0      	blx	r8
    writePixel(x0+r, y0  , color);
   b787c:	6822      	ldr	r2, [r4, #0]
   b787e:	fa15 f189 	uxtah	r1, r5, r9
   b7882:	fa1f f889 	uxth.w	r8, r9
   b7886:	465b      	mov	r3, fp
   b7888:	f8d2 9018 	ldr.w	r9, [r2, #24]
   b788c:	b209      	sxth	r1, r1
   b788e:	4632      	mov	r2, r6
   b7890:	4620      	mov	r0, r4
   b7892:	47c8      	blx	r9
    writePixel(x0-r, y0  , color);
   b7894:	6822      	ldr	r2, [r4, #0]
   b7896:	eba8 0105 	sub.w	r1, r8, r5
   b789a:	465b      	mov	r3, fp
   b789c:	6995      	ldr	r5, [r2, #24]
   b789e:	b209      	sxth	r1, r1
   b78a0:	4632      	mov	r2, r6
   b78a2:	4620      	mov	r0, r4
   b78a4:	47a8      	blx	r5
    int16_t x = 0;
   b78a6:	2300      	movs	r3, #0
   b78a8:	9303      	str	r3, [sp, #12]
    while (x<y) {
   b78aa:	9b03      	ldr	r3, [sp, #12]
   b78ac:	42bb      	cmp	r3, r7
   b78ae:	da76      	bge.n	b799e <_ZN12Adafruit_GFX10drawCircleEssst+0x17a>
        if (f >= 0) {
   b78b0:	9b01      	ldr	r3, [sp, #4]
   b78b2:	2b00      	cmp	r3, #0
   b78b4:	db0a      	blt.n	b78cc <_ZN12Adafruit_GFX10drawCircleEssst+0xa8>
            ddF_y += 2;
   b78b6:	9a04      	ldr	r2, [sp, #16]
   b78b8:	3202      	adds	r2, #2
   b78ba:	b213      	sxth	r3, r2
   b78bc:	9304      	str	r3, [sp, #16]
            f += ddF_y;
   b78be:	9b01      	ldr	r3, [sp, #4]
   b78c0:	fa13 f282 	uxtah	r2, r3, r2
            y--;
   b78c4:	3f01      	subs	r7, #1
            f += ddF_y;
   b78c6:	b213      	sxth	r3, r2
            y--;
   b78c8:	b23f      	sxth	r7, r7
            f += ddF_y;
   b78ca:	9301      	str	r3, [sp, #4]
        x++;
   b78cc:	9a03      	ldr	r2, [sp, #12]
        writePixel(x0 + x, y0 + y, color);
   b78ce:	6821      	ldr	r1, [r4, #0]
   b78d0:	3201      	adds	r2, #1
   b78d2:	b213      	sxth	r3, r2
   b78d4:	9303      	str	r3, [sp, #12]
        ddF_x += 2;
   b78d6:	9b01      	ldr	r3, [sp, #4]
        writePixel(x0 + x, y0 + y, color);
   b78d8:	698d      	ldr	r5, [r1, #24]
   b78da:	b296      	uxth	r6, r2
        ddF_x += 2;
   b78dc:	eb03 0246 	add.w	r2, r3, r6, lsl #1
        f += ddF_x;
   b78e0:	3201      	adds	r2, #1
   b78e2:	b213      	sxth	r3, r2
   b78e4:	9301      	str	r3, [sp, #4]
        writePixel(x0 + x, y0 + y, color);
   b78e6:	9b00      	ldr	r3, [sp, #0]
   b78e8:	eb08 0a06 	add.w	sl, r8, r6
   b78ec:	fa13 f287 	uxtah	r2, r3, r7
   b78f0:	fa0f fa8a 	sxth.w	sl, sl
   b78f4:	b212      	sxth	r2, r2
   b78f6:	465b      	mov	r3, fp
   b78f8:	9202      	str	r2, [sp, #8]
   b78fa:	4651      	mov	r1, sl
   b78fc:	4620      	mov	r0, r4
   b78fe:	47a8      	blx	r5
        writePixel(x0 - x, y0 + y, color);
   b7900:	eba8 0906 	sub.w	r9, r8, r6
   b7904:	6821      	ldr	r1, [r4, #0]
   b7906:	9a02      	ldr	r2, [sp, #8]
   b7908:	698d      	ldr	r5, [r1, #24]
   b790a:	fa0f f989 	sxth.w	r9, r9
   b790e:	465b      	mov	r3, fp
   b7910:	4649      	mov	r1, r9
   b7912:	4620      	mov	r0, r4
   b7914:	47a8      	blx	r5
        writePixel(x0 + x, y0 - y, color);
   b7916:	b2bb      	uxth	r3, r7
   b7918:	9302      	str	r3, [sp, #8]
   b791a:	6821      	ldr	r1, [r4, #0]
   b791c:	9b00      	ldr	r3, [sp, #0]
   b791e:	9a02      	ldr	r2, [sp, #8]
   b7920:	1a9a      	subs	r2, r3, r2
   b7922:	698b      	ldr	r3, [r1, #24]
   b7924:	b212      	sxth	r2, r2
   b7926:	461d      	mov	r5, r3
   b7928:	9205      	str	r2, [sp, #20]
   b792a:	465b      	mov	r3, fp
   b792c:	4651      	mov	r1, sl
   b792e:	4620      	mov	r0, r4
   b7930:	47a8      	blx	r5
        writePixel(x0 - x, y0 - y, color);
   b7932:	6821      	ldr	r1, [r4, #0]
   b7934:	9a05      	ldr	r2, [sp, #20]
   b7936:	f8d1 a018 	ldr.w	sl, [r1, #24]
   b793a:	465b      	mov	r3, fp
   b793c:	4649      	mov	r1, r9
   b793e:	4620      	mov	r0, r4
   b7940:	47d0      	blx	sl
        writePixel(x0 + y, y0 + x, color);
   b7942:	9b02      	ldr	r3, [sp, #8]
   b7944:	6821      	ldr	r1, [r4, #0]
   b7946:	eb08 0903 	add.w	r9, r8, r3
   b794a:	9b00      	ldr	r3, [sp, #0]
   b794c:	f8d1 a018 	ldr.w	sl, [r1, #24]
   b7950:	199a      	adds	r2, r3, r6
   b7952:	fa0f f989 	sxth.w	r9, r9
   b7956:	b212      	sxth	r2, r2
   b7958:	465b      	mov	r3, fp
   b795a:	9205      	str	r2, [sp, #20]
   b795c:	4649      	mov	r1, r9
   b795e:	4620      	mov	r0, r4
   b7960:	47d0      	blx	sl
        writePixel(x0 - y, y0 + x, color);
   b7962:	9b02      	ldr	r3, [sp, #8]
   b7964:	6821      	ldr	r1, [r4, #0]
   b7966:	9a05      	ldr	r2, [sp, #20]
   b7968:	f8d1 a018 	ldr.w	sl, [r1, #24]
   b796c:	eba8 0503 	sub.w	r5, r8, r3
   b7970:	b22d      	sxth	r5, r5
   b7972:	465b      	mov	r3, fp
   b7974:	4629      	mov	r1, r5
   b7976:	4620      	mov	r0, r4
   b7978:	47d0      	blx	sl
        writePixel(x0 + y, y0 - x, color);
   b797a:	9b00      	ldr	r3, [sp, #0]
   b797c:	6821      	ldr	r1, [r4, #0]
   b797e:	1b9a      	subs	r2, r3, r6
   b7980:	b212      	sxth	r2, r2
   b7982:	698e      	ldr	r6, [r1, #24]
   b7984:	9202      	str	r2, [sp, #8]
   b7986:	465b      	mov	r3, fp
   b7988:	4649      	mov	r1, r9
   b798a:	4620      	mov	r0, r4
   b798c:	47b0      	blx	r6
        writePixel(x0 - y, y0 - x, color);
   b798e:	6821      	ldr	r1, [r4, #0]
   b7990:	9a02      	ldr	r2, [sp, #8]
   b7992:	698e      	ldr	r6, [r1, #24]
   b7994:	465b      	mov	r3, fp
   b7996:	4629      	mov	r1, r5
   b7998:	4620      	mov	r0, r4
   b799a:	47b0      	blx	r6
    while (x<y) {
   b799c:	e785      	b.n	b78aa <_ZN12Adafruit_GFX10drawCircleEssst+0x86>
    endWrite();
   b799e:	6823      	ldr	r3, [r4, #0]
   b79a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b79a2:	4620      	mov	r0, r4
}
   b79a4:	b007      	add	sp, #28
   b79a6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    endWrite();
   b79aa:	4718      	bx	r3

000b79ac <_ZN12Adafruit_GFX16fillCircleHelperEssshst>:
  uint8_t corners, int16_t delta, uint16_t color) {
   b79ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b79b0:	b08b      	sub	sp, #44	; 0x2c
   b79b2:	461c      	mov	r4, r3
   b79b4:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   b79b8:	9304      	str	r3, [sp, #16]
    int16_t f     = 1 - r;
   b79ba:	b2a3      	uxth	r3, r4
   b79bc:	f1c3 0501 	rsb	r5, r3, #1
    int16_t ddF_y = -2 * r;
   b79c0:	ebc3 33c3 	rsb	r3, r3, r3, lsl #15
   b79c4:	005b      	lsls	r3, r3, #1
   b79c6:	b21b      	sxth	r3, r3
   b79c8:	9307      	str	r3, [sp, #28]
    delta++; // Avoid some +1's in the loop
   b79ca:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
   b79ce:	3301      	adds	r3, #1
   b79d0:	b29b      	uxth	r3, r3
   b79d2:	9305      	str	r3, [sp, #20]
   b79d4:	b293      	uxth	r3, r2
   b79d6:	9306      	str	r3, [sp, #24]
  uint8_t corners, int16_t delta, uint16_t color) {
   b79d8:	4688      	mov	r8, r1
    delta++; // Avoid some +1's in the loop
   b79da:	9b05      	ldr	r3, [sp, #20]
  uint8_t corners, int16_t delta, uint16_t color) {
   b79dc:	f89d 1050 	ldrb.w	r1, [sp, #80]	; 0x50
    delta++; // Avoid some +1's in the loop
   b79e0:	9303      	str	r3, [sp, #12]
    int16_t x     = 0;
   b79e2:	2300      	movs	r3, #0
   b79e4:	9302      	str	r3, [sp, #8]
            if(corners & 1) writeFastVLine(x0+x, y0-y, 2*y+delta, color);
   b79e6:	f001 0301 	and.w	r3, r1, #1
   b79ea:	9308      	str	r3, [sp, #32]
    delta++; // Avoid some +1's in the loop
   b79ec:	f8dd a018 	ldr.w	sl, [sp, #24]
            if(corners & 2) writeFastVLine(x0-x, y0-y, 2*y+delta, color);
   b79f0:	f001 0302 	and.w	r3, r1, #2
  uint8_t corners, int16_t delta, uint16_t color) {
   b79f4:	4683      	mov	fp, r0
    int16_t f     = 1 - r;
   b79f6:	b22d      	sxth	r5, r5
            if(corners & 2) writeFastVLine(x0-x, y0-y, 2*y+delta, color);
   b79f8:	9309      	str	r3, [sp, #36]	; 0x24
    while(x < y) {
   b79fa:	9b02      	ldr	r3, [sp, #8]
   b79fc:	42a3      	cmp	r3, r4
   b79fe:	da6f      	bge.n	b7ae0 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x134>
        if (f >= 0) {
   b7a00:	2d00      	cmp	r5, #0
   b7a02:	db6b      	blt.n	b7adc <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x130>
            ddF_y += 2;
   b7a04:	9b07      	ldr	r3, [sp, #28]
   b7a06:	3302      	adds	r3, #2
            y--;
   b7a08:	1e66      	subs	r6, r4, #1
            ddF_y += 2;
   b7a0a:	b21a      	sxth	r2, r3
            f     += ddF_y;
   b7a0c:	fa15 f583 	uxtah	r5, r5, r3
            y--;
   b7a10:	b236      	sxth	r6, r6
            ddF_y += 2;
   b7a12:	9207      	str	r2, [sp, #28]
            f     += ddF_y;
   b7a14:	b22d      	sxth	r5, r5
        x++;
   b7a16:	9f02      	ldr	r7, [sp, #8]
   b7a18:	3701      	adds	r7, #1
   b7a1a:	fa1f f987 	uxth.w	r9, r7
   b7a1e:	b23b      	sxth	r3, r7
        ddF_x += 2;
   b7a20:	eb05 0549 	add.w	r5, r5, r9, lsl #1
        f     += ddF_x;
   b7a24:	3501      	adds	r5, #1
        if(x < (y + 1)) {
   b7a26:	429e      	cmp	r6, r3
   b7a28:	9302      	str	r3, [sp, #8]
        f     += ddF_x;
   b7a2a:	b22d      	sxth	r5, r5
        if(x < (y + 1)) {
   b7a2c:	db29      	blt.n	b7a82 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0xd6>
            if(corners & 1) writeFastVLine(x0+x, y0-y, 2*y+delta, color);
   b7a2e:	9b08      	ldr	r3, [sp, #32]
   b7a30:	b193      	cbz	r3, b7a58 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0xac>
   b7a32:	9804      	ldr	r0, [sp, #16]
   b7a34:	9000      	str	r0, [sp, #0]
   b7a36:	f8db 0000 	ldr.w	r0, [fp]
   b7a3a:	9906      	ldr	r1, [sp, #24]
   b7a3c:	9b05      	ldr	r3, [sp, #20]
   b7a3e:	6a00      	ldr	r0, [r0, #32]
   b7a40:	b2b2      	uxth	r2, r6
   b7a42:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   b7a46:	1a8a      	subs	r2, r1, r2
   b7a48:	eb09 0108 	add.w	r1, r9, r8
   b7a4c:	4607      	mov	r7, r0
   b7a4e:	b21b      	sxth	r3, r3
   b7a50:	b212      	sxth	r2, r2
   b7a52:	b209      	sxth	r1, r1
   b7a54:	4658      	mov	r0, fp
   b7a56:	47b8      	blx	r7
            if(corners & 2) writeFastVLine(x0-x, y0-y, 2*y+delta, color);
   b7a58:	9b09      	ldr	r3, [sp, #36]	; 0x24
   b7a5a:	b193      	cbz	r3, b7a82 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0xd6>
   b7a5c:	9906      	ldr	r1, [sp, #24]
   b7a5e:	9804      	ldr	r0, [sp, #16]
   b7a60:	9b05      	ldr	r3, [sp, #20]
   b7a62:	9000      	str	r0, [sp, #0]
   b7a64:	b2b2      	uxth	r2, r6
   b7a66:	f8db 0000 	ldr.w	r0, [fp]
   b7a6a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
   b7a6e:	1a8a      	subs	r2, r1, r2
   b7a70:	eba8 0109 	sub.w	r1, r8, r9
   b7a74:	b21b      	sxth	r3, r3
   b7a76:	f8d0 9020 	ldr.w	r9, [r0, #32]
   b7a7a:	b212      	sxth	r2, r2
   b7a7c:	b209      	sxth	r1, r1
   b7a7e:	4658      	mov	r0, fp
   b7a80:	47c8      	blx	r9
        if(y != py) {
   b7a82:	42b4      	cmp	r4, r6
   b7a84:	d020      	beq.n	b7ac8 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x11c>
            if(corners & 1) writeFastVLine(x0+py, y0-px, 2*px+delta, color);
   b7a86:	9b08      	ldr	r3, [sp, #32]
   b7a88:	b173      	cbz	r3, b7aa8 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0xfc>
   b7a8a:	f8db 3000 	ldr.w	r3, [fp]
   b7a8e:	9a04      	ldr	r2, [sp, #16]
   b7a90:	9200      	str	r2, [sp, #0]
   b7a92:	eb08 0104 	add.w	r1, r8, r4
   b7a96:	f8d3 9020 	ldr.w	r9, [r3, #32]
   b7a9a:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   b7a9e:	fa0f f28a 	sxth.w	r2, sl
   b7aa2:	b209      	sxth	r1, r1
   b7aa4:	4658      	mov	r0, fp
   b7aa6:	47c8      	blx	r9
            if(corners & 2) writeFastVLine(x0-py, y0-px, 2*px+delta, color);
   b7aa8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   b7aaa:	b16b      	cbz	r3, b7ac8 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x11c>
   b7aac:	f8db 3000 	ldr.w	r3, [fp]
   b7ab0:	9a04      	ldr	r2, [sp, #16]
   b7ab2:	9200      	str	r2, [sp, #0]
   b7ab4:	eba8 0104 	sub.w	r1, r8, r4
   b7ab8:	fa0f f28a 	sxth.w	r2, sl
   b7abc:	6a1c      	ldr	r4, [r3, #32]
   b7abe:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
   b7ac2:	b209      	sxth	r1, r1
   b7ac4:	4658      	mov	r0, fp
   b7ac6:	47a0      	blx	r4
   b7ac8:	f10a 33ff 	add.w	r3, sl, #4294967295
   b7acc:	fa1f fa83 	uxth.w	sl, r3
   b7ad0:	9b03      	ldr	r3, [sp, #12]
   b7ad2:	3302      	adds	r3, #2
   b7ad4:	b29b      	uxth	r3, r3
   b7ad6:	9303      	str	r3, [sp, #12]
  uint8_t corners, int16_t delta, uint16_t color) {
   b7ad8:	4634      	mov	r4, r6
   b7ada:	e78e      	b.n	b79fa <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x4e>
   b7adc:	4626      	mov	r6, r4
   b7ade:	e79a      	b.n	b7a16 <_ZN12Adafruit_GFX16fillCircleHelperEssshst+0x6a>
}
   b7ae0:	b00b      	add	sp, #44	; 0x2c
   b7ae2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000b7ae6 <_ZN12Adafruit_GFX10fillCircleEssst>:
        uint16_t color) {
   b7ae6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   b7aea:	461e      	mov	r6, r3
   b7aec:	b086      	sub	sp, #24
    startWrite();
   b7aee:	6803      	ldr	r3, [r0, #0]
        uint16_t color) {
   b7af0:	9105      	str	r1, [sp, #20]
   b7af2:	4604      	mov	r4, r0
    startWrite();
   b7af4:	695b      	ldr	r3, [r3, #20]
        uint16_t color) {
   b7af6:	f8bd 7030 	ldrh.w	r7, [sp, #48]	; 0x30
   b7afa:	4615      	mov	r5, r2
    startWrite();
   b7afc:	4798      	blx	r3
    writeFastVLine(x0, y0-r, 2*r+1, color);
   b7afe:	b2b2      	uxth	r2, r6
   b7b00:	6820      	ldr	r0, [r4, #0]
   b7b02:	9700      	str	r7, [sp, #0]
   b7b04:	0053      	lsls	r3, r2, #1
   b7b06:	3301      	adds	r3, #1
   b7b08:	1aaa      	subs	r2, r5, r2
   b7b0a:	f8d0 8020 	ldr.w	r8, [r0, #32]
   b7b0e:	9905      	ldr	r1, [sp, #20]
   b7b10:	4620      	mov	r0, r4
   b7b12:	b21b      	sxth	r3, r3
   b7b14:	b212      	sxth	r2, r2
   b7b16:	47c0      	blx	r8
    fillCircleHelper(x0, y0, r, 3, 0, color);
   b7b18:	2303      	movs	r3, #3
   b7b1a:	2200      	movs	r2, #0
   b7b1c:	e9cd 3200 	strd	r3, r2, [sp]
   b7b20:	4620      	mov	r0, r4
   b7b22:	4633      	mov	r3, r6
   b7b24:	9905      	ldr	r1, [sp, #20]
   b7b26:	9702      	str	r7, [sp, #8]
   b7b28:	462a      	mov	r2, r5
   b7b2a:	f7ff ff3f 	bl	b79ac <_ZN12Adafruit_GFX16fillCircleHelperEssshst>
    endWrite();
   b7b2e:	6823      	ldr	r3, [r4, #0]
   b7b30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b7b32:	4620      	mov	r0, r4
}
   b7b34:	b006      	add	sp, #24
   b7b36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    endWrite();
   b7b3a:	4718      	bx	r3

000b7b3c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>:
  const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color) {
   b7b3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b7b40:	b089      	sub	sp, #36	; 0x24
   b7b42:	e9cd 1202 	strd	r1, r2, [sp, #8]
    startWrite();
   b7b46:	6802      	ldr	r2, [r0, #0]
  const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color) {
   b7b48:	f9bd 8048 	ldrsh.w	r8, [sp, #72]	; 0x48
   b7b4c:	9304      	str	r3, [sp, #16]
   b7b4e:	f9bd 304c 	ldrsh.w	r3, [sp, #76]	; 0x4c
    startWrite();
   b7b52:	6952      	ldr	r2, [r2, #20]
  const uint8_t bitmap[], int16_t w, int16_t h, uint16_t color) {
   b7b54:	9305      	str	r3, [sp, #20]
   b7b56:	f8bd a050 	ldrh.w	sl, [sp, #80]	; 0x50
   b7b5a:	4604      	mov	r4, r0
    startWrite();
   b7b5c:	4790      	blx	r2
    int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
   b7b5e:	f118 0207 	adds.w	r2, r8, #7
    startWrite();
   b7b62:	f04f 0600 	mov.w	r6, #0
    int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
   b7b66:	bf48      	it	mi
   b7b68:	f108 020e 	addmi.w	r2, r8, #14
   b7b6c:	ea4f 0be2 	mov.w	fp, r2, asr #3
    startWrite();
   b7b70:	9601      	str	r6, [sp, #4]
    uint8_t byte = 0;
   b7b72:	4635      	mov	r5, r6
   b7b74:	9b03      	ldr	r3, [sp, #12]
   b7b76:	9a01      	ldr	r2, [sp, #4]
    for(int16_t j=0; j<h; j++, y++) {
   b7b78:	f9bd 1004 	ldrsh.w	r1, [sp, #4]
   b7b7c:	189a      	adds	r2, r3, r2
   b7b7e:	9b05      	ldr	r3, [sp, #20]
   b7b80:	428b      	cmp	r3, r1
   b7b82:	b212      	sxth	r2, r2
   b7b84:	dd27      	ble.n	b7bd6 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x9a>
            else      byte   = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
   b7b86:	9b04      	ldr	r3, [sp, #16]
   b7b88:	4433      	add	r3, r6
    for(int16_t j=0; j<h; j++, y++) {
   b7b8a:	f04f 0900 	mov.w	r9, #0
            else      byte   = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
   b7b8e:	9306      	str	r3, [sp, #24]
   b7b90:	fa0f f089 	sxth.w	r0, r9
        for(int16_t i=0; i<w; i++) {
   b7b94:	4580      	cmp	r8, r0
   b7b96:	fa1f f189 	uxth.w	r1, r9
   b7b9a:	dd17      	ble.n	b7bcc <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x90>
            if(i & 7) byte <<= 1;
   b7b9c:	074f      	lsls	r7, r1, #29
            else      byte   = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
   b7b9e:	bf05      	ittet	eq
   b7ba0:	9b06      	ldreq	r3, [sp, #24]
   b7ba2:	10c0      	asreq	r0, r0, #3
            if(i & 7) byte <<= 1;
   b7ba4:	006d      	lslne	r5, r5, #1
            else      byte   = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
   b7ba6:	5c1d      	ldrbeq	r5, [r3, r0]
            if(i & 7) byte <<= 1;
   b7ba8:	bf18      	it	ne
   b7baa:	b2ed      	uxtbne	r5, r5
            if(byte & 0x80) writePixel(x+i, y, color);
   b7bac:	062b      	lsls	r3, r5, #24
   b7bae:	d50a      	bpl.n	b7bc6 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x8a>
   b7bb0:	9b02      	ldr	r3, [sp, #8]
   b7bb2:	6820      	ldr	r0, [r4, #0]
   b7bb4:	9207      	str	r2, [sp, #28]
   b7bb6:	4419      	add	r1, r3
   b7bb8:	6983      	ldr	r3, [r0, #24]
   b7bba:	b209      	sxth	r1, r1
   b7bbc:	461f      	mov	r7, r3
   b7bbe:	4620      	mov	r0, r4
   b7bc0:	4653      	mov	r3, sl
   b7bc2:	47b8      	blx	r7
   b7bc4:	9a07      	ldr	r2, [sp, #28]
        for(int16_t i=0; i<w; i++) {
   b7bc6:	f109 0901 	add.w	r9, r9, #1
   b7bca:	e7e1      	b.n	b7b90 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x54>
    for(int16_t j=0; j<h; j++, y++) {
   b7bcc:	9b01      	ldr	r3, [sp, #4]
   b7bce:	3301      	adds	r3, #1
   b7bd0:	9301      	str	r3, [sp, #4]
   b7bd2:	445e      	add	r6, fp
   b7bd4:	e7ce      	b.n	b7b74 <_ZN12Adafruit_GFX10drawBitmapEssPKhsst+0x38>
    endWrite();
   b7bd6:	6823      	ldr	r3, [r4, #0]
   b7bd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b7bda:	4620      	mov	r0, r4
}
   b7bdc:	b009      	add	sp, #36	; 0x24
   b7bde:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    endWrite();
   b7be2:	4718      	bx	r3

000b7be4 <_ZN12Adafruit_GFX8drawCharEsshtthh>:
  uint16_t color, uint16_t bg, uint8_t size_x, uint8_t size_y) {
   b7be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b7be8:	ed2d 8b02 	vpush	{d8}
   b7bec:	b091      	sub	sp, #68	; 0x44
   b7bee:	4616      	mov	r6, r2
    if(!gfxFont) { // 'Classic' built-in font
   b7bf0:	6a02      	ldr	r2, [r0, #32]
  uint16_t color, uint16_t bg, uint8_t size_x, uint8_t size_y) {
   b7bf2:	f8bd 8074 	ldrh.w	r8, [sp, #116]	; 0x74
   b7bf6:	f89d 5078 	ldrb.w	r5, [sp, #120]	; 0x78
   b7bfa:	f89d 407c 	ldrb.w	r4, [sp, #124]	; 0x7c
   b7bfe:	9103      	str	r1, [sp, #12]
   b7c00:	461f      	mov	r7, r3
   b7c02:	f8bd 3070 	ldrh.w	r3, [sp, #112]	; 0x70
   b7c06:	9304      	str	r3, [sp, #16]
   b7c08:	4683      	mov	fp, r0
    if(!gfxFont) { // 'Classic' built-in font
   b7c0a:	2a00      	cmp	r2, #0
   b7c0c:	f040 80c5 	bne.w	b7d9a <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1b6>
        if((x >= _width)            || // Clip right
   b7c10:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
   b7c14:	428b      	cmp	r3, r1
   b7c16:	f340 814c 	ble.w	b7eb2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2ce>
   b7c1a:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
   b7c1e:	42b3      	cmp	r3, r6
   b7c20:	f340 8147 	ble.w	b7eb2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2ce>
           ((x + 6 * size_x - 1) < 0) || // Clip left
   b7c24:	2306      	movs	r3, #6
   b7c26:	fb13 1305 	smlabb	r3, r3, r5, r1
           (y >= _height)           || // Clip bottom
   b7c2a:	2b00      	cmp	r3, #0
   b7c2c:	f340 8141 	ble.w	b7eb2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2ce>
           ((y + 8 * size_y - 1) < 0))   // Clip top
   b7c30:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
           ((x + 6 * size_x - 1) < 0) || // Clip left
   b7c34:	2b00      	cmp	r3, #0
   b7c36:	f340 813c 	ble.w	b7eb2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2ce>
        if(!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
   b7c3a:	7f03      	ldrb	r3, [r0, #28]
   b7c3c:	b91b      	cbnz	r3, b7c46 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x62>
   b7c3e:	2faf      	cmp	r7, #175	; 0xaf
   b7c40:	bf84      	itt	hi
   b7c42:	3701      	addhi	r7, #1
   b7c44:	b2ff      	uxtbhi	r7, r7
        startWrite();
   b7c46:	f8db 3000 	ldr.w	r3, [fp]
   b7c4a:	4658      	mov	r0, fp
   b7c4c:	695b      	ldr	r3, [r3, #20]
   b7c4e:	4798      	blx	r3
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
   b7c50:	2205      	movs	r2, #5
   b7c52:	9209      	str	r2, [sp, #36]	; 0x24
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
   b7c54:	2200      	movs	r2, #0
   b7c56:	9205      	str	r2, [sp, #20]
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
   b7c58:	4a98      	ldr	r2, [pc, #608]	; (b7ebc <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2d8>)
   b7c5a:	eb07 0387 	add.w	r3, r7, r7, lsl #2
   b7c5e:	18d3      	adds	r3, r2, r3
   b7c60:	930c      	str	r3, [sp, #48]	; 0x30
                        writePixel(x+i, y+j, color);
   b7c62:	b2b3      	uxth	r3, r6
   b7c64:	9306      	str	r3, [sp, #24]
            uint8_t line = pgm_read_byte(&font[c * 5 + i]);
   b7c66:	9a05      	ldr	r2, [sp, #20]
   b7c68:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b7c6a:	5c9b      	ldrb	r3, [r3, r2]
   b7c6c:	9307      	str	r3, [sp, #28]
                        writeFillRect(x+i*size_x, y+j*size_y, size_x, size_y, bg);
   b7c6e:	b2ab      	uxth	r3, r5
   b7c70:	930b      	str	r3, [sp, #44]	; 0x2c
   b7c72:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   b7c76:	9308      	str	r3, [sp, #32]
   b7c78:	9b03      	ldr	r3, [sp, #12]
   b7c7a:	fb02 f905 	mul.w	r9, r2, r5
   b7c7e:	fa19 f983 	uxtah	r9, r9, r3
   b7c82:	fa0f f389 	sxth.w	r3, r9
   b7c86:	ee08 3a10 	vmov	s16, r3
   b7c8a:	2308      	movs	r3, #8
   b7c8c:	930a      	str	r3, [sp, #40]	; 0x28
                        writePixel(x+i, y+j, bg);
   b7c8e:	9b03      	ldr	r3, [sp, #12]
   b7c90:	eb02 0a03 	add.w	sl, r2, r3
            for(int8_t j=0; j<8; j++, line >>= 1) {
   b7c94:	f04f 0900 	mov.w	r9, #0
                        writePixel(x+i, y+j, bg);
   b7c98:	fa0f fa8a 	sxth.w	sl, sl
                if(line & 1) {
   b7c9c:	9a07      	ldr	r2, [sp, #28]
                        writePixel(x+i, y+j, color);
   b7c9e:	f8db 3000 	ldr.w	r3, [fp]
                if(line & 1) {
   b7ca2:	07d2      	lsls	r2, r2, #31
   b7ca4:	d552      	bpl.n	b7d4c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x168>
                    if(size_x == 1 && size_y == 1)
   b7ca6:	2d01      	cmp	r5, #1
                        writePixel(x+i, y+j, color);
   b7ca8:	fa1f f289 	uxth.w	r2, r9
                    if(size_x == 1 && size_y == 1)
   b7cac:	d13e      	bne.n	b7d2c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x148>
   b7cae:	2c01      	cmp	r4, #1
   b7cb0:	d13c      	bne.n	b7d2c <_ZN12Adafruit_GFX8drawCharEsshtthh+0x148>
                        writePixel(x+i, y+j, color);
   b7cb2:	699b      	ldr	r3, [r3, #24]
   b7cb4:	9906      	ldr	r1, [sp, #24]
   b7cb6:	461f      	mov	r7, r3
   b7cb8:	9b04      	ldr	r3, [sp, #16]
   b7cba:	440a      	add	r2, r1
                        writePixel(x+i, y+j, bg);
   b7cbc:	b212      	sxth	r2, r2
   b7cbe:	4651      	mov	r1, sl
   b7cc0:	4658      	mov	r0, fp
   b7cc2:	47b8      	blx	r7
            for(int8_t j=0; j<8; j++, line >>= 1) {
   b7cc4:	f109 0301 	add.w	r3, r9, #1
   b7cc8:	fa4f f983 	sxtb.w	r9, r3
   b7ccc:	9b07      	ldr	r3, [sp, #28]
   b7cce:	085b      	lsrs	r3, r3, #1
   b7cd0:	9307      	str	r3, [sp, #28]
   b7cd2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   b7cd4:	3b01      	subs	r3, #1
   b7cd6:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   b7cda:	930a      	str	r3, [sp, #40]	; 0x28
   b7cdc:	d1de      	bne.n	b7c9c <_ZN12Adafruit_GFX8drawCharEsshtthh+0xb8>
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
   b7cde:	9f05      	ldr	r7, [sp, #20]
   b7ce0:	3701      	adds	r7, #1
   b7ce2:	b27b      	sxtb	r3, r7
   b7ce4:	9305      	str	r3, [sp, #20]
   b7ce6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   b7ce8:	3b01      	subs	r3, #1
   b7cea:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
   b7cee:	9309      	str	r3, [sp, #36]	; 0x24
   b7cf0:	d1b9      	bne.n	b7c66 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x82>
        if(bg != color) { // If opaque, draw vertical line for last column
   b7cf2:	9b04      	ldr	r3, [sp, #16]
   b7cf4:	4543      	cmp	r3, r8
   b7cf6:	d00f      	beq.n	b7d18 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x134>
            if(size_x == 1 && size_y == 1) writeFastVLine(x+5, y, 8, bg);
   b7cf8:	2d01      	cmp	r5, #1
   b7cfa:	f8db 3000 	ldr.w	r3, [fp]
   b7cfe:	d13b      	bne.n	b7d78 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x194>
   b7d00:	2c01      	cmp	r4, #1
   b7d02:	d139      	bne.n	b7d78 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x194>
   b7d04:	9908      	ldr	r1, [sp, #32]
   b7d06:	f8cd 8000 	str.w	r8, [sp]
   b7d0a:	3105      	adds	r1, #5
   b7d0c:	6a1c      	ldr	r4, [r3, #32]
   b7d0e:	4632      	mov	r2, r6
   b7d10:	2308      	movs	r3, #8
   b7d12:	b209      	sxth	r1, r1
   b7d14:	4658      	mov	r0, fp
   b7d16:	47a0      	blx	r4
        endWrite();
   b7d18:	f8db 3000 	ldr.w	r3, [fp]
   b7d1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b7d1e:	4658      	mov	r0, fp
}
   b7d20:	b011      	add	sp, #68	; 0x44
   b7d22:	ecbd 8b02 	vpop	{d8}
   b7d26:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        endWrite();
   b7d2a:	4718      	bx	r3
                        writeFillRect(x+i*size_x, y+j*size_y, size_x, size_y, color);
   b7d2c:	9906      	ldr	r1, [sp, #24]
   b7d2e:	fb14 f202 	smulbb	r2, r4, r2
   b7d32:	440a      	add	r2, r1
   b7d34:	9904      	ldr	r1, [sp, #16]
   b7d36:	9101      	str	r1, [sp, #4]
                        writeFillRect(x+i*size_x, y+j*size_y, size_x, size_y, bg);
   b7d38:	9400      	str	r4, [sp, #0]
   b7d3a:	69db      	ldr	r3, [r3, #28]
   b7d3c:	ee18 1a10 	vmov	r1, s16
   b7d40:	461f      	mov	r7, r3
   b7d42:	b212      	sxth	r2, r2
   b7d44:	462b      	mov	r3, r5
   b7d46:	4658      	mov	r0, fp
   b7d48:	47b8      	blx	r7
   b7d4a:	e7bb      	b.n	b7cc4 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xe0>
                } else if(bg != color) {
   b7d4c:	9a04      	ldr	r2, [sp, #16]
   b7d4e:	4542      	cmp	r2, r8
   b7d50:	d0b8      	beq.n	b7cc4 <_ZN12Adafruit_GFX8drawCharEsshtthh+0xe0>
                    if(size_x == 1 && size_y == 1)
   b7d52:	2d01      	cmp	r5, #1
                        writePixel(x+i, y+j, color);
   b7d54:	fa1f f289 	uxth.w	r2, r9
                    if(size_x == 1 && size_y == 1)
   b7d58:	d107      	bne.n	b7d6a <_ZN12Adafruit_GFX8drawCharEsshtthh+0x186>
   b7d5a:	2c01      	cmp	r4, #1
   b7d5c:	d105      	bne.n	b7d6a <_ZN12Adafruit_GFX8drawCharEsshtthh+0x186>
                        writePixel(x+i, y+j, bg);
   b7d5e:	699b      	ldr	r3, [r3, #24]
   b7d60:	9906      	ldr	r1, [sp, #24]
   b7d62:	461f      	mov	r7, r3
   b7d64:	440a      	add	r2, r1
   b7d66:	4643      	mov	r3, r8
   b7d68:	e7a8      	b.n	b7cbc <_ZN12Adafruit_GFX8drawCharEsshtthh+0xd8>
                        writeFillRect(x+i*size_x, y+j*size_y, size_x, size_y, bg);
   b7d6a:	9906      	ldr	r1, [sp, #24]
   b7d6c:	f8cd 8004 	str.w	r8, [sp, #4]
   b7d70:	fb14 f202 	smulbb	r2, r4, r2
   b7d74:	440a      	add	r2, r1
   b7d76:	e7df      	b.n	b7d38 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x154>
            else          writeFillRect(x+5*size_x, y, size_x, 8*size_y, bg);
   b7d78:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   b7d7a:	f8cd 8004 	str.w	r8, [sp, #4]
   b7d7e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
   b7d82:	9a08      	ldr	r2, [sp, #32]
   b7d84:	00e4      	lsls	r4, r4, #3
   b7d86:	440a      	add	r2, r1
   b7d88:	4611      	mov	r1, r2
   b7d8a:	9400      	str	r4, [sp, #0]
   b7d8c:	69dc      	ldr	r4, [r3, #28]
   b7d8e:	4632      	mov	r2, r6
   b7d90:	462b      	mov	r3, r5
   b7d92:	b209      	sxth	r1, r1
   b7d94:	4658      	mov	r0, fp
   b7d96:	47a0      	blx	r4
        endWrite();
   b7d98:	e7be      	b.n	b7d18 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x134>
        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
   b7d9a:	7a13      	ldrb	r3, [r2, #8]
    return gfxFont->glyph + c;
   b7d9c:	6851      	ldr	r1, [r2, #4]
    return gfxFont->bitmap;
   b7d9e:	6812      	ldr	r2, [r2, #0]
   b7da0:	920b      	str	r2, [sp, #44]	; 0x2c
        c -= (uint8_t)pgm_read_byte(&gfxFont->first);
   b7da2:	1aff      	subs	r7, r7, r3
    return gfxFont->glyph + c;
   b7da4:	b2ff      	uxtb	r7, r7
   b7da6:	eb01 03c7 	add.w	r3, r1, r7, lsl #3
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
   b7daa:	f831 2037 	ldrh.w	r2, [r1, r7, lsl #3]
   b7dae:	9206      	str	r2, [sp, #24]
        uint8_t  w  = pgm_read_byte(&glyph->width),
   b7db0:	789a      	ldrb	r2, [r3, #2]
   b7db2:	9209      	str	r2, [sp, #36]	; 0x24
                 h  = pgm_read_byte(&glyph->height);
   b7db4:	78da      	ldrb	r2, [r3, #3]
   b7db6:	920c      	str	r2, [sp, #48]	; 0x30
        if(size_x > 1 || size_y > 1) {
   b7db8:	2d01      	cmp	r5, #1
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
   b7dba:	f993 2005 	ldrsb.w	r2, [r3, #5]
                 yo = pgm_read_byte(&glyph->yOffset);
   b7dbe:	f993 a006 	ldrsb.w	sl, [r3, #6]
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
   b7dc2:	920a      	str	r2, [sp, #40]	; 0x28
        if(size_x > 1 || size_y > 1) {
   b7dc4:	d801      	bhi.n	b7dca <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1e6>
   b7dc6:	2c01      	cmp	r4, #1
   b7dc8:	d957      	bls.n	b7e7a <_ZN12Adafruit_GFX8drawCharEsshtthh+0x296>
            xo16 = xo;
   b7dca:	f9bd 3028 	ldrsh.w	r3, [sp, #40]	; 0x28
   b7dce:	9308      	str	r3, [sp, #32]
            yo16 = yo;
   b7dd0:	fa0f f38a 	sxth.w	r3, sl
   b7dd4:	9307      	str	r3, [sp, #28]
        startWrite();
   b7dd6:	f8db 3000 	ldr.w	r3, [fp]
   b7dda:	4658      	mov	r0, fp
   b7ddc:	695b      	ldr	r3, [r3, #20]
   b7dde:	4798      	blx	r3
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7de0:	b2b3      	uxth	r3, r6
        uint8_t  xx, yy, bits = 0, bit = 0;
   b7de2:	f04f 0800 	mov.w	r8, #0
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7de6:	930e      	str	r3, [sp, #56]	; 0x38
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7de8:	fa1a f386 	uxtah	r3, sl, r6
        uint8_t  xx, yy, bits = 0, bit = 0;
   b7dec:	46c1      	mov	r9, r8
        for(yy=0; yy<h; yy++) {
   b7dee:	4647      	mov	r7, r8
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7df0:	930f      	str	r3, [sp, #60]	; 0x3c
        for(yy=0; yy<h; yy++) {
   b7df2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   b7df4:	429f      	cmp	r7, r3
   b7df6:	d28f      	bcs.n	b7d18 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x134>
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7df8:	9b07      	ldr	r3, [sp, #28]
   b7dfa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   b7dfc:	443b      	add	r3, r7
   b7dfe:	fb03 2304 	mla	r3, r3, r4, r2
            for(xx=0; xx<w; xx++) {
   b7e02:	2200      	movs	r2, #0
   b7e04:	9205      	str	r2, [sp, #20]
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7e06:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7e08:	b21b      	sxth	r3, r3
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7e0a:	eb02 0a07 	add.w	sl, r2, r7
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7e0e:	ee08 3a10 	vmov	s16, r3
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7e12:	fa0f fa8a 	sxth.w	sl, sl
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7e16:	4643      	mov	r3, r8
            for(xx=0; xx<w; xx++) {
   b7e18:	9a09      	ldr	r2, [sp, #36]	; 0x24
   b7e1a:	9905      	ldr	r1, [sp, #20]
   b7e1c:	4291      	cmp	r1, r2
   b7e1e:	d241      	bcs.n	b7ea4 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x2c0>
                if(!(bit++ & 7)) {
   b7e20:	1c5a      	adds	r2, r3, #1
   b7e22:	b2d2      	uxtb	r2, r2
   b7e24:	075b      	lsls	r3, r3, #29
   b7e26:	920d      	str	r2, [sp, #52]	; 0x34
   b7e28:	d107      	bne.n	b7e3a <_ZN12Adafruit_GFX8drawCharEsshtthh+0x256>
                    bits = pgm_read_byte(&bitmap[bo++]);
   b7e2a:	9b06      	ldr	r3, [sp, #24]
   b7e2c:	9906      	ldr	r1, [sp, #24]
   b7e2e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   b7e30:	3301      	adds	r3, #1
   b7e32:	b29b      	uxth	r3, r3
   b7e34:	f812 9001 	ldrb.w	r9, [r2, r1]
   b7e38:	9306      	str	r3, [sp, #24]
                if(bits & 0x80) {
   b7e3a:	f019 0f80 	tst.w	r9, #128	; 0x80
   b7e3e:	d012      	beq.n	b7e66 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x282>
                    if(size_x == 1 && size_y == 1) {
   b7e40:	2d01      	cmp	r5, #1
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7e42:	f8db 3000 	ldr.w	r3, [fp]
                        writeFillRect(x+i*size_x, y+j*size_y, size_x, size_y, bg);
   b7e46:	f8bd 100c 	ldrh.w	r1, [sp, #12]
                    if(size_x == 1 && size_y == 1) {
   b7e4a:	d11a      	bne.n	b7e82 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29e>
   b7e4c:	2c01      	cmp	r4, #1
   b7e4e:	d118      	bne.n	b7e82 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x29e>
                        writePixel(x+xo+xx, y+yo+yy, color);
   b7e50:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   b7e52:	699b      	ldr	r3, [r3, #24]
   b7e54:	4411      	add	r1, r2
   b7e56:	9a05      	ldr	r2, [sp, #20]
   b7e58:	4411      	add	r1, r2
   b7e5a:	461e      	mov	r6, r3
   b7e5c:	4652      	mov	r2, sl
   b7e5e:	9b04      	ldr	r3, [sp, #16]
   b7e60:	b209      	sxth	r1, r1
   b7e62:	4658      	mov	r0, fp
   b7e64:	47b0      	blx	r6
            for(xx=0; xx<w; xx++) {
   b7e66:	9e05      	ldr	r6, [sp, #20]
   b7e68:	3601      	adds	r6, #1
   b7e6a:	b2f3      	uxtb	r3, r6
                bits <<= 1;
   b7e6c:	ea4f 0949 	mov.w	r9, r9, lsl #1
            for(xx=0; xx<w; xx++) {
   b7e70:	9305      	str	r3, [sp, #20]
                bits <<= 1;
   b7e72:	fa5f f989 	uxtb.w	r9, r9
                if(!(bit++ & 7)) {
   b7e76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            for(xx=0; xx<w; xx++) {
   b7e78:	e7ce      	b.n	b7e18 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x234>
        int16_t  xo16 = 0, yo16 = 0;
   b7e7a:	2300      	movs	r3, #0
   b7e7c:	e9cd 3307 	strd	r3, r3, [sp, #28]
   b7e80:	e7a9      	b.n	b7dd6 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x1f2>
                        writeFillRect(x+(xo16+xx)*size_x, y+(yo16+yy)*size_y,
   b7e82:	9805      	ldr	r0, [sp, #20]
   b7e84:	9a08      	ldr	r2, [sp, #32]
   b7e86:	4402      	add	r2, r0
   b7e88:	fb02 1105 	mla	r1, r2, r5, r1
   b7e8c:	9a04      	ldr	r2, [sp, #16]
   b7e8e:	e9cd 4200 	strd	r4, r2, [sp]
   b7e92:	69db      	ldr	r3, [r3, #28]
   b7e94:	ee18 2a10 	vmov	r2, s16
   b7e98:	461e      	mov	r6, r3
   b7e9a:	b209      	sxth	r1, r1
   b7e9c:	462b      	mov	r3, r5
   b7e9e:	4658      	mov	r0, fp
   b7ea0:	47b0      	blx	r6
   b7ea2:	e7e0      	b.n	b7e66 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x282>
   b7ea4:	9b09      	ldr	r3, [sp, #36]	; 0x24
        for(yy=0; yy<h; yy++) {
   b7ea6:	3701      	adds	r7, #1
   b7ea8:	4498      	add	r8, r3
   b7eaa:	fa5f f888 	uxtb.w	r8, r8
   b7eae:	b2ff      	uxtb	r7, r7
   b7eb0:	e79f      	b.n	b7df2 <_ZN12Adafruit_GFX8drawCharEsshtthh+0x20e>
}
   b7eb2:	b011      	add	sp, #68	; 0x44
   b7eb4:	ecbd 8b02 	vpop	{d8}
   b7eb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   b7ebc:	000c1590 	.word	0x000c1590

000b7ec0 <_ZN12Adafruit_GFX5writeEh>:
size_t Adafruit_GFX::write(uint8_t c) {
   b7ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(!gfxFont) { // 'Classic' built-in font
   b7ec2:	6a02      	ldr	r2, [r0, #32]
size_t Adafruit_GFX::write(uint8_t c) {
   b7ec4:	b085      	sub	sp, #20
   b7ec6:	4604      	mov	r4, r0
   b7ec8:	460b      	mov	r3, r1
    if(!gfxFont) { // 'Classic' built-in font
   b7eca:	2a00      	cmp	r2, #0
   b7ecc:	d134      	bne.n	b7f38 <_ZN12Adafruit_GFX5writeEh+0x78>
        if(c == '\n') {                        // Newline?
   b7ece:	290a      	cmp	r1, #10
   b7ed0:	d108      	bne.n	b7ee4 <_ZN12Adafruit_GFX5writeEh+0x24>
            cursor_y += textsize_y * 8;        // advance y one line
   b7ed2:	8a43      	ldrh	r3, [r0, #18]
            cursor_x  = 0;                     // Reset x to zero,
   b7ed4:	8202      	strh	r2, [r0, #16]
            cursor_y += textsize_y * 8;        // advance y one line
   b7ed6:	7e42      	ldrb	r2, [r0, #25]
   b7ed8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
            cursor_y += (int16_t)textsize_y *
   b7edc:	8263      	strh	r3, [r4, #18]
}
   b7ede:	2001      	movs	r0, #1
   b7ee0:	b005      	add	sp, #20
   b7ee2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        } else if(c != '\r') {                 // Ignore carriage returns
   b7ee4:	290d      	cmp	r1, #13
   b7ee6:	d0fa      	beq.n	b7ede <_ZN12Adafruit_GFX5writeEh+0x1e>
            if(wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
   b7ee8:	7ee1      	ldrb	r1, [r4, #27]
   b7eea:	7e00      	ldrb	r0, [r0, #24]
            cursor_y += textsize_y * 8;        // advance y one line
   b7eec:	7e65      	ldrb	r5, [r4, #25]
            if(wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
   b7eee:	b171      	cbz	r1, b7f0e <_ZN12Adafruit_GFX5writeEh+0x4e>
   b7ef0:	f9b4 6010 	ldrsh.w	r6, [r4, #16]
   b7ef4:	2106      	movs	r1, #6
   b7ef6:	fb11 6100 	smlabb	r1, r1, r0, r6
   b7efa:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
   b7efe:	42b1      	cmp	r1, r6
            cursor_y += textsize_y * 8;        // advance y one line
   b7f00:	bfc1      	itttt	gt
   b7f02:	f9b4 1012 	ldrshgt.w	r1, [r4, #18]
                cursor_x  = 0;                 // Reset x to zero,
   b7f06:	8222      	strhgt	r2, [r4, #16]
                cursor_y += textsize_y * 8;    // advance y one line
   b7f08:	eb01 02c5 	addgt.w	r2, r1, r5, lsl #3
   b7f0c:	8262      	strhgt	r2, [r4, #18]
            drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x, textsize_y);
   b7f0e:	8ae2      	ldrh	r2, [r4, #22]
   b7f10:	9201      	str	r2, [sp, #4]
   b7f12:	8aa2      	ldrh	r2, [r4, #20]
   b7f14:	9200      	str	r2, [sp, #0]
   b7f16:	e9cd 0502 	strd	r0, r5, [sp, #8]
   b7f1a:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
   b7f1e:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
   b7f22:	4620      	mov	r0, r4
   b7f24:	f7ff fe5e 	bl	b7be4 <_ZN12Adafruit_GFX8drawCharEsshtthh>
            cursor_x += textsize_x * 6;          // Advance x one char
   b7f28:	7e23      	ldrb	r3, [r4, #24]
   b7f2a:	8a22      	ldrh	r2, [r4, #16]
   b7f2c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   b7f30:	eb02 0343 	add.w	r3, r2, r3, lsl #1
                cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
   b7f34:	8223      	strh	r3, [r4, #16]
   b7f36:	e7d2      	b.n	b7ede <_ZN12Adafruit_GFX5writeEh+0x1e>
        if(c == '\n') {
   b7f38:	290a      	cmp	r1, #10
   b7f3a:	d107      	bne.n	b7f4c <_ZN12Adafruit_GFX5writeEh+0x8c>
            cursor_x  = 0;
   b7f3c:	2300      	movs	r3, #0
   b7f3e:	8203      	strh	r3, [r0, #16]
            cursor_y += (int16_t)textsize_y *
   b7f40:	7e41      	ldrb	r1, [r0, #25]
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
   b7f42:	7a92      	ldrb	r2, [r2, #10]
            cursor_y += (int16_t)textsize_y *
   b7f44:	8a43      	ldrh	r3, [r0, #18]
   b7f46:	fb01 3302 	mla	r3, r1, r2, r3
   b7f4a:	e7c7      	b.n	b7edc <_ZN12Adafruit_GFX5writeEh+0x1c>
        } else if(c != '\r') {
   b7f4c:	290d      	cmp	r1, #13
   b7f4e:	d0c6      	beq.n	b7ede <_ZN12Adafruit_GFX5writeEh+0x1e>
            uint8_t first = pgm_read_byte(&gfxFont->first);
   b7f50:	7a15      	ldrb	r5, [r2, #8]
            if((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
   b7f52:	42a9      	cmp	r1, r5
   b7f54:	d3c3      	bcc.n	b7ede <_ZN12Adafruit_GFX5writeEh+0x1e>
   b7f56:	7a51      	ldrb	r1, [r2, #9]
   b7f58:	4299      	cmp	r1, r3
   b7f5a:	d3c0      	bcc.n	b7ede <_ZN12Adafruit_GFX5writeEh+0x1e>
    return gfxFont->glyph + c;
   b7f5c:	6851      	ldr	r1, [r2, #4]
                GFXglyph *glyph  = pgm_read_glyph_ptr(gfxFont, c - first);
   b7f5e:	1b5d      	subs	r5, r3, r5
    return gfxFont->glyph + c;
   b7f60:	b2ed      	uxtb	r5, r5
   b7f62:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
                uint8_t   w     = pgm_read_byte(&glyph->width),
   b7f66:	78a8      	ldrb	r0, [r5, #2]
                if((w > 0) && (h > 0)) { // Is there an associated bitmap?
   b7f68:	b328      	cbz	r0, b7fb6 <_ZN12Adafruit_GFX5writeEh+0xf6>
   b7f6a:	78e9      	ldrb	r1, [r5, #3]
   b7f6c:	b319      	cbz	r1, b7fb6 <_ZN12Adafruit_GFX5writeEh+0xf6>
                    if(wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
   b7f6e:	7ee1      	ldrb	r1, [r4, #27]
            if(wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
   b7f70:	7e26      	ldrb	r6, [r4, #24]
            cursor_y += textsize_y * 8;        // advance y one line
   b7f72:	7e67      	ldrb	r7, [r4, #25]
                    if(wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
   b7f74:	b191      	cbz	r1, b7f9c <_ZN12Adafruit_GFX5writeEh+0xdc>
   b7f76:	f995 1005 	ldrsb.w	r1, [r5, #5]
   b7f7a:	4408      	add	r0, r1
   b7f7c:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
   b7f80:	fb06 1100 	mla	r1, r6, r0, r1
   b7f84:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
   b7f88:	4281      	cmp	r1, r0
   b7f8a:	dd07      	ble.n	b7f9c <_ZN12Adafruit_GFX5writeEh+0xdc>
                        cursor_x  = 0;
   b7f8c:	2000      	movs	r0, #0
   b7f8e:	8220      	strh	r0, [r4, #16]
            cursor_y += textsize_y * 8;        // advance y one line
   b7f90:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
                          (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
   b7f94:	7a92      	ldrb	r2, [r2, #10]
                        cursor_y += (int16_t)textsize_y *
   b7f96:	fb02 1207 	mla	r2, r2, r7, r1
   b7f9a:	8262      	strh	r2, [r4, #18]
                    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x, textsize_y);
   b7f9c:	8ae2      	ldrh	r2, [r4, #22]
   b7f9e:	9201      	str	r2, [sp, #4]
   b7fa0:	8aa2      	ldrh	r2, [r4, #20]
   b7fa2:	9200      	str	r2, [sp, #0]
   b7fa4:	e9cd 6702 	strd	r6, r7, [sp, #8]
   b7fa8:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
   b7fac:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
   b7fb0:	4620      	mov	r0, r4
   b7fb2:	f7ff fe17 	bl	b7be4 <_ZN12Adafruit_GFX8drawCharEsshtthh>
                cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
   b7fb6:	7929      	ldrb	r1, [r5, #4]
   b7fb8:	7e22      	ldrb	r2, [r4, #24]
   b7fba:	8a23      	ldrh	r3, [r4, #16]
   b7fbc:	fb01 3302 	mla	r3, r1, r2, r3
   b7fc0:	e7b8      	b.n	b7f34 <_ZN12Adafruit_GFX5writeEh+0x74>

000b7fc2 <_ZN12Adafruit_GFX11setTextSizeEh>:
    textsize_x = (s_x > 0) ? s_x : 1;
   b7fc2:	2901      	cmp	r1, #1
   b7fc4:	bf38      	it	cc
   b7fc6:	2101      	movcc	r1, #1
   b7fc8:	7601      	strb	r1, [r0, #24]
    textsize_y = (s_y > 0) ? s_y : 1;
   b7fca:	7641      	strb	r1, [r0, #25]
}
   b7fcc:	4770      	bx	lr

000b7fce <_ZN18Adafruit_SPIDeviceD1Ev>:
}

/*!
 *    @brief  Release memory allocated in constructors
 */
Adafruit_SPIDevice::~Adafruit_SPIDevice() {
   b7fce:	b510      	push	{r4, lr}
   b7fd0:	4604      	mov	r4, r0
  if (_spiSetting) {
   b7fd2:	6840      	ldr	r0, [r0, #4]
   b7fd4:	b110      	cbz	r0, b7fdc <_ZN18Adafruit_SPIDeviceD1Ev+0xe>
    delete _spiSetting;
   b7fd6:	6803      	ldr	r3, [r0, #0]
   b7fd8:	689b      	ldr	r3, [r3, #8]
   b7fda:	4798      	blx	r3
    _spiSetting = nullptr;
  }
}
   b7fdc:	4620      	mov	r0, r4
   b7fde:	bd10      	pop	{r4, pc}

000b7fe0 <_ZN18Adafruit_SPIDevice5beginEv>:
/*!
 *    @brief  Initializes SPI bus and sets CS pin high
 *    @return Always returns true because there's no way to test success of SPI
 * init
 */
bool Adafruit_SPIDevice::begin(void) {
   b7fe0:	b538      	push	{r3, r4, r5, lr}
   b7fe2:	4604      	mov	r4, r0
  pinMode(_cs, OUTPUT);
   b7fe4:	f990 000e 	ldrsb.w	r0, [r0, #14]
   b7fe8:	2101      	movs	r1, #1
   b7fea:	b280      	uxth	r0, r0
   b7fec:	f005 ffbe 	bl	bdf6c <pinMode>
  digitalWrite(_cs, HIGH);
   b7ff0:	f994 000e 	ldrsb.w	r0, [r4, #14]
   b7ff4:	2101      	movs	r1, #1
   b7ff6:	b280      	uxth	r0, r0
   b7ff8:	f005 ffc9 	bl	bdf8e <digitalWrite>

  if (_spi) { // hardware SPI
   b7ffc:	6825      	ldr	r5, [r4, #0]
   b7ffe:	b135      	cbz	r5, b800e <_ZN18Adafruit_SPIDevice5beginEv+0x2e>
    _spi->begin();
   b8000:	4628      	mov	r0, r5
   b8002:	f002 faa9 	bl	ba558 <_ZN8SPIClass5beginEv>
    if (_miso != -1) {
      pinMode(_miso, INPUT);
    }
  }

  _begun = true;
   b8006:	2001      	movs	r0, #1
   b8008:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  return true;
}
   b800c:	bd38      	pop	{r3, r4, r5, pc}
    pinMode(_sck, OUTPUT);
   b800e:	f994 000f 	ldrsb.w	r0, [r4, #15]
   b8012:	2101      	movs	r1, #1
   b8014:	b280      	uxth	r0, r0
   b8016:	f005 ffa9 	bl	bdf6c <pinMode>
    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
   b801a:	7b63      	ldrb	r3, [r4, #13]
   b801c:	f994 000f 	ldrsb.w	r0, [r4, #15]
   b8020:	2b01      	cmp	r3, #1
      digitalWrite(_sck, LOW);
   b8022:	bf94      	ite	ls
   b8024:	4629      	movls	r1, r5
      digitalWrite(_sck, HIGH);
   b8026:	2101      	movhi	r1, #1
   b8028:	b280      	uxth	r0, r0
   b802a:	f005 ffb0 	bl	bdf8e <digitalWrite>
    if (_mosi != -1) {
   b802e:	f994 0010 	ldrsb.w	r0, [r4, #16]
   b8032:	1c42      	adds	r2, r0, #1
   b8034:	d009      	beq.n	b804a <_ZN18Adafruit_SPIDevice5beginEv+0x6a>
      pinMode(_mosi, OUTPUT);
   b8036:	2101      	movs	r1, #1
   b8038:	b280      	uxth	r0, r0
   b803a:	f005 ff97 	bl	bdf6c <pinMode>
      digitalWrite(_mosi, HIGH);
   b803e:	f994 0010 	ldrsb.w	r0, [r4, #16]
   b8042:	2101      	movs	r1, #1
   b8044:	b280      	uxth	r0, r0
   b8046:	f005 ffa2 	bl	bdf8e <digitalWrite>
    if (_miso != -1) {
   b804a:	f994 0011 	ldrsb.w	r0, [r4, #17]
   b804e:	1c43      	adds	r3, r0, #1
   b8050:	d0d9      	beq.n	b8006 <_ZN18Adafruit_SPIDevice5beginEv+0x26>
      pinMode(_miso, INPUT);
   b8052:	2100      	movs	r1, #0
   b8054:	b280      	uxth	r0, r0
   b8056:	f005 ff89 	bl	bdf6c <pinMode>
   b805a:	e7d4      	b.n	b8006 <_ZN18Adafruit_SPIDevice5beginEv+0x26>

000b805c <_ZN18Adafruit_SPIDevice8transferEPhj>:
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
   b805c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b8060:	4604      	mov	r4, r0
  if (_spi) {
   b8062:	6800      	ldr	r0, [r0, #0]
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
   b8064:	b085      	sub	sp, #20
   b8066:	460d      	mov	r5, r1
  if (_spi) {
   b8068:	b140      	cbz	r0, b807c <_ZN18Adafruit_SPIDevice8transferEPhj+0x20>
    // hardware SPI is easy

#if defined(SPARK)
    _spi->transfer(buffer, buffer, len, NULL);
   b806a:	2300      	movs	r3, #0
   b806c:	9300      	str	r3, [sp, #0]
   b806e:	4613      	mov	r3, r2
   b8070:	460a      	mov	r2, r1
   b8072:	f002 fb13 	bl	ba69c <_ZN8SPIClass8transferEPKvPvjPFvvE>
        buffer[i] = reply;
      }
    }
  }
  return;
}
   b8076:	b005      	add	sp, #20
   b8078:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
   b807c:	7b23      	ldrb	r3, [r4, #12]
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
   b807e:	68a0      	ldr	r0, [r4, #8]
   b8080:	4f48      	ldr	r7, [pc, #288]	; (b81a4 <_ZN18Adafruit_SPIDevice8transferEPhj+0x148>)
   b8082:	fbb7 f7f0 	udiv	r7, r7, r0
    startbit = 0x80;
   b8086:	2b00      	cmp	r3, #0
  bool towrite, lastmosi = !(buffer[0] & startbit);
   b8088:	780b      	ldrb	r3, [r1, #0]
    startbit = 0x80;
   b808a:	bf0c      	ite	eq
   b808c:	f04f 0b01 	moveq.w	fp, #1
   b8090:	f04f 0b80 	movne.w	fp, #128	; 0x80
  bool towrite, lastmosi = !(buffer[0] & startbit);
   b8094:	ea1b 0f03 	tst.w	fp, r3
   b8098:	eb01 0302 	add.w	r3, r1, r2
   b809c:	bf0c      	ite	eq
   b809e:	f04f 0901 	moveq.w	r9, #1
   b80a2:	f04f 0900 	movne.w	r9, #0
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
   b80a6:	b2ff      	uxtb	r7, r7
  for (size_t i = 0; i < len; i++) {
   b80a8:	9303      	str	r3, [sp, #12]
   b80aa:	9b03      	ldr	r3, [sp, #12]
   b80ac:	42ab      	cmp	r3, r5
   b80ae:	d0e2      	beq.n	b8076 <_ZN18Adafruit_SPIDevice8transferEPhj+0x1a>
    uint8_t send = buffer[i];
   b80b0:	f895 a000 	ldrb.w	sl, [r5]
    for (uint8_t b = startbit; b != 0;
   b80b4:	465e      	mov	r6, fp
    uint8_t reply = 0;
   b80b6:	f04f 0800 	mov.w	r8, #0
      if (bitdelay_us) {
   b80ba:	b117      	cbz	r7, b80c2 <_ZN18Adafruit_SPIDevice8transferEPhj+0x66>
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
void delay(unsigned long ms);
inline void delayMicroseconds(unsigned int us) { HAL_Delay_Microseconds(us); }
   b80bc:	4638      	mov	r0, r7
   b80be:	f001 fe4f 	bl	b9d60 <HAL_Delay_Microseconds>
      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
   b80c2:	7b63      	ldrb	r3, [r4, #13]
   b80c4:	f013 0ffd 	tst.w	r3, #253	; 0xfd
   b80c8:	d141      	bne.n	b814e <_ZN18Adafruit_SPIDevice8transferEPhj+0xf2>
        if ((_mosi != -1) && (lastmosi != towrite)) {
   b80ca:	f994 3010 	ldrsb.w	r3, [r4, #16]
   b80ce:	1c5a      	adds	r2, r3, #1
   b80d0:	d00f      	beq.n	b80f2 <_ZN18Adafruit_SPIDevice8transferEPhj+0x96>
        towrite = send & b;
   b80d2:	ea1a 0106 	ands.w	r1, sl, r6
        if ((_mosi != -1) && (lastmosi != towrite)) {
   b80d6:	bf14      	ite	ne
   b80d8:	2301      	movne	r3, #1
   b80da:	2300      	moveq	r3, #0
   b80dc:	454b      	cmp	r3, r9
   b80de:	d008      	beq.n	b80f2 <_ZN18Adafruit_SPIDevice8transferEPhj+0x96>
            *mosiPort |= mosiPinMask;
   b80e0:	6963      	ldr	r3, [r4, #20]
   b80e2:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b80e4:	681a      	ldr	r2, [r3, #0]
          if (towrite)
   b80e6:	2900      	cmp	r1, #0
   b80e8:	d02c      	beq.n	b8144 <_ZN18Adafruit_SPIDevice8transferEPhj+0xe8>
            *mosiPort |= mosiPinMask;
   b80ea:	4302      	orrs	r2, r0
   b80ec:	601a      	str	r2, [r3, #0]
   b80ee:	f04f 0901 	mov.w	r9, #1
        *clkPort |= clkPinMask; // Clock high
   b80f2:	69a1      	ldr	r1, [r4, #24]
   b80f4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   b80f6:	680a      	ldr	r2, [r1, #0]
   b80f8:	4313      	orrs	r3, r2
   b80fa:	600b      	str	r3, [r1, #0]
        if (bitdelay_us) {
   b80fc:	b117      	cbz	r7, b8104 <_ZN18Adafruit_SPIDevice8transferEPhj+0xa8>
   b80fe:	4638      	mov	r0, r7
   b8100:	f001 fe2e 	bl	b9d60 <HAL_Delay_Microseconds>
        if (_miso != -1) {
   b8104:	f994 3011 	ldrsb.w	r3, [r4, #17]
   b8108:	3301      	adds	r3, #1
   b810a:	d006      	beq.n	b811a <_ZN18Adafruit_SPIDevice8transferEPhj+0xbe>
          if (*misoPort & misoPinMask) {
   b810c:	69e3      	ldr	r3, [r4, #28]
   b810e:	681a      	ldr	r2, [r3, #0]
   b8110:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   b8112:	421a      	tst	r2, r3
            reply |= b;
   b8114:	bf18      	it	ne
   b8116:	ea46 0808 	orrne.w	r8, r6, r8
        *clkPort &= ~clkPinMask; // Clock low
   b811a:	69a1      	ldr	r1, [r4, #24]
   b811c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   b811e:	680a      	ldr	r2, [r1, #0]
   b8120:	ea22 0303 	bic.w	r3, r2, r3
   b8124:	600b      	str	r3, [r1, #0]
      if (_miso != -1) {
   b8126:	f994 3011 	ldrsb.w	r3, [r4, #17]
   b812a:	3301      	adds	r3, #1
        buffer[i] = reply;
   b812c:	bf18      	it	ne
   b812e:	f885 8000 	strbne.w	r8, [r5]
    for (uint8_t b = startbit; b != 0;
   b8132:	7b23      	ldrb	r3, [r4, #12]
   b8134:	2b00      	cmp	r3, #0
   b8136:	d132      	bne.n	b819e <_ZN18Adafruit_SPIDevice8transferEPhj+0x142>
   b8138:	0076      	lsls	r6, r6, #1
   b813a:	b2f6      	uxtb	r6, r6
   b813c:	2e00      	cmp	r6, #0
   b813e:	d1bc      	bne.n	b80ba <_ZN18Adafruit_SPIDevice8transferEPhj+0x5e>
  for (size_t i = 0; i < len; i++) {
   b8140:	3501      	adds	r5, #1
   b8142:	e7b2      	b.n	b80aa <_ZN18Adafruit_SPIDevice8transferEPhj+0x4e>
            *mosiPort &= ~mosiPinMask;
   b8144:	ea22 0200 	bic.w	r2, r2, r0
   b8148:	601a      	str	r2, [r3, #0]
   b814a:	4689      	mov	r9, r1
   b814c:	e7d1      	b.n	b80f2 <_ZN18Adafruit_SPIDevice8transferEPhj+0x96>
        *clkPort |= clkPinMask; // Clock high
   b814e:	69a1      	ldr	r1, [r4, #24]
   b8150:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   b8152:	680a      	ldr	r2, [r1, #0]
   b8154:	4313      	orrs	r3, r2
   b8156:	600b      	str	r3, [r1, #0]
        if (bitdelay_us) {
   b8158:	b117      	cbz	r7, b8160 <_ZN18Adafruit_SPIDevice8transferEPhj+0x104>
   b815a:	4638      	mov	r0, r7
   b815c:	f001 fe00 	bl	b9d60 <HAL_Delay_Microseconds>
        if (_mosi != -1) {
   b8160:	f994 3010 	ldrsb.w	r3, [r4, #16]
   b8164:	3301      	adds	r3, #1
   b8166:	d008      	beq.n	b817a <_ZN18Adafruit_SPIDevice8transferEPhj+0x11e>
            *mosiPort |= mosiPinMask;
   b8168:	6963      	ldr	r3, [r4, #20]
   b816a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   b816c:	681a      	ldr	r2, [r3, #0]
          if (send & b)
   b816e:	ea1a 0f06 	tst.w	sl, r6
            *mosiPort |= mosiPinMask;
   b8172:	bf14      	ite	ne
   b8174:	430a      	orrne	r2, r1
            *mosiPort &= ~mosiPinMask;
   b8176:	438a      	biceq	r2, r1
   b8178:	601a      	str	r2, [r3, #0]
        *clkPort &= ~clkPinMask; // Clock low
   b817a:	69a1      	ldr	r1, [r4, #24]
   b817c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   b817e:	680a      	ldr	r2, [r1, #0]
   b8180:	ea22 0303 	bic.w	r3, r2, r3
   b8184:	600b      	str	r3, [r1, #0]
        if (_miso != -1) {
   b8186:	f994 3011 	ldrsb.w	r3, [r4, #17]
   b818a:	3301      	adds	r3, #1
   b818c:	d0cb      	beq.n	b8126 <_ZN18Adafruit_SPIDevice8transferEPhj+0xca>
          if (*misoPort & misoPinMask) {
   b818e:	69e3      	ldr	r3, [r4, #28]
   b8190:	681a      	ldr	r2, [r3, #0]
   b8192:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   b8194:	421a      	tst	r2, r3
            reply |= b;
   b8196:	bf18      	it	ne
   b8198:	ea46 0808 	orrne.w	r8, r6, r8
   b819c:	e7c3      	b.n	b8126 <_ZN18Adafruit_SPIDevice8transferEPhj+0xca>
    for (uint8_t b = startbit; b != 0;
   b819e:	0876      	lsrs	r6, r6, #1
   b81a0:	e7cc      	b.n	b813c <_ZN18Adafruit_SPIDevice8transferEPhj+0xe0>
   b81a2:	bf00      	nop
   b81a4:	0007a120 	.word	0x0007a120

000b81a8 <_ZN18Adafruit_SPIDevice8transferEh>:
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
   b81a8:	b507      	push	{r0, r1, r2, lr}
  uint8_t data = send;
  transfer(&data, 1);
   b81aa:	2201      	movs	r2, #1
  uint8_t data = send;
   b81ac:	f88d 1007 	strb.w	r1, [sp, #7]
  transfer(&data, 1);
   b81b0:	f10d 0107 	add.w	r1, sp, #7
   b81b4:	f7ff ff52 	bl	b805c <_ZN18Adafruit_SPIDevice8transferEPhj>
  return data;
}
   b81b8:	f89d 0007 	ldrb.w	r0, [sp, #7]
   b81bc:	b003      	add	sp, #12
   b81be:	f85d fb04 	ldr.w	pc, [sp], #4

000b81c2 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j>:
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
   b81c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   b81c6:	4604      	mov	r4, r0
  if (_spi) {
   b81c8:	6800      	ldr	r0, [r0, #0]
                               uint8_t *prefix_buffer, size_t prefix_len) {
   b81ca:	460e      	mov	r6, r1
   b81cc:	4617      	mov	r7, r2
   b81ce:	461d      	mov	r5, r3
  if (_spi) {
   b81d0:	b110      	cbz	r0, b81d8 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x16>
    _spi->beginTransaction(*_spiSetting);
   b81d2:	6861      	ldr	r1, [r4, #4]
   b81d4:	f002 f9ee 	bl	ba5b4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>
  }

  digitalWrite(_cs, LOW);
   b81d8:	f994 000e 	ldrsb.w	r0, [r4, #14]
   b81dc:	2100      	movs	r1, #0
   b81de:	b280      	uxth	r0, r0
   b81e0:	f005 fed5 	bl	bdf8e <digitalWrite>
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
   b81e4:	9b06      	ldr	r3, [sp, #24]
   b81e6:	eb05 0803 	add.w	r8, r5, r3
   b81ea:	4545      	cmp	r5, r8
   b81ec:	d108      	bne.n	b8200 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x3e>
   b81ee:	4437      	add	r7, r6
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
   b81f0:	42b7      	cmp	r7, r6
   b81f2:	d00b      	beq.n	b820c <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x4a>
    transfer(buffer[i]);
   b81f4:	f816 1b01 	ldrb.w	r1, [r6], #1
   b81f8:	4620      	mov	r0, r4
   b81fa:	f7ff ffd5 	bl	b81a8 <_ZN18Adafruit_SPIDevice8transferEh>
  for (size_t i = 0; i < len; i++) {
   b81fe:	e7f7      	b.n	b81f0 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x2e>
    transfer(prefix_buffer[i]);
   b8200:	f815 1b01 	ldrb.w	r1, [r5], #1
   b8204:	4620      	mov	r0, r4
   b8206:	f7ff ffcf 	bl	b81a8 <_ZN18Adafruit_SPIDevice8transferEh>
  for (size_t i = 0; i < prefix_len; i++) {
   b820a:	e7ee      	b.n	b81ea <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x28>
  }
  digitalWrite(_cs, HIGH);
   b820c:	f994 000e 	ldrsb.w	r0, [r4, #14]
   b8210:	2101      	movs	r1, #1
   b8212:	b280      	uxth	r0, r0
   b8214:	f005 febb 	bl	bdf8e <digitalWrite>

  if (_spi) {
   b8218:	6820      	ldr	r0, [r4, #0]
   b821a:	b108      	cbz	r0, b8220 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j+0x5e>
    _spi->endTransaction();
   b821c:	f002 f9b0 	bl	ba580 <_ZN8SPIClass14endTransactionEv>
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
   b8220:	2001      	movs	r0, #1
   b8222:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000b8226 <_ZN18Adafruit_I2CDeviceC1EhP7TwoWire>:
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
  _wire = theWire;
   b8226:	6042      	str	r2, [r0, #4]
  _begun = false;
   b8228:	2200      	movs	r2, #0
   b822a:	7202      	strb	r2, [r0, #8]
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
   b822c:	2220      	movs	r2, #32
  _addr = addr;
   b822e:	7001      	strb	r1, [r0, #0]
  _maxBufferSize = 32;
   b8230:	60c2      	str	r2, [r0, #12]
#endif
}
   b8232:	4770      	bx	lr

000b8234 <_ZN18Adafruit_I2CDevice8detectedEv>:
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
   b8234:	b510      	push	{r4, lr}
  // Init I2C if not done yet
  if (!_begun && !begin()) {
   b8236:	7a03      	ldrb	r3, [r0, #8]
bool Adafruit_I2CDevice::detected(void) {
   b8238:	4604      	mov	r4, r0
  if (!_begun && !begin()) {
   b823a:	b153      	cbz	r3, b8252 <_ZN18Adafruit_I2CDevice8detectedEv+0x1e>
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
   b823c:	7821      	ldrb	r1, [r4, #0]
   b823e:	6860      	ldr	r0, [r4, #4]
   b8240:	f005 fd98 	bl	bdd74 <_ZN7TwoWire17beginTransmissionEh>
  if (_wire->endTransmission() == 0) {
   b8244:	6860      	ldr	r0, [r4, #4]
   b8246:	f005 fd9d 	bl	bdd84 <_ZN7TwoWire15endTransmissionEv>
   b824a:	fab0 f080 	clz	r0, r0
   b824e:	0940      	lsrs	r0, r0, #5
    return true;
  }
  return false;
}
   b8250:	bd10      	pop	{r4, pc}
  if (!_begun && !begin()) {
   b8252:	2101      	movs	r1, #1
   b8254:	f000 f803 	bl	b825e <_ZN18Adafruit_I2CDevice5beginEb>
   b8258:	2800      	cmp	r0, #0
   b825a:	d1ef      	bne.n	b823c <_ZN18Adafruit_I2CDevice8detectedEv+0x8>
   b825c:	e7f8      	b.n	b8250 <_ZN18Adafruit_I2CDevice8detectedEv+0x1c>

000b825e <_ZN18Adafruit_I2CDevice5beginEb>:
bool Adafruit_I2CDevice::begin(bool addr_detect) {
   b825e:	b538      	push	{r3, r4, r5, lr}
   b8260:	4604      	mov	r4, r0
  _wire->begin();
   b8262:	6840      	ldr	r0, [r0, #4]
bool Adafruit_I2CDevice::begin(bool addr_detect) {
   b8264:	460d      	mov	r5, r1
  _wire->begin();
   b8266:	f005 fd7f 	bl	bdd68 <_ZN7TwoWire5beginEv>
  _begun = true;
   b826a:	2001      	movs	r0, #1
   b826c:	7220      	strb	r0, [r4, #8]
  if (addr_detect) {
   b826e:	b125      	cbz	r5, b827a <_ZN18Adafruit_I2CDevice5beginEb+0x1c>
    return detected();
   b8270:	4620      	mov	r0, r4
}
   b8272:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return detected();
   b8276:	f7ff bfdd 	b.w	b8234 <_ZN18Adafruit_I2CDevice8detectedEv>
}
   b827a:	bd38      	pop	{r3, r4, r5, pc}

000b827c <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j>:
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
   b827c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   b8280:	e9dd 9608 	ldrd	r9, r6, [sp, #32]
   b8284:	461f      	mov	r7, r3
  if ((len + prefix_len) > maxBufferSize()) {
   b8286:	68c3      	ldr	r3, [r0, #12]
                               size_t prefix_len) {
   b8288:	4615      	mov	r5, r2
  if ((len + prefix_len) > maxBufferSize()) {
   b828a:	4432      	add	r2, r6
   b828c:	429a      	cmp	r2, r3
                               size_t prefix_len) {
   b828e:	4604      	mov	r4, r0
   b8290:	4688      	mov	r8, r1
  if ((len + prefix_len) > maxBufferSize()) {
   b8292:	d902      	bls.n	b829a <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x1e>
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
   b8294:	2000      	movs	r0, #0
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("Failed to send!");
#endif
    return false;
  }
}
   b8296:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  _wire->beginTransmission(_addr);
   b829a:	7801      	ldrb	r1, [r0, #0]
   b829c:	6840      	ldr	r0, [r0, #4]
   b829e:	f005 fd69 	bl	bdd74 <_ZN7TwoWire17beginTransmissionEh>
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
   b82a2:	b97e      	cbnz	r6, b82c4 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x48>
  if (_wire->write(buffer, len) != len) {
   b82a4:	6860      	ldr	r0, [r4, #4]
   b82a6:	6803      	ldr	r3, [r0, #0]
   b82a8:	462a      	mov	r2, r5
   b82aa:	68db      	ldr	r3, [r3, #12]
   b82ac:	4641      	mov	r1, r8
   b82ae:	4798      	blx	r3
   b82b0:	4285      	cmp	r5, r0
   b82b2:	d1ef      	bne.n	b8294 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x18>
  if (_wire->endTransmission(stop) == 0) {
   b82b4:	6860      	ldr	r0, [r4, #4]
   b82b6:	4639      	mov	r1, r7
   b82b8:	f005 fd60 	bl	bdd7c <_ZN7TwoWire15endTransmissionEh>
   b82bc:	fab0 f080 	clz	r0, r0
   b82c0:	0940      	lsrs	r0, r0, #5
   b82c2:	e7e8      	b.n	b8296 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x1a>
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
   b82c4:	f1b9 0f00 	cmp.w	r9, #0
   b82c8:	d0ec      	beq.n	b82a4 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x28>
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
   b82ca:	6860      	ldr	r0, [r4, #4]
   b82cc:	6803      	ldr	r3, [r0, #0]
   b82ce:	4632      	mov	r2, r6
   b82d0:	68db      	ldr	r3, [r3, #12]
   b82d2:	4649      	mov	r1, r9
   b82d4:	4798      	blx	r3
   b82d6:	4286      	cmp	r6, r0
   b82d8:	d1dc      	bne.n	b8294 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x18>
   b82da:	e7e3      	b.n	b82a4 <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j+0x28>

000b82dc <_ZN18Adafruit_I2CDevice8setSpeedEm>:
 *    underlying Wire support!
 *    @param desiredclk The desired I2C SCL frequency
 *    @return True if this platform supports changing I2C speed.
 *    Not necessarily that the speed was achieved!
 */
bool Adafruit_I2CDevice::setSpeed(uint32_t desiredclk) {
   b82dc:	b508      	push	{r3, lr}

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
  inline void setClock(uint32_t speed) {
	  setSpeed(speed);
   b82de:	6840      	ldr	r0, [r0, #4]
   b82e0:	f005 fd3e 	bl	bdd60 <_ZN7TwoWire8setSpeedEm>
  _wire->setClock(desiredclk);
  return true;
#else
  return false;
#endif
}
   b82e4:	2001      	movs	r0, #1
   b82e6:	bd08      	pop	{r3, pc}

000b82e8 <_ZL10lfnGetCharP18longDirectoryEntryh>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(ldir_t *ldir, uint8_t i) {
  if (i < LDIR_NAME1_DIM) {
   b82e8:	2904      	cmp	r1, #4
   b82ea:	d804      	bhi.n	b82f6 <_ZL10lfnGetCharP18longDirectoryEntryh+0xe>
    return ldir->name1[i];
   b82ec:	eb00 0041 	add.w	r0, r0, r1, lsl #1
   b82f0:	f8b0 0001 	ldrh.w	r0, [r0, #1]
   b82f4:	4770      	bx	lr
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
   b82f6:	290a      	cmp	r1, #10
    return ldir->name2[i - LDIR_NAME1_DIM];
   b82f8:	bf9b      	ittet	ls
   b82fa:	f101 31ff 	addls.w	r1, r1, #4294967295
   b82fe:	eb00 0041 	addls.w	r0, r0, r1, lsl #1
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM + LDIR_NAME2_DIM)) {
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
   b8302:	3101      	addhi	r1, #1
    return ldir->name2[i - LDIR_NAME1_DIM];
   b8304:	88c0      	ldrhls	r0, [r0, #6]
    return ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM];
   b8306:	bf84      	itt	hi
   b8308:	eb00 0041 	addhi.w	r0, r0, r1, lsl #1
   b830c:	8880      	ldrhhi	r0, [r0, #4]
  }
  return 0;
}
   b830e:	4770      	bx	lr

000b8310 <_ZN9FatVolume9cacheSyncEv>:
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t blockNumber, uint8_t options) {
    return m_fatCache.read(blockNumber,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
   b8310:	b510      	push	{r4, lr}
   b8312:	4604      	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
   b8314:	3024      	adds	r0, #36	; 0x24
   b8316:	f000 feed 	bl	b90f4 <_ZN8FatCache4syncEv>
   b831a:	b128      	cbz	r0, b8328 <_ZN9FatVolume9cacheSyncEv+0x18>
   b831c:	f504 700c 	add.w	r0, r4, #560	; 0x230
  }
   b8320:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return m_cache.sync() && m_fatCache.sync() && syncBlocks();
   b8324:	f000 bee6 	b.w	b90f4 <_ZN8FatCache4syncEv>
  }
   b8328:	bd10      	pop	{r4, pc}

000b832a <_ZN7FatFile11lfnChecksumEPh>:
  for (uint8_t i = 0; i < 11; i++) {
   b832a:	1e41      	subs	r1, r0, #1
   b832c:	f100 030a 	add.w	r3, r0, #10
  uint8_t sum = 0;
   b8330:	2000      	movs	r0, #0
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
   b8332:	0842      	lsrs	r2, r0, #1
   b8334:	ea42 10c0 	orr.w	r0, r2, r0, lsl #7
   b8338:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   b833c:	fa52 f080 	uxtab	r0, r2, r0
  for (uint8_t i = 0; i < 11; i++) {
   b8340:	428b      	cmp	r3, r1
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
   b8342:	b2c0      	uxtb	r0, r0
  for (uint8_t i = 0; i < 11; i++) {
   b8344:	d1f5      	bne.n	b8332 <_ZN7FatFile11lfnChecksumEPh+0x8>
}
   b8346:	4770      	bx	lr

000b8348 <_ZN7FatFile11openClusterEPS_>:
fail:
  name[0] = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
   b8348:	b538      	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
   b834a:	68cb      	ldr	r3, [r1, #12]
bool FatFile::openCluster(FatFile* file) {
   b834c:	4604      	mov	r4, r0
   b834e:	460d      	mov	r5, r1
  if (file->m_dirCluster == 0) {
   b8350:	b923      	cbnz	r3, b835c <_ZN7FatFile11openClusterEPS_+0x14>
  m_attr = FILE_ATTR_SUBDIR;
  m_flags = F_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
   b8352:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return openRoot(file->m_vol);
   b8356:	6889      	ldr	r1, [r1, #8]
   b8358:	f000 bbc7 	b.w	b8aea <_ZN7FatFile8openRootEP9FatVolume>
  memset(this, 0, sizeof(FatFile));
   b835c:	2224      	movs	r2, #36	; 0x24
   b835e:	2100      	movs	r1, #0
   b8360:	f006 fdcb 	bl	beefa <memset>
  m_attr = FILE_ATTR_SUBDIR;
   b8364:	2310      	movs	r3, #16
  m_flags = F_READ;
   b8366:	2001      	movs	r0, #1
  m_attr = FILE_ATTR_SUBDIR;
   b8368:	7023      	strb	r3, [r4, #0]
  m_flags = F_READ;
   b836a:	70a0      	strb	r0, [r4, #2]
  m_vol = file->m_vol;
   b836c:	68ab      	ldr	r3, [r5, #8]
   b836e:	60a3      	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
   b8370:	68eb      	ldr	r3, [r5, #12]
   b8372:	6223      	str	r3, [r4, #32]
}
   b8374:	bd38      	pop	{r3, r4, r5, pc}
	...

000b8378 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
   b8378:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   b837c:	4606      	mov	r6, r0
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
   b837e:	f810 3b01 	ldrb.w	r3, [r0], #1
   b8382:	2b20      	cmp	r3, #32
   b8384:	d0fa      	beq.n	b837c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4>
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
   b8386:	4d6a      	ldr	r5, [pc, #424]	; (b8530 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1b8>)
    path++;
  }
  fname->lfn = path;
   b8388:	608e      	str	r6, [r1, #8]

  for (len = 0; ; len++) {
   b838a:	2400      	movs	r4, #0
    c = path[len];
   b838c:	5d33      	ldrb	r3, [r6, r4]
    if (c == 0 || isDirSeparator(c)) {
   b838e:	b1c3      	cbz	r3, b83c2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4a>
   b8390:	2b2f      	cmp	r3, #47	; 0x2f
   b8392:	d016      	beq.n	b83c2 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4a>
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
   b8394:	2b5c      	cmp	r3, #92	; 0x5c
   b8396:	d102      	bne.n	b839e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x26>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
   b8398:	2000      	movs	r0, #0
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
   b839a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
   b839e:	f1a3 0022 	sub.w	r0, r3, #34	; 0x22
   b83a2:	b2c0      	uxtb	r0, r0
   b83a4:	281d      	cmp	r0, #29
   b83a6:	d803      	bhi.n	b83b0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x38>
   b83a8:	fa25 f000 	lsr.w	r0, r5, r0
   b83ac:	07c0      	lsls	r0, r0, #31
   b83ae:	d4f3      	bmi.n	b8398 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
   b83b0:	f003 00bf 	and.w	r0, r3, #191	; 0xbf
   b83b4:	283c      	cmp	r0, #60	; 0x3c
   b83b6:	d0ef      	beq.n	b8398 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
    if (!lfnLegalChar(c)) {
   b83b8:	3b20      	subs	r3, #32
   b83ba:	2b5e      	cmp	r3, #94	; 0x5e
   b83bc:	d8ec      	bhi.n	b8398 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
  for (len = 0; ; len++) {
   b83be:	3401      	adds	r4, #1
    c = path[len];
   b83c0:	e7e4      	b.n	b838c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x14>
   b83c2:	1933      	adds	r3, r6, r4
  for (len = 0; ; len++) {
   b83c4:	4618      	mov	r0, r3
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
   b83c6:	4607      	mov	r7, r0
   b83c8:	f810 5b01 	ldrb.w	r5, [r0], #1
   b83cc:	2d20      	cmp	r5, #32
   b83ce:	d0fa      	beq.n	b83c6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4e>
   b83d0:	2d2f      	cmp	r5, #47	; 0x2f
   b83d2:	d0f8      	beq.n	b83c6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x4e>
  *ptr = &path[end];
   b83d4:	6017      	str	r7, [r2, #0]
  while (len) {
   b83d6:	b14c      	cbz	r4, b83ec <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x74>
    c = path[len - 1];
   b83d8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    if (c != '.' && c != ' ') {
   b83dc:	2a2e      	cmp	r2, #46	; 0x2e
   b83de:	d001      	beq.n	b83e4 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x6c>
   b83e0:	2a20      	cmp	r2, #32
   b83e2:	d101      	bne.n	b83e8 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x70>
    len--;
   b83e4:	3c01      	subs	r4, #1
  while (len) {
   b83e6:	e7f6      	b.n	b83d6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x5e>
  if (len > 255) {
   b83e8:	2cff      	cmp	r4, #255	; 0xff
   b83ea:	dcd5      	bgt.n	b8398 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
    fname->sfn[k] = ' ';
   b83ec:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
   b83f0:	f8c1 3011 	str.w	r3, [r1, #17]
  fname->len = len;
   b83f4:	604c      	str	r4, [r1, #4]
    fname->sfn[k] = ' ';
   b83f6:	f8c1 300d 	str.w	r3, [r1, #13]
   b83fa:	614b      	str	r3, [r1, #20]
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
   b83fc:	f04f 0800 	mov.w	r8, #0
   b8400:	f816 3008 	ldrb.w	r3, [r6, r8]
   b8404:	2b2e      	cmp	r3, #46	; 0x2e
   b8406:	d001      	beq.n	b840c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x94>
   b8408:	2b20      	cmp	r3, #32
   b840a:	d102      	bne.n	b8412 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x9a>
   b840c:	f108 0801 	add.w	r8, r8, #1
   b8410:	e7f6      	b.n	b8400 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x88>
  is83 = !si;
   b8412:	fab8 f088 	clz	r0, r8
   b8416:	0940      	lsrs	r0, r0, #5
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
   b8418:	1e65      	subs	r5, r4, #1
   b841a:	1c6b      	adds	r3, r5, #1
   b841c:	d002      	beq.n	b8424 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xac>
   b841e:	5d73      	ldrb	r3, [r6, r5]
   b8420:	2b2e      	cmp	r3, #46	; 0x2e
   b8422:	d114      	bne.n	b844e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd6>
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
   b8424:	f04f 0900 	mov.w	r9, #0
   b8428:	2707      	movs	r7, #7
   b842a:	464a      	mov	r2, r9
   b842c:	46ca      	mov	sl, r9
   b842e:	f04f 0e08 	mov.w	lr, #8
  for (; si < len; si++) {
   b8432:	45a0      	cmp	r8, r4
   b8434:	da68      	bge.n	b8508 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x190>
    c = path[si];
   b8436:	f816 3008 	ldrb.w	r3, [r6, r8]
    if (c == ' ' || (c == '.' && dot != si)) {
   b843a:	2b20      	cmp	r3, #32
   b843c:	d003      	beq.n	b8446 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xce>
   b843e:	2b2e      	cmp	r3, #46	; 0x2e
   b8440:	d107      	bne.n	b8452 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xda>
   b8442:	45a8      	cmp	r8, r5
   b8444:	d012      	beq.n	b846c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
      is83 = false;
   b8446:	2000      	movs	r0, #0
  for (; si < len; si++) {
   b8448:	f108 0801 	add.w	r8, r8, #1
   b844c:	e7f1      	b.n	b8432 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xba>
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
   b844e:	3d01      	subs	r5, #1
   b8450:	e7e3      	b.n	b841a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xa2>
    if (c == '"' || c == '|') {
   b8452:	2b22      	cmp	r3, #34	; 0x22
   b8454:	d008      	beq.n	b8468 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
   b8456:	2b7c      	cmp	r3, #124	; 0x7c
   b8458:	d006      	beq.n	b8468 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
   b845a:	f1a3 0c2a 	sub.w	ip, r3, #42	; 0x2a
   b845e:	f1bc 0f05 	cmp.w	ip, #5
   b8462:	d80a      	bhi.n	b847a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x102>
   b8464:	2b2d      	cmp	r3, #45	; 0x2d
   b8466:	d012      	beq.n	b848e <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x116>
    if (!legal83Char(c) && si != dot) {
   b8468:	45a8      	cmp	r8, r5
   b846a:	d15b      	bne.n	b8524 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x1ac>
      if (in == 10) {
   b846c:	2f0a      	cmp	r7, #10
   b846e:	d04a      	beq.n	b8506 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x18e>
      in = 10;  // Max index for full 8.3 name.
   b8470:	270a      	movs	r7, #10
      i = 8;    // Place for extension.
   b8472:	2208      	movs	r2, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
   b8474:	f04f 0e10 	mov.w	lr, #16
   b8478:	e7e6      	b.n	b8448 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd0>
    if (0X3A <= c && c <= 0X3F) {
   b847a:	f1a3 0c3a 	sub.w	ip, r3, #58	; 0x3a
   b847e:	f1bc 0f05 	cmp.w	ip, #5
   b8482:	d9f1      	bls.n	b8468 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
    if (0X5B <= c && c <= 0X5D) {
   b8484:	f1a3 0c5b 	sub.w	ip, r3, #91	; 0x5b
   b8488:	f1bc 0f02 	cmp.w	ip, #2
   b848c:	d9ec      	bls.n	b8468 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
    if (!legal83Char(c) && si != dot) {
   b848e:	f1a3 0c21 	sub.w	ip, r3, #33	; 0x21
   b8492:	f1bc 0f5d 	cmp.w	ip, #93	; 0x5d
   b8496:	d8e7      	bhi.n	b8468 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf0>
    if (si == dot || i > in) {
   b8498:	45a8      	cmp	r8, r5
   b849a:	d0e7      	beq.n	b846c <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xf4>
   b849c:	42ba      	cmp	r2, r7
   b849e:	d830      	bhi.n	b8502 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x18a>
      if ('a' <= c && c <= 'z') {
   b84a0:	f1a3 0c61 	sub.w	ip, r3, #97	; 0x61
   b84a4:	f1bc 0f19 	cmp.w	ip, #25
   b84a8:	d81a      	bhi.n	b84e0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x168>
        c += 'A' - 'a';
   b84aa:	3b20      	subs	r3, #32
        lc |= bit;
   b84ac:	ea4e 0909 	orr.w	r9, lr, r9
        c += 'A' - 'a';
   b84b0:	b2db      	uxtb	r3, r3
        lc |= bit;
   b84b2:	fa5f f989 	uxtb.w	r9, r9
      fname->sfn[i++] = c;
   b84b6:	f102 0c01 	add.w	ip, r2, #1
   b84ba:	fa5f fc8c 	uxtb.w	ip, ip
   b84be:	440a      	add	r2, r1
      if (i < 7) {
   b84c0:	f1bc 0f06 	cmp.w	ip, #6
      fname->sfn[i++] = c;
   b84c4:	7353      	strb	r3, [r2, #13]
      if (i < 7) {
   b84c6:	d801      	bhi.n	b84cc <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x154>
        fname->seqPos = i;
   b84c8:	f881 c00c 	strb.w	ip, [r1, #12]
   b84cc:	4662      	mov	r2, ip
   b84ce:	e7bb      	b.n	b8448 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xd0>
      if (si > dot) {
   b84d0:	45a8      	cmp	r8, r5
   b84d2:	dc18      	bgt.n	b8506 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x18e>
   b84d4:	46a8      	mov	r8, r5
      in = 10;  // Max index for full 8.3 name.
   b84d6:	270a      	movs	r7, #10
      i = 8;    // Place for extension.
   b84d8:	2208      	movs	r2, #8
      bit = DIR_NT_LC_EXT;  // bit for extension.
   b84da:	f04f 0e10 	mov.w	lr, #16
   b84de:	e7b2      	b.n	b8446 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0xce>
      } else if ('A' <= c && c <= 'Z') {
   b84e0:	f1a3 0c41 	sub.w	ip, r3, #65	; 0x41
   b84e4:	f1bc 0f19 	cmp.w	ip, #25
        uc |= bit;
   b84e8:	bf98      	it	ls
   b84ea:	ea4e 0a0a 	orrls.w	sl, lr, sl
   b84ee:	e7e2      	b.n	b84b6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13e>
    fname->sfn[fname->seqPos] = '~';
   b84f0:	7b0b      	ldrb	r3, [r1, #12]
    fname->flags = FNAME_FLAG_LOST_CHARS;
   b84f2:	2001      	movs	r0, #1
   b84f4:	7008      	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
   b84f6:	4419      	add	r1, r3
   b84f8:	237e      	movs	r3, #126	; 0x7e
   b84fa:	734b      	strb	r3, [r1, #13]
    fname->sfn[fname->seqPos + 1] = '1';
   b84fc:	2331      	movs	r3, #49	; 0x31
   b84fe:	738b      	strb	r3, [r1, #14]
   b8500:	e74b      	b.n	b839a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x22>
      if (in == 10) {
   b8502:	2f0a      	cmp	r7, #10
   b8504:	d1e4      	bne.n	b84d0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x158>
        is83 = false;
   b8506:	2000      	movs	r0, #0
  if (fname->sfn[0] == ' ') {
   b8508:	7b4b      	ldrb	r3, [r1, #13]
   b850a:	2b20      	cmp	r3, #32
   b850c:	f43f af44 	beq.w	b8398 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x20>
  if (is83) {
   b8510:	2800      	cmp	r0, #0
   b8512:	d0ed      	beq.n	b84f0 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x178>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
   b8514:	ea1a 0f09 	tst.w	sl, r9
   b8518:	bf18      	it	ne
   b851a:	f04f 0902 	movne.w	r9, #2
   b851e:	f881 9000 	strb.w	r9, [r1]
   b8522:	e73a      	b.n	b839a <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x22>
    if (si == dot || i > in) {
   b8524:	42ba      	cmp	r2, r7
   b8526:	d8ec      	bhi.n	b8502 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x18a>
      is83 = false;
   b8528:	2000      	movs	r0, #0
      c = '_';
   b852a:	235f      	movs	r3, #95	; 0x5f
   b852c:	e7c3      	b.n	b84b6 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_+0x13e>
   b852e:	bf00      	nop
   b8530:	31000101 	.word	0x31000101

000b8534 <_ZN7FatFile6removeEv>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
   b8534:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   b8538:	b08a      	sub	sp, #40	; 0x28
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b853a:	2300      	movs	r3, #0
   b853c:	9301      	str	r3, [sp, #4]
  FatFile dirFile;
  dir_t* dir;
  ldir_t* ldir;

  // Cant' remove not open for write.
  if (!isFile() || !(m_flags & F_WRITE)) {
   b853e:	7803      	ldrb	r3, [r0, #0]
   b8540:	0719      	lsls	r1, r3, #28
bool FatFile::remove() {
   b8542:	4604      	mov	r4, r0
  if (!isFile() || !(m_flags & F_WRITE)) {
   b8544:	d50a      	bpl.n	b855c <_ZN7FatFile6removeEv+0x28>
   b8546:	7883      	ldrb	r3, [r0, #2]
   b8548:	079a      	lsls	r2, r3, #30
   b854a:	d507      	bpl.n	b855c <_ZN7FatFile6removeEv+0x28>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
   b854c:	6a01      	ldr	r1, [r0, #32]
   b854e:	b939      	cbnz	r1, b8560 <_ZN7FatFile6removeEv+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
   b8550:	2101      	movs	r1, #1
   b8552:	4620      	mov	r0, r4
   b8554:	f000 faba 	bl	b8acc <_ZN7FatFile13cacheDirEntryEh>
  if (!dir) {
   b8558:	4605      	mov	r5, r0
   b855a:	b938      	cbnz	r0, b856c <_ZN7FatFile6removeEv+0x38>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
   b855c:	2000      	movs	r0, #0
   b855e:	e048      	b.n	b85f2 <_ZN7FatFile6removeEv+0xbe>
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
   b8560:	6880      	ldr	r0, [r0, #8]
   b8562:	f000 feb8 	bl	b92d6 <_ZN9FatVolume9freeChainEm>
   b8566:	2800      	cmp	r0, #0
   b8568:	d1f2      	bne.n	b8550 <_ZN7FatFile6removeEv+0x1c>
   b856a:	e7f7      	b.n	b855c <_ZN7FatFile6removeEv+0x28>
  chksum = lfnChecksum(dir->name);
   b856c:	f7ff fedd 	bl	b832a <_ZN7FatFile11lfnChecksumEPh>
  dir->name[0] = DIR_NAME_DELETED;
   b8570:	27e5      	movs	r7, #229	; 0xe5
   b8572:	702f      	strb	r7, [r5, #0]
  m_attr = FILE_ATTR_CLOSED;
   b8574:	2300      	movs	r3, #0
  chksum = lfnChecksum(dir->name);
   b8576:	4606      	mov	r6, r0
  m_attr = FILE_ATTR_CLOSED;
   b8578:	7023      	strb	r3, [r4, #0]
  if (!m_vol->cacheSync()) {
   b857a:	68a0      	ldr	r0, [r4, #8]
   b857c:	f7ff fec8 	bl	b8310 <_ZN9FatVolume9cacheSyncEv>
   b8580:	2800      	cmp	r0, #0
   b8582:	d0eb      	beq.n	b855c <_ZN7FatFile6removeEv+0x28>
  if (!isLFN()) {
   b8584:	78e3      	ldrb	r3, [r4, #3]
   b8586:	2b00      	cmp	r3, #0
   b8588:	d033      	beq.n	b85f2 <_ZN7FatFile6removeEv+0xbe>
  if (!dirFile.openCluster(this)) {
   b858a:	4621      	mov	r1, r4
   b858c:	a801      	add	r0, sp, #4
   b858e:	f7ff fedb 	bl	b8348 <_ZN7FatFile11openClusterEPS_>
   b8592:	2800      	cmp	r0, #0
   b8594:	d0e2      	beq.n	b855c <_ZN7FatFile6removeEv+0x28>
   b8596:	2501      	movs	r5, #1
  for (ord = 1; ord <= m_lfnOrd; ord++) {
   b8598:	78e3      	ldrb	r3, [r4, #3]
   b859a:	fa5f f885 	uxtb.w	r8, r5
   b859e:	4543      	cmp	r3, r8
   b85a0:	d3dc      	bcc.n	b855c <_ZN7FatFile6removeEv+0x28>
    if (!dirFile.seekSet(32UL*(m_dirIndex - ord))) {
   b85a2:	88a1      	ldrh	r1, [r4, #4]
   b85a4:	1b49      	subs	r1, r1, r5
   b85a6:	0149      	lsls	r1, r1, #5
   b85a8:	a801      	add	r0, sp, #4
   b85aa:	f000 fb84 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
   b85ae:	2800      	cmp	r0, #0
   b85b0:	d0d4      	beq.n	b855c <_ZN7FatFile6removeEv+0x28>
    ldir = reinterpret_cast<ldir_t*>(dirFile.readDirCache());
   b85b2:	2100      	movs	r1, #0
   b85b4:	a801      	add	r0, sp, #4
   b85b6:	f000 fb5f 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
   b85ba:	2800      	cmp	r0, #0
   b85bc:	d0ce      	beq.n	b855c <_ZN7FatFile6removeEv+0x28>
    if (ldir->attr != DIR_ATT_LONG_NAME ||
   b85be:	7ac3      	ldrb	r3, [r0, #11]
   b85c0:	2b0f      	cmp	r3, #15
   b85c2:	d1cb      	bne.n	b855c <_ZN7FatFile6removeEv+0x28>
        ord != (ldir->ord & 0X1F) ||
   b85c4:	7802      	ldrb	r2, [r0, #0]
    if (ldir->attr != DIR_ATT_LONG_NAME ||
   b85c6:	f002 031f 	and.w	r3, r2, #31
   b85ca:	4543      	cmp	r3, r8
   b85cc:	d1c6      	bne.n	b855c <_ZN7FatFile6removeEv+0x28>
        ord != (ldir->ord & 0X1F) ||
   b85ce:	7b43      	ldrb	r3, [r0, #13]
   b85d0:	42b3      	cmp	r3, r6
   b85d2:	d1c3      	bne.n	b855c <_ZN7FatFile6removeEv+0x28>
    ldir->ord = DIR_NAME_DELETED;
   b85d4:	7007      	strb	r7, [r0, #0]
    m_vol->cacheDirty();
   b85d6:	68a1      	ldr	r1, [r4, #8]
    m_status |= CACHE_STATUS_DIRTY;
   b85d8:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
   b85dc:	f043 0301 	orr.w	r3, r3, #1
   b85e0:	f881 3024 	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
   b85e4:	0653      	lsls	r3, r2, #25
   b85e6:	f105 0501 	add.w	r5, r5, #1
   b85ea:	d5d5      	bpl.n	b8598 <_ZN7FatFile6removeEv+0x64>
      if (!m_vol->cacheSync()) {
   b85ec:	68a0      	ldr	r0, [r4, #8]
   b85ee:	f7ff fe8f 	bl	b8310 <_ZN9FatVolume9cacheSyncEv>
}
   b85f2:	b00a      	add	sp, #40	; 0x28
   b85f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000b85f8 <_ZN7FatFile12lfnUniqueSfnEP7fname_t>:
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
   b85f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
   b85fc:	f891 900c 	ldrb.w	r9, [r1, #12]
bool FatFile::lfnUniqueSfn(fname_t* fname) {
   b8600:	4606      	mov	r6, r0
   b8602:	460c      	mov	r4, r1
  uint8_t pos = fname->seqPos;;
   b8604:	2502      	movs	r5, #2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
   b8606:	277e      	movs	r7, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == DIR_NAME_FREE) {
        goto done;
      }
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
   b8608:	f101 080d 	add.w	r8, r1, #13
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
   b860c:	6861      	ldr	r1, [r4, #4]
   b860e:	68a2      	ldr	r2, [r4, #8]
   b8610:	186b      	adds	r3, r5, r1
   b8612:	b29b      	uxth	r3, r3
  for (size_t i = 0; i < len; i++) {
   b8614:	4411      	add	r1, r2
   b8616:	4291      	cmp	r1, r2
   b8618:	d006      	beq.n	b8628 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x30>
    hash = ((hash << 5) + hash) ^ str[i];
   b861a:	f812 0b01 	ldrb.w	r0, [r2], #1
   b861e:	eb03 1343 	add.w	r3, r3, r3, lsl #5
   b8622:	4043      	eors	r3, r0
   b8624:	b29b      	uxth	r3, r3
  for (size_t i = 0; i < len; i++) {
   b8626:	e7f6      	b.n	b8616 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x1e>
      if (pos > 3) {
   b8628:	f1b9 0f03 	cmp.w	r9, #3
   b862c:	bf28      	it	cs
   b862e:	f04f 0903 	movcs.w	r9, #3
      for (uint8_t i = pos + 4 ; i > pos; i--) {
   b8632:	f109 0204 	add.w	r2, r9, #4
   b8636:	b2d2      	uxtb	r2, r2
        uint8_t h = hex & 0XF;
   b8638:	f003 010f 	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
   b863c:	18a0      	adds	r0, r4, r2
      for (uint8_t i = pos + 4 ; i > pos; i--) {
   b863e:	3a01      	subs	r2, #1
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
   b8640:	2909      	cmp	r1, #9
      for (uint8_t i = pos + 4 ; i > pos; i--) {
   b8642:	b2d2      	uxtb	r2, r2
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
   b8644:	bf94      	ite	ls
   b8646:	3130      	addls	r1, #48	; 0x30
   b8648:	3137      	addhi	r1, #55	; 0x37
      for (uint8_t i = pos + 4 ; i > pos; i--) {
   b864a:	4591      	cmp	r9, r2
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
   b864c:	7341      	strb	r1, [r0, #13]
        hex >>= 4;
   b864e:	ea4f 1313 	mov.w	r3, r3, lsr #4
      for (uint8_t i = pos + 4 ; i > pos; i--) {
   b8652:	d1f1      	bne.n	b8638 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x40>
    fname->sfn[pos] = '~';
   b8654:	eb04 0309 	add.w	r3, r4, r9
    seekSet(0);
   b8658:	2100      	movs	r1, #0
   b865a:	735f      	strb	r7, [r3, #13]
   b865c:	4630      	mov	r0, r6
   b865e:	f000 fb2a 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
      dir = readDirCache(true);
   b8662:	2101      	movs	r1, #1
   b8664:	4630      	mov	r0, r6
   b8666:	f000 fb07 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
      if (!dir) {
   b866a:	4601      	mov	r1, r0
   b866c:	b928      	cbnz	r0, b867a <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x82>
        if (!getError()) {
   b866e:	7870      	ldrb	r0, [r6, #1]
   b8670:	fab0 f080 	clz	r0, r0
   b8674:	0940      	lsrs	r0, r0, #5
fail:
  return false;

done:
  return true;
}
   b8676:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (dir->name[0] == DIR_NAME_FREE) {
   b867a:	7803      	ldrb	r3, [r0, #0]
   b867c:	b16b      	cbz	r3, b869a <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0xa2>
      if (DIR_IS_FILE_OR_SUBDIR(dir) && !memcmp(fname->sfn, dir->name, 11)) {
   b867e:	7ac3      	ldrb	r3, [r0, #11]
   b8680:	071b      	lsls	r3, r3, #28
   b8682:	d4ee      	bmi.n	b8662 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
   b8684:	220b      	movs	r2, #11
   b8686:	4640      	mov	r0, r8
   b8688:	f006 fbff 	bl	bee8a <memcmp>
   b868c:	2800      	cmp	r0, #0
   b868e:	d1e8      	bne.n	b8662 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x6a>
  for (uint8_t seq = 2; seq < 100; seq++) {
   b8690:	3501      	adds	r5, #1
   b8692:	b2ad      	uxth	r5, r5
   b8694:	2d64      	cmp	r5, #100	; 0x64
   b8696:	d1b9      	bne.n	b860c <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x14>
   b8698:	e7ed      	b.n	b8676 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x7e>
  return true;
   b869a:	2001      	movs	r0, #1
   b869c:	e7eb      	b.n	b8676 <_ZN7FatFile12lfnUniqueSfnEP7fname_t+0x7e>
	...

000b86a0 <_ZN7FatFile4openEPS_P7fname_ti>:
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
   b86a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b86a4:	ed2d 8b02 	vpush	{d8}
   b86a8:	b08b      	sub	sp, #44	; 0x2c
   b86aa:	460d      	mov	r5, r1
   b86ac:	9306      	str	r3, [sp, #24]
  if (!dirFile->isDir() || isOpen()) {
   b86ae:	780b      	ldrb	r3, [r1, #0]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
   b86b0:	9007      	str	r0, [sp, #28]
  if (!dirFile->isDir() || isOpen()) {
   b86b2:	f013 0f70 	tst.w	r3, #112	; 0x70
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
   b86b6:	4617      	mov	r7, r2
  if (!dirFile->isDir() || isOpen()) {
   b86b8:	d105      	bne.n	b86c6 <_ZN7FatFile4openEPS_P7fname_ti+0x26>
  return false;
   b86ba:	2000      	movs	r0, #0
}
   b86bc:	b00b      	add	sp, #44	; 0x2c
   b86be:	ecbd 8b02 	vpop	{d8}
   b86c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return m_attr;
   b86c6:	9b07      	ldr	r3, [sp, #28]
   b86c8:	781b      	ldrb	r3, [r3, #0]
  if (!dirFile->isDir() || isOpen()) {
   b86ca:	2b00      	cmp	r3, #0
   b86cc:	d1f5      	bne.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  size_t len = fname->len;
   b86ce:	6853      	ldr	r3, [r2, #4]
   b86d0:	9305      	str	r3, [sp, #20]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
   b86d2:	7813      	ldrb	r3, [r2, #0]
   b86d4:	079c      	lsls	r4, r3, #30
   b86d6:	bf1f      	itttt	ne
   b86d8:	9b05      	ldrne	r3, [sp, #20]
   b86da:	330c      	addne	r3, #12
   b86dc:	220d      	movne	r2, #13
   b86de:	fbb3 f3f2 	udivne	r3, r3, r2
   b86e2:	bf1a      	itte	ne
   b86e4:	3301      	addne	r3, #1
   b86e6:	b2db      	uxtbne	r3, r3
   b86e8:	2301      	moveq	r3, #1
    seekSet(0);
   b86ea:	2100      	movs	r1, #0
   b86ec:	4628      	mov	r0, r5
   b86ee:	9303      	str	r3, [sp, #12]
   b86f0:	f000 fae1 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
   b86f4:	f107 030d 	add.w	r3, r7, #13
  }
   b86f8:	f04f 0b00 	mov.w	fp, #0
   b86fc:	ee08 3a10 	vmov	s16, r3
   b8700:	46da      	mov	sl, fp
   b8702:	465c      	mov	r4, fp
   b8704:	465e      	mov	r6, fp
   b8706:	f8cd b010 	str.w	fp, [sp, #16]
   b870a:	46d9      	mov	r9, fp
    curIndex = dirFile->m_curPosition/32;
   b870c:	696b      	ldr	r3, [r5, #20]
    dir = dirFile->readDirCache(true);
   b870e:	2101      	movs	r1, #1
   b8710:	4628      	mov	r0, r5
    curIndex = dirFile->m_curPosition/32;
   b8712:	f3c3 184f 	ubfx	r8, r3, #5, #16
    dir = dirFile->readDirCache(true);
   b8716:	f000 faaf 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
   b871a:	4603      	mov	r3, r0
   b871c:	2800      	cmp	r0, #0
   b871e:	d171      	bne.n	b8804 <_ZN7FatFile4openEPS_P7fname_ti+0x164>
      if (dirFile->getError()) {
   b8720:	786b      	ldrb	r3, [r5, #1]
   b8722:	2b00      	cmp	r3, #0
   b8724:	d1c9      	bne.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
   b8726:	9b06      	ldr	r3, [sp, #24]
   b8728:	059a      	lsls	r2, r3, #22
   b872a:	d5c6      	bpl.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>

#define O_READ    O_RDONLY
#define O_WRITE   O_WRONLY

inline bool isWriteMode(oflag_t oflag) {
  oflag &= O_ACCMODE;
   b872c:	f003 0303 	and.w	r3, r3, #3
  return oflag == O_WRONLY || oflag == O_RDWR;
   b8730:	3b01      	subs	r3, #1
   b8732:	2b01      	cmp	r3, #1
   b8734:	d8c1      	bhi.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  if (freeFound == 0) {
   b8736:	9b04      	ldr	r3, [sp, #16]
   b8738:	2c00      	cmp	r4, #0
   b873a:	bf08      	it	eq
   b873c:	4643      	moveq	r3, r8
   b873e:	9304      	str	r3, [sp, #16]
  while (freeFound < freeNeed) {
   b8740:	9b03      	ldr	r3, [sp, #12]
   b8742:	429c      	cmp	r4, r3
   b8744:	f0c0 80f1 	bcc.w	b892a <_ZN7FatFile4openEPS_P7fname_ti+0x28a>
  if (fnameFound) {
   b8748:	f1b9 0f00 	cmp.w	r9, #0
   b874c:	f040 810a 	bne.w	b8964 <_ZN7FatFile4openEPS_P7fname_ti+0x2c4>
  if (!dirFile->seekSet(32UL*freeIndex)) {
   b8750:	9b04      	ldr	r3, [sp, #16]
   b8752:	4628      	mov	r0, r5
   b8754:	0159      	lsls	r1, r3, #5
   b8756:	f000 faae 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
   b875a:	2800      	cmp	r0, #0
   b875c:	d0ad      	beq.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  lfnOrd = freeNeed - 1;
   b875e:	9b03      	ldr	r3, [sp, #12]
   b8760:	f103 39ff 	add.w	r9, r3, #4294967295
   b8764:	fa5f f989 	uxtb.w	r9, r9
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
   b8768:	464e      	mov	r6, r9
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
   b876a:	f04f 0a00 	mov.w	sl, #0
    ldir->attr = DIR_ATT_LONG_NAME;
   b876e:	f04f 080f 	mov.w	r8, #15
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
   b8772:	2e00      	cmp	r6, #0
   b8774:	f000 810d 	beq.w	b8992 <_ZN7FatFile4openEPS_P7fname_ti+0x2f2>
    ldir = reinterpret_cast<ldir_t*>(dirFile->readDirCache());
   b8778:	2100      	movs	r1, #0
   b877a:	4628      	mov	r0, r5
   b877c:	f000 fa7c 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
    if (!ldir) {
   b8780:	4604      	mov	r4, r0
   b8782:	2800      	cmp	r0, #0
   b8784:	d099      	beq.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
    dirFile->m_vol->cacheDirty();
   b8786:	68aa      	ldr	r2, [r5, #8]
   b8788:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->ord = ord == lfnOrd ? LDIR_ORD_LAST_LONG_ENTRY | ord : ord;
   b878c:	454e      	cmp	r6, r9
   b878e:	f043 0301 	orr.w	r3, r3, #1
   b8792:	bf0c      	ite	eq
   b8794:	f046 0b40 	orreq.w	fp, r6, #64	; 0x40
   b8798:	46b3      	movne	fp, r6
   b879a:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   b879e:	f880 b000 	strb.w	fp, [r0]
    ldir->attr = DIR_ATT_LONG_NAME;
   b87a2:	f880 800b 	strb.w	r8, [r0, #11]
    ldir->type = 0;
   b87a6:	f880 a00c 	strb.w	sl, [r0, #12]
    ldir->chksum = lfnChecksum(fname->sfn);
   b87aa:	f107 000d 	add.w	r0, r7, #13
   b87ae:	f7ff fdbc 	bl	b832a <_ZN7FatFile11lfnChecksumEPh>
    ldir->mustBeZero = 0;
   b87b2:	f884 a01a 	strb.w	sl, [r4, #26]
    ldir->chksum = lfnChecksum(fname->sfn);
   b87b6:	7360      	strb	r0, [r4, #13]
    ldir->mustBeZero = 0;
   b87b8:	f884 a01b 	strb.w	sl, [r4, #27]
  size_t k = 13*((ldir->ord & 0X1F) - 1);
   b87bc:	f00b 031f 	and.w	r3, fp, #31
   b87c0:	220d      	movs	r2, #13
   b87c2:	3b01      	subs	r3, #1
    lfnPutName(ldir, fname->lfn, len);
   b87c4:	f8d7 c008 	ldr.w	ip, [r7, #8]
  size_t k = 13*((ldir->ord & 0X1F) - 1);
   b87c8:	4353      	muls	r3, r2
   b87ca:	2200      	movs	r2, #0
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
   b87cc:	9905      	ldr	r1, [sp, #20]
   b87ce:	4299      	cmp	r1, r3
   b87d0:	f240 80d0 	bls.w	b8974 <_ZN7FatFile4openEPS_P7fname_ti+0x2d4>
   b87d4:	f81c 1003 	ldrb.w	r1, [ip, r3]
  if (i < LDIR_NAME1_DIM) {
   b87d8:	2a04      	cmp	r2, #4
   b87da:	fa5f fe82 	uxtb.w	lr, r2
   b87de:	f102 0001 	add.w	r0, r2, #1
   b87e2:	f200 80cd 	bhi.w	b8980 <_ZN7FatFile4openEPS_P7fname_ti+0x2e0>
    ldir->name1[i] = c;
   b87e6:	eb04 0242 	add.w	r2, r4, r2, lsl #1
   b87ea:	f8a2 1001 	strh.w	r1, [r2, #1]
  for (uint8_t i = 0; i < 13; i++, k++) {
   b87ee:	280d      	cmp	r0, #13
   b87f0:	f103 0301 	add.w	r3, r3, #1
   b87f4:	4602      	mov	r2, r0
   b87f6:	d1e9      	bne.n	b87cc <_ZN7FatFile4openEPS_P7fname_ti+0x12c>
  for (uint8_t ord = lfnOrd ; ord ; ord--) {
   b87f8:	3e01      	subs	r6, #1
   b87fa:	b2f6      	uxtb	r6, r6
   b87fc:	e7b9      	b.n	b8772 <_ZN7FatFile4openEPS_P7fname_ti+0xd2>
        fnameFound = true;
   b87fe:	f04f 0901 	mov.w	r9, #1
   b8802:	e783      	b.n	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == DIR_NAME_FREE) {
   b8804:	7802      	ldrb	r2, [r0, #0]
   b8806:	2ae5      	cmp	r2, #229	; 0xe5
   b8808:	d000      	beq.n	b880c <_ZN7FatFile4openEPS_P7fname_ti+0x16c>
   b880a:	b97a      	cbnz	r2, b882c <_ZN7FatFile4openEPS_P7fname_ti+0x18c>
    curIndex = dirFile->m_curPosition/32;
   b880c:	9904      	ldr	r1, [sp, #16]
   b880e:	2c00      	cmp	r4, #0
   b8810:	bf08      	it	eq
   b8812:	4641      	moveq	r1, r8
   b8814:	9104      	str	r1, [sp, #16]
      if (freeFound < freeNeed) {
   b8816:	9903      	ldr	r1, [sp, #12]
   b8818:	428c      	cmp	r4, r1
        freeFound++;
   b881a:	bf3c      	itt	cc
   b881c:	3401      	addcc	r4, #1
   b881e:	b2e4      	uxtbcc	r4, r4
      if (dir->name[0] == DIR_NAME_FREE) {
   b8820:	2a00      	cmp	r2, #0
   b8822:	d080      	beq.n	b8726 <_ZN7FatFile4openEPS_P7fname_ti+0x86>
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
   b8824:	2ae5      	cmp	r2, #229	; 0xe5
   b8826:	d105      	bne.n	b8834 <_ZN7FatFile4openEPS_P7fname_ti+0x194>
      lfnOrd = 0;
   b8828:	2600      	movs	r6, #0
   b882a:	e76f      	b.n	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
        freeFound = 0;
   b882c:	9903      	ldr	r1, [sp, #12]
   b882e:	428c      	cmp	r4, r1
   b8830:	bf38      	it	cc
   b8832:	2400      	movcc	r4, #0
    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
   b8834:	2a2e      	cmp	r2, #46	; 0x2e
   b8836:	d0f7      	beq.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
 * \param[in] dir Pointer to a directory entry.
 *
 * \return true if the entry is for part of a long name else false.
 */
static inline uint8_t DIR_IS_LONG_NAME(const dir_t* dir) {
  return dir->attributes == DIR_ATT_LONG_NAME;
   b8838:	7ad9      	ldrb	r1, [r3, #11]
    } else if (DIR_IS_LONG_NAME(dir)) {
   b883a:	290f      	cmp	r1, #15
   b883c:	d14a      	bne.n	b88d4 <_ZN7FatFile4openEPS_P7fname_ti+0x234>
      if (!lfnOrd) {
   b883e:	bb16      	cbnz	r6, b8886 <_ZN7FatFile4openEPS_P7fname_ti+0x1e6>
        if ((ldir->ord & LDIR_ORD_LAST_LONG_ENTRY) == 0) {
   b8840:	f012 0640 	ands.w	r6, r2, #64	; 0x40
   b8844:	f43f af62 	beq.w	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
        lfnOrd = ord = ldir->ord & 0X1F;
   b8848:	f002 061f 	and.w	r6, r2, #31
        chksum = ldir->chksum;
   b884c:	f893 b00d 	ldrb.w	fp, [r3, #13]
        lfnOrd = ord = ldir->ord & 0X1F;
   b8850:	46b2      	mov	sl, r6
      size_t k = 13*(ord - 1);
   b8852:	220d      	movs	r2, #13
   b8854:	f10a 38ff 	add.w	r8, sl, #4294967295
   b8858:	fb02 f808 	mul.w	r8, r2, r8
      if (k >= len) {
   b885c:	9a05      	ldr	r2, [sp, #20]
   b885e:	4542      	cmp	r2, r8
   b8860:	d9e2      	bls.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
   b8862:	eba2 0208 	sub.w	r2, r2, r8
   b8866:	9208      	str	r2, [sp, #32]
   b8868:	2200      	movs	r2, #0
   b886a:	eb02 0108 	add.w	r1, r2, r8
   b886e:	9109      	str	r1, [sp, #36]	; 0x24
        uint16_t u = lfnGetChar(ldir, i);
   b8870:	4618      	mov	r0, r3
   b8872:	b2d1      	uxtb	r1, r2
   b8874:	f7ff fd38 	bl	b82e8 <_ZL10lfnGetCharP18longDirectoryEntryh>
        if (k == len) {
   b8878:	9908      	ldr	r1, [sp, #32]
   b887a:	428a      	cmp	r2, r1
   b887c:	d10d      	bne.n	b889a <_ZN7FatFile4openEPS_P7fname_ti+0x1fa>
            lfnOrd = 0;
   b887e:	2800      	cmp	r0, #0
   b8880:	bf18      	it	ne
   b8882:	2600      	movne	r6, #0
   b8884:	e742      	b.n	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
      } else if (ldir->ord != --ord || chksum != ldir->chksum) {
   b8886:	f10a 3aff 	add.w	sl, sl, #4294967295
   b888a:	fa5f fa8a 	uxtb.w	sl, sl
   b888e:	4552      	cmp	r2, sl
   b8890:	d1ca      	bne.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
   b8892:	7b5a      	ldrb	r2, [r3, #13]
   b8894:	455a      	cmp	r2, fp
   b8896:	d0dc      	beq.n	b8852 <_ZN7FatFile4openEPS_P7fname_ti+0x1b2>
   b8898:	e7c6      	b.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
   b889a:	28ff      	cmp	r0, #255	; 0xff
   b889c:	d8c4      	bhi.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
   b889e:	fa5f fe80 	uxtb.w	lr, r0
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
   b88a2:	f1ae 0141 	sub.w	r1, lr, #65	; 0x41
   b88a6:	2919      	cmp	r1, #25
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
   b88a8:	68b9      	ldr	r1, [r7, #8]
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
   b88aa:	bf9c      	itt	ls
   b88ac:	f10e 0020 	addls.w	r0, lr, #32
   b88b0:	fa5f fe80 	uxtbls.w	lr, r0
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
   b88b4:	4608      	mov	r0, r1
   b88b6:	9909      	ldr	r1, [sp, #36]	; 0x24
   b88b8:	5c41      	ldrb	r1, [r0, r1]
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
   b88ba:	f1a1 0c41 	sub.w	ip, r1, #65	; 0x41
   b88be:	f1bc 0f19 	cmp.w	ip, #25
   b88c2:	bf9c      	itt	ls
   b88c4:	3120      	addls	r1, #32
   b88c6:	b2c9      	uxtbls	r1, r1
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
   b88c8:	4571      	cmp	r1, lr
   b88ca:	d1ad      	bne.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
      for (uint8_t i = 0; i < 13; i++) {
   b88cc:	3201      	adds	r2, #1
   b88ce:	2a0d      	cmp	r2, #13
   b88d0:	d1cb      	bne.n	b886a <_ZN7FatFile4openEPS_P7fname_ti+0x1ca>
   b88d2:	e71b      	b.n	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
    } else if (DIR_IS_FILE_OR_SUBDIR(dir)) {
   b88d4:	0708      	lsls	r0, r1, #28
   b88d6:	d4a7      	bmi.n	b8828 <_ZN7FatFile4openEPS_P7fname_ti+0x188>
      if (lfnOrd) {
   b88d8:	b15e      	cbz	r6, b88f2 <_ZN7FatFile4openEPS_P7fname_ti+0x252>
        if (1 == ord && lfnChecksum(dir->name) == chksum) {
   b88da:	f1ba 0f01 	cmp.w	sl, #1
   b88de:	f47f aeec 	bne.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
   b88e2:	4618      	mov	r0, r3
   b88e4:	f7ff fd21 	bl	b832a <_ZN7FatFile11lfnChecksumEPh>
   b88e8:	4558      	cmp	r0, fp
   b88ea:	f47f aee6 	bne.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
   b88ee:	46b1      	mov	r9, r6
   b88f0:	e00e      	b.n	b8910 <_ZN7FatFile4openEPS_P7fname_ti+0x270>
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
   b88f2:	ee18 1a10 	vmov	r1, s16
   b88f6:	220b      	movs	r2, #11
   b88f8:	4618      	mov	r0, r3
   b88fa:	f006 fac6 	bl	bee8a <memcmp>
   b88fe:	2800      	cmp	r0, #0
   b8900:	f47f af04 	bne.w	b870c <_ZN7FatFile4openEPS_P7fname_ti+0x6c>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
   b8904:	f897 9000 	ldrb.w	r9, [r7]
   b8908:	f019 0901 	ands.w	r9, r9, #1
   b890c:	f47f af77 	bne.w	b87fe <_ZN7FatFile4openEPS_P7fname_ti+0x15e>
  if (oflag & O_EXCL) {
   b8910:	9b06      	ldr	r3, [sp, #24]
   b8912:	0519      	lsls	r1, r3, #20
   b8914:	f53f aed1 	bmi.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
   b8918:	9b06      	ldr	r3, [sp, #24]
   b891a:	9807      	ldr	r0, [sp, #28]
   b891c:	f8cd 9000 	str.w	r9, [sp]
   b8920:	4642      	mov	r2, r8
   b8922:	4629      	mov	r1, r5
   b8924:	f000 fa0a 	bl	b8d3c <_ZN7FatFile15openCachedEntryEPS_tih>
   b8928:	e6c8      	b.n	b86bc <_ZN7FatFile4openEPS_P7fname_ti+0x1c>
    dir = dirFile->readDirCache();
   b892a:	2100      	movs	r1, #0
   b892c:	4628      	mov	r0, r5
   b892e:	f000 f9a3 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
    if (!dir) {
   b8932:	b9a0      	cbnz	r0, b895e <_ZN7FatFile4openEPS_P7fname_ti+0x2be>
      if (dirFile->getError()) {
   b8934:	786b      	ldrb	r3, [r5, #1]
   b8936:	2b00      	cmp	r3, #0
   b8938:	f47f aebf 	bne.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
    if (!dirFile->addDirCluster()) {
   b893c:	4628      	mov	r0, r5
   b893e:	f000 f887 	bl	b8a50 <_ZN7FatFile13addDirClusterEv>
   b8942:	2800      	cmp	r0, #0
   b8944:	f43f aeb9 	beq.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
    return m_blocksPerCluster;
   b8948:	68ab      	ldr	r3, [r5, #8]
    if (dirFile->m_vol->blocksPerCluster() > 1) {
   b894a:	791b      	ldrb	r3, [r3, #4]
   b894c:	2b01      	cmp	r3, #1
   b894e:	f63f aefb 	bhi.w	b8748 <_ZN7FatFile4openEPS_P7fname_ti+0xa8>
  while (freeFound < freeNeed) {
   b8952:	9b03      	ldr	r3, [sp, #12]
    freeFound += 16;
   b8954:	3410      	adds	r4, #16
   b8956:	b2e4      	uxtb	r4, r4
  while (freeFound < freeNeed) {
   b8958:	42a3      	cmp	r3, r4
   b895a:	d8ef      	bhi.n	b893c <_ZN7FatFile4openEPS_P7fname_ti+0x29c>
   b895c:	e6f4      	b.n	b8748 <_ZN7FatFile4openEPS_P7fname_ti+0xa8>
    freeFound++;
   b895e:	3401      	adds	r4, #1
   b8960:	b2e4      	uxtb	r4, r4
  while (freeFound < freeNeed) {
   b8962:	e6ed      	b.n	b8740 <_ZN7FatFile4openEPS_P7fname_ti+0xa0>
    if (!dirFile->lfnUniqueSfn(fname)) {
   b8964:	4639      	mov	r1, r7
   b8966:	4628      	mov	r0, r5
   b8968:	f7ff fe46 	bl	b85f8 <_ZN7FatFile12lfnUniqueSfnEP7fname_t>
   b896c:	2800      	cmp	r0, #0
   b896e:	f47f aeef 	bne.w	b8750 <_ZN7FatFile4openEPS_P7fname_ti+0xb0>
   b8972:	e6a2      	b.n	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
   b8974:	bf14      	ite	ne
   b8976:	f04f 31ff 	movne.w	r1, #4294967295
   b897a:	2100      	moveq	r1, #0
   b897c:	b289      	uxth	r1, r1
   b897e:	e72b      	b.n	b87d8 <_ZN7FatFile4openEPS_P7fname_ti+0x138>
  } else if (i < (LDIR_NAME1_DIM + LDIR_NAME2_DIM)) {
   b8980:	f1be 0f0a 	cmp.w	lr, #10
    ldir->name2[i - LDIR_NAME1_DIM] = c;
   b8984:	bf94      	ite	ls
   b8986:	eb04 0242 	addls.w	r2, r4, r2, lsl #1
    ldir->name3[i - LDIR_NAME1_DIM - LDIR_NAME2_DIM] = c;
   b898a:	eb04 0240 	addhi.w	r2, r4, r0, lsl #1
   b898e:	8091      	strh	r1, [r2, #4]
   b8990:	e72d      	b.n	b87ee <_ZN7FatFile4openEPS_P7fname_ti+0x14e>
  dir = dirFile->readDirCache();
   b8992:	4631      	mov	r1, r6
   b8994:	4628      	mov	r0, r5
  curIndex = dirFile->m_curPosition/32;
   b8996:	f8d5 8014 	ldr.w	r8, [r5, #20]
  dir = dirFile->readDirCache();
   b899a:	f000 f96d 	bl	b8c78 <_ZN7FatFile12readDirCacheEb>
  if (!dir) {
   b899e:	4604      	mov	r4, r0
   b89a0:	2800      	cmp	r0, #0
   b89a2:	f43f ae8a 	beq.w	b86ba <_ZN7FatFile4openEPS_P7fname_ti+0x1a>
  memset(dir, 0, sizeof(dir_t));
   b89a6:	2220      	movs	r2, #32
   b89a8:	4631      	mov	r1, r6
   b89aa:	f006 faa6 	bl	beefa <memset>
  memcpy(dir->name, fname->sfn, 11);
   b89ae:	f8d7 300d 	ldr.w	r3, [r7, #13]
   b89b2:	6023      	str	r3, [r4, #0]
   b89b4:	f8d7 3011 	ldr.w	r3, [r7, #17]
   b89b8:	6063      	str	r3, [r4, #4]
   b89ba:	f8b7 3015 	ldrh.w	r3, [r7, #21]
   b89be:	8123      	strh	r3, [r4, #8]
   b89c0:	7dfb      	ldrb	r3, [r7, #23]
   b89c2:	72a3      	strb	r3, [r4, #10]
  dir->reservedNT =  (DIR_NT_LC_BASE | DIR_NT_LC_EXT) & fname->flags;
   b89c4:	783b      	ldrb	r3, [r7, #0]
   b89c6:	f003 0318 	and.w	r3, r3, #24
   b89ca:	7323      	strb	r3, [r4, #12]
  if (m_dateTime) {
   b89cc:	4b0f      	ldr	r3, [pc, #60]	; (b8a0c <_ZN7FatFile4openEPS_P7fname_ti+0x36c>)
   b89ce:	681b      	ldr	r3, [r3, #0]
   b89d0:	b19b      	cbz	r3, b89fa <_ZN7FatFile4openEPS_P7fname_ti+0x35a>
    m_dateTime(&dir->creationDate, &dir->creationTime);
   b89d2:	f104 010e 	add.w	r1, r4, #14
   b89d6:	f104 0010 	add.w	r0, r4, #16
   b89da:	4798      	blx	r3
  dir->lastAccessDate = dir->creationDate;
   b89dc:	8a23      	ldrh	r3, [r4, #16]
   b89de:	8263      	strh	r3, [r4, #18]
  dir->lastWriteDate = dir->creationDate;
   b89e0:	8323      	strh	r3, [r4, #24]
  dir->lastWriteTime = dir->creationTime;
   b89e2:	89e3      	ldrh	r3, [r4, #14]
   b89e4:	82e3      	strh	r3, [r4, #22]
  dirFile->m_vol->cacheDirty();
   b89e6:	68aa      	ldr	r2, [r5, #8]
    m_status |= CACHE_STATUS_DIRTY;
   b89e8:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   b89ec:	f043 0301 	orr.w	r3, r3, #1
  curIndex = dirFile->m_curPosition/32;
   b89f0:	f3c8 184f 	ubfx	r8, r8, #5, #16
   b89f4:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
  uint32_t cacheBlockNumber() {
    return m_cache.lbn();
  }
  void cacheDirty() {
    m_cache.dirty();
  }
   b89f8:	e78e      	b.n	b8918 <_ZN7FatFile4openEPS_P7fname_ti+0x278>
    dir->creationDate = FAT_DEFAULT_DATE;
   b89fa:	2321      	movs	r3, #33	; 0x21
   b89fc:	7423      	strb	r3, [r4, #16]
   b89fe:	2328      	movs	r3, #40	; 0x28
   b8a00:	7463      	strb	r3, [r4, #17]
    dir->creationTime = FAT_DEFAULT_TIME;
   b8a02:	2308      	movs	r3, #8
   b8a04:	73a6      	strb	r6, [r4, #14]
   b8a06:	73e3      	strb	r3, [r4, #15]
   b8a08:	e7e8      	b.n	b89dc <_ZN7FatFile4openEPS_P7fname_ti+0x33c>
   b8a0a:	bf00      	nop
   b8a0c:	2003e648 	.word	0x2003e648

000b8a10 <_ZN7FatFile8openRootEP9FatVolume.part.0>:
fail:
  return false;
}
#endif  // DOXYGEN_SHOULD_SKIP_THIS
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
   b8a10:	b538      	push	{r3, r4, r5, lr}
   b8a12:	4604      	mov	r4, r0
   b8a14:	460d      	mov	r5, r1
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
   b8a16:	2224      	movs	r2, #36	; 0x24
   b8a18:	2100      	movs	r1, #0
   b8a1a:	f006 fa6e 	bl	beefa <memset>

  m_vol = vol;
   b8a1e:	60a5      	str	r5, [r4, #8]
    return m_fatType;
   b8a20:	79eb      	ldrb	r3, [r5, #7]
  switch (vol->fatType()) {
   b8a22:	2b10      	cmp	r3, #16
   b8a24:	d003      	beq.n	b8a2e <_ZN7FatFile8openRootEP9FatVolume.part.0+0x1e>
   b8a26:	2b20      	cmp	r3, #32
   b8a28:	d006      	beq.n	b8a38 <_ZN7FatFile8openRootEP9FatVolume.part.0+0x28>
   b8a2a:	2000      	movs	r0, #0
  m_flags = F_READ;
  return true;

fail:
  return false;
}
   b8a2c:	bd38      	pop	{r3, r4, r5, pc}
    m_attr = FILE_ATTR_ROOT_FIXED;
   b8a2e:	2320      	movs	r3, #32
  m_flags = F_READ;
   b8a30:	2001      	movs	r0, #1
    m_attr = FILE_ATTR_ROOT32;
   b8a32:	7023      	strb	r3, [r4, #0]
  m_flags = F_READ;
   b8a34:	70a0      	strb	r0, [r4, #2]
  return true;
   b8a36:	e7f9      	b.n	b8a2c <_ZN7FatFile8openRootEP9FatVolume.part.0+0x1c>
    m_attr = FILE_ATTR_ROOT32;
   b8a38:	2340      	movs	r3, #64	; 0x40
   b8a3a:	e7f9      	b.n	b8a30 <_ZN7FatFile8openRootEP9FatVolume.part.0+0x20>

000b8a3c <_ZN7FatFile10addClusterEv>:
  m_flags |= F_FILE_DIR_DIRTY;
   b8a3c:	7883      	ldrb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
   b8a3e:	6901      	ldr	r1, [r0, #16]
  m_flags |= F_FILE_DIR_DIRTY;
   b8a40:	f043 0304 	orr.w	r3, r3, #4
   b8a44:	7083      	strb	r3, [r0, #2]
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
   b8a46:	f100 0210 	add.w	r2, r0, #16
   b8a4a:	6880      	ldr	r0, [r0, #8]
   b8a4c:	f000 bc08 	b.w	b9260 <_ZN9FatVolume15allocateClusterEmPm>

000b8a50 <_ZN7FatFile13addDirClusterEv>:
bool FatFile::addDirCluster() {
   b8a50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (isRootFixed()) {
   b8a54:	7801      	ldrb	r1, [r0, #0]
   b8a56:	f011 0520 	ands.w	r5, r1, #32
bool FatFile::addDirCluster() {
   b8a5a:	4604      	mov	r4, r0
  if (isRootFixed()) {
   b8a5c:	d003      	beq.n	b8a66 <_ZN7FatFile13addDirClusterEv+0x16>
  return false;
   b8a5e:	2600      	movs	r6, #0
}
   b8a60:	4630      	mov	r0, r6
   b8a62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curPosition >= 512UL*4095) {
   b8a66:	6942      	ldr	r2, [r0, #20]
   b8a68:	4b17      	ldr	r3, [pc, #92]	; (b8ac8 <_ZN7FatFile13addDirClusterEv+0x78>)
   b8a6a:	429a      	cmp	r2, r3
   b8a6c:	d2f7      	bcs.n	b8a5e <_ZN7FatFile13addDirClusterEv+0xe>
  if (!addCluster()) {
   b8a6e:	f7ff ffe5 	bl	b8a3c <_ZN7FatFile10addClusterEv>
   b8a72:	4606      	mov	r6, r0
   b8a74:	2800      	cmp	r0, #0
   b8a76:	d0f2      	beq.n	b8a5e <_ZN7FatFile13addDirClusterEv+0xe>
  block = m_vol->clusterFirstBlock(m_curCluster);
   b8a78:	6921      	ldr	r1, [r4, #16]
   b8a7a:	68a0      	ldr	r0, [r4, #8]
   b8a7c:	f000 fb85 	bl	b918a <_ZNK9FatVolume17clusterFirstBlockEm>
   b8a80:	4607      	mov	r7, r0
    return m_cache.read(blockNumber, options);
   b8a82:	68a0      	ldr	r0, [r4, #8]
   b8a84:	2205      	movs	r2, #5
   b8a86:	4639      	mov	r1, r7
   b8a88:	3024      	adds	r0, #36	; 0x24
   b8a8a:	f000 fb5b 	bl	b9144 <_ZN8FatCache4readEmh>
  if (!pc) {
   b8a8e:	4680      	mov	r8, r0
   b8a90:	2800      	cmp	r0, #0
   b8a92:	d0e4      	beq.n	b8a5e <_ZN7FatFile13addDirClusterEv+0xe>
  memset(pc, 0, 512);
   b8a94:	4629      	mov	r1, r5
   b8a96:	f44f 7200 	mov.w	r2, #512	; 0x200
   b8a9a:	f006 fa2e 	bl	beefa <memset>
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
   b8a9e:	2501      	movs	r5, #1
   b8aa0:	68a3      	ldr	r3, [r4, #8]
    return m_blocksPerCluster;
   b8aa2:	791a      	ldrb	r2, [r3, #4]
   b8aa4:	42aa      	cmp	r2, r5
   b8aa6:	d909      	bls.n	b8abc <_ZN7FatFile13addDirClusterEv+0x6c>
    return m_blockDev->writeBlock(block, src);
   b8aa8:	6818      	ldr	r0, [r3, #0]
   b8aaa:	4642      	mov	r2, r8
   b8aac:	19e9      	adds	r1, r5, r7
   b8aae:	f000 feb6 	bl	b981e <_ZN9SdSpiCard10writeBlockEmPKh>
    if (!m_vol->writeBlock(block + i, pc->data)) {
   b8ab2:	2800      	cmp	r0, #0
   b8ab4:	d0d3      	beq.n	b8a5e <_ZN7FatFile13addDirClusterEv+0xe>
  for (uint8_t i = 1; i < m_vol->blocksPerCluster(); i++) {
   b8ab6:	3501      	adds	r5, #1
   b8ab8:	b2ed      	uxtb	r5, r5
   b8aba:	e7f1      	b.n	b8aa0 <_ZN7FatFile13addDirClusterEv+0x50>
  m_curPosition += 512UL*m_vol->blocksPerCluster();
   b8abc:	6963      	ldr	r3, [r4, #20]
   b8abe:	eb03 2342 	add.w	r3, r3, r2, lsl #9
   b8ac2:	6163      	str	r3, [r4, #20]
  return true;
   b8ac4:	e7cc      	b.n	b8a60 <_ZN7FatFile13addDirClusterEv+0x10>
   b8ac6:	bf00      	nop
   b8ac8:	001ffe00 	.word	0x001ffe00

000b8acc <_ZN7FatFile13cacheDirEntryEh>:
dir_t* FatFile::cacheDirEntry(uint8_t action) {
   b8acc:	b510      	push	{r4, lr}
   b8ace:	4604      	mov	r4, r0
    return m_cache.read(blockNumber, options);
   b8ad0:	6880      	ldr	r0, [r0, #8]
   b8ad2:	460a      	mov	r2, r1
   b8ad4:	3024      	adds	r0, #36	; 0x24
   b8ad6:	69a1      	ldr	r1, [r4, #24]
   b8ad8:	f000 fb34 	bl	b9144 <_ZN8FatCache4readEmh>
  if (!pc) {
   b8adc:	b120      	cbz	r0, b8ae8 <_ZN7FatFile13cacheDirEntryEh+0x1c>
  return pc->dir + (m_dirIndex & 0XF);
   b8ade:	88a3      	ldrh	r3, [r4, #4]
   b8ae0:	f003 030f 	and.w	r3, r3, #15
   b8ae4:	eb00 1043 	add.w	r0, r0, r3, lsl #5
}
   b8ae8:	bd10      	pop	{r4, pc}

000b8aea <_ZN7FatFile8openRootEP9FatVolume>:
  if (isOpen()) {
   b8aea:	7803      	ldrb	r3, [r0, #0]
   b8aec:	b90b      	cbnz	r3, b8af2 <_ZN7FatFile8openRootEP9FatVolume+0x8>
   b8aee:	f7ff bf8f 	b.w	b8a10 <_ZN7FatFile8openRootEP9FatVolume.part.0>
}
   b8af2:	2000      	movs	r0, #0
   b8af4:	4770      	bx	lr

000b8af6 <_ZN7FatFile4readEPvj>:
    setpos(&pos);
  }
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
   b8af6:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return m_attr;
   b8afa:	7803      	ldrb	r3, [r0, #0]
   b8afc:	4604      	mov	r4, r0
   b8afe:	4688      	mov	r8, r1
   b8b00:	4615      	mov	r5, r2
  size_t toRead;
  uint32_t block;  // raw device block number
  cache_t* pc;

  // error if not open for read
  if (!isOpen() || !(m_flags & F_READ)) {
   b8b02:	2b00      	cmp	r3, #0
   b8b04:	d05d      	beq.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
   b8b06:	7882      	ldrb	r2, [r0, #2]
   b8b08:	07d1      	lsls	r1, r2, #31
   b8b0a:	d55a      	bpl.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
   b8b0c:	071a      	lsls	r2, r3, #28
   b8b0e:	d52d      	bpl.n	b8b6c <_ZN7FatFile4readEPvj+0x76>
    uint32_t tmp32 = m_fileSize - m_curPosition;
   b8b10:	69c3      	ldr	r3, [r0, #28]
   b8b12:	6942      	ldr	r2, [r0, #20]
   b8b14:	1a9b      	subs	r3, r3, r2
   b8b16:	429d      	cmp	r5, r3
   b8b18:	bf28      	it	cs
   b8b1a:	461d      	movcs	r5, r3
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
   b8b1c:	462e      	mov	r6, r5
  uint8_t blockOfCluster = 0;
   b8b1e:	f04f 0900 	mov.w	r9, #0
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
   b8b22:	f104 0b10 	add.w	fp, r4, #16
  while (toRead) {
   b8b26:	2e00      	cmp	r6, #0
   b8b28:	f000 808f 	beq.w	b8c4a <_ZN7FatFile4readEPvj+0x154>
    return m_attr & FILE_ATTR_ROOT_FIXED;
   b8b2c:	7822      	ldrb	r2, [r4, #0]
    offset = m_curPosition & 0X1FF;  // offset in block
   b8b2e:	6963      	ldr	r3, [r4, #20]
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
   b8b30:	68a0      	ldr	r0, [r4, #8]
    if (isRootFixed()) {
   b8b32:	0697      	lsls	r7, r2, #26
    offset = m_curPosition & 0X1FF;  // offset in block
   b8b34:	f3c3 0a08 	ubfx	sl, r3, #0, #9
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
   b8b38:	ea4f 2153 	mov.w	r1, r3, lsr #9
    if (isRootFixed()) {
   b8b3c:	d51f      	bpl.n	b8b7e <_ZN7FatFile4readEPvj+0x88>
      block = m_vol->rootDirStart() + (m_curPosition >> 9);
   b8b3e:	6a00      	ldr	r0, [r0, #32]
   b8b40:	4401      	add	r1, r0
          }
        }
      }
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
    }
    if (offset != 0 || toRead < 512 || block == m_vol->cacheBlockNumber()) {
   b8b42:	68a0      	ldr	r0, [r4, #8]
   b8b44:	f1ba 0f00 	cmp.w	sl, #0
   b8b48:	d142      	bne.n	b8bd0 <_ZN7FatFile4readEPvj+0xda>
   b8b4a:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   b8b4e:	d33f      	bcc.n	b8bd0 <_ZN7FatFile4readEPvj+0xda>
    return m_lbn;
   b8b50:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   b8b52:	4299      	cmp	r1, r3
   b8b54:	d03c      	beq.n	b8bd0 <_ZN7FatFile4readEPvj+0xda>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_BLOCK_IO
    } else if (toRead >= 1024) {
   b8b56:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   b8b5a:	d252      	bcs.n	b8c02 <_ZN7FatFile4readEPvj+0x10c>
    return m_blockDev->readBlock(block, dst);
   b8b5c:	6800      	ldr	r0, [r0, #0]
   b8b5e:	4642      	mov	r2, r8
   b8b60:	f000 fdd4 	bl	b970c <_ZN9SdSpiCard9readBlockEmPh>
      }
#endif  // USE_MULTI_BLOCK_IO
    } else {
      // read single block
      n = 512;
      if (!m_vol->readBlock(block, dst)) {
   b8b64:	b368      	cbz	r0, b8bc2 <_ZN7FatFile4readEPvj+0xcc>
      n = 512;
   b8b66:	f44f 7700 	mov.w	r7, #512	; 0x200
   b8b6a:	e044      	b.n	b8bf6 <_ZN7FatFile4readEPvj+0x100>
  } else if (isRootFixed()) {
   b8b6c:	069b      	lsls	r3, r3, #26
   b8b6e:	d5d5      	bpl.n	b8b1c <_ZN7FatFile4readEPvj+0x26>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
   b8b70:	6883      	ldr	r3, [r0, #8]
   b8b72:	891a      	ldrh	r2, [r3, #8]
   b8b74:	6943      	ldr	r3, [r0, #20]
   b8b76:	ebc3 1342 	rsb	r3, r3, r2, lsl #5
    if (nbyte > tmp16) {
   b8b7a:	b29b      	uxth	r3, r3
   b8b7c:	e7cb      	b.n	b8b16 <_ZN7FatFile4readEPvj+0x20>
//------------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t blockOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterBlockMask;
   b8b7e:	f890 9005 	ldrb.w	r9, [r0, #5]
   b8b82:	ea09 0901 	and.w	r9, r9, r1
      if (offset == 0 && blockOfCluster == 0) {
   b8b86:	f1ba 0f00 	cmp.w	sl, #0
   b8b8a:	d108      	bne.n	b8b9e <_ZN7FatFile4readEPvj+0xa8>
   b8b8c:	f1b9 0f00 	cmp.w	r9, #0
   b8b90:	d105      	bne.n	b8b9e <_ZN7FatFile4readEPvj+0xa8>
        if (m_curPosition == 0) {
   b8b92:	b95b      	cbnz	r3, b8bac <_ZN7FatFile4readEPvj+0xb6>
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
   b8b94:	0651      	lsls	r1, r2, #25
    return m_rootDirStart;
   b8b96:	bf4c      	ite	mi
   b8b98:	6a03      	ldrmi	r3, [r0, #32]
   b8b9a:	6a23      	ldrpl	r3, [r4, #32]
   b8b9c:	6123      	str	r3, [r4, #16]
      block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
   b8b9e:	6921      	ldr	r1, [r4, #16]
   b8ba0:	68a0      	ldr	r0, [r4, #8]
   b8ba2:	f000 faf2 	bl	b918a <_ZNK9FatVolume17clusterFirstBlockEm>
   b8ba6:	eb09 0100 	add.w	r1, r9, r0
   b8baa:	e7ca      	b.n	b8b42 <_ZN7FatFile4readEPvj+0x4c>
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
   b8bac:	6921      	ldr	r1, [r4, #16]
   b8bae:	465a      	mov	r2, fp
   b8bb0:	f000 faf1 	bl	b9196 <_ZN9FatVolume6fatGetEmPm>
          if (fg < 0) {
   b8bb4:	2800      	cmp	r0, #0
   b8bb6:	db04      	blt.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
          if (fg == 0) {
   b8bb8:	d1f1      	bne.n	b8b9e <_ZN7FatFile4readEPvj+0xa8>
            if (isDir()) {
   b8bba:	7823      	ldrb	r3, [r4, #0]
   b8bbc:	f013 0f70 	tst.w	r3, #112	; 0x70
   b8bc0:	d143      	bne.n	b8c4a <_ZN7FatFile4readEPvj+0x154>
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
   b8bc2:	7863      	ldrb	r3, [r4, #1]
   b8bc4:	f043 0302 	orr.w	r3, r3, #2
   b8bc8:	7063      	strb	r3, [r4, #1]
  return -1;
   b8bca:	f04f 30ff 	mov.w	r0, #4294967295
   b8bce:	e03d      	b.n	b8c4c <_ZN7FatFile4readEPvj+0x156>
      n = 512 - offset;
   b8bd0:	f5ca 7700 	rsb	r7, sl, #512	; 0x200
      if (n > toRead) {
   b8bd4:	42b7      	cmp	r7, r6
    return m_cache.read(blockNumber, options);
   b8bd6:	f04f 0200 	mov.w	r2, #0
   b8bda:	f100 0024 	add.w	r0, r0, #36	; 0x24
   b8bde:	bf28      	it	cs
   b8be0:	4637      	movcs	r7, r6
   b8be2:	f000 faaf 	bl	b9144 <_ZN8FatCache4readEmh>
      if (!pc) {
   b8be6:	2800      	cmp	r0, #0
   b8be8:	d0eb      	beq.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
      memcpy(dst, src, n);
   b8bea:	eb00 010a 	add.w	r1, r0, sl
   b8bee:	463a      	mov	r2, r7
   b8bf0:	4640      	mov	r0, r8
   b8bf2:	f006 f95a 	bl	beeaa <memcpy>
    m_curPosition += n;
   b8bf6:	6963      	ldr	r3, [r4, #20]
   b8bf8:	443b      	add	r3, r7
    dst += n;
   b8bfa:	44b8      	add	r8, r7
    m_curPosition += n;
   b8bfc:	6163      	str	r3, [r4, #20]
    toRead -= n;
   b8bfe:	1bf6      	subs	r6, r6, r7
  while (toRead) {
   b8c00:	e791      	b.n	b8b26 <_ZN7FatFile4readEPvj+0x30>
      if (!isRootFixed()) {
   b8c02:	7822      	ldrb	r2, [r4, #0]
   b8c04:	0692      	lsls	r2, r2, #26
      size_t nb = toRead >> 9;
   b8c06:	ea4f 2a56 	mov.w	sl, r6, lsr #9
      if (!isRootFixed()) {
   b8c0a:	d406      	bmi.n	b8c1a <_ZN7FatFile4readEPvj+0x124>
        uint8_t mb = m_vol->blocksPerCluster() - blockOfCluster;
   b8c0c:	7902      	ldrb	r2, [r0, #4]
   b8c0e:	eba2 0209 	sub.w	r2, r2, r9
        if (mb < nb) {
   b8c12:	b2d2      	uxtb	r2, r2
   b8c14:	4592      	cmp	sl, r2
   b8c16:	bf28      	it	cs
   b8c18:	4692      	movcs	sl, r2
          && block < (m_vol->cacheBlockNumber() + nb)) {
   b8c1a:	4299      	cmp	r1, r3
      n = 512*nb;
   b8c1c:	ea4f 274a 	mov.w	r7, sl, lsl #9
          && block < (m_vol->cacheBlockNumber() + nb)) {
   b8c20:	d208      	bcs.n	b8c34 <_ZN7FatFile4readEPvj+0x13e>
    return m_blockDev->readBlocks(block, dst, nb);
   b8c22:	68a0      	ldr	r0, [r4, #8]
   b8c24:	4653      	mov	r3, sl
   b8c26:	6800      	ldr	r0, [r0, #0]
   b8c28:	4642      	mov	r2, r8
   b8c2a:	f000 fdb7 	bl	b979c <_ZN9SdSpiCard10readBlocksEmPhj>
      if (!m_vol->readBlocks(block, dst, nb)) {
   b8c2e:	2800      	cmp	r0, #0
   b8c30:	d1e1      	bne.n	b8bf6 <_ZN7FatFile4readEPvj+0x100>
   b8c32:	e7c6      	b.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
          && block < (m_vol->cacheBlockNumber() + nb)) {
   b8c34:	4453      	add	r3, sl
   b8c36:	428b      	cmp	r3, r1
   b8c38:	d9f3      	bls.n	b8c22 <_ZN7FatFile4readEPvj+0x12c>
    return m_cache.sync();
   b8c3a:	3024      	adds	r0, #36	; 0x24
   b8c3c:	9101      	str	r1, [sp, #4]
   b8c3e:	f000 fa59 	bl	b90f4 <_ZN8FatCache4syncEv>
        if (!m_vol->cacheSyncData()) {
   b8c42:	9901      	ldr	r1, [sp, #4]
   b8c44:	2800      	cmp	r0, #0
   b8c46:	d1ec      	bne.n	b8c22 <_ZN7FatFile4readEPvj+0x12c>
   b8c48:	e7bb      	b.n	b8bc2 <_ZN7FatFile4readEPvj+0xcc>
  return nbyte - toRead;
   b8c4a:	1ba8      	subs	r0, r5, r6
}
   b8c4c:	b003      	add	sp, #12
   b8c4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000b8c52 <_ZN7FatFile4peekEv>:
int FatFile::peek() {
   b8c52:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return read(&b, 1) == 1 ? b : -1;
   b8c54:	2201      	movs	r2, #1
   b8c56:	f10d 0107 	add.w	r1, sp, #7
  pos->cluster = m_curCluster;
   b8c5a:	e9d0 5604 	ldrd	r5, r6, [r0, #16]
int FatFile::peek() {
   b8c5e:	4604      	mov	r4, r0
   b8c60:	f7ff ff49 	bl	b8af6 <_ZN7FatFile4readEPvj>
   b8c64:	2801      	cmp	r0, #1
   b8c66:	bf0a      	itet	eq
   b8c68:	f89d 0007 	ldrbeq.w	r0, [sp, #7]
   b8c6c:	f04f 30ff 	movne.w	r0, #4294967295
  return false;
}
//------------------------------------------------------------------------------
void FatFile::setpos(FatPos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
   b8c70:	e9c4 5604 	strdeq	r5, r6, [r4, #16]
}
   b8c74:	b002      	add	sp, #8
   b8c76:	bd70      	pop	{r4, r5, r6, pc}

000b8c78 <_ZN7FatFile12readDirCacheEb>:
dir_t* FatFile::readDirCache(bool skipReadOk) {
   b8c78:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
   b8c7a:	6943      	ldr	r3, [r0, #20]
  if (i == 0 || !skipReadOk) {
   b8c7c:	f413 7ff0 	tst.w	r3, #480	; 0x1e0
dir_t* FatFile::readDirCache(bool skipReadOk) {
   b8c80:	4604      	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;
   b8c82:	f3c3 1543 	ubfx	r5, r3, #5, #4
  if (i == 0 || !skipReadOk) {
   b8c86:	d000      	beq.n	b8c8a <_ZN7FatFile12readDirCacheEb+0x12>
   b8c88:	b999      	cbnz	r1, b8cb2 <_ZN7FatFile12readDirCacheEb+0x3a>
    int8_t n = read(&n, 1);
   b8c8a:	2201      	movs	r2, #1
   b8c8c:	f10d 0107 	add.w	r1, sp, #7
   b8c90:	4620      	mov	r0, r4
   b8c92:	f7ff ff30 	bl	b8af6 <_ZN7FatFile4readEPvj>
    if  (n != 1) {
   b8c96:	b240      	sxtb	r0, r0
   b8c98:	2801      	cmp	r0, #1
   b8c9a:	d002      	beq.n	b8ca2 <_ZN7FatFile12readDirCacheEb+0x2a>
  return 0;
   b8c9c:	2000      	movs	r0, #0
}
   b8c9e:	b003      	add	sp, #12
   b8ca0:	bd30      	pop	{r4, r5, pc}
    m_curPosition += 31;
   b8ca2:	6963      	ldr	r3, [r4, #20]
   b8ca4:	331f      	adds	r3, #31
  return m_vol->cacheAddress()->dir + i;
   b8ca6:	68a0      	ldr	r0, [r4, #8]
    m_curPosition += 32;
   b8ca8:	6163      	str	r3, [r4, #20]
  return m_vol->cacheAddress()->dir + i;
   b8caa:	3030      	adds	r0, #48	; 0x30
   b8cac:	eb00 1045 	add.w	r0, r0, r5, lsl #5
   b8cb0:	e7f5      	b.n	b8c9e <_ZN7FatFile12readDirCacheEb+0x26>
    m_curPosition += 32;
   b8cb2:	3320      	adds	r3, #32
   b8cb4:	e7f7      	b.n	b8ca6 <_ZN7FatFile12readDirCacheEb+0x2e>

000b8cb6 <_ZN7FatFile7seekSetEm>:
bool FatFile::seekSet(uint32_t pos) {
   b8cb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return m_attr;
   b8cba:	7802      	ldrb	r2, [r0, #0]
  uint32_t tmp = m_curCluster;
   b8cbc:	6907      	ldr	r7, [r0, #16]
bool FatFile::seekSet(uint32_t pos) {
   b8cbe:	4604      	mov	r4, r0
   b8cc0:	460d      	mov	r5, r1
  if (!isOpen()) {
   b8cc2:	b162      	cbz	r2, b8cde <_ZN7FatFile7seekSetEm+0x28>
  if (pos == m_curPosition) {
   b8cc4:	6940      	ldr	r0, [r0, #20]
   b8cc6:	4288      	cmp	r0, r1
   b8cc8:	d002      	beq.n	b8cd0 <_ZN7FatFile7seekSetEm+0x1a>
  if (pos == 0) {
   b8cca:	b919      	cbnz	r1, b8cd4 <_ZN7FatFile7seekSetEm+0x1e>
    m_curCluster = 0;
   b8ccc:	6121      	str	r1, [r4, #16]
  m_curPosition = pos;
   b8cce:	6165      	str	r5, [r4, #20]
    return true;
   b8cd0:	2001      	movs	r0, #1
   b8cd2:	e006      	b.n	b8ce2 <_ZN7FatFile7seekSetEm+0x2c>
  if (isFile()) {
   b8cd4:	0716      	lsls	r6, r2, #28
   b8cd6:	d506      	bpl.n	b8ce6 <_ZN7FatFile7seekSetEm+0x30>
    if (pos > m_fileSize) {
   b8cd8:	69e3      	ldr	r3, [r4, #28]
   b8cda:	428b      	cmp	r3, r1
   b8cdc:	d20b      	bcs.n	b8cf6 <_ZN7FatFile7seekSetEm+0x40>
  m_curCluster = tmp;
   b8cde:	6127      	str	r7, [r4, #16]
  return false;
   b8ce0:	2000      	movs	r0, #0
}
   b8ce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (isRootFixed()) {
   b8ce6:	0691      	lsls	r1, r2, #26
   b8ce8:	d505      	bpl.n	b8cf6 <_ZN7FatFile7seekSetEm+0x40>
    return m_rootDirEntryCount;
   b8cea:	68a3      	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
   b8cec:	891b      	ldrh	r3, [r3, #8]
   b8cee:	ebb5 1f43 	cmp.w	r5, r3, lsl #5
   b8cf2:	d9ec      	bls.n	b8cce <_ZN7FatFile7seekSetEm+0x18>
   b8cf4:	e7f3      	b.n	b8cde <_ZN7FatFile7seekSetEm+0x28>
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
   b8cf6:	f8d4 c008 	ldr.w	ip, [r4, #8]
   b8cfa:	f89c 6006 	ldrb.w	r6, [ip, #6]
   b8cfe:	1e43      	subs	r3, r0, #1
   b8d00:	f106 0109 	add.w	r1, r6, #9
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
   b8d04:	1e6e      	subs	r6, r5, #1
  nCur = (m_curPosition - 1) >> (m_vol->clusterSizeShift() + 9);
   b8d06:	40cb      	lsrs	r3, r1
  nNew = (pos - 1) >> (m_vol->clusterSizeShift() + 9);
   b8d08:	40ce      	lsrs	r6, r1
  if (nNew < nCur || m_curPosition == 0) {
   b8d0a:	42b3      	cmp	r3, r6
   b8d0c:	d800      	bhi.n	b8d10 <_ZN7FatFile7seekSetEm+0x5a>
   b8d0e:	b998      	cbnz	r0, b8d38 <_ZN7FatFile7seekSetEm+0x82>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
   b8d10:	0653      	lsls	r3, r2, #25
    return m_rootDirStart;
   b8d12:	bf4c      	ite	mi
   b8d14:	f8dc 3020 	ldrmi.w	r3, [ip, #32]
   b8d18:	6a23      	ldrpl	r3, [r4, #32]
   b8d1a:	6123      	str	r3, [r4, #16]
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
   b8d1c:	f104 0810 	add.w	r8, r4, #16
  while (nNew--) {
   b8d20:	2e00      	cmp	r6, #0
   b8d22:	d0d4      	beq.n	b8cce <_ZN7FatFile7seekSetEm+0x18>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
   b8d24:	6921      	ldr	r1, [r4, #16]
   b8d26:	68a0      	ldr	r0, [r4, #8]
   b8d28:	4642      	mov	r2, r8
   b8d2a:	f000 fa34 	bl	b9196 <_ZN9FatVolume6fatGetEmPm>
   b8d2e:	2800      	cmp	r0, #0
   b8d30:	f106 36ff 	add.w	r6, r6, #4294967295
   b8d34:	dcf4      	bgt.n	b8d20 <_ZN7FatFile7seekSetEm+0x6a>
   b8d36:	e7d2      	b.n	b8cde <_ZN7FatFile7seekSetEm+0x28>
    nNew -= nCur;
   b8d38:	1af6      	subs	r6, r6, r3
   b8d3a:	e7ef      	b.n	b8d1c <_ZN7FatFile7seekSetEm+0x66>

000b8d3c <_ZN7FatFile15openCachedEntryEPS_tih>:
                              oflag_t oflag, uint8_t lfnOrd) {
   b8d3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b8d3e:	460f      	mov	r7, r1
   b8d40:	4604      	mov	r4, r0
   b8d42:	4615      	mov	r5, r2
  memset(this, 0, sizeof(FatFile));
   b8d44:	2100      	movs	r1, #0
   b8d46:	2224      	movs	r2, #36	; 0x24
                              oflag_t oflag, uint8_t lfnOrd) {
   b8d48:	461e      	mov	r6, r3
  memset(this, 0, sizeof(FatFile));
   b8d4a:	f006 f8d6 	bl	beefa <memset>
  m_vol = dirFile->m_vol;
   b8d4e:	68b8      	ldr	r0, [r7, #8]
   b8d50:	60a0      	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
   b8d52:	80a5      	strh	r5, [r4, #4]
  dir_t* dir = &m_vol->cacheAddress()->dir[0XF & dirIndex];
   b8d54:	f005 050f 	and.w	r5, r5, #15
  m_dirCluster = dirFile->m_firstCluster;
   b8d58:	6a3b      	ldr	r3, [r7, #32]
   b8d5a:	60e3      	str	r3, [r4, #12]
  return (dir->attributes & DIR_ATT_VOLUME_ID) == 0;
   b8d5c:	016a      	lsls	r2, r5, #5
   b8d5e:	eb00 1545 	add.w	r5, r0, r5, lsl #5
   b8d62:	f895 303b 	ldrb.w	r3, [r5, #59]	; 0x3b
  if (!DIR_IS_FILE_OR_SUBDIR(dir)) {
   b8d66:	071f      	lsls	r7, r3, #28
   b8d68:	d444      	bmi.n	b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>
  m_attr = dir->attributes & FILE_ATTR_COPY;
   b8d6a:	f003 0317 	and.w	r3, r3, #23
   b8d6e:	7023      	strb	r3, [r4, #0]
  if (DIR_IS_FILE(dir)) {
   b8d70:	f895 103b 	ldrb.w	r1, [r5, #59]	; 0x3b
   b8d74:	f011 0f18 	tst.w	r1, #24
    m_attr |= FILE_ATTR_FILE;
   b8d78:	bf04      	itt	eq
   b8d7a:	f043 0308 	orreq.w	r3, r3, #8
   b8d7e:	7023      	strbeq	r3, [r4, #0]
  m_lfnOrd = lfnOrd;
   b8d80:	f89d 3018 	ldrb.w	r3, [sp, #24]
   b8d84:	70e3      	strb	r3, [r4, #3]
  switch (oflag & O_ACCMODE) {
   b8d86:	f006 0303 	and.w	r3, r6, #3
   b8d8a:	2b01      	cmp	r3, #1
   b8d8c:	d02c      	beq.n	b8de8 <_ZN7FatFile15openCachedEntryEPS_tih+0xac>
   b8d8e:	2b02      	cmp	r3, #2
   b8d90:	d028      	beq.n	b8de4 <_ZN7FatFile15openCachedEntryEPS_tih+0xa8>
   b8d92:	bb7b      	cbnz	r3, b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>
      if (oflag & O_TRUNC) {
   b8d94:	0571      	lsls	r1, r6, #21
   b8d96:	d42d      	bmi.n	b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>
      m_flags = F_READ;
   b8d98:	2301      	movs	r3, #1
      m_flags = F_WRITE;
   b8d9a:	70a3      	strb	r3, [r4, #2]
  if (m_flags & F_WRITE) {
   b8d9c:	78a1      	ldrb	r1, [r4, #2]
   b8d9e:	078b      	lsls	r3, r1, #30
   b8da0:	d504      	bpl.n	b8dac <_ZN7FatFile15openCachedEntryEPS_tih+0x70>
    return m_attr & FILE_ATTR_SUBDIR;
   b8da2:	7823      	ldrb	r3, [r4, #0]
    if (isSubDir() || isReadOnly()) {
   b8da4:	06df      	lsls	r7, r3, #27
   b8da6:	d425      	bmi.n	b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>
   b8da8:	07dd      	lsls	r5, r3, #31
   b8daa:	d423      	bmi.n	b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>
  m_flags |= (oflag & O_APPEND ? F_APPEND : 0) | (oflag & O_SYNC ? F_SYNC : 0);
   b8dac:	11b3      	asrs	r3, r6, #6
   b8dae:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   b8db2:	f006 0508 	and.w	r5, r6, #8
   b8db6:	432b      	orrs	r3, r5
   b8db8:	430b      	orrs	r3, r1
   b8dba:	70a3      	strb	r3, [r4, #2]
    return m_lbn;
   b8dbc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  m_dirBlock = m_vol->cacheBlockNumber();
   b8dbe:	61a3      	str	r3, [r4, #24]
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
   b8dc0:	1883      	adds	r3, r0, r2
   b8dc2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
                 | dir->firstClusterLow;
   b8dc6:	f8b3 104a 	ldrh.w	r1, [r3, #74]	; 0x4a
  firstCluster = ((uint32_t)dir->firstClusterHigh << 16)
   b8dca:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  if (oflag & O_TRUNC) {
   b8dce:	0572      	lsls	r2, r6, #21
   b8dd0:	d513      	bpl.n	b8dfa <_ZN7FatFile15openCachedEntryEPS_tih+0xbe>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
   b8dd2:	b959      	cbnz	r1, b8dec <_ZN7FatFile15openCachedEntryEPS_tih+0xb0>
    m_flags |= F_FILE_DIR_DIRTY;
   b8dd4:	78a3      	ldrb	r3, [r4, #2]
   b8dd6:	f043 0304 	orr.w	r3, r3, #4
   b8dda:	70a3      	strb	r3, [r4, #2]
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
   b8ddc:	0473      	lsls	r3, r6, #17
   b8dde:	d410      	bmi.n	b8e02 <_ZN7FatFile15openCachedEntryEPS_tih+0xc6>
  return true;
   b8de0:	2001      	movs	r0, #1
}
   b8de2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      m_flags = F_READ | F_WRITE;
   b8de4:	2303      	movs	r3, #3
   b8de6:	e7d8      	b.n	b8d9a <_ZN7FatFile15openCachedEntryEPS_tih+0x5e>
      m_flags = F_WRITE;
   b8de8:	2302      	movs	r3, #2
   b8dea:	e7d6      	b.n	b8d9a <_ZN7FatFile15openCachedEntryEPS_tih+0x5e>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
   b8dec:	f000 fa73 	bl	b92d6 <_ZN9FatVolume9freeChainEm>
   b8df0:	2800      	cmp	r0, #0
   b8df2:	d1ef      	bne.n	b8dd4 <_ZN7FatFile15openCachedEntryEPS_tih+0x98>
  m_attr = FILE_ATTR_CLOSED;
   b8df4:	2000      	movs	r0, #0
   b8df6:	7020      	strb	r0, [r4, #0]
  return false;
   b8df8:	e7f3      	b.n	b8de2 <_ZN7FatFile15openCachedEntryEPS_tih+0xa6>
    m_firstCluster = firstCluster;
   b8dfa:	6221      	str	r1, [r4, #32]
    m_fileSize = dir->fileSize;
   b8dfc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   b8dfe:	61e3      	str	r3, [r4, #28]
   b8e00:	e7ec      	b.n	b8ddc <_ZN7FatFile15openCachedEntryEPS_tih+0xa0>
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
   b8e02:	69e1      	ldr	r1, [r4, #28]
   b8e04:	4620      	mov	r0, r4
   b8e06:	f7ff ff56 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
   b8e0a:	2800      	cmp	r0, #0
   b8e0c:	d1e8      	bne.n	b8de0 <_ZN7FatFile15openCachedEntryEPS_tih+0xa4>
   b8e0e:	e7f1      	b.n	b8df4 <_ZN7FatFile15openCachedEntryEPS_tih+0xb8>

000b8e10 <_ZN7FatFile4syncEv>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
   b8e10:	b538      	push	{r3, r4, r5, lr}
  if (!isOpen()) {
   b8e12:	7803      	ldrb	r3, [r0, #0]
bool FatFile::sync() {
   b8e14:	4604      	mov	r4, r0
  if (!isOpen()) {
   b8e16:	b90b      	cbnz	r3, b8e1c <_ZN7FatFile4syncEv+0xc>
    return true;
   b8e18:	2001      	movs	r0, #1
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
  return false;
}
   b8e1a:	bd38      	pop	{r3, r4, r5, pc}
  if (m_flags & F_FILE_DIR_DIRTY) {
   b8e1c:	7883      	ldrb	r3, [r0, #2]
   b8e1e:	075a      	lsls	r2, r3, #29
   b8e20:	d523      	bpl.n	b8e6a <_ZN7FatFile4syncEv+0x5a>
    dir_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
   b8e22:	2101      	movs	r1, #1
   b8e24:	f7ff fe52 	bl	b8acc <_ZN7FatFile13cacheDirEntryEh>
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
   b8e28:	4605      	mov	r5, r0
   b8e2a:	b928      	cbnz	r0, b8e38 <_ZN7FatFile4syncEv+0x28>
  m_error |= WRITE_ERROR;
   b8e2c:	7863      	ldrb	r3, [r4, #1]
   b8e2e:	f043 0301 	orr.w	r3, r3, #1
   b8e32:	7063      	strb	r3, [r4, #1]
  return false;
   b8e34:	2000      	movs	r0, #0
   b8e36:	e7f0      	b.n	b8e1a <_ZN7FatFile4syncEv+0xa>
    if (!dir || dir->name[0] == DIR_NAME_DELETED) {
   b8e38:	7803      	ldrb	r3, [r0, #0]
   b8e3a:	2be5      	cmp	r3, #229	; 0xe5
   b8e3c:	d0f6      	beq.n	b8e2c <_ZN7FatFile4syncEv+0x1c>
    if (isFile()) {
   b8e3e:	7823      	ldrb	r3, [r4, #0]
   b8e40:	071b      	lsls	r3, r3, #28
      dir->fileSize = m_fileSize;
   b8e42:	bf44      	itt	mi
   b8e44:	69e3      	ldrmi	r3, [r4, #28]
   b8e46:	61c3      	strmi	r3, [r0, #28]
    dir->firstClusterLow = m_firstCluster & 0XFFFF;
   b8e48:	6a23      	ldr	r3, [r4, #32]
   b8e4a:	8343      	strh	r3, [r0, #26]
    dir->firstClusterHigh = m_firstCluster >> 16;
   b8e4c:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   b8e4e:	8283      	strh	r3, [r0, #20]
    if (m_dateTime) {
   b8e50:	4b09      	ldr	r3, [pc, #36]	; (b8e78 <_ZN7FatFile4syncEv+0x68>)
   b8e52:	681b      	ldr	r3, [r3, #0]
   b8e54:	b12b      	cbz	r3, b8e62 <_ZN7FatFile4syncEv+0x52>
      m_dateTime(&dir->lastWriteDate, &dir->lastWriteTime);
   b8e56:	f100 0116 	add.w	r1, r0, #22
   b8e5a:	3018      	adds	r0, #24
   b8e5c:	4798      	blx	r3
      dir->lastAccessDate = dir->lastWriteDate;
   b8e5e:	8b2b      	ldrh	r3, [r5, #24]
   b8e60:	826b      	strh	r3, [r5, #18]
    m_flags &= ~F_FILE_DIR_DIRTY;
   b8e62:	78a3      	ldrb	r3, [r4, #2]
   b8e64:	f023 0304 	bic.w	r3, r3, #4
   b8e68:	70a3      	strb	r3, [r4, #2]
  if (m_vol->cacheSync()) {
   b8e6a:	68a0      	ldr	r0, [r4, #8]
   b8e6c:	f7ff fa50 	bl	b8310 <_ZN9FatVolume9cacheSyncEv>
   b8e70:	2800      	cmp	r0, #0
   b8e72:	d0db      	beq.n	b8e2c <_ZN7FatFile4syncEv+0x1c>
   b8e74:	e7d0      	b.n	b8e18 <_ZN7FatFile4syncEv+0x8>
   b8e76:	bf00      	nop
   b8e78:	2003e648 	.word	0x2003e648

000b8e7c <_ZN7FatFile5closeEv>:
bool FatFile::close() {
   b8e7c:	b510      	push	{r4, lr}
   b8e7e:	4604      	mov	r4, r0
  bool rtn = sync();
   b8e80:	f7ff ffc6 	bl	b8e10 <_ZN7FatFile4syncEv>
  m_attr = FILE_ATTR_CLOSED;
   b8e84:	2300      	movs	r3, #0
   b8e86:	7023      	strb	r3, [r4, #0]
}
   b8e88:	bd10      	pop	{r4, pc}

000b8e8a <_ZN7FatFile4openEPS_PKci>:
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
   b8e8a:	b5f0      	push	{r4, r5, r6, r7, lr}
   b8e8c:	b093      	sub	sp, #76	; 0x4c
   b8e8e:	461f      	mov	r7, r3
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b8e90:	2300      	movs	r3, #0
   b8e92:	9309      	str	r3, [sp, #36]	; 0x24
  if (isOpen() || !dirFile->isDir()) {
   b8e94:	7803      	ldrb	r3, [r0, #0]
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
   b8e96:	9201      	str	r2, [sp, #4]
   b8e98:	4606      	mov	r6, r0
   b8e9a:	460c      	mov	r4, r1
  if (isOpen() || !dirFile->isDir()) {
   b8e9c:	b113      	cbz	r3, b8ea4 <_ZN7FatFile4openEPS_PKci+0x1a>
  return false;
   b8e9e:	2000      	movs	r0, #0
}
   b8ea0:	b013      	add	sp, #76	; 0x4c
   b8ea2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (isOpen() || !dirFile->isDir()) {
   b8ea4:	780b      	ldrb	r3, [r1, #0]
   b8ea6:	f013 0f70 	tst.w	r3, #112	; 0x70
   b8eaa:	d0f8      	beq.n	b8e9e <_ZN7FatFile4openEPS_PKci+0x14>
  if (isDirSeparator(*path)) {
   b8eac:	7813      	ldrb	r3, [r2, #0]
   b8eae:	2b2f      	cmp	r3, #47	; 0x2f
   b8eb0:	d112      	bne.n	b8ed8 <_ZN7FatFile4openEPS_PKci+0x4e>
    while (isDirSeparator(*path)) {
   b8eb2:	9a01      	ldr	r2, [sp, #4]
   b8eb4:	7813      	ldrb	r3, [r2, #0]
   b8eb6:	2b2f      	cmp	r3, #47	; 0x2f
   b8eb8:	d102      	bne.n	b8ec0 <_ZN7FatFile4openEPS_PKci+0x36>
      path++;
   b8eba:	3201      	adds	r2, #1
   b8ebc:	9201      	str	r2, [sp, #4]
    while (isDirSeparator(*path)) {
   b8ebe:	e7f8      	b.n	b8eb2 <_ZN7FatFile4openEPS_PKci+0x28>
      return openRoot(dirFile->m_vol);
   b8ec0:	68a1      	ldr	r1, [r4, #8]
    if (*path == 0) {
   b8ec2:	b91b      	cbnz	r3, b8ecc <_ZN7FatFile4openEPS_PKci+0x42>
      return openRoot(dirFile->m_vol);
   b8ec4:	4630      	mov	r0, r6
   b8ec6:	f7ff fe10 	bl	b8aea <_ZN7FatFile8openRootEP9FatVolume>
   b8eca:	e7e9      	b.n	b8ea0 <_ZN7FatFile4openEPS_PKci+0x16>
    return m_attr;
   b8ecc:	a809      	add	r0, sp, #36	; 0x24
   b8ece:	f7ff fd9f 	bl	b8a10 <_ZN7FatFile8openRootEP9FatVolume.part.0>
    if (!tmpDir.openRoot(dirFile->m_vol)) {
   b8ed2:	2800      	cmp	r0, #0
   b8ed4:	d0e3      	beq.n	b8e9e <_ZN7FatFile4openEPS_PKci+0x14>
    dirFile = &tmpDir;
   b8ed6:	ac09      	add	r4, sp, #36	; 0x24
    if (!parsePathName(path, &fname, &path)) {
   b8ed8:	9801      	ldr	r0, [sp, #4]
   b8eda:	aa01      	add	r2, sp, #4
   b8edc:	a903      	add	r1, sp, #12
   b8ede:	f7ff fa4b 	bl	b8378 <_ZN7FatFile13parsePathNameEPKcP7fname_tPS1_>
   b8ee2:	2800      	cmp	r0, #0
   b8ee4:	d0db      	beq.n	b8e9e <_ZN7FatFile4openEPS_PKci+0x14>
    if (*path == 0) {
   b8ee6:	9b01      	ldr	r3, [sp, #4]
   b8ee8:	781b      	ldrb	r3, [r3, #0]
   b8eea:	b19b      	cbz	r3, b8f14 <_ZN7FatFile4openEPS_PKci+0x8a>
    if (!open(dirFile, &fname, O_RDONLY)) {
   b8eec:	2300      	movs	r3, #0
   b8eee:	aa03      	add	r2, sp, #12
   b8ef0:	4621      	mov	r1, r4
   b8ef2:	4630      	mov	r0, r6
   b8ef4:	f7ff fbd4 	bl	b86a0 <_ZN7FatFile4openEPS_P7fname_ti>
   b8ef8:	2800      	cmp	r0, #0
   b8efa:	d0d0      	beq.n	b8e9e <_ZN7FatFile4openEPS_PKci+0x14>
    tmpDir = *this;
   b8efc:	4635      	mov	r5, r6
   b8efe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   b8f00:	ac09      	add	r4, sp, #36	; 0x24
   b8f02:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   b8f04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   b8f06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   b8f08:	682b      	ldr	r3, [r5, #0]
   b8f0a:	6023      	str	r3, [r4, #0]
    close();
   b8f0c:	4630      	mov	r0, r6
   b8f0e:	f7ff ffb5 	bl	b8e7c <_ZN7FatFile5closeEv>
  while (1) {
   b8f12:	e7e0      	b.n	b8ed6 <_ZN7FatFile4openEPS_PKci+0x4c>
  return open(dirFile, &fname, oflag);
   b8f14:	463b      	mov	r3, r7
   b8f16:	aa03      	add	r2, sp, #12
   b8f18:	4621      	mov	r1, r4
   b8f1a:	4630      	mov	r0, r6
   b8f1c:	f7ff fbc0 	bl	b86a0 <_ZN7FatFile4openEPS_P7fname_ti>
   b8f20:	e7be      	b.n	b8ea0 <_ZN7FatFile4openEPS_PKci+0x16>

000b8f22 <_ZN7FatFile6removeEPS_PKc>:
bool FatFile::remove(FatFile* dirFile, const char* path) {
   b8f22:	b500      	push	{lr}
   b8f24:	b08b      	sub	sp, #44	; 0x2c
  FatFile() : m_attr(FILE_ATTR_CLOSED), m_error(0) {}
   b8f26:	2300      	movs	r3, #0
   b8f28:	460a      	mov	r2, r1
   b8f2a:	9301      	str	r3, [sp, #4]
  if (!file.open(dirFile, path, O_WRONLY)) {
   b8f2c:	4601      	mov	r1, r0
   b8f2e:	2301      	movs	r3, #1
   b8f30:	a801      	add	r0, sp, #4
   b8f32:	f7ff ffaa 	bl	b8e8a <_ZN7FatFile4openEPS_PKci>
   b8f36:	b110      	cbz	r0, b8f3e <_ZN7FatFile6removeEPS_PKc+0x1c>
  return file.remove();
   b8f38:	a801      	add	r0, sp, #4
   b8f3a:	f7ff fafb 	bl	b8534 <_ZN7FatFile6removeEv>
}
   b8f3e:	b00b      	add	sp, #44	; 0x2c
   b8f40:	f85d fb04 	ldr.w	pc, [sp], #4

000b8f44 <_ZN7FatFile5writeEPKvj>:

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::write(const void* buf, size_t nbyte) {
   b8f44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isFile() || !(m_flags & F_WRITE)) {
   b8f48:	7803      	ldrb	r3, [r0, #0]
int FatFile::write(const void* buf, size_t nbyte) {
   b8f4a:	4689      	mov	r9, r1
  if (!isFile() || !(m_flags & F_WRITE)) {
   b8f4c:	0719      	lsls	r1, r3, #28
int FatFile::write(const void* buf, size_t nbyte) {
   b8f4e:	4604      	mov	r4, r0
   b8f50:	4617      	mov	r7, r2
  if (!isFile() || !(m_flags & F_WRITE)) {
   b8f52:	d55b      	bpl.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
   b8f54:	7883      	ldrb	r3, [r0, #2]
   b8f56:	079a      	lsls	r2, r3, #30
   b8f58:	d558      	bpl.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & F_APPEND)) {
   b8f5a:	071b      	lsls	r3, r3, #28
   b8f5c:	d451      	bmi.n	b9002 <_ZN7FatFile5writeEPKvj+0xbe>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
   b8f5e:	6963      	ldr	r3, [r4, #20]
   b8f60:	43db      	mvns	r3, r3
   b8f62:	42bb      	cmp	r3, r7
   b8f64:	d352      	bcc.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
   b8f66:	46b8      	mov	r8, r7
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
    uint16_t blockOffset = m_curPosition & 0X1FF;
    if (blockOfCluster == 0 && blockOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
   b8f68:	f104 0a10 	add.w	sl, r4, #16
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
   b8f6c:	6966      	ldr	r6, [r4, #20]
  while (nToWrite) {
   b8f6e:	f1b8 0f00 	cmp.w	r8, #0
   b8f72:	f000 8091 	beq.w	b9098 <_ZN7FatFile5writeEPKvj+0x154>
    uint8_t blockOfCluster = m_vol->blockOfCluster(m_curPosition);
   b8f76:	68a0      	ldr	r0, [r4, #8]
    return (position >> 9) & m_clusterBlockMask;
   b8f78:	7943      	ldrb	r3, [r0, #5]
    uint16_t blockOffset = m_curPosition & 0X1FF;
   b8f7a:	f3c6 0508 	ubfx	r5, r6, #0, #9
    if (blockOfCluster == 0 && blockOffset == 0) {
   b8f7e:	ea13 2656 	ands.w	r6, r3, r6, lsr #9
   b8f82:	d10e      	bne.n	b8fa2 <_ZN7FatFile5writeEPKvj+0x5e>
   b8f84:	b96d      	cbnz	r5, b8fa2 <_ZN7FatFile5writeEPKvj+0x5e>
      if (m_curCluster != 0) {
   b8f86:	6921      	ldr	r1, [r4, #16]
   b8f88:	2900      	cmp	r1, #0
   b8f8a:	d046      	beq.n	b901a <_ZN7FatFile5writeEPKvj+0xd6>
        int8_t fg = m_vol->fatGet(m_curCluster, &m_curCluster);
   b8f8c:	4652      	mov	r2, sl
   b8f8e:	f000 f902 	bl	b9196 <_ZN9FatVolume6fatGetEmPm>
        if (fg < 0) {
   b8f92:	2800      	cmp	r0, #0
   b8f94:	db3a      	blt.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
   b8f96:	d104      	bne.n	b8fa2 <_ZN7FatFile5writeEPKvj+0x5e>
          // add cluster if at end of chain
          if (!addCluster()) {
   b8f98:	4620      	mov	r0, r4
   b8f9a:	f7ff fd4f 	bl	b8a3c <_ZN7FatFile10addClusterEv>
   b8f9e:	2800      	cmp	r0, #0
   b8fa0:	d034      	beq.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // block for data write
    uint32_t block = m_vol->clusterFirstBlock(m_curCluster) + blockOfCluster;
   b8fa2:	6921      	ldr	r1, [r4, #16]
   b8fa4:	68a0      	ldr	r0, [r4, #8]
   b8fa6:	f000 f8f0 	bl	b918a <_ZNK9FatVolume17clusterFirstBlockEm>
   b8faa:	1831      	adds	r1, r6, r0

    if (blockOffset != 0 || nToWrite < 512) {
   b8fac:	68a0      	ldr	r0, [r4, #8]
   b8fae:	b915      	cbnz	r5, b8fb6 <_ZN7FatFile5writeEPKvj+0x72>
   b8fb0:	f5b8 7f00 	cmp.w	r8, #512	; 0x200
   b8fb4:	d23f      	bcs.n	b9036 <_ZN7FatFile5writeEPKvj+0xf2>
      // partial block - must use cache
      // max space in block
      n = 512 - blockOffset;
   b8fb6:	f5c5 7600 	rsb	r6, r5, #512	; 0x200
      // lesser of space and amount to write
      if (n > nToWrite) {
   b8fba:	4546      	cmp	r6, r8
   b8fbc:	bf28      	it	cs
   b8fbe:	4646      	movcs	r6, r8
        n = nToWrite;
      }

      if (blockOffset == 0 && m_curPosition >= m_fileSize) {
   b8fc0:	2d00      	cmp	r5, #0
   b8fc2:	d136      	bne.n	b9032 <_ZN7FatFile5writeEPKvj+0xee>
   b8fc4:	6962      	ldr	r2, [r4, #20]
   b8fc6:	69e3      	ldr	r3, [r4, #28]
        // start of new block don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
   b8fc8:	429a      	cmp	r2, r3
   b8fca:	bf34      	ite	cc
   b8fcc:	2201      	movcc	r2, #1
   b8fce:	2205      	movcs	r2, #5
    return m_cache.read(blockNumber, options);
   b8fd0:	3024      	adds	r0, #36	; 0x24
   b8fd2:	f000 f8b7 	bl	b9144 <_ZN8FatCache4readEmh>
      } else {
        // rewrite part of block
        cacheOption = FatCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(block, cacheOption);
      if (!pc) {
   b8fd6:	b1c8      	cbz	r0, b900c <_ZN7FatFile5writeEPKvj+0xc8>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + blockOffset;
      memcpy(dst, src, n);
   b8fd8:	4428      	add	r0, r5
   b8fda:	4632      	mov	r2, r6
   b8fdc:	4649      	mov	r1, r9
      if (512 == (n + blockOffset)) {
   b8fde:	4435      	add	r5, r6
      memcpy(dst, src, n);
   b8fe0:	f005 ff63 	bl	beeaa <memcpy>
      if (512 == (n + blockOffset)) {
   b8fe4:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
   b8fe8:	d104      	bne.n	b8ff4 <_ZN7FatFile5writeEPKvj+0xb0>
    return m_cache.sync();
   b8fea:	68a0      	ldr	r0, [r4, #8]
   b8fec:	3024      	adds	r0, #36	; 0x24
   b8fee:	f000 f881 	bl	b90f4 <_ZN8FatCache4syncEv>
      if (m_vol->cacheBlockNumber() <= block
          && block < (m_vol->cacheBlockNumber() + nb)) {
        // invalidate cache if block is in cache
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeBlocks(block, src, nb)) {
   b8ff2:	b158      	cbz	r0, b900c <_ZN7FatFile5writeEPKvj+0xc8>
      if (!m_vol->writeBlock(block, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
   b8ff4:	6963      	ldr	r3, [r4, #20]
   b8ff6:	4433      	add	r3, r6
   b8ff8:	6163      	str	r3, [r4, #20]
    src += n;
   b8ffa:	44b1      	add	r9, r6
    nToWrite -= n;
   b8ffc:	eba8 0806 	sub.w	r8, r8, r6
  while (nToWrite) {
   b9000:	e7b4      	b.n	b8f6c <_ZN7FatFile5writeEPKvj+0x28>
    if (!seekSet(m_fileSize)) {
   b9002:	69c1      	ldr	r1, [r0, #28]
   b9004:	f7ff fe57 	bl	b8cb6 <_ZN7FatFile7seekSetEm>
   b9008:	2800      	cmp	r0, #0
   b900a:	d1a8      	bne.n	b8f5e <_ZN7FatFile5writeEPKvj+0x1a>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
   b900c:	7863      	ldrb	r3, [r4, #1]
   b900e:	f043 0301 	orr.w	r3, r3, #1
   b9012:	7063      	strb	r3, [r4, #1]
  return -1;
   b9014:	f04f 30ff 	mov.w	r0, #4294967295
   b9018:	e050      	b.n	b90bc <_ZN7FatFile5writeEPKvj+0x178>
        if (m_firstCluster == 0) {
   b901a:	6a23      	ldr	r3, [r4, #32]
   b901c:	b93b      	cbnz	r3, b902e <_ZN7FatFile5writeEPKvj+0xea>
          if (!addCluster()) {
   b901e:	4620      	mov	r0, r4
   b9020:	f7ff fd0c 	bl	b8a3c <_ZN7FatFile10addClusterEv>
   b9024:	2800      	cmp	r0, #0
   b9026:	d0f1      	beq.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
          m_firstCluster = m_curCluster;
   b9028:	6923      	ldr	r3, [r4, #16]
   b902a:	6223      	str	r3, [r4, #32]
   b902c:	e7b9      	b.n	b8fa2 <_ZN7FatFile5writeEPKvj+0x5e>
          m_curCluster = m_firstCluster;
   b902e:	6123      	str	r3, [r4, #16]
   b9030:	e7b7      	b.n	b8fa2 <_ZN7FatFile5writeEPKvj+0x5e>
        cacheOption = FatCache::CACHE_FOR_WRITE;
   b9032:	2201      	movs	r2, #1
   b9034:	e7cc      	b.n	b8fd0 <_ZN7FatFile5writeEPKvj+0x8c>
    } else if (nToWrite >= 1024) {
   b9036:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
    return m_lbn;
   b903a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   b903c:	d31b      	bcc.n	b9076 <_ZN7FatFile5writeEPKvj+0x132>
      uint8_t maxBlocks = m_vol->blocksPerCluster() - blockOfCluster;
   b903e:	f890 c004 	ldrb.w	ip, [r0, #4]
   b9042:	ebac 0606 	sub.w	r6, ip, r6
      if (nb > maxBlocks) {
   b9046:	b2f3      	uxtb	r3, r6
      size_t nb = nToWrite >> 9;
   b9048:	ea4f 2e58 	mov.w	lr, r8, lsr #9
      if (nb > maxBlocks) {
   b904c:	4573      	cmp	r3, lr
   b904e:	bf28      	it	cs
   b9050:	4673      	movcs	r3, lr
          && block < (m_vol->cacheBlockNumber() + nb)) {
   b9052:	4291      	cmp	r1, r2
      n = 512*nb;
   b9054:	ea4f 2643 	mov.w	r6, r3, lsl #9
          && block < (m_vol->cacheBlockNumber() + nb)) {
   b9058:	d307      	bcc.n	b906a <_ZN7FatFile5writeEPKvj+0x126>
   b905a:	441a      	add	r2, r3
   b905c:	428a      	cmp	r2, r1
    m_lbn = 0XFFFFFFFF;
   b905e:	bf82      	ittt	hi
   b9060:	f04f 32ff 	movhi.w	r2, #4294967295
    m_status = 0;
   b9064:	f880 5024 	strbhi.w	r5, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
   b9068:	62c2      	strhi	r2, [r0, #44]	; 0x2c
    return m_blockDev->writeBlocks(block, src, nb);
   b906a:	68a5      	ldr	r5, [r4, #8]
   b906c:	464a      	mov	r2, r9
   b906e:	6828      	ldr	r0, [r5, #0]
   b9070:	f000 fc4b 	bl	b990a <_ZN9SdSpiCard11writeBlocksEmPKhj>
   b9074:	e7bd      	b.n	b8ff2 <_ZN7FatFile5writeEPKvj+0xae>
      if (m_vol->cacheBlockNumber() == block) {
   b9076:	4291      	cmp	r1, r2
    m_lbn = 0XFFFFFFFF;
   b9078:	bf02      	ittt	eq
   b907a:	f04f 33ff 	moveq.w	r3, #4294967295
    m_status = 0;
   b907e:	f880 5024 	strbeq.w	r5, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
   b9082:	62c3      	streq	r3, [r0, #44]	; 0x2c
    return m_blockDev->writeBlock(block, src);
   b9084:	68a3      	ldr	r3, [r4, #8]
   b9086:	464a      	mov	r2, r9
   b9088:	6818      	ldr	r0, [r3, #0]
   b908a:	f000 fbc8 	bl	b981e <_ZN9SdSpiCard10writeBlockEmPKh>
      if (!m_vol->writeBlock(block, src)) {
   b908e:	2800      	cmp	r0, #0
   b9090:	d0bc      	beq.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
      n = 512;
   b9092:	f44f 7600 	mov.w	r6, #512	; 0x200
   b9096:	e7ad      	b.n	b8ff4 <_ZN7FatFile5writeEPKvj+0xb0>
  if (m_curPosition > m_fileSize) {
   b9098:	69e2      	ldr	r2, [r4, #28]
    m_flags |= F_FILE_DIR_DIRTY;
   b909a:	78a3      	ldrb	r3, [r4, #2]
  if (m_curPosition > m_fileSize) {
   b909c:	42b2      	cmp	r2, r6
   b909e:	d204      	bcs.n	b90aa <_ZN7FatFile5writeEPKvj+0x166>
    m_fileSize = m_curPosition;
   b90a0:	61e6      	str	r6, [r4, #28]
    m_flags |= F_FILE_DIR_DIRTY;
   b90a2:	f043 0304 	orr.w	r3, r3, #4
   b90a6:	70a3      	strb	r3, [r4, #2]
   b90a8:	e003      	b.n	b90b2 <_ZN7FatFile5writeEPKvj+0x16e>
  } else if (m_dateTime) {
   b90aa:	4a08      	ldr	r2, [pc, #32]	; (b90cc <_ZN7FatFile5writeEPKvj+0x188>)
   b90ac:	6812      	ldr	r2, [r2, #0]
   b90ae:	2a00      	cmp	r2, #0
   b90b0:	d1f7      	bne.n	b90a2 <_ZN7FatFile5writeEPKvj+0x15e>
  if (m_flags & F_SYNC) {
   b90b2:	f994 3002 	ldrsb.w	r3, [r4, #2]
   b90b6:	2b00      	cmp	r3, #0
   b90b8:	db02      	blt.n	b90c0 <_ZN7FatFile5writeEPKvj+0x17c>
  return nbyte;
   b90ba:	4638      	mov	r0, r7
}
   b90bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!sync()) {
   b90c0:	4620      	mov	r0, r4
   b90c2:	f7ff fea5 	bl	b8e10 <_ZN7FatFile4syncEv>
   b90c6:	2800      	cmp	r0, #0
   b90c8:	d1f7      	bne.n	b90ba <_ZN7FatFile5writeEPKvj+0x176>
   b90ca:	e79f      	b.n	b900c <_ZN7FatFile5writeEPKvj+0xc8>
   b90cc:	2003e648 	.word	0x2003e648

000b90d0 <_ZN5Print5writeEPKc>:
    size_t write(const char *str) {
   b90d0:	b513      	push	{r0, r1, r4, lr}
   b90d2:	4604      	mov	r4, r0
    }
   b90d4:	4608      	mov	r0, r1
      if (str == NULL) return 0;
   b90d6:	b159      	cbz	r1, b90f0 <_ZN5Print5writeEPKc+0x20>
      return write((const uint8_t *)str, strlen(str));
   b90d8:	9101      	str	r1, [sp, #4]
   b90da:	f005 ff84 	bl	befe6 <strlen>
   b90de:	6823      	ldr	r3, [r4, #0]
   b90e0:	9901      	ldr	r1, [sp, #4]
   b90e2:	68db      	ldr	r3, [r3, #12]
   b90e4:	4602      	mov	r2, r0
   b90e6:	4620      	mov	r0, r4
    }
   b90e8:	b002      	add	sp, #8
   b90ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return write((const uint8_t *)str, strlen(str));
   b90ee:	4718      	bx	r3
    }
   b90f0:	b002      	add	sp, #8
   b90f2:	bd10      	pop	{r4, pc}

000b90f4 <_ZN8FatCache4syncEv>:
fail:

  return 0;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
   b90f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
   b90f6:	7803      	ldrb	r3, [r0, #0]
   b90f8:	07da      	lsls	r2, r3, #31
bool FatCache::sync() {
   b90fa:	4604      	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
   b90fc:	d520      	bpl.n	b9140 <_ZN8FatCache4syncEv+0x4c>
   b90fe:	6843      	ldr	r3, [r0, #4]
   b9100:	6881      	ldr	r1, [r0, #8]
    if (!m_vol->writeBlock(m_lbn, m_block.data)) {
   b9102:	f100 020c 	add.w	r2, r0, #12
   b9106:	6818      	ldr	r0, [r3, #0]
   b9108:	9201      	str	r2, [sp, #4]
   b910a:	f000 fb88 	bl	b981e <_ZN9SdSpiCard10writeBlockEmPKh>
   b910e:	9a01      	ldr	r2, [sp, #4]
   b9110:	4605      	mov	r5, r0
   b9112:	b918      	cbnz	r0, b911c <_ZN8FatCache4syncEv+0x28>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

fail:
  return false;
   b9114:	2500      	movs	r5, #0
}
   b9116:	4628      	mov	r0, r5
   b9118:	b003      	add	sp, #12
   b911a:	bd30      	pop	{r4, r5, pc}
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
   b911c:	7823      	ldrb	r3, [r4, #0]
   b911e:	079b      	lsls	r3, r3, #30
   b9120:	d404      	bmi.n	b912c <_ZN8FatCache4syncEv+0x38>
    m_status &= ~CACHE_STATUS_DIRTY;
   b9122:	7823      	ldrb	r3, [r4, #0]
   b9124:	f023 0301 	bic.w	r3, r3, #1
   b9128:	7023      	strb	r3, [r4, #0]
   b912a:	e7f4      	b.n	b9116 <_ZN8FatCache4syncEv+0x22>
      uint32_t lbn = m_lbn + m_vol->blocksPerFat();
   b912c:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
   b9130:	6919      	ldr	r1, [r3, #16]
   b9132:	4401      	add	r1, r0
   b9134:	6818      	ldr	r0, [r3, #0]
   b9136:	f000 fb72 	bl	b981e <_ZN9SdSpiCard10writeBlockEmPKh>
      if (!m_vol->writeBlock(lbn, m_block.data)) {
   b913a:	2800      	cmp	r0, #0
   b913c:	d1f1      	bne.n	b9122 <_ZN8FatCache4syncEv+0x2e>
   b913e:	e7e9      	b.n	b9114 <_ZN8FatCache4syncEv+0x20>
  return true;
   b9140:	2501      	movs	r5, #1
   b9142:	e7e8      	b.n	b9116 <_ZN8FatCache4syncEv+0x22>

000b9144 <_ZN8FatCache4readEmh>:
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
   b9144:	b570      	push	{r4, r5, r6, lr}
  if (m_lbn != lbn) {
   b9146:	6883      	ldr	r3, [r0, #8]
   b9148:	428b      	cmp	r3, r1
cache_t* FatCache::read(uint32_t lbn, uint8_t option) {
   b914a:	4604      	mov	r4, r0
   b914c:	460e      	mov	r6, r1
   b914e:	4615      	mov	r5, r2
  if (m_lbn != lbn) {
   b9150:	d009      	beq.n	b9166 <_ZN8FatCache4readEmh+0x22>
    if (!sync()) {
   b9152:	f7ff ffcf 	bl	b90f4 <_ZN8FatCache4syncEv>
   b9156:	b908      	cbnz	r0, b915c <_ZN8FatCache4readEmh+0x18>
  return 0;
   b9158:	2000      	movs	r0, #0
}
   b915a:	bd70      	pop	{r4, r5, r6, pc}
    if (!(option & CACHE_OPTION_NO_READ)) {
   b915c:	076b      	lsls	r3, r5, #29
   b915e:	d50a      	bpl.n	b9176 <_ZN8FatCache4readEmh+0x32>
    m_status = 0;
   b9160:	2300      	movs	r3, #0
   b9162:	7023      	strb	r3, [r4, #0]
    m_lbn = lbn;
   b9164:	60a6      	str	r6, [r4, #8]
  m_status |= option & CACHE_STATUS_MASK;
   b9166:	7822      	ldrb	r2, [r4, #0]
   b9168:	f005 0503 	and.w	r5, r5, #3
   b916c:	4620      	mov	r0, r4
   b916e:	4315      	orrs	r5, r2
   b9170:	f800 5b0c 	strb.w	r5, [r0], #12
  return &m_block;
   b9174:	e7f1      	b.n	b915a <_ZN8FatCache4readEmh+0x16>
    return m_blockDev->readBlock(block, dst);
   b9176:	6863      	ldr	r3, [r4, #4]
   b9178:	f104 020c 	add.w	r2, r4, #12
   b917c:	6818      	ldr	r0, [r3, #0]
   b917e:	4631      	mov	r1, r6
   b9180:	f000 fac4 	bl	b970c <_ZN9SdSpiCard9readBlockEmPh>
      if (!m_vol->readBlock(lbn, m_block.data)) {
   b9184:	2800      	cmp	r0, #0
   b9186:	d1eb      	bne.n	b9160 <_ZN8FatCache4readEmh+0x1c>
   b9188:	e7e6      	b.n	b9158 <_ZN8FatCache4readEmh+0x14>

000b918a <_ZNK9FatVolume17clusterFirstBlockEm>:
fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t FatVolume::clusterFirstBlock(uint32_t cluster) const {
  return m_dataStartBlock + ((cluster - 2) << m_clusterSizeShift);
   b918a:	7983      	ldrb	r3, [r0, #6]
   b918c:	6940      	ldr	r0, [r0, #20]
   b918e:	3902      	subs	r1, #2
   b9190:	4099      	lsls	r1, r3
}
   b9192:	4408      	add	r0, r1
   b9194:	4770      	bx	lr

000b9196 <_ZN9FatVolume6fatGetEmPm>:
  uint32_t lba;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
   b9196:	2901      	cmp	r1, #1
int8_t FatVolume::fatGet(uint32_t cluster, uint32_t* value) {
   b9198:	b570      	push	{r4, r5, r6, lr}
   b919a:	4605      	mov	r5, r0
   b919c:	460c      	mov	r4, r1
   b919e:	4616      	mov	r6, r2
  if (cluster < 2 || cluster > m_lastCluster) {
   b91a0:	d802      	bhi.n	b91a8 <_ZN9FatVolume6fatGetEmPm+0x12>
  }
  *value = next;
  return 1;

fail:
  return -1;
   b91a2:	f04f 30ff 	mov.w	r0, #4294967295
}
   b91a6:	bd70      	pop	{r4, r5, r6, pc}
  if (cluster < 2 || cluster > m_lastCluster) {
   b91a8:	69c3      	ldr	r3, [r0, #28]
   b91aa:	428b      	cmp	r3, r1
   b91ac:	d3f9      	bcc.n	b91a2 <_ZN9FatVolume6fatGetEmPm+0xc>
    return m_fatType;
   b91ae:	79c3      	ldrb	r3, [r0, #7]
  if (fatType() == 32) {
   b91b0:	2b20      	cmp	r3, #32
   b91b2:	d116      	bne.n	b91e2 <_ZN9FatVolume6fatGetEmPm+0x4c>
    lba = m_fatStartBlock + (cluster >> 7);
   b91b4:	6981      	ldr	r1, [r0, #24]
    return m_fatCache.read(blockNumber,
   b91b6:	2202      	movs	r2, #2
   b91b8:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
   b91bc:	f500 700c 	add.w	r0, r0, #560	; 0x230
   b91c0:	f7ff ffc0 	bl	b9144 <_ZN8FatCache4readEmh>
    if (!pc) {
   b91c4:	2800      	cmp	r0, #0
   b91c6:	d0ec      	beq.n	b91a2 <_ZN9FatVolume6fatGetEmPm+0xc>
    next = pc->fat32[cluster & 0X7F] & FAT32MASK;
   b91c8:	f004 047f 	and.w	r4, r4, #127	; 0x7f
   b91cc:	f850 3024 	ldr.w	r3, [r0, r4, lsl #2]
   b91d0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
  if (isEOC(next)) {
   b91d4:	69ea      	ldr	r2, [r5, #28]
   b91d6:	429a      	cmp	r2, r3
  *value = next;
   b91d8:	bf26      	itte	cs
   b91da:	6033      	strcs	r3, [r6, #0]
  return 1;
   b91dc:	2001      	movcs	r0, #1
    return 0;
   b91de:	2000      	movcc	r0, #0
   b91e0:	e7e1      	b.n	b91a6 <_ZN9FatVolume6fatGetEmPm+0x10>
  if (fatType() == 16) {
   b91e2:	2b10      	cmp	r3, #16
   b91e4:	d1dd      	bne.n	b91a2 <_ZN9FatVolume6fatGetEmPm+0xc>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
   b91e6:	f3c1 2307 	ubfx	r3, r1, #8, #8
   b91ea:	6981      	ldr	r1, [r0, #24]
   b91ec:	2202      	movs	r2, #2
   b91ee:	4419      	add	r1, r3
   b91f0:	f500 700c 	add.w	r0, r0, #560	; 0x230
   b91f4:	f7ff ffa6 	bl	b9144 <_ZN8FatCache4readEmh>
    if (!pc) {
   b91f8:	2800      	cmp	r0, #0
   b91fa:	d0d2      	beq.n	b91a2 <_ZN9FatVolume6fatGetEmPm+0xc>
    next = pc->fat16[cluster & 0XFF];
   b91fc:	b2e4      	uxtb	r4, r4
   b91fe:	f830 3014 	ldrh.w	r3, [r0, r4, lsl #1]
    goto done;
   b9202:	e7e7      	b.n	b91d4 <_ZN9FatVolume6fatGetEmPm+0x3e>

000b9204 <_ZN9FatVolume6fatPutEmm>:
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t lba;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
   b9204:	2901      	cmp	r1, #1
bool FatVolume::fatPut(uint32_t cluster, uint32_t value) {
   b9206:	b538      	push	{r3, r4, r5, lr}
   b9208:	460c      	mov	r4, r1
   b920a:	4615      	mov	r5, r2
  if (cluster < 2 || cluster > m_lastCluster) {
   b920c:	d801      	bhi.n	b9212 <_ZN9FatVolume6fatPutEmm+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
   b920e:	2000      	movs	r0, #0
}
   b9210:	bd38      	pop	{r3, r4, r5, pc}
  if (cluster < 2 || cluster > m_lastCluster) {
   b9212:	69c3      	ldr	r3, [r0, #28]
   b9214:	428b      	cmp	r3, r1
   b9216:	d3fa      	bcc.n	b920e <_ZN9FatVolume6fatPutEmm+0xa>
    return m_fatType;
   b9218:	79c3      	ldrb	r3, [r0, #7]
  if (fatType() == 32) {
   b921a:	2b20      	cmp	r3, #32
   b921c:	d10f      	bne.n	b923e <_ZN9FatVolume6fatPutEmm+0x3a>
    lba = m_fatStartBlock + (cluster >> 7);
   b921e:	6981      	ldr	r1, [r0, #24]
    return m_fatCache.read(blockNumber,
   b9220:	2203      	movs	r2, #3
   b9222:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
   b9226:	f500 700c 	add.w	r0, r0, #560	; 0x230
   b922a:	f7ff ff8b 	bl	b9144 <_ZN8FatCache4readEmh>
    if (!pc) {
   b922e:	2800      	cmp	r0, #0
   b9230:	d0ed      	beq.n	b920e <_ZN9FatVolume6fatPutEmm+0xa>
    pc->fat32[cluster & 0X7F] = value;
   b9232:	f004 047f 	and.w	r4, r4, #127	; 0x7f
   b9236:	f840 5024 	str.w	r5, [r0, r4, lsl #2]
    return true;
   b923a:	2001      	movs	r0, #1
   b923c:	e7e8      	b.n	b9210 <_ZN9FatVolume6fatPutEmm+0xc>
  if (fatType() == 16) {
   b923e:	2b10      	cmp	r3, #16
   b9240:	d1e5      	bne.n	b920e <_ZN9FatVolume6fatPutEmm+0xa>
    lba = m_fatStartBlock + ((cluster >> 8) & 0XFF);
   b9242:	f3c1 2307 	ubfx	r3, r1, #8, #8
   b9246:	6981      	ldr	r1, [r0, #24]
   b9248:	2203      	movs	r2, #3
   b924a:	4419      	add	r1, r3
   b924c:	f500 700c 	add.w	r0, r0, #560	; 0x230
   b9250:	f7ff ff78 	bl	b9144 <_ZN8FatCache4readEmh>
    if (!pc) {
   b9254:	2800      	cmp	r0, #0
   b9256:	d0da      	beq.n	b920e <_ZN9FatVolume6fatPutEmm+0xa>
    pc->fat16[cluster & 0XFF] = value;
   b9258:	b2e4      	uxtb	r4, r4
   b925a:	f820 5014 	strh.w	r5, [r0, r4, lsl #1]
   b925e:	e7ec      	b.n	b923a <_ZN9FatVolume6fatPutEmm+0x36>

000b9260 <_ZN9FatVolume15allocateClusterEmPm>:
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
   b9260:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if (m_allocSearchStart < current) {
   b9264:	68c4      	ldr	r4, [r0, #12]
   b9266:	428c      	cmp	r4, r1
bool FatVolume::allocateCluster(uint32_t current, uint32_t* next) {
   b9268:	4605      	mov	r5, r0
   b926a:	460e      	mov	r6, r1
   b926c:	4690      	mov	r8, r2
  if (m_allocSearchStart < current) {
   b926e:	d301      	bcc.n	b9274 <_ZN9FatVolume15allocateClusterEmPm+0x14>
      setStart = true;
   b9270:	2701      	movs	r7, #1
   b9272:	e001      	b.n	b9278 <_ZN9FatVolume15allocateClusterEmPm+0x18>
   b9274:	460c      	mov	r4, r1
    setStart = false;
   b9276:	2700      	movs	r7, #0
    if (find > m_lastCluster) {
   b9278:	69eb      	ldr	r3, [r5, #28]
    find++;
   b927a:	3401      	adds	r4, #1
    if (find > m_lastCluster) {
   b927c:	42a3      	cmp	r3, r4
   b927e:	d202      	bcs.n	b9286 <_ZN9FatVolume15allocateClusterEmPm+0x26>
      if (setStart) {
   b9280:	b9c7      	cbnz	r7, b92b4 <_ZN9FatVolume15allocateClusterEmPm+0x54>
      find = m_allocSearchStart;
   b9282:	68ec      	ldr	r4, [r5, #12]
   b9284:	e7f4      	b.n	b9270 <_ZN9FatVolume15allocateClusterEmPm+0x10>
    if (find == current) {
   b9286:	42a6      	cmp	r6, r4
   b9288:	d014      	beq.n	b92b4 <_ZN9FatVolume15allocateClusterEmPm+0x54>
    int8_t fg = fatGet(find, &f);
   b928a:	aa01      	add	r2, sp, #4
   b928c:	4621      	mov	r1, r4
   b928e:	4628      	mov	r0, r5
   b9290:	f7ff ff81 	bl	b9196 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
   b9294:	2800      	cmp	r0, #0
   b9296:	db0d      	blt.n	b92b4 <_ZN9FatVolume15allocateClusterEmPm+0x54>
    if (fg && f == 0) {
   b9298:	d0ee      	beq.n	b9278 <_ZN9FatVolume15allocateClusterEmPm+0x18>
   b929a:	9b01      	ldr	r3, [sp, #4]
   b929c:	2b00      	cmp	r3, #0
   b929e:	d1eb      	bne.n	b9278 <_ZN9FatVolume15allocateClusterEmPm+0x18>
  if (setStart) {
   b92a0:	b107      	cbz	r7, b92a4 <_ZN9FatVolume15allocateClusterEmPm+0x44>
    m_allocSearchStart = find;
   b92a2:	60ec      	str	r4, [r5, #12]
  }
  uint32_t clusterFirstBlock(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
   b92a4:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
   b92a8:	4621      	mov	r1, r4
   b92aa:	4628      	mov	r0, r5
   b92ac:	f7ff ffaa 	bl	b9204 <_ZN9FatVolume6fatPutEmm>
  if (!fatPutEOC(find)) {
   b92b0:	4607      	mov	r7, r0
   b92b2:	b920      	cbnz	r0, b92be <_ZN9FatVolume15allocateClusterEmPm+0x5e>
  return false;
   b92b4:	2700      	movs	r7, #0
}
   b92b6:	4638      	mov	r0, r7
   b92b8:	b002      	add	sp, #8
   b92ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (current) {
   b92be:	b916      	cbnz	r6, b92c6 <_ZN9FatVolume15allocateClusterEmPm+0x66>
  *next = find;
   b92c0:	f8c8 4000 	str.w	r4, [r8]
  return true;
   b92c4:	e7f7      	b.n	b92b6 <_ZN9FatVolume15allocateClusterEmPm+0x56>
    if (!fatPut(current, find)) {
   b92c6:	4622      	mov	r2, r4
   b92c8:	4631      	mov	r1, r6
   b92ca:	4628      	mov	r0, r5
   b92cc:	f7ff ff9a 	bl	b9204 <_ZN9FatVolume6fatPutEmm>
   b92d0:	2800      	cmp	r0, #0
   b92d2:	d1f5      	bne.n	b92c0 <_ZN9FatVolume15allocateClusterEmPm+0x60>
   b92d4:	e7ee      	b.n	b92b4 <_ZN9FatVolume15allocateClusterEmPm+0x54>

000b92d6 <_ZN9FatVolume9freeChainEm>:
//------------------------------------------------------------------------------
// free a cluster chain
bool FatVolume::freeChain(uint32_t cluster) {
   b92d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
   b92d8:	4605      	mov	r5, r0
   b92da:	460c      	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
   b92dc:	aa01      	add	r2, sp, #4
   b92de:	4621      	mov	r1, r4
   b92e0:	4628      	mov	r0, r5
   b92e2:	f7ff ff58 	bl	b9196 <_ZN9FatVolume6fatGetEmPm>
    if (fg < 0) {
   b92e6:	1e06      	subs	r6, r0, #0
   b92e8:	db10      	blt.n	b930c <_ZN9FatVolume9freeChainEm+0x36>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
   b92ea:	2200      	movs	r2, #0
   b92ec:	4621      	mov	r1, r4
   b92ee:	4628      	mov	r0, r5
   b92f0:	f7ff ff88 	bl	b9204 <_ZN9FatVolume6fatPutEmm>
   b92f4:	b150      	cbz	r0, b930c <_ZN9FatVolume9freeChainEm+0x36>
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);

    if (cluster <= m_allocSearchStart) {
   b92f6:	68eb      	ldr	r3, [r5, #12]
   b92f8:	42a3      	cmp	r3, r4
      m_allocSearchStart = cluster - 1;
   b92fa:	bf24      	itt	cs
   b92fc:	f104 34ff 	addcs.w	r4, r4, #4294967295
   b9300:	60ec      	strcs	r4, [r5, #12]
    }
    cluster = next;
   b9302:	9c01      	ldr	r4, [sp, #4]
  } while (fg);
   b9304:	2e00      	cmp	r6, #0
   b9306:	d1e9      	bne.n	b92dc <_ZN9FatVolume9freeChainEm+0x6>

  return true;

fail:
  return false;
}
   b9308:	b002      	add	sp, #8
   b930a:	bd70      	pop	{r4, r5, r6, pc}
  return false;
   b930c:	2000      	movs	r0, #0
   b930e:	e7fb      	b.n	b9308 <_ZN9FatVolume9freeChainEm+0x32>

000b9310 <_ZN9FatVolume4initEh>:
  uint32_t volumeStartBlock = 0;
  fat32_boot_t* fbs;
  cache_t* pc;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
   b9310:	2301      	movs	r3, #1
bool FatVolume::init(uint8_t part) {
   b9312:	b570      	push	{r4, r5, r6, lr}
  m_fatType = 0;
   b9314:	2200      	movs	r2, #0
  m_allocSearchStart = 1;
   b9316:	60c3      	str	r3, [r0, #12]
    m_lbn = 0XFFFFFFFF;
   b9318:	f04f 33ff 	mov.w	r3, #4294967295
bool FatVolume::init(uint8_t part) {
   b931c:	4604      	mov	r4, r0
  m_fatType = 0;
   b931e:	71c2      	strb	r2, [r0, #7]
  m_cache.init(this);
   b9320:	f100 0624 	add.w	r6, r0, #36	; 0x24
    m_vol = vol;
   b9324:	6280      	str	r0, [r0, #40]	; 0x28
    m_status = 0;
   b9326:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
   b932a:	62c3      	str	r3, [r0, #44]	; 0x2c
    m_vol = vol;
   b932c:	f8c0 0234 	str.w	r0, [r0, #564]	; 0x234
    m_status = 0;
   b9330:	f880 2230 	strb.w	r2, [r0, #560]	; 0x230
    m_lbn = 0XFFFFFFFF;
   b9334:	f8c0 3238 	str.w	r3, [r0, #568]	; 0x238
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(this);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
   b9338:	460d      	mov	r5, r1
   b933a:	b1b9      	cbz	r1, b936c <_ZN9FatVolume4initEh+0x5c>
    if (part > 4) {
   b933c:	2904      	cmp	r1, #4
   b933e:	d901      	bls.n	b9344 <_ZN9FatVolume4initEh+0x34>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
   b9340:	2000      	movs	r0, #0
}
   b9342:	bd70      	pop	{r4, r5, r6, pc}
    return m_cache.read(blockNumber, options);
   b9344:	4611      	mov	r1, r2
   b9346:	4630      	mov	r0, r6
   b9348:	f7ff fefc 	bl	b9144 <_ZN8FatCache4readEmh>
    if (!pc) {
   b934c:	2800      	cmp	r0, #0
   b934e:	d0f7      	beq.n	b9340 <_ZN9FatVolume4initEh+0x30>
    if ((p->boot & 0X7F) != 0 || p->firstSector == 0) {
   b9350:	eb00 1305 	add.w	r3, r0, r5, lsl #4
   b9354:	f893 31ae 	ldrb.w	r3, [r3, #430]	; 0x1ae
   b9358:	065b      	lsls	r3, r3, #25
   b935a:	d1f1      	bne.n	b9340 <_ZN9FatVolume4initEh+0x30>
   b935c:	f105 011b 	add.w	r1, r5, #27
   b9360:	eb00 1001 	add.w	r0, r0, r1, lsl #4
   b9364:	f8d0 5006 	ldr.w	r5, [r0, #6]
   b9368:	2d00      	cmp	r5, #0
   b936a:	d0e9      	beq.n	b9340 <_ZN9FatVolume4initEh+0x30>
   b936c:	2200      	movs	r2, #0
   b936e:	4629      	mov	r1, r5
   b9370:	4630      	mov	r0, r6
   b9372:	f7ff fee7 	bl	b9144 <_ZN8FatCache4readEmh>
  if (!pc) {
   b9376:	2800      	cmp	r0, #0
   b9378:	d0e2      	beq.n	b9340 <_ZN9FatVolume4initEh+0x30>
  if (fbs->bytesPerSector != 512 ||
   b937a:	f8b0 300b 	ldrh.w	r3, [r0, #11]
   b937e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   b9382:	d1dd      	bne.n	b9340 <_ZN9FatVolume4initEh+0x30>
   b9384:	7c03      	ldrb	r3, [r0, #16]
   b9386:	2b02      	cmp	r3, #2
   b9388:	d1da      	bne.n	b9340 <_ZN9FatVolume4initEh+0x30>
      fbs->fatCount != 2 ||
   b938a:	89c3      	ldrh	r3, [r0, #14]
   b938c:	2b00      	cmp	r3, #0
   b938e:	d0d7      	beq.n	b9340 <_ZN9FatVolume4initEh+0x30>
  m_blocksPerCluster = fbs->sectorsPerCluster;
   b9390:	7b41      	ldrb	r1, [r0, #13]
   b9392:	7121      	strb	r1, [r4, #4]
  m_clusterBlockMask = m_blocksPerCluster - 1;
   b9394:	1e4b      	subs	r3, r1, #1
   b9396:	7163      	strb	r3, [r4, #5]
  m_clusterSizeShift = 0;
   b9398:	2300      	movs	r3, #0
   b939a:	71a3      	strb	r3, [r4, #6]
   b939c:	2609      	movs	r6, #9
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
   b939e:	2301      	movs	r3, #1
   b93a0:	4299      	cmp	r1, r3
   b93a2:	d007      	beq.n	b93b4 <_ZN9FatVolume4initEh+0xa4>
    if (tmp == 0) {
   b93a4:	3e01      	subs	r6, #1
   b93a6:	d0cb      	beq.n	b9340 <_ZN9FatVolume4initEh+0x30>
  for (tmp = 1; m_blocksPerCluster != tmp; tmp <<= 1, m_clusterSizeShift++) {
   b93a8:	79a2      	ldrb	r2, [r4, #6]
   b93aa:	005b      	lsls	r3, r3, #1
   b93ac:	3201      	adds	r2, #1
   b93ae:	b2db      	uxtb	r3, r3
   b93b0:	71a2      	strb	r2, [r4, #6]
   b93b2:	e7f5      	b.n	b93a0 <_ZN9FatVolume4initEh+0x90>
  m_blocksPerFat = fbs->sectorsPerFat16 ?
   b93b4:	8ac1      	ldrh	r1, [r0, #22]
   b93b6:	b901      	cbnz	r1, b93ba <_ZN9FatVolume4initEh+0xaa>
   b93b8:	6a41      	ldr	r1, [r0, #36]	; 0x24
   b93ba:	6121      	str	r1, [r4, #16]
  m_fatStartBlock = volumeStartBlock + fbs->reservedSectorCount;
   b93bc:	89c3      	ldrh	r3, [r0, #14]
   b93be:	442b      	add	r3, r5
   b93c0:	61a3      	str	r3, [r4, #24]
  m_rootDirEntryCount = fbs->rootDirEntryCount;
   b93c2:	f8b0 2011 	ldrh.w	r2, [r0, #17]
   b93c6:	8122      	strh	r2, [r4, #8]
  m_rootDirStart = m_fatStartBlock + 2 * m_blocksPerFat;
   b93c8:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   b93cc:	6223      	str	r3, [r4, #32]
  m_dataStartBlock = m_rootDirStart + ((32 * fbs->rootDirEntryCount + 511)/512);
   b93ce:	f8b0 1011 	ldrh.w	r1, [r0, #17]
   b93d2:	0149      	lsls	r1, r1, #5
   b93d4:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
   b93d8:	eb03 2351 	add.w	r3, r3, r1, lsr #9
   b93dc:	6163      	str	r3, [r4, #20]
  totalBlocks = fbs->totalSectors16 ?
   b93de:	f8b0 2013 	ldrh.w	r2, [r0, #19]
   b93e2:	b902      	cbnz	r2, b93e6 <_ZN9FatVolume4initEh+0xd6>
   b93e4:	6a02      	ldr	r2, [r0, #32]
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
   b93e6:	1ae9      	subs	r1, r5, r3
  clusterCount >>= m_clusterSizeShift;
   b93e8:	79a3      	ldrb	r3, [r4, #6]
  clusterCount = totalBlocks - (m_dataStartBlock - volumeStartBlock);
   b93ea:	4411      	add	r1, r2
  clusterCount >>= m_clusterSizeShift;
   b93ec:	40d9      	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
   b93ee:	1c4b      	adds	r3, r1, #1
   b93f0:	61e3      	str	r3, [r4, #28]
  if (clusterCount < 4085) {
   b93f2:	f640 73f4 	movw	r3, #4084	; 0xff4
   b93f6:	4299      	cmp	r1, r3
   b93f8:	d802      	bhi.n	b9400 <_ZN9FatVolume4initEh+0xf0>
    m_fatType = 12;
   b93fa:	230c      	movs	r3, #12
   b93fc:	71e3      	strb	r3, [r4, #7]
   b93fe:	e79f      	b.n	b9340 <_ZN9FatVolume4initEh+0x30>
  } else if (clusterCount < 65525) {
   b9400:	f64f 73f4 	movw	r3, #65524	; 0xfff4
   b9404:	4299      	cmp	r1, r3
    m_rootDirStart = fbs->fat32RootCluster;
   b9406:	bf85      	ittet	hi
   b9408:	6ac3      	ldrhi	r3, [r0, #44]	; 0x2c
   b940a:	6223      	strhi	r3, [r4, #32]
    m_fatType = 16;
   b940c:	2310      	movls	r3, #16
    m_fatType = 32;
   b940e:	2320      	movhi	r3, #32
   b9410:	71e3      	strb	r3, [r4, #7]
  return true;
   b9412:	2001      	movs	r0, #1
   b9414:	e795      	b.n	b9342 <_ZN9FatVolume4initEh+0x32>

000b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return  m_spiDriver->receive(buf, n);
  }
  void spiSend(uint8_t data) {
     m_spiDriver->send(data);
   b9416:	f000 bacb 	b.w	b99b0 <_ZN14SdSpiAltDriver4sendEh>

000b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>:
    return m_spiDriver->receive();
   b941a:	f000 baae 	b.w	b997a <_ZN14SdSpiAltDriver7receiveEv>
	...

000b9420 <_ZN9SdSpiCard10isTimedOutEtt>:
    spiStop();
  }
  return rtn;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isTimedOut(uint16_t startMS, uint16_t timeoutMS) {
   b9420:	b570      	push	{r4, r5, r6, lr}
#if WDT_YIELD_TIME_MICROS
  static uint32_t last;
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
   b9422:	4e0e      	ldr	r6, [pc, #56]	; (b945c <_ZN9SdSpiCard10isTimedOutEtt+0x3c>)
bool SdSpiCard::isTimedOut(uint16_t startMS, uint16_t timeoutMS) {
   b9424:	460d      	mov	r5, r1
   b9426:	4614      	mov	r4, r2
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
   b9428:	f000 fca2 	bl	b9d70 <HAL_Timer_Get_Micro_Seconds>
  if ((micros() - last) > WDT_YIELD_TIME_MICROS) {
   b942c:	6833      	ldr	r3, [r6, #0]
   b942e:	1ac0      	subs	r0, r0, r3
   b9430:	4b0b      	ldr	r3, [pc, #44]	; (b9460 <_ZN9SdSpiCard10isTimedOutEtt+0x40>)
   b9432:	4298      	cmp	r0, r3
   b9434:	d908      	bls.n	b9448 <_ZN9SdSpiCard10isTimedOutEtt+0x28>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   b9436:	f000 fca3 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   b943a:	4b0a      	ldr	r3, [pc, #40]	; (b9464 <_ZN9SdSpiCard10isTimedOutEtt+0x44>)
   b943c:	6018      	str	r0, [r3, #0]
    }
    static void disconnect(const CloudDisconnectOptions& options = CloudDisconnectOptions());
    static void process(void) {
    		application_checkin();
    		spark_process();
   b943e:	f000 ff9d 	bl	ba37c <spark_process>
   b9442:	f000 fc95 	bl	b9d70 <HAL_Timer_Get_Micro_Seconds>
    SysCall::yield();
    last = micros();
   b9446:	6030      	str	r0, [r6, #0]
inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   b9448:	f000 fc9a 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
  }
#endif  // WDT_YIELD_TIME_MICROS
  return (curTimeMS() - startMS) > timeoutMS;
   b944c:	b280      	uxth	r0, r0
   b944e:	1b40      	subs	r0, r0, r5
}
   b9450:	42a0      	cmp	r0, r4
   b9452:	bfd4      	ite	le
   b9454:	2000      	movle	r0, #0
   b9456:	2001      	movgt	r0, #1
   b9458:	bd70      	pop	{r4, r5, r6, pc}
   b945a:	bf00      	nop
   b945c:	2003e650 	.word	0x2003e650
   b9460:	000186a0 	.word	0x000186a0
   b9464:	2003e740 	.word	0x2003e740

000b9468 <_ZN9SdSpiCard8spiStartEv>:
fail:
  spiStop();
  return false;
}
//-----------------------------------------------------------------------------
void SdSpiCard::spiStart() {
   b9468:	b538      	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
   b946a:	7a05      	ldrb	r5, [r0, #8]
void SdSpiCard::spiStart() {
   b946c:	4604      	mov	r4, r0
  if (!m_spiActive) {
   b946e:	b94d      	cbnz	r5, b9484 <_ZN9SdSpiCard8spiStartEv+0x1c>
    m_spiDriver->activate();
   b9470:	6840      	ldr	r0, [r0, #4]
   b9472:	f000 fa6b 	bl	b994c <_ZN14SdSpiAltDriver8activateEv>
     digitalWrite(m_csPin, LOW);
   b9476:	6863      	ldr	r3, [r4, #4]
   b9478:	4629      	mov	r1, r5
   b947a:	7d18      	ldrb	r0, [r3, #20]
   b947c:	f004 fd87 	bl	bdf8e <digitalWrite>
    spiActivate();
    spiSelect();
    m_spiActive = true;
   b9480:	2301      	movs	r3, #1
   b9482:	7223      	strb	r3, [r4, #8]
  }
}
   b9484:	bd38      	pop	{r3, r4, r5, pc}

000b9486 <_ZN9SdSpiCard7spiStopEv>:
//-----------------------------------------------------------------------------
void SdSpiCard::spiStop() {
   b9486:	b510      	push	{r4, lr}
  if (m_spiActive) {
   b9488:	7a03      	ldrb	r3, [r0, #8]
void SdSpiCard::spiStop() {
   b948a:	4604      	mov	r4, r0
  if (m_spiActive) {
   b948c:	b16b      	cbz	r3, b94aa <_ZN9SdSpiCard7spiStopEv+0x24>
    digitalWrite(m_csPin, HIGH);
   b948e:	6843      	ldr	r3, [r0, #4]
   b9490:	2101      	movs	r1, #1
   b9492:	7d18      	ldrb	r0, [r3, #20]
   b9494:	f004 fd7b 	bl	bdf8e <digitalWrite>
    spiUnselect();
    spiSend(0XFF);
   b9498:	6860      	ldr	r0, [r4, #4]
   b949a:	21ff      	movs	r1, #255	; 0xff
   b949c:	f7ff ffbb 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
    m_spiDriver->deactivate();
   b94a0:	6860      	ldr	r0, [r4, #4]
   b94a2:	f000 fa67 	bl	b9974 <_ZN14SdSpiAltDriver10deactivateEv>
    spiDeactivate();
    m_spiActive = false;
   b94a6:	2300      	movs	r3, #0
   b94a8:	7223      	strb	r3, [r4, #8]
  }
}
   b94aa:	bd10      	pop	{r4, pc}

000b94ac <_ZN9SdSpiCard8readDataEPhj>:
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
   b94ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b94ae:	4604      	mov	r4, r0
   b94b0:	460d      	mov	r5, r1
   b94b2:	4616      	mov	r6, r2
   b94b4:	f000 fc64 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline uint16_t curTimeMS() {
  return millis();
   b94b8:	b287      	uxth	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
   b94ba:	6860      	ldr	r0, [r4, #4]
   b94bc:	f7ff ffad 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b94c0:	28ff      	cmp	r0, #255	; 0xff
   b94c2:	7260      	strb	r0, [r4, #9]
   b94c4:	d10e      	bne.n	b94e4 <_ZN9SdSpiCard8readDataEPhj+0x38>
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
   b94c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   b94ca:	4639      	mov	r1, r7
   b94cc:	4620      	mov	r0, r4
   b94ce:	f7ff ffa7 	bl	b9420 <_ZN9SdSpiCard10isTimedOutEtt>
   b94d2:	2800      	cmp	r0, #0
   b94d4:	d0f1      	beq.n	b94ba <_ZN9SdSpiCard8readDataEPhj+0xe>
    m_errorCode = code;
   b94d6:	2355      	movs	r3, #85	; 0x55
  spiStop();
   b94d8:	4620      	mov	r0, r4
   b94da:	7023      	strb	r3, [r4, #0]
   b94dc:	f7ff ffd3 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b94e0:	2000      	movs	r0, #0
}
   b94e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (m_status != DATA_START_BLOCK) {
   b94e4:	28fe      	cmp	r0, #254	; 0xfe
   b94e6:	d001      	beq.n	b94ec <_ZN9SdSpiCard8readDataEPhj+0x40>
   b94e8:	2350      	movs	r3, #80	; 0x50
   b94ea:	e7f5      	b.n	b94d8 <_ZN9SdSpiCard8readDataEPhj+0x2c>
    return  m_spiDriver->receive(buf, n);
   b94ec:	6860      	ldr	r0, [r4, #4]
   b94ee:	4632      	mov	r2, r6
   b94f0:	4629      	mov	r1, r5
   b94f2:	f000 fa47 	bl	b9984 <_ZN14SdSpiAltDriver7receiveEPhj>
  if ((m_status = spiReceive(dst, count))) {
   b94f6:	7260      	strb	r0, [r4, #9]
   b94f8:	b108      	cbz	r0, b94fe <_ZN9SdSpiCard8readDataEPhj+0x52>
    m_errorCode = code;
   b94fa:	2360      	movs	r3, #96	; 0x60
   b94fc:	e7ec      	b.n	b94d8 <_ZN9SdSpiCard8readDataEPhj+0x2c>
  spiReceive();
   b94fe:	6860      	ldr	r0, [r4, #4]
   b9500:	f7ff ff8b 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
  spiReceive();
   b9504:	6860      	ldr	r0, [r4, #4]
   b9506:	f7ff ff88 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
  return true;
   b950a:	2001      	movs	r0, #1
   b950c:	e7e9      	b.n	b94e2 <_ZN9SdSpiCard8readDataEPhj+0x36>

000b950e <_ZN9SdSpiCard11waitNotBusyEt>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(uint16_t timeoutMS) {
   b950e:	b570      	push	{r4, r5, r6, lr}
   b9510:	4604      	mov	r4, r0
   b9512:	460e      	mov	r6, r1
   b9514:	f000 fc34 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
   b9518:	b285      	uxth	r5, r0
  uint16_t t0 = curTimeMS();
#if WDT_YIELD_TIME_MICROS
  // Call isTimedOut first to insure yield is called.
  while (!isTimedOut(t0, timeoutMS)) {
   b951a:	4632      	mov	r2, r6
   b951c:	4629      	mov	r1, r5
   b951e:	4620      	mov	r0, r4
   b9520:	f7ff ff7e 	bl	b9420 <_ZN9SdSpiCard10isTimedOutEtt>
   b9524:	b930      	cbnz	r0, b9534 <_ZN9SdSpiCard11waitNotBusyEt+0x26>
    if (spiReceive() == 0XFF) {
   b9526:	6860      	ldr	r0, [r4, #4]
   b9528:	f7ff ff77 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b952c:	28ff      	cmp	r0, #255	; 0xff
   b952e:	d1f4      	bne.n	b951a <_ZN9SdSpiCard11waitNotBusyEt+0xc>
      return true;
   b9530:	2001      	movs	r0, #1
      return false;
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
   b9532:	bd70      	pop	{r4, r5, r6, pc}
  return false;
   b9534:	2000      	movs	r0, #0
   b9536:	e7fc      	b.n	b9532 <_ZN9SdSpiCard11waitNotBusyEt+0x24>

000b9538 <_ZN9SdSpiCard11cardCommandEhm>:
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
   b9538:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (!m_spiActive) {
   b953a:	7a03      	ldrb	r3, [r0, #8]
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
   b953c:	9201      	str	r2, [sp, #4]
   b953e:	4604      	mov	r4, r0
   b9540:	460d      	mov	r5, r1
  if (!m_spiActive) {
   b9542:	b90b      	cbnz	r3, b9548 <_ZN9SdSpiCard11cardCommandEhm+0x10>
    spiStart();
   b9544:	f7ff ff90 	bl	b9468 <_ZN9SdSpiCard8spiStartEv>
  if (cmd != CMD0) {
   b9548:	b125      	cbz	r5, b9554 <_ZN9SdSpiCard11cardCommandEhm+0x1c>
    waitNotBusy(SD_CMD_TIMEOUT);
   b954a:	f44f 7196 	mov.w	r1, #300	; 0x12c
   b954e:	4620      	mov	r0, r4
   b9550:	f7ff ffdd 	bl	b950e <_ZN9SdSpiCard11waitNotBusyEt>
  spiSend(cmd | 0x40);
   b9554:	6860      	ldr	r0, [r4, #4]
   b9556:	f045 0140 	orr.w	r1, r5, #64	; 0x40
   b955a:	f7ff ff5c 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
   b955e:	2603      	movs	r6, #3
    spiSend(pa[i]);
   b9560:	af01      	add	r7, sp, #4
   b9562:	5db9      	ldrb	r1, [r7, r6]
   b9564:	6860      	ldr	r0, [r4, #4]
   b9566:	f7ff ff56 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
  for (int8_t i = 3; i >= 0; i--) {
   b956a:	3e01      	subs	r6, #1
   b956c:	d2f9      	bcs.n	b9562 <_ZN9SdSpiCard11cardCommandEhm+0x2a>
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
   b956e:	2d00      	cmp	r5, #0
   b9570:	6860      	ldr	r0, [r4, #4]
   b9572:	bf0c      	ite	eq
   b9574:	2195      	moveq	r1, #149	; 0x95
   b9576:	2187      	movne	r1, #135	; 0x87
   b9578:	f7ff ff4d 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
  spiReceive();
   b957c:	6860      	ldr	r0, [r4, #4]
   b957e:	f7ff ff4c 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b9582:	250b      	movs	r5, #11
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
   b9584:	6860      	ldr	r0, [r4, #4]
   b9586:	f7ff ff48 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b958a:	0603      	lsls	r3, r0, #24
   b958c:	7260      	strb	r0, [r4, #9]
   b958e:	d503      	bpl.n	b9598 <_ZN9SdSpiCard11cardCommandEhm+0x60>
   b9590:	3d01      	subs	r5, #1
   b9592:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   b9596:	d1f5      	bne.n	b9584 <_ZN9SdSpiCard11cardCommandEhm+0x4c>
}
   b9598:	b003      	add	sp, #12
   b959a:	bdf0      	pop	{r4, r5, r6, r7, pc}

000b959c <_ZN9SdSpiCard8cardAcmdEhm>:
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
   b959c:	b570      	push	{r4, r5, r6, lr}
   b959e:	4604      	mov	r4, r0
   b95a0:	460d      	mov	r5, r1
   b95a2:	4616      	mov	r6, r2
    cardCommand(CMD55, 0);
   b95a4:	2137      	movs	r1, #55	; 0x37
   b95a6:	2200      	movs	r2, #0
   b95a8:	f7ff ffc6 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
    return cardCommand(cmd, arg);
   b95ac:	4632      	mov	r2, r6
   b95ae:	4629      	mov	r1, r5
   b95b0:	4620      	mov	r0, r4
  }
   b95b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return cardCommand(cmd, arg);
   b95b6:	f7ff bfbf 	b.w	b9538 <_ZN9SdSpiCard11cardCommandEhm>
	...

000b95bc <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE>:
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
   b95bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_spiActive = false;
   b95c0:	2500      	movs	r5, #0
   b95c2:	7205      	strb	r5, [r0, #8]
  m_errorCode = SD_CARD_ERROR_NONE;
   b95c4:	7005      	strb	r5, [r0, #0]
  m_type = 0;
   b95c6:	7285      	strb	r5, [r0, #10]
  m_spiDriver = spi;
   b95c8:	6041      	str	r1, [r0, #4]
bool SdSpiCard::begin(SdSpiDriver* spi, uint8_t csPin, SPISettings settings) {
   b95ca:	4604      	mov	r4, r0
   b95cc:	4690      	mov	r8, r2
   b95ce:	461e      	mov	r6, r3
   b95d0:	f000 fbd6 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
  m_spiDriver->begin(csPin);
   b95d4:	4641      	mov	r1, r8
   b95d6:	4607      	mov	r7, r0
   b95d8:	6860      	ldr	r0, [r4, #4]
   b95da:	f000 f9bb 	bl	b9954 <_ZN14SdSpiAltDriver5beginEh>
  m_spiDriver->setSpiSettings(SD_SCK_HZ(250000));
   b95de:	6863      	ldr	r3, [r4, #4]
class SPISettings : public Printable {
   b95e0:	4a49      	ldr	r2, [pc, #292]	; (b9708 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x14c>)
   b95e2:	721d      	strb	r5, [r3, #8]
   b95e4:	2501      	movs	r5, #1
   b95e6:	60da      	str	r2, [r3, #12]
   b95e8:	821d      	strh	r5, [r3, #16]
  spiStart();
   b95ea:	4620      	mov	r0, r4
   b95ec:	f7ff ff3c 	bl	b9468 <_ZN9SdSpiCard8spiStartEv>
   b95f0:	6863      	ldr	r3, [r4, #4]
   b95f2:	4629      	mov	r1, r5
   b95f4:	7d18      	ldrb	r0, [r3, #20]
   b95f6:	f004 fcca 	bl	bdf8e <digitalWrite>
   b95fa:	250a      	movs	r5, #10
    spiSend(0XFF);
   b95fc:	6860      	ldr	r0, [r4, #4]
   b95fe:	21ff      	movs	r1, #255	; 0xff
  for (uint8_t i = 0; i < 10; i++) {
   b9600:	3d01      	subs	r5, #1
    spiSend(0XFF);
   b9602:	f7ff ff08 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
  for (uint8_t i = 0; i < 10; i++) {
   b9606:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   b960a:	d1f7      	bne.n	b95fc <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x40>
     digitalWrite(m_csPin, LOW);
   b960c:	6863      	ldr	r3, [r4, #4]
   b960e:	4629      	mov	r1, r5
   b9610:	7d18      	ldrb	r0, [r3, #20]
   b9612:	f004 fcbc 	bl	bdf8e <digitalWrite>
  }
   b9616:	250a      	movs	r5, #10
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
   b9618:	2200      	movs	r2, #0
   b961a:	4611      	mov	r1, r2
   b961c:	4620      	mov	r0, r4
   b961e:	f7ff ff8b 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9622:	2801      	cmp	r0, #1
   b9624:	4680      	mov	r8, r0
   b9626:	d018      	beq.n	b965a <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x9e>
    if (i == SD_CMD0_RETRY) {
   b9628:	3d01      	subs	r5, #1
   b962a:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   b962e:	d107      	bne.n	b9640 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x84>
    m_errorCode = code;
   b9630:	2320      	movs	r3, #32
  spiStop();
   b9632:	4620      	mov	r0, r4
   b9634:	7023      	strb	r3, [r4, #0]
   b9636:	f7ff ff26 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b963a:	2000      	movs	r0, #0
}
   b963c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    spiSend(STOP_TRAN_TOKEN);
   b9640:	6860      	ldr	r0, [r4, #4]
   b9642:	21fd      	movs	r1, #253	; 0xfd
   b9644:	f7ff fee7 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
   b9648:	f44f 7802 	mov.w	r8, #520	; 0x208
      spiReceive();
   b964c:	6860      	ldr	r0, [r4, #4]
   b964e:	f7ff fee4 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
    for (int i = 0; i < 520; i++) {
   b9652:	f1b8 0801 	subs.w	r8, r8, #1
   b9656:	d1f9      	bne.n	b964c <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x90>
   b9658:	e7de      	b.n	b9618 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x5c>
  if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
   b965a:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
   b965e:	2108      	movs	r1, #8
   b9660:	4620      	mov	r0, r4
   b9662:	f7ff ff69 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9666:	2805      	cmp	r0, #5
   b9668:	d114      	bne.n	b9694 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xd8>
    m_type = value;
   b966a:	f884 800a 	strb.w	r8, [r4, #10]
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
   b966e:	2500      	movs	r5, #0
   b9670:	b2bf      	uxth	r7, r7
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
   b9672:	462a      	mov	r2, r5
   b9674:	2129      	movs	r1, #41	; 0x29
   b9676:	4620      	mov	r0, r4
   b9678:	f7ff ff90 	bl	b959c <_ZN9SdSpiCard8cardAcmdEhm>
   b967c:	4602      	mov	r2, r0
   b967e:	b1d8      	cbz	r0, b96b8 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xfc>
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
   b9680:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
   b9684:	4639      	mov	r1, r7
   b9686:	4620      	mov	r0, r4
   b9688:	f7ff feca 	bl	b9420 <_ZN9SdSpiCard10isTimedOutEtt>
   b968c:	2800      	cmp	r0, #0
   b968e:	d0f0      	beq.n	b9672 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xb6>
    m_errorCode = code;
   b9690:	2343      	movs	r3, #67	; 0x43
   b9692:	e7ce      	b.n	b9632 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
   b9694:	2504      	movs	r5, #4
      m_status = spiReceive();
   b9696:	6860      	ldr	r0, [r4, #4]
   b9698:	f7ff febf 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
    for (uint8_t i = 0; i < 4; i++) {
   b969c:	3d01      	subs	r5, #1
   b969e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
   b96a2:	7260      	strb	r0, [r4, #9]
    for (uint8_t i = 0; i < 4; i++) {
   b96a4:	d1f7      	bne.n	b9696 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xda>
    if (m_status == 0XAA) {
   b96a6:	28aa      	cmp	r0, #170	; 0xaa
   b96a8:	d104      	bne.n	b96b4 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xf8>
    m_type = value;
   b96aa:	2302      	movs	r3, #2
   b96ac:	72a3      	strb	r3, [r4, #10]
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
   b96ae:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
   b96b2:	e7dd      	b.n	b9670 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0xb4>
    m_errorCode = code;
   b96b4:	2325      	movs	r3, #37	; 0x25
   b96b6:	e7bc      	b.n	b9632 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
  if (type() == SD_CARD_TYPE_SD2) {
   b96b8:	7aa3      	ldrb	r3, [r4, #10]
   b96ba:	2b02      	cmp	r3, #2
   b96bc:	d118      	bne.n	b96f0 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x134>
    if (cardCommand(CMD58, 0)) {
   b96be:	213a      	movs	r1, #58	; 0x3a
   b96c0:	4620      	mov	r0, r4
   b96c2:	f7ff ff39 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b96c6:	b108      	cbz	r0, b96cc <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x110>
   b96c8:	2337      	movs	r3, #55	; 0x37
   b96ca:	e7b2      	b.n	b9632 <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x76>
    if ((spiReceive() & 0XC0) == 0XC0) {
   b96cc:	6860      	ldr	r0, [r4, #4]
   b96ce:	f7ff fea4 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b96d2:	f000 00c0 	and.w	r0, r0, #192	; 0xc0
   b96d6:	28c0      	cmp	r0, #192	; 0xc0
    m_type = value;
   b96d8:	bf04      	itt	eq
   b96da:	2303      	moveq	r3, #3
   b96dc:	72a3      	strbeq	r3, [r4, #10]
      spiReceive();
   b96de:	6860      	ldr	r0, [r4, #4]
   b96e0:	f7ff fe9b 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b96e4:	6860      	ldr	r0, [r4, #4]
   b96e6:	f7ff fe98 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b96ea:	6860      	ldr	r0, [r4, #4]
   b96ec:	f7ff fe95 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
  spiStop();
   b96f0:	4620      	mov	r0, r4
   b96f2:	f7ff fec8 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  m_spiDriver->setSpiSettings(settings);
   b96f6:	6863      	ldr	r3, [r4, #4]
   b96f8:	7930      	ldrb	r0, [r6, #4]
   b96fa:	68b1      	ldr	r1, [r6, #8]
   b96fc:	89b2      	ldrh	r2, [r6, #12]
   b96fe:	821a      	strh	r2, [r3, #16]
   b9700:	7218      	strb	r0, [r3, #8]
   b9702:	60d9      	str	r1, [r3, #12]
  return true;
   b9704:	2001      	movs	r0, #1
   b9706:	e799      	b.n	b963c <_ZN9SdSpiCard5beginEP14SdSpiAltDriverhN8particle11SPISettingsE+0x80>
   b9708:	0003d090 	.word	0x0003d090

000b970c <_ZN9SdSpiCard9readBlockEmPh>:
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
   b970c:	b538      	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
   b970e:	7a83      	ldrb	r3, [r0, #10]
   b9710:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
   b9712:	bf18      	it	ne
   b9714:	0249      	lslne	r1, r1, #9
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
   b9716:	4615      	mov	r5, r2
  if (cardCommand(CMD17, blockNumber)) {
   b9718:	460a      	mov	r2, r1
   b971a:	2111      	movs	r1, #17
bool SdSpiCard::readBlock(uint32_t blockNumber, uint8_t* dst) {
   b971c:	4604      	mov	r4, r0
  if (cardCommand(CMD17, blockNumber)) {
   b971e:	f7ff ff0b 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9722:	b130      	cbz	r0, b9732 <_ZN9SdSpiCard9readBlockEmPh+0x26>
    m_errorCode = code;
   b9724:	2330      	movs	r3, #48	; 0x30
   b9726:	7023      	strb	r3, [r4, #0]
  spiStop();
   b9728:	4620      	mov	r0, r4
   b972a:	f7ff feac 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b972e:	2500      	movs	r5, #0
   b9730:	e00b      	b.n	b974a <_ZN9SdSpiCard9readBlockEmPh+0x3e>
  if (!readData(dst, 512)) {
   b9732:	4629      	mov	r1, r5
   b9734:	f44f 7200 	mov.w	r2, #512	; 0x200
   b9738:	4620      	mov	r0, r4
   b973a:	f7ff feb7 	bl	b94ac <_ZN9SdSpiCard8readDataEPhj>
   b973e:	4605      	mov	r5, r0
   b9740:	2800      	cmp	r0, #0
   b9742:	d0f1      	beq.n	b9728 <_ZN9SdSpiCard9readBlockEmPh+0x1c>
  spiStop();
   b9744:	4620      	mov	r0, r4
   b9746:	f7ff fe9e 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
}
   b974a:	4628      	mov	r0, r5
   b974c:	bd38      	pop	{r3, r4, r5, pc}

000b974e <_ZN9SdSpiCard9readStartEm>:
bool SdSpiCard::readStart(uint32_t blockNumber) {
   b974e:	b510      	push	{r4, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
   b9750:	7a83      	ldrb	r3, [r0, #10]
   b9752:	2b03      	cmp	r3, #3
bool SdSpiCard::readStart(uint32_t blockNumber) {
   b9754:	460a      	mov	r2, r1
    blockNumber <<= 9;
   b9756:	bf18      	it	ne
   b9758:	024a      	lslne	r2, r1, #9
  if (cardCommand(CMD18, blockNumber)) {
   b975a:	2112      	movs	r1, #18
bool SdSpiCard::readStart(uint32_t blockNumber) {
   b975c:	4604      	mov	r4, r0
  if (cardCommand(CMD18, blockNumber)) {
   b975e:	f7ff feeb 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9762:	b130      	cbz	r0, b9772 <_ZN9SdSpiCard9readStartEm+0x24>
   b9764:	2331      	movs	r3, #49	; 0x31
  spiStop();
   b9766:	4620      	mov	r0, r4
   b9768:	7023      	strb	r3, [r4, #0]
   b976a:	f7ff fe8c 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b976e:	2000      	movs	r0, #0
}
   b9770:	bd10      	pop	{r4, pc}
  return true;
   b9772:	2001      	movs	r0, #1
   b9774:	e7fc      	b.n	b9770 <_ZN9SdSpiCard9readStartEm+0x22>

000b9776 <_ZN9SdSpiCard8readStopEv>:
bool SdSpiCard::readStop() {
   b9776:	b510      	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
   b9778:	2200      	movs	r2, #0
   b977a:	210c      	movs	r1, #12
bool SdSpiCard::readStop() {
   b977c:	4604      	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
   b977e:	f7ff fedb 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9782:	b130      	cbz	r0, b9792 <_ZN9SdSpiCard8readStopEv+0x1c>
   b9784:	2328      	movs	r3, #40	; 0x28
  spiStop();
   b9786:	4620      	mov	r0, r4
   b9788:	7023      	strb	r3, [r4, #0]
   b978a:	f7ff fe7c 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b978e:	2000      	movs	r0, #0
}
   b9790:	bd10      	pop	{r4, pc}
  spiStop();
   b9792:	4620      	mov	r0, r4
   b9794:	f7ff fe77 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return true;
   b9798:	2001      	movs	r0, #1
   b979a:	e7f9      	b.n	b9790 <_ZN9SdSpiCard8readStopEv+0x1a>

000b979c <_ZN9SdSpiCard10readBlocksEmPhj>:
bool SdSpiCard::readBlocks(uint32_t block, uint8_t* dst, size_t count) {
   b979c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b979e:	4604      	mov	r4, r0
   b97a0:	4616      	mov	r6, r2
   b97a2:	461f      	mov	r7, r3
  if (!readStart(block)) {
   b97a4:	f7ff ffd3 	bl	b974e <_ZN9SdSpiCard9readStartEm>
   b97a8:	b168      	cbz	r0, b97c6 <_ZN9SdSpiCard10readBlocksEmPhj+0x2a>
   b97aa:	2500      	movs	r5, #0
  for (uint16_t b = 0; b < count; b++, dst += 512) {
   b97ac:	b2ab      	uxth	r3, r5
   b97ae:	429f      	cmp	r7, r3
   b97b0:	eb06 2145 	add.w	r1, r6, r5, lsl #9
   b97b4:	d909      	bls.n	b97ca <_ZN9SdSpiCard10readBlocksEmPhj+0x2e>
    if (!readData(dst, 512)) {
   b97b6:	f44f 7200 	mov.w	r2, #512	; 0x200
   b97ba:	4620      	mov	r0, r4
   b97bc:	f7ff fe76 	bl	b94ac <_ZN9SdSpiCard8readDataEPhj>
   b97c0:	3501      	adds	r5, #1
   b97c2:	2800      	cmp	r0, #0
   b97c4:	d1f2      	bne.n	b97ac <_ZN9SdSpiCard10readBlocksEmPhj+0x10>
}
   b97c6:	2000      	movs	r0, #0
   b97c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return readStop();
   b97ca:	4620      	mov	r0, r4
}
   b97cc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return readStop();
   b97d0:	f7ff bfd1 	b.w	b9776 <_ZN9SdSpiCard8readStopEv>

000b97d4 <_ZN9SdSpiCard9writeDataEhPKh>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
   b97d4:	b538      	push	{r3, r4, r5, lr}
   b97d6:	4604      	mov	r4, r0
   b97d8:	4615      	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
   b97da:	6840      	ldr	r0, [r0, #4]
   b97dc:	f7ff fe1b 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriver->send(buf, n);
   b97e0:	f44f 7200 	mov.w	r2, #512	; 0x200
   b97e4:	6860      	ldr	r0, [r4, #4]
   b97e6:	4629      	mov	r1, r5
   b97e8:	f000 f8e6 	bl	b99b8 <_ZN14SdSpiAltDriver4sendEPKhj>
  spiSend(src, 512);
  spiSend(crc >> 8);
   b97ec:	6860      	ldr	r0, [r4, #4]
   b97ee:	21ff      	movs	r1, #255	; 0xff
   b97f0:	f7ff fe11 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
  spiSend(crc & 0XFF);
   b97f4:	6860      	ldr	r0, [r4, #4]
   b97f6:	21ff      	movs	r1, #255	; 0xff
   b97f8:	f7ff fe0d 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>

  m_status = spiReceive();
   b97fc:	6860      	ldr	r0, [r4, #4]
   b97fe:	f7ff fe0c 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b9802:	7260      	strb	r0, [r4, #9]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
   b9804:	f000 001f 	and.w	r0, r0, #31
   b9808:	2805      	cmp	r0, #5
   b980a:	d006      	beq.n	b981a <_ZN9SdSpiCard9writeDataEhPKh+0x46>
    m_errorCode = code;
   b980c:	2357      	movs	r3, #87	; 0x57
    goto fail;
  }
  return true;

fail:
  spiStop();
   b980e:	4620      	mov	r0, r4
   b9810:	7023      	strb	r3, [r4, #0]
   b9812:	f7ff fe38 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b9816:	2000      	movs	r0, #0
}
   b9818:	bd38      	pop	{r3, r4, r5, pc}
  return true;
   b981a:	2001      	movs	r0, #1
   b981c:	e7fc      	b.n	b9818 <_ZN9SdSpiCard9writeDataEhPKh+0x44>

000b981e <_ZN9SdSpiCard10writeBlockEmPKh>:
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   b981e:	b570      	push	{r4, r5, r6, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
   b9820:	7a83      	ldrb	r3, [r0, #10]
   b9822:	2b03      	cmp	r3, #3
    blockNumber <<= 9;
   b9824:	bf18      	it	ne
   b9826:	0249      	lslne	r1, r1, #9
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   b9828:	4615      	mov	r5, r2
  if (cardCommand(CMD24, blockNumber)) {
   b982a:	460a      	mov	r2, r1
   b982c:	2118      	movs	r1, #24
bool SdSpiCard::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   b982e:	4604      	mov	r4, r0
  if (cardCommand(CMD24, blockNumber)) {
   b9830:	f7ff fe82 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9834:	4606      	mov	r6, r0
   b9836:	b130      	cbz	r0, b9846 <_ZN9SdSpiCard10writeBlockEmPKh+0x28>
   b9838:	2332      	movs	r3, #50	; 0x32
   b983a:	7023      	strb	r3, [r4, #0]
  spiStop();
   b983c:	4620      	mov	r0, r4
   b983e:	f7ff fe22 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b9842:	2500      	movs	r5, #0
   b9844:	e01f      	b.n	b9886 <_ZN9SdSpiCard10writeBlockEmPKh+0x68>
  if (!writeData(DATA_START_BLOCK, src)) {
   b9846:	462a      	mov	r2, r5
   b9848:	21fe      	movs	r1, #254	; 0xfe
   b984a:	4620      	mov	r0, r4
   b984c:	f7ff ffc2 	bl	b97d4 <_ZN9SdSpiCard9writeDataEhPKh>
   b9850:	2800      	cmp	r0, #0
   b9852:	d0f3      	beq.n	b983c <_ZN9SdSpiCard10writeBlockEmPKh+0x1e>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   b9854:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
   b9858:	4620      	mov	r0, r4
   b985a:	f7ff fe58 	bl	b950e <_ZN9SdSpiCard11waitNotBusyEt>
   b985e:	4605      	mov	r5, r0
   b9860:	b908      	cbnz	r0, b9866 <_ZN9SdSpiCard10writeBlockEmPKh+0x48>
   b9862:	235a      	movs	r3, #90	; 0x5a
   b9864:	e7e9      	b.n	b983a <_ZN9SdSpiCard10writeBlockEmPKh+0x1c>
  if (cardCommand(CMD13, 0) || spiReceive()) {
   b9866:	4632      	mov	r2, r6
   b9868:	210d      	movs	r1, #13
   b986a:	4620      	mov	r0, r4
   b986c:	f7ff fe64 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b9870:	b108      	cbz	r0, b9876 <_ZN9SdSpiCard10writeBlockEmPKh+0x58>
   b9872:	2329      	movs	r3, #41	; 0x29
   b9874:	e7e1      	b.n	b983a <_ZN9SdSpiCard10writeBlockEmPKh+0x1c>
   b9876:	6860      	ldr	r0, [r4, #4]
   b9878:	f7ff fdcf 	bl	b941a <_ZN9SdSpiCard10spiReceiveEv.isra.0>
   b987c:	2800      	cmp	r0, #0
   b987e:	d1f8      	bne.n	b9872 <_ZN9SdSpiCard10writeBlockEmPKh+0x54>
  spiStop();
   b9880:	4620      	mov	r0, r4
   b9882:	f7ff fe00 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
}
   b9886:	4628      	mov	r0, r5
   b9888:	bd70      	pop	{r4, r5, r6, pc}

000b988a <_ZN9SdSpiCard9writeDataEPKh>:
bool SdSpiCard::writeData(const uint8_t* src) {
   b988a:	b513      	push	{r0, r1, r4, lr}
   b988c:	9101      	str	r1, [sp, #4]
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   b988e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
bool SdSpiCard::writeData(const uint8_t* src) {
   b9892:	4604      	mov	r4, r0
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   b9894:	f7ff fe3b 	bl	b950e <_ZN9SdSpiCard11waitNotBusyEt>
   b9898:	9a01      	ldr	r2, [sp, #4]
   b989a:	b930      	cbnz	r0, b98aa <_ZN9SdSpiCard9writeDataEPKh+0x20>
   b989c:	235b      	movs	r3, #91	; 0x5b
   b989e:	7023      	strb	r3, [r4, #0]
  spiStop();
   b98a0:	4620      	mov	r0, r4
   b98a2:	f7ff fdf0 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b98a6:	2000      	movs	r0, #0
   b98a8:	e005      	b.n	b98b6 <_ZN9SdSpiCard9writeDataEPKh+0x2c>
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
   b98aa:	21fc      	movs	r1, #252	; 0xfc
   b98ac:	4620      	mov	r0, r4
   b98ae:	f7ff ff91 	bl	b97d4 <_ZN9SdSpiCard9writeDataEhPKh>
   b98b2:	2800      	cmp	r0, #0
   b98b4:	d0f4      	beq.n	b98a0 <_ZN9SdSpiCard9writeDataEPKh+0x16>
}
   b98b6:	b002      	add	sp, #8
   b98b8:	bd10      	pop	{r4, pc}

000b98ba <_ZN9SdSpiCard10writeStartEm>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t blockNumber) {
   b98ba:	b510      	push	{r4, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
   b98bc:	7a83      	ldrb	r3, [r0, #10]
   b98be:	2b03      	cmp	r3, #3
bool SdSpiCard::writeStart(uint32_t blockNumber) {
   b98c0:	460a      	mov	r2, r1
    blockNumber <<= 9;
   b98c2:	bf18      	it	ne
   b98c4:	024a      	lslne	r2, r1, #9
  }
  if (cardCommand(CMD25, blockNumber)) {
   b98c6:	2119      	movs	r1, #25
bool SdSpiCard::writeStart(uint32_t blockNumber) {
   b98c8:	4604      	mov	r4, r0
  if (cardCommand(CMD25, blockNumber)) {
   b98ca:	f7ff fe35 	bl	b9538 <_ZN9SdSpiCard11cardCommandEhm>
   b98ce:	b130      	cbz	r0, b98de <_ZN9SdSpiCard10writeStartEm+0x24>
   b98d0:	2333      	movs	r3, #51	; 0x33
    goto fail;
  }
  return true;

fail:
  spiStop();
   b98d2:	4620      	mov	r0, r4
   b98d4:	7023      	strb	r3, [r4, #0]
   b98d6:	f7ff fdd6 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
  return false;
   b98da:	2000      	movs	r0, #0
}
   b98dc:	bd10      	pop	{r4, pc}
  return true;
   b98de:	2001      	movs	r0, #1
   b98e0:	e7fc      	b.n	b98dc <_ZN9SdSpiCard10writeStartEm+0x22>

000b98e2 <_ZN9SdSpiCard9writeStopEv>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
   b98e2:	b538      	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   b98e4:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
bool SdSpiCard::writeStop() {
   b98e8:	4604      	mov	r4, r0
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   b98ea:	f7ff fe10 	bl	b950e <_ZN9SdSpiCard11waitNotBusyEt>
   b98ee:	4605      	mov	r5, r0
   b98f0:	b930      	cbnz	r0, b9900 <_ZN9SdSpiCard9writeStopEv+0x1e>
   b98f2:	2356      	movs	r3, #86	; 0x56
   b98f4:	7023      	strb	r3, [r4, #0]
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
  spiStop();
   b98f6:	4620      	mov	r0, r4
   b98f8:	f7ff fdc5 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
   b98fc:	4628      	mov	r0, r5
   b98fe:	bd38      	pop	{r3, r4, r5, pc}
  spiSend(STOP_TRAN_TOKEN);
   b9900:	6860      	ldr	r0, [r4, #4]
   b9902:	21fd      	movs	r1, #253	; 0xfd
   b9904:	f7ff fd87 	bl	b9416 <_ZN9SdSpiCard7spiSendEh.isra.0>
   b9908:	e7f5      	b.n	b98f6 <_ZN9SdSpiCard9writeStopEv+0x14>

000b990a <_ZN9SdSpiCard11writeBlocksEmPKhj>:
bool SdSpiCard::writeBlocks(uint32_t block, const uint8_t* src, size_t count) {
   b990a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   b990c:	4604      	mov	r4, r0
   b990e:	4616      	mov	r6, r2
   b9910:	461f      	mov	r7, r3
  if (!writeStart(block)) {
   b9912:	f7ff ffd2 	bl	b98ba <_ZN9SdSpiCard10writeStartEm>
   b9916:	b170      	cbz	r0, b9936 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
  for (size_t b = 0; b < count; b++, src += 512) {
   b9918:	2500      	movs	r5, #0
   b991a:	42bd      	cmp	r5, r7
   b991c:	eb06 2145 	add.w	r1, r6, r5, lsl #9
  return writeStop();
   b9920:	4620      	mov	r0, r4
  for (size_t b = 0; b < count; b++, src += 512) {
   b9922:	d004      	beq.n	b992e <_ZN9SdSpiCard11writeBlocksEmPKhj+0x24>
    if (!writeData(src)) {
   b9924:	f7ff ffb1 	bl	b988a <_ZN9SdSpiCard9writeDataEPKh>
   b9928:	b128      	cbz	r0, b9936 <_ZN9SdSpiCard11writeBlocksEmPKhj+0x2c>
  for (size_t b = 0; b < count; b++, src += 512) {
   b992a:	3501      	adds	r5, #1
   b992c:	e7f5      	b.n	b991a <_ZN9SdSpiCard11writeBlocksEmPKhj+0x10>
}
   b992e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  return writeStop();
   b9932:	f7ff bfd6 	b.w	b98e2 <_ZN9SdSpiCard9writeStopEv>
  spiStop();
   b9936:	4620      	mov	r0, r4
   b9938:	f7ff fda5 	bl	b9486 <_ZN9SdSpiCard7spiStopEv>
}
   b993c:	2000      	movs	r0, #0
   b993e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000b9940 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv>:
#if defined(PLATFORM_ID)
#include "SdSpiDriver.h"
static volatile bool SPI_DMA_TransferCompleted = false;
//-----------------------------------------------------------------------------
static void SD_SPI_DMA_TransferComplete_Callback(void) {
    SPI_DMA_TransferCompleted = true;
   b9940:	4b01      	ldr	r3, [pc, #4]	; (b9948 <_ZL36SD_SPI_DMA_TransferComplete_Callbackv+0x8>)
   b9942:	2201      	movs	r2, #1
   b9944:	701a      	strb	r2, [r3, #0]
}
   b9946:	4770      	bx	lr
   b9948:	2003e654 	.word	0x2003e654

000b994c <_ZN14SdSpiAltDriver8activateEv>:
/** Set SPI options for access to SD/SDHC cards.
 *
 * \param[in] divisor SCK clock divider relative to the APB1 or APB2 clock.
 */
void SdSpiAltDriver::activate() {
  m_spi->beginTransaction(m_spiSettings);
   b994c:	1d01      	adds	r1, r0, #4
   b994e:	6800      	ldr	r0, [r0, #0]
   b9950:	f000 be30 	b.w	ba5b4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>

000b9954 <_ZN14SdSpiAltDriver5beginEh>:
//------------------------------------------------------------------------------
/** Initialize the SPI bus.
 *
 * \param[in] chipSelectPin SD card chip select pin.
 */
void SdSpiAltDriver::begin(uint8_t csPin) {
   b9954:	b510      	push	{r4, lr}
   b9956:	4604      	mov	r4, r0
  m_csPin = csPin;
   b9958:	7501      	strb	r1, [r0, #20]
  m_spi->begin();
   b995a:	6800      	ldr	r0, [r0, #0]
   b995c:	f000 fdfc 	bl	ba558 <_ZN8SPIClass5beginEv>
  pinMode(m_csPin, OUTPUT);
   b9960:	7d20      	ldrb	r0, [r4, #20]
   b9962:	2101      	movs	r1, #1
   b9964:	f004 fb02 	bl	bdf6c <pinMode>
  digitalWrite(m_csPin, HIGH);
   b9968:	7d20      	ldrb	r0, [r4, #20]
   b996a:	2101      	movs	r1, #1
}
   b996c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  digitalWrite(m_csPin, HIGH);
   b9970:	f004 bb0d 	b.w	bdf8e <digitalWrite>

000b9974 <_ZN14SdSpiAltDriver10deactivateEv>:
//------------------------------------------------------------------------------
/**
 * End SPI transaction.
 */
void SdSpiAltDriver::deactivate() {
  m_spi->endTransaction();
   b9974:	6800      	ldr	r0, [r0, #0]
   b9976:	f000 be03 	b.w	ba580 <_ZN8SPIClass14endTransactionEv>

000b997a <_ZN14SdSpiAltDriver7receiveEv>:
/** Receive a byte.
 *
 * \return The byte.
 */
uint8_t SdSpiAltDriver::receive() {
  return m_spi->transfer(0XFF);
   b997a:	6800      	ldr	r0, [r0, #0]
   b997c:	21ff      	movs	r1, #255	; 0xff
   b997e:	f000 be87 	b.w	ba690 <_ZN8SPIClass8transferEh>
	...

000b9984 <_ZN14SdSpiAltDriver7receiveEPhj>:
 * \param[out] buf Buffer to receive the data.
 * \param[in] n Number of bytes to receive.
 *
 * \return Zero for no error or nonzero error code.
 */
uint8_t SdSpiAltDriver::receive(uint8_t* buf, size_t n) {
   b9984:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b9986:	4613      	mov	r3, r2
  SPI_DMA_TransferCompleted = false;
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
   b9988:	4a07      	ldr	r2, [pc, #28]	; (b99a8 <_ZN14SdSpiAltDriver7receiveEPhj+0x24>)
   b998a:	9200      	str	r2, [sp, #0]
  SPI_DMA_TransferCompleted = false;
   b998c:	2500      	movs	r5, #0
   b998e:	4c07      	ldr	r4, [pc, #28]	; (b99ac <_ZN14SdSpiAltDriver7receiveEPhj+0x28>)
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
   b9990:	6800      	ldr	r0, [r0, #0]
  SPI_DMA_TransferCompleted = false;
   b9992:	7025      	strb	r5, [r4, #0]
  m_spi->transfer(nullptr, buf, n, SD_SPI_DMA_TransferComplete_Callback);
   b9994:	460a      	mov	r2, r1
   b9996:	4629      	mov	r1, r5
   b9998:	f000 fe80 	bl	ba69c <_ZN8SPIClass8transferEPKvPvjPFvvE>
  while (!SPI_DMA_TransferCompleted) {}
   b999c:	7823      	ldrb	r3, [r4, #0]
   b999e:	2b00      	cmp	r3, #0
   b99a0:	d0fc      	beq.n	b999c <_ZN14SdSpiAltDriver7receiveEPhj+0x18>
  return 0;
}
   b99a2:	2000      	movs	r0, #0
   b99a4:	b003      	add	sp, #12
   b99a6:	bd30      	pop	{r4, r5, pc}
   b99a8:	000b9941 	.word	0x000b9941
   b99ac:	2003e654 	.word	0x2003e654

000b99b0 <_ZN14SdSpiAltDriver4sendEh>:
/** Send a byte.
 *
 * \param[in] b Byte to send
 */
void SdSpiAltDriver::send(uint8_t b) {
  m_spi->transfer(b);
   b99b0:	6800      	ldr	r0, [r0, #0]
   b99b2:	f000 be6d 	b.w	ba690 <_ZN8SPIClass8transferEh>
	...

000b99b8 <_ZN14SdSpiAltDriver4sendEPKhj>:
/** Send multiple bytes.
 *
 * \param[in] buf Buffer for data to be sent.
 * \param[in] n Number of bytes to send.
 */
void SdSpiAltDriver::send(const uint8_t* buf , size_t n) {
   b99b8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   b99ba:	4613      	mov	r3, r2
  SPI_DMA_TransferCompleted = false;

  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
   b99bc:	4a06      	ldr	r2, [pc, #24]	; (b99d8 <_ZN14SdSpiAltDriver4sendEPKhj+0x20>)
   b99be:	9200      	str	r2, [sp, #0]
  SPI_DMA_TransferCompleted = false;
   b99c0:	2500      	movs	r5, #0
   b99c2:	4c06      	ldr	r4, [pc, #24]	; (b99dc <_ZN14SdSpiAltDriver4sendEPKhj+0x24>)
  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
   b99c4:	6800      	ldr	r0, [r0, #0]
  SPI_DMA_TransferCompleted = false;
   b99c6:	7025      	strb	r5, [r4, #0]
  m_spi->transfer(const_cast<uint8_t*>(buf), nullptr, n,
   b99c8:	462a      	mov	r2, r5
   b99ca:	f000 fe67 	bl	ba69c <_ZN8SPIClass8transferEPKvPvjPFvvE>
                            SD_SPI_DMA_TransferComplete_Callback);

  while (!SPI_DMA_TransferCompleted) {}
   b99ce:	7823      	ldrb	r3, [r4, #0]
   b99d0:	2b00      	cmp	r3, #0
   b99d2:	d0fc      	beq.n	b99ce <_ZN14SdSpiAltDriver4sendEPKhj+0x16>
}
   b99d4:	b003      	add	sp, #12
   b99d6:	bd30      	pop	{r4, r5, pc}
   b99d8:	000b9941 	.word	0x000b9941
   b99dc:	2003e654 	.word	0x2003e654

000b99e0 <_ZN15Adafruit_SH110X7displayEv>:
    @brief  Push data currently in RAM to SH110X display.
    @note   Drawing operations are not visible until this function is
            called. Call after each graphics command, or after a whole set
            of graphics commands, as best needed by one's own application.
*/
void Adafruit_SH110X::display(void) {
   b99e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   b99e4:	4604      	mov	r4, r0
   b99e6:	b08b      	sub	sp, #44	; 0x2c
#define digitalPinToInterrupt(P)      (P)
#endif

inline void yield() {
#if PLATFORM_THREADING
  os_thread_yield();
   b99e8:	f000 fa8c 	bl	b9f04 <os_thread_yield>
  // a screen write and one immediately after should cover it.  But if
  // not, if this becomes a problem, yields() might be added in the
  // 32-byte transfer condition below.
  yield();

  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
   b99ec:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
  Serial.print(", ");
  Serial.print(window_y2);
  Serial.println(")");
  */

  uint8_t first_page = window_y1 / 8;
   b99f0:	f9b4 603a 	ldrsh.w	r6, [r4, #58]	; 0x3a
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
   b99f4:	f9b4 7008 	ldrsh.w	r7, [r4, #8]
   b99f8:	f894 9038 	ldrb.w	r9, [r4, #56]	; 0x38
   b99fc:	1dda      	adds	r2, r3, #7
   b99fe:	bf48      	it	mi
   b9a00:	f103 020e 	addmi.w	r2, r3, #14
  uint8_t dc_byte = 0x40;
   b9a04:	2340      	movs	r3, #64	; 0x40
   b9a06:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
  uint8_t pages = ((HEIGHT + 7) / 8);
   b9a0a:	f3c2 03c7 	ubfx	r3, r2, #3, #8
   b9a0e:	9303      	str	r3, [sp, #12]
                       bool stop = false);
  bool setSpeed(uint32_t desiredclk);

  /*!   @brief  How many bytes we can read in a transaction
   *    @return The size of the Wire receive/transmit buffer */
  size_t maxBufferSize() { return _maxBufferSize; }
   b9a10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  uint8_t last_page = (window_y2 + 7) / 8;
  uint8_t page_start = min(bytes_per_page, (uint8_t)window_x1);
  uint8_t page_end = (uint8_t)max((int)0, (int)window_x2);
   b9a12:	f9b4 203c 	ldrsh.w	r2, [r4, #60]	; 0x3c
  uint16_t maxbuff = i2c_dev->maxBufferSize() - 1;
   b9a16:	68db      	ldr	r3, [r3, #12]
  uint8_t bytes_per_page = WIDTH;
   b9a18:	b2ff      	uxtb	r7, r7
  uint8_t first_page = window_y1 / 8;
   b9a1a:	2e00      	cmp	r6, #0
  uint16_t maxbuff = i2c_dev->maxBufferSize() - 1;
   b9a1c:	f103 33ff 	add.w	r3, r3, #4294967295
  uint8_t page_end = (uint8_t)max((int)0, (int)window_x2);
   b9a20:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
  uint8_t first_page = window_y1 / 8;
   b9a24:	bfb8      	it	lt
   b9a26:	3607      	addlt	r6, #7
  uint8_t page_end = (uint8_t)max((int)0, (int)window_x2);
   b9a28:	b2d2      	uxtb	r2, r2
  uint16_t maxbuff = i2c_dev->maxBufferSize() - 1;
   b9a2a:	b29b      	uxth	r3, r3
  uint8_t first_page = window_y1 / 8;
   b9a2c:	45b9      	cmp	r9, r7
   b9a2e:	f3c6 06c7 	ubfx	r6, r6, #3, #8
  uint8_t page_start = min(bytes_per_page, (uint8_t)window_x1);
   b9a32:	bf28      	it	cs
   b9a34:	46b9      	movcs	r9, r7
  uint8_t page_end = (uint8_t)max((int)0, (int)window_x2);
   b9a36:	9204      	str	r2, [sp, #16]
  Serial.print(page_start);
  Serial.print(" -> ");
  Serial.println(page_end);
  */

  for (uint8_t p = first_page; p < pages; p++) {
   b9a38:	b2db      	uxtb	r3, r3
    ptr = buffer + (uint16_t)p * (uint16_t)bytes_per_page;
    // fast forward to dirty rectangle beginning
    ptr += page_start;
    bytes_remaining -= page_start;
    // cut off end of dirty rectangle
    bytes_remaining -= (WIDTH - 1) - page_end;
   b9a3a:	1c7a      	adds	r2, r7, #1
   b9a3c:	fb06 9b07 	mla	fp, r6, r7, r9
   b9a40:	9205      	str	r2, [sp, #20]
   b9a42:	9306      	str	r3, [sp, #24]
  for (uint8_t p = first_page; p < pages; p++) {
   b9a44:	9b03      	ldr	r3, [sp, #12]
   b9a46:	429e      	cmp	r6, r3
   b9a48:	d26a      	bcs.n	b9b20 <_ZN15Adafruit_SH110X7displayEv+0x140>
    ptr += page_start;
   b9a4a:	6b63      	ldr	r3, [r4, #52]	; 0x34
    bytes_remaining -= (WIDTH - 1) - page_end;
   b9a4c:	8925      	ldrh	r5, [r4, #8]

    if (i2c_dev) { // I2C
      uint8_t cmd[] = {
          0x00, (uint8_t)(SH110X_SETPAGEADDR + p),
          (uint8_t)(0x10 + ((page_start + _page_start_offset) >> 4)),
   b9a4e:	f894 2054 	ldrb.w	r2, [r4, #84]	; 0x54
    ptr += page_start;
   b9a52:	eb03 080b 	add.w	r8, r3, fp
    bytes_remaining -= (WIDTH - 1) - page_end;
   b9a56:	9b05      	ldr	r3, [sp, #20]
   b9a58:	1b5d      	subs	r5, r3, r5
   b9a5a:	9b04      	ldr	r3, [sp, #16]
          (uint8_t)(0x10 + ((page_start + _page_start_offset) >> 4)),
   b9a5c:	444a      	add	r2, r9
    bytes_remaining -= (WIDTH - 1) - page_end;
   b9a5e:	441d      	add	r5, r3
    if (i2c_dev) { // I2C
   b9a60:	6aa3      	ldr	r3, [r4, #40]	; 0x28
          (uint8_t)(0x10 + ((page_start + _page_start_offset) >> 4)),
   b9a62:	1110      	asrs	r0, r2, #4
    bytes_remaining -= (WIDTH - 1) - page_end;
   b9a64:	eba5 0509 	sub.w	r5, r5, r9
   b9a68:	f1a6 0150 	sub.w	r1, r6, #80	; 0x50
   b9a6c:	b2ed      	uxtb	r5, r5
    if (i2c_dev) { // I2C
   b9a6e:	b2c9      	uxtb	r1, r1
          (uint8_t)(0x10 + ((page_start + _page_start_offset) >> 4)),
   b9a70:	3010      	adds	r0, #16
          (uint8_t)((page_start + _page_start_offset) & 0xF)};
   b9a72:	f002 020f 	and.w	r2, r2, #15
    if (i2c_dev) { // I2C
   b9a76:	b39b      	cbz	r3, b9ae0 <_ZN15Adafruit_SH110X7displayEv+0x100>
      uint8_t cmd[] = {
   b9a78:	f04f 0a00 	mov.w	sl, #0
          (uint8_t)((page_start + _page_start_offset) & 0xF)};
   b9a7c:	f88d 1025 	strb.w	r1, [sp, #37]	; 0x25
   b9a80:	f88d 0026 	strb.w	r0, [sp, #38]	; 0x26

      // Set high speed clk
      i2c_dev->setSpeed(i2c_preclk);
   b9a84:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      uint8_t cmd[] = {
   b9a86:	f88d a024 	strb.w	sl, [sp, #36]	; 0x24
      i2c_dev->setSpeed(i2c_preclk);
   b9a8a:	4618      	mov	r0, r3
          (uint8_t)((page_start + _page_start_offset) & 0xF)};
   b9a8c:	f88d 2027 	strb.w	r2, [sp, #39]	; 0x27
      i2c_dev->setSpeed(i2c_preclk);
   b9a90:	f7fe fc24 	bl	b82dc <_ZN18Adafruit_I2CDevice8setSpeedEm>

      i2c_dev->write(cmd, 4);
   b9a94:	e9cd aa00 	strd	sl, sl, [sp]
   b9a98:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   b9a9a:	2301      	movs	r3, #1
   b9a9c:	2204      	movs	r2, #4
   b9a9e:	a909      	add	r1, sp, #36	; 0x24
   b9aa0:	f7fe fbec 	bl	b827c <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j>

      while (bytes_remaining) {
        uint8_t to_write = min(bytes_remaining, (uint8_t)maxbuff);
        i2c_dev->write(ptr, to_write, true, &dc_byte, 1);
   b9aa4:	f10d 0a23 	add.w	sl, sp, #35	; 0x23
   b9aa8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      while (bytes_remaining) {
   b9aaa:	b195      	cbz	r5, b9ad2 <_ZN15Adafruit_SH110X7displayEv+0xf2>
        uint8_t to_write = min(bytes_remaining, (uint8_t)maxbuff);
   b9aac:	9b06      	ldr	r3, [sp, #24]
   b9aae:	42ab      	cmp	r3, r5
   b9ab0:	bf28      	it	cs
   b9ab2:	462b      	movcs	r3, r5
   b9ab4:	461a      	mov	r2, r3
        i2c_dev->write(ptr, to_write, true, &dc_byte, 1);
   b9ab6:	2301      	movs	r3, #1
   b9ab8:	4641      	mov	r1, r8
   b9aba:	e9cd a300 	strd	sl, r3, [sp]
   b9abe:	9207      	str	r2, [sp, #28]
   b9ac0:	f7fe fbdc 	bl	b827c <_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j>
        ptr += to_write;
   b9ac4:	9a07      	ldr	r2, [sp, #28]
        bytes_remaining -= to_write;
   b9ac6:	1aad      	subs	r5, r5, r2
        ptr += to_write;
   b9ac8:	4490      	add	r8, r2
        bytes_remaining -= to_write;
   b9aca:	b2ed      	uxtb	r5, r5
   b9acc:	f000 fa1a 	bl	b9f04 <os_thread_yield>
#endif // PLATFORM_THREADING
}
   b9ad0:	e7ea      	b.n	b9aa8 <_ZN15Adafruit_SH110X7displayEv+0xc8>
        yield();
      }

      // Set low speed clk
      i2c_dev->setSpeed(i2c_postclk);
   b9ad2:	6b21      	ldr	r1, [r4, #48]	; 0x30
   b9ad4:	f7fe fc02 	bl	b82dc <_ZN18Adafruit_I2CDevice8setSpeedEm>
  for (uint8_t p = first_page; p < pages; p++) {
   b9ad8:	3601      	adds	r6, #1
   b9ada:	b2f6      	uxtb	r6, r6
   b9adc:	44bb      	add	fp, r7
   b9ade:	e7b1      	b.n	b9a44 <_ZN15Adafruit_SH110X7displayEv+0x64>

    } else { // SPI
      uint8_t cmd[] = {
          (uint8_t)(SH110X_SETPAGEADDR + p),
          (uint8_t)(0x10 + ((page_start + _page_start_offset) >> 4)),
          (uint8_t)((page_start + _page_start_offset) & 0xF)};
   b9ae0:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
   b9ae4:	f88d 0025 	strb.w	r0, [sp, #37]	; 0x25

      digitalWrite(dcPin, LOW);
   b9ae8:	4619      	mov	r1, r3
   b9aea:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
          (uint8_t)((page_start + _page_start_offset) & 0xF)};
   b9aee:	f88d 2026 	strb.w	r2, [sp, #38]	; 0x26
      digitalWrite(dcPin, LOW);
   b9af2:	9307      	str	r3, [sp, #28]
   b9af4:	f004 fa4b 	bl	bdf8e <digitalWrite>
      spi_dev->write(cmd, 3);
   b9af8:	9b07      	ldr	r3, [sp, #28]
   b9afa:	9300      	str	r3, [sp, #0]
   b9afc:	2203      	movs	r2, #3
   b9afe:	a909      	add	r1, sp, #36	; 0x24
   b9b00:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b9b02:	f7fe fb5e 	bl	b81c2 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j>
      digitalWrite(dcPin, HIGH);
   b9b06:	f8b4 0040 	ldrh.w	r0, [r4, #64]	; 0x40
   b9b0a:	2101      	movs	r1, #1
   b9b0c:	f004 fa3f 	bl	bdf8e <digitalWrite>
      spi_dev->write(ptr, bytes_remaining);
   b9b10:	9b07      	ldr	r3, [sp, #28]
   b9b12:	6a60      	ldr	r0, [r4, #36]	; 0x24
   b9b14:	9300      	str	r3, [sp, #0]
   b9b16:	462a      	mov	r2, r5
   b9b18:	4641      	mov	r1, r8
   b9b1a:	f7fe fb52 	bl	b81c2 <_ZN18Adafruit_SPIDevice5writeEPhjS0_j>
   b9b1e:	e7db      	b.n	b9ad8 <_ZN15Adafruit_SH110X7displayEv+0xf8>
    }
  }
  // reset dirty window
  window_x1 = 1024;
  window_y1 = 1024;
  window_x2 = -1;
   b9b20:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
   b9b24:	f04f 33ff 	mov.w	r3, #4294967295
   b9b28:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
  window_y2 = -1;
}
   b9b2c:	b00b      	add	sp, #44	; 0x2c
   b9b2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

000b9b34 <_ZN15Adafruit_SH110XC1EttP7TwoWireamm>:
Adafruit_SH110X::Adafruit_SH110X(uint16_t w, uint16_t h, TwoWire *twi,
   b9b34:	b530      	push	{r4, r5, lr}
   b9b36:	b085      	sub	sp, #20
   b9b38:	4604      	mov	r4, r0
    : Adafruit_GrayOLED(1, w, h, twi, rst_pin, clkDuring, clkAfter) {}
   b9b3a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   b9b3c:	9503      	str	r5, [sp, #12]
   b9b3e:	9d09      	ldr	r5, [sp, #36]	; 0x24
   b9b40:	9502      	str	r5, [sp, #8]
   b9b42:	f99d 5020 	ldrsb.w	r5, [sp, #32]
   b9b46:	e9cd 3500 	strd	r3, r5, [sp]
   b9b4a:	4613      	mov	r3, r2
   b9b4c:	460a      	mov	r2, r1
   b9b4e:	2101      	movs	r1, #1
   b9b50:	f7fd fbb2 	bl	b72b8 <_ZN17Adafruit_GrayOLEDC1EhttP7TwoWireamm>
   b9b54:	4b03      	ldr	r3, [pc, #12]	; (b9b64 <_ZN15Adafruit_SH110XC1EttP7TwoWireamm+0x30>)
   b9b56:	6023      	str	r3, [r4, #0]
   b9b58:	4620      	mov	r0, r4
   b9b5a:	2300      	movs	r3, #0
   b9b5c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
   b9b60:	b005      	add	sp, #20
   b9b62:	bd30      	pop	{r4, r5, pc}
   b9b64:	000c1af0 	.word	0x000c1af0

000b9b68 <_ZN15Adafruit_SH110XD1Ev>:
Adafruit_SH110X::~Adafruit_SH110X(void) {}
   b9b68:	b510      	push	{r4, lr}
   b9b6a:	4b03      	ldr	r3, [pc, #12]	; (b9b78 <_ZN15Adafruit_SH110XD1Ev+0x10>)
   b9b6c:	6003      	str	r3, [r0, #0]
   b9b6e:	4604      	mov	r4, r0
   b9b70:	f7fd fbc4 	bl	b72fc <_ZN17Adafruit_GrayOLEDD1Ev>
   b9b74:	4620      	mov	r0, r4
   b9b76:	bd10      	pop	{r4, pc}
   b9b78:	000c1af0 	.word	0x000c1af0

000b9b7c <_ZN15Adafruit_SH1107D1Ev>:
    : Adafruit_SH110X(w, h, spi, dc_pin, rst_pin, cs_pin, bitrate) {}

/*!
    @brief  Destructor for Adafruit_SH1107 object.
*/
Adafruit_SH1107::~Adafruit_SH1107(void) {}
   b9b7c:	b510      	push	{r4, lr}
   b9b7e:	4b03      	ldr	r3, [pc, #12]	; (b9b8c <_ZN15Adafruit_SH1107D1Ev+0x10>)
   b9b80:	6003      	str	r3, [r0, #0]
   b9b82:	4604      	mov	r4, r0
   b9b84:	f7ff fff0 	bl	b9b68 <_ZN15Adafruit_SH110XD1Ev>
   b9b88:	4620      	mov	r0, r4
   b9b8a:	bd10      	pop	{r4, pc}
   b9b8c:	000c1d2c 	.word	0x000c1d2c

000b9b90 <_ZN15Adafruit_SH1107D0Ev>:
   b9b90:	b510      	push	{r4, lr}
   b9b92:	4604      	mov	r4, r0
   b9b94:	f7ff fff2 	bl	b9b7c <_ZN15Adafruit_SH1107D1Ev>
   b9b98:	4620      	mov	r0, r4
   b9b9a:	2158      	movs	r1, #88	; 0x58
   b9b9c:	f7fa fa7f 	bl	b409e <_ZdlPvj>
   b9ba0:	4620      	mov	r0, r4
   b9ba2:	bd10      	pop	{r4, pc}

000b9ba4 <_ZN15Adafruit_SH1107C1EttP7TwoWireamm>:
Adafruit_SH1107::Adafruit_SH1107(uint16_t w, uint16_t h, TwoWire *twi,
   b9ba4:	b530      	push	{r4, r5, lr}
   b9ba6:	b085      	sub	sp, #20
   b9ba8:	4604      	mov	r4, r0
    : Adafruit_SH110X(w, h, twi, rst_pin, clkDuring, clkAfter) {}
   b9baa:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   b9bac:	9502      	str	r5, [sp, #8]
   b9bae:	9d09      	ldr	r5, [sp, #36]	; 0x24
   b9bb0:	9501      	str	r5, [sp, #4]
   b9bb2:	f99d 5020 	ldrsb.w	r5, [sp, #32]
   b9bb6:	9500      	str	r5, [sp, #0]
   b9bb8:	f7ff ffbc 	bl	b9b34 <_ZN15Adafruit_SH110XC1EttP7TwoWireamm>
   b9bbc:	4b02      	ldr	r3, [pc, #8]	; (b9bc8 <_ZN15Adafruit_SH1107C1EttP7TwoWireamm+0x24>)
   b9bbe:	6023      	str	r3, [r4, #0]
   b9bc0:	4620      	mov	r0, r4
   b9bc2:	b005      	add	sp, #20
   b9bc4:	bd30      	pop	{r4, r5, pc}
   b9bc6:	bf00      	nop
   b9bc8:	000c1d2c 	.word	0x000c1d2c

000b9bcc <_ZN15Adafruit_SH11075beginEhb>:
    @return true on successful allocation/init, false otherwise.
            Well-behaved code should check the return value before
            proceeding.
    @note   MUST call this function before any drawing or updates!
*/
bool Adafruit_SH1107::begin(uint8_t addr, bool reset) {
   b9bcc:	b530      	push	{r4, r5, lr}
   b9bce:	4604      	mov	r4, r0
   b9bd0:	b085      	sub	sp, #20

  Adafruit_GrayOLED::_init(addr, reset);
   b9bd2:	f7fd fc17 	bl	b7404 <_ZN17Adafruit_GrayOLED5_initEhb>

  setContrast(0x2F);
   b9bd6:	212f      	movs	r1, #47	; 0x2f
   b9bd8:	4620      	mov	r0, r4
   b9bda:	f7fd fc7c 	bl	b74d6 <_ZN17Adafruit_GrayOLED11setContrastEh>

  // the featherwing with 128x64 oled is 'rotated' so to make the splash right,
  // rotate!
  if (WIDTH == 64 && HEIGHT == 128) {
   b9bde:	68a2      	ldr	r2, [r4, #8]
   b9be0:	4b2f      	ldr	r3, [pc, #188]	; (b9ca0 <_ZN15Adafruit_SH11075beginEhb+0xd4>)
   b9be2:	429a      	cmp	r2, r3
   b9be4:	d121      	bne.n	b9c2a <_ZN15Adafruit_SH11075beginEhb+0x5e>
    setRotation(1);
   b9be6:	6823      	ldr	r3, [r4, #0]
   b9be8:	2101      	movs	r1, #1
   b9bea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b9bec:	4620      	mov	r0, r4
   b9bee:	4798      	blx	r3
    drawBitmap((HEIGHT - splash2_width) / 2, (WIDTH - splash2_height) / 2,
   b9bf0:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
   b9bf4:	f9b4 100a 	ldrsh.w	r1, [r4, #10]
   b9bf8:	2320      	movs	r3, #32
   b9bfa:	3a20      	subs	r2, #32
   b9bfc:	3973      	subs	r1, #115	; 0x73
   b9bfe:	2501      	movs	r5, #1
   b9c00:	e9cd 3501 	strd	r3, r5, [sp, #4]
   b9c04:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   b9c08:	2373      	movs	r3, #115	; 0x73
   b9c0a:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   b9c0e:	9300      	str	r3, [sp, #0]
   b9c10:	f341 014f 	sbfx	r1, r1, #1, #16
   b9c14:	4b23      	ldr	r3, [pc, #140]	; (b9ca4 <_ZN15Adafruit_SH11075beginEhb+0xd8>)
   b9c16:	4620      	mov	r0, r4
   b9c18:	f342 024f 	sbfx	r2, r2, #1, #16
   b9c1c:	f7fd ff8e 	bl	b7b3c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>
               splash2_data, splash2_width, splash2_height, 1);
    setRotation(0);
   b9c20:	6823      	ldr	r3, [r4, #0]
   b9c22:	2100      	movs	r1, #0
   b9c24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b9c26:	4620      	mov	r0, r4
   b9c28:	4798      	blx	r3
  }
  if (WIDTH == 128 && HEIGHT == 128) {
   b9c2a:	68a3      	ldr	r3, [r4, #8]
   b9c2c:	f1b3 1f80 	cmp.w	r3, #8388736	; 0x800080
   b9c30:	d117      	bne.n	b9c62 <_ZN15Adafruit_SH11075beginEhb+0x96>
    drawBitmap((HEIGHT - splash2_width) / 2, (WIDTH - splash2_height) / 2,
   b9c32:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
   b9c36:	f9b4 100a 	ldrsh.w	r1, [r4, #10]
   b9c3a:	2320      	movs	r3, #32
   b9c3c:	2001      	movs	r0, #1
   b9c3e:	3a20      	subs	r2, #32
   b9c40:	3973      	subs	r1, #115	; 0x73
   b9c42:	e9cd 3001 	strd	r3, r0, [sp, #4]
   b9c46:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   b9c4a:	2373      	movs	r3, #115	; 0x73
   b9c4c:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
   b9c50:	9300      	str	r3, [sp, #0]
   b9c52:	f342 024f 	sbfx	r2, r2, #1, #16
   b9c56:	4b13      	ldr	r3, [pc, #76]	; (b9ca4 <_ZN15Adafruit_SH11075beginEhb+0xd8>)
   b9c58:	f341 014f 	sbfx	r1, r1, #1, #16
   b9c5c:	4620      	mov	r0, r4
   b9c5e:	f7fd ff6d 	bl	b7b3c <_ZN12Adafruit_GFX10drawBitmapEssPKhsst>
      SH110X_DISPLAYALLON_RESUME, // 0xa4
      SH110X_NORMALDISPLAY,       // 0xa6
  };
  // clang-format on

  if (!oled_commandList(init, sizeof(init))) {
   b9c62:	4911      	ldr	r1, [pc, #68]	; (b9ca8 <_ZN15Adafruit_SH11075beginEhb+0xdc>)
   b9c64:	2216      	movs	r2, #22
   b9c66:	4620      	mov	r0, r4
   b9c68:	f7fd fb8f 	bl	b738a <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh>
   b9c6c:	4605      	mov	r5, r0
   b9c6e:	b918      	cbnz	r0, b9c78 <_ZN15Adafruit_SH11075beginEhb+0xac>
    return false;
   b9c70:	2500      	movs	r5, #0

  delay(100);                     // 100ms delay recommended
  oled_command(SH110X_DISPLAYON); // 0xaf

  return true; // Success
}
   b9c72:	4628      	mov	r0, r5
   b9c74:	b005      	add	sp, #20
   b9c76:	bd30      	pop	{r4, r5, pc}
  if (WIDTH == 128 && HEIGHT == 128) {
   b9c78:	68a3      	ldr	r3, [r4, #8]
   b9c7a:	f1b3 1f80 	cmp.w	r3, #8388736	; 0x800080
   b9c7e:	d007      	beq.n	b9c90 <_ZN15Adafruit_SH11075beginEhb+0xc4>
  delay(100);                     // 100ms delay recommended
   b9c80:	2064      	movs	r0, #100	; 0x64
   b9c82:	f003 fae9 	bl	bd258 <delay>
  oled_command(SH110X_DISPLAYON); // 0xaf
   b9c86:	21af      	movs	r1, #175	; 0xaf
   b9c88:	4620      	mov	r0, r4
   b9c8a:	f7fd fb53 	bl	b7334 <_ZN17Adafruit_GrayOLED12oled_commandEh>
  return true; // Success
   b9c8e:	e7f0      	b.n	b9c72 <_ZN15Adafruit_SH11075beginEhb+0xa6>
    if (!oled_commandList(init_128x128, sizeof(init_128x128))) {
   b9c90:	4906      	ldr	r1, [pc, #24]	; (b9cac <_ZN15Adafruit_SH11075beginEhb+0xe0>)
   b9c92:	2204      	movs	r2, #4
   b9c94:	4620      	mov	r0, r4
   b9c96:	f7fd fb78 	bl	b738a <_ZN17Adafruit_GrayOLED16oled_commandListEPKhh>
   b9c9a:	2800      	cmp	r0, #0
   b9c9c:	d1f0      	bne.n	b9c80 <_ZN15Adafruit_SH11075beginEhb+0xb4>
   b9c9e:	e7e7      	b.n	b9c70 <_ZN15Adafruit_SH11075beginEhb+0xa4>
   b9ca0:	00800040 	.word	0x00800040
   b9ca4:	000c1b44 	.word	0x000c1b44
   b9ca8:	000c1d84 	.word	0x000c1d84
   b9cac:	000c1d80 	.word	0x000c1d80

000b9cb0 <netdb_freeaddrinfo>:

DYNALIB_BEGIN(hal_netdb)

DYNALIB_FN(0, hal_netdb, netdb_gethostbyname, struct hostent*(const char*))
DYNALIB_FN(1, hal_netdb, netdb_gethostbyname_r, int(const char*, struct hostent*, char*, size_t, struct hostent**, int*))
DYNALIB_FN(2, hal_netdb, netdb_freeaddrinfo, void(struct addrinfo*))
   b9cb0:	b508      	push	{r3, lr}
   b9cb2:	4b02      	ldr	r3, [pc, #8]	; (b9cbc <netdb_freeaddrinfo+0xc>)
   b9cb4:	681b      	ldr	r3, [r3, #0]
   b9cb6:	689b      	ldr	r3, [r3, #8]
   b9cb8:	9301      	str	r3, [sp, #4]
   b9cba:	bd08      	pop	{r3, pc}
   b9cbc:	00030268 	.word	0x00030268

000b9cc0 <netdb_getaddrinfo>:
DYNALIB_FN(3, hal_netdb, netdb_getaddrinfo, int(const char*, const char*, const struct addrinfo*, struct addrinfo**))
   b9cc0:	b508      	push	{r3, lr}
   b9cc2:	4b02      	ldr	r3, [pc, #8]	; (b9ccc <netdb_getaddrinfo+0xc>)
   b9cc4:	681b      	ldr	r3, [r3, #0]
   b9cc6:	68db      	ldr	r3, [r3, #12]
   b9cc8:	9301      	str	r3, [sp, #4]
   b9cca:	bd08      	pop	{r3, pc}
   b9ccc:	00030268 	.word	0x00030268

000b9cd0 <HAL_Validate_Pin_Function>:
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
   b9cd0:	b508      	push	{r3, lr}
   b9cd2:	4b02      	ldr	r3, [pc, #8]	; (b9cdc <HAL_Validate_Pin_Function+0xc>)
   b9cd4:	681b      	ldr	r3, [r3, #0]
   b9cd6:	685b      	ldr	r3, [r3, #4]
   b9cd8:	9301      	str	r3, [sp, #4]
   b9cda:	bd08      	pop	{r3, pc}
   b9cdc:	0003022c 	.word	0x0003022c

000b9ce0 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
   b9ce0:	b508      	push	{r3, lr}
   b9ce2:	4b02      	ldr	r3, [pc, #8]	; (b9cec <HAL_Pin_Mode+0xc>)
   b9ce4:	681b      	ldr	r3, [r3, #0]
   b9ce6:	689b      	ldr	r3, [r3, #8]
   b9ce8:	9301      	str	r3, [sp, #4]
   b9cea:	bd08      	pop	{r3, pc}
   b9cec:	0003022c 	.word	0x0003022c

000b9cf0 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
   b9cf0:	b508      	push	{r3, lr}
   b9cf2:	4b02      	ldr	r3, [pc, #8]	; (b9cfc <HAL_Get_Pin_Mode+0xc>)
   b9cf4:	681b      	ldr	r3, [r3, #0]
   b9cf6:	68db      	ldr	r3, [r3, #12]
   b9cf8:	9301      	str	r3, [sp, #4]
   b9cfa:	bd08      	pop	{r3, pc}
   b9cfc:	0003022c 	.word	0x0003022c

000b9d00 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
   b9d00:	b508      	push	{r3, lr}
   b9d02:	4b02      	ldr	r3, [pc, #8]	; (b9d0c <HAL_GPIO_Write+0xc>)
   b9d04:	681b      	ldr	r3, [r3, #0]
   b9d06:	691b      	ldr	r3, [r3, #16]
   b9d08:	9301      	str	r3, [sp, #4]
   b9d0a:	bd08      	pop	{r3, pc}
   b9d0c:	0003022c 	.word	0x0003022c

000b9d10 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
   b9d10:	b508      	push	{r3, lr}
   b9d12:	4b02      	ldr	r3, [pc, #8]	; (b9d1c <HAL_GPIO_Read+0xc>)
   b9d14:	681b      	ldr	r3, [r3, #0]
   b9d16:	695b      	ldr	r3, [r3, #20]
   b9d18:	9301      	str	r3, [sp, #4]
   b9d1a:	bd08      	pop	{r3, pc}
   b9d1c:	0003022c 	.word	0x0003022c

000b9d20 <HAL_Interrupts_Attach>:
DYNALIB_FN(6, hal_gpio, HAL_Interrupts_Attach, int(uint16_t, HAL_InterruptHandler, void*, InterruptMode, HAL_InterruptExtraConfiguration*))
   b9d20:	b508      	push	{r3, lr}
   b9d22:	4b02      	ldr	r3, [pc, #8]	; (b9d2c <HAL_Interrupts_Attach+0xc>)
   b9d24:	681b      	ldr	r3, [r3, #0]
   b9d26:	699b      	ldr	r3, [r3, #24]
   b9d28:	9301      	str	r3, [sp, #4]
   b9d2a:	bd08      	pop	{r3, pc}
   b9d2c:	0003022c 	.word	0x0003022c

000b9d30 <HAL_Interrupts_Detach>:
DYNALIB_FN(7, hal_gpio, HAL_Interrupts_Detach, int(uint16_t))
   b9d30:	b508      	push	{r3, lr}
   b9d32:	4b02      	ldr	r3, [pc, #8]	; (b9d3c <HAL_Interrupts_Detach+0xc>)
   b9d34:	681b      	ldr	r3, [r3, #0]
   b9d36:	69db      	ldr	r3, [r3, #28]
   b9d38:	9301      	str	r3, [sp, #4]
   b9d3a:	bd08      	pop	{r3, pc}
   b9d3c:	0003022c 	.word	0x0003022c

000b9d40 <hal_adc_read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, hal_adc_set_sample_time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, hal_adc_read, int32_t(uint16_t))
   b9d40:	b508      	push	{r3, lr}
   b9d42:	4b02      	ldr	r3, [pc, #8]	; (b9d4c <hal_adc_read+0xc>)
   b9d44:	681b      	ldr	r3, [r3, #0]
   b9d46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   b9d48:	9301      	str	r3, [sp, #4]
   b9d4a:	bd08      	pop	{r3, pc}
   b9d4c:	0003022c 	.word	0x0003022c

000b9d50 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > PLATFORM_GCC
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
   b9d50:	b508      	push	{r3, lr}
   b9d52:	4b02      	ldr	r3, [pc, #8]	; (b9d5c <HAL_RNG_GetRandomNumber+0xc>)
   b9d54:	681b      	ldr	r3, [r3, #0]
   b9d56:	685b      	ldr	r3, [r3, #4]
   b9d58:	9301      	str	r3, [sp, #4]
   b9d5a:	bd08      	pop	{r3, pc}
   b9d5c:	00030218 	.word	0x00030218

000b9d60 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif // PLATFORM_ID > PLATFORM_GCC

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
   b9d60:	b508      	push	{r3, lr}
   b9d62:	4b02      	ldr	r3, [pc, #8]	; (b9d6c <HAL_Delay_Microseconds+0xc>)
   b9d64:	681b      	ldr	r3, [r3, #0]
   b9d66:	68db      	ldr	r3, [r3, #12]
   b9d68:	9301      	str	r3, [sp, #4]
   b9d6a:	bd08      	pop	{r3, pc}
   b9d6c:	00030218 	.word	0x00030218

000b9d70 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
   b9d70:	b508      	push	{r3, lr}
   b9d72:	4b02      	ldr	r3, [pc, #8]	; (b9d7c <HAL_Timer_Get_Micro_Seconds+0xc>)
   b9d74:	681b      	ldr	r3, [r3, #0]
   b9d76:	691b      	ldr	r3, [r3, #16]
   b9d78:	9301      	str	r3, [sp, #4]
   b9d7a:	bd08      	pop	{r3, pc}
   b9d7c:	00030218 	.word	0x00030218

000b9d80 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
   b9d80:	b508      	push	{r3, lr}
   b9d82:	4b02      	ldr	r3, [pc, #8]	; (b9d8c <HAL_Timer_Get_Milli_Seconds+0xc>)
   b9d84:	681b      	ldr	r3, [r3, #0]
   b9d86:	695b      	ldr	r3, [r3, #20]
   b9d88:	9301      	str	r3, [sp, #4]
   b9d8a:	bd08      	pop	{r3, pc}
   b9d8c:	00030218 	.word	0x00030218

000b9d90 <hal_rtc_time_is_valid>:
DYNALIB_FN(BASE_IDX + 15, hal, HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal, HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal, HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal, HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal, HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, hal_rtc_time_is_valid, bool(void*))
   b9d90:	b508      	push	{r3, lr}
   b9d92:	4b02      	ldr	r3, [pc, #8]	; (b9d9c <hal_rtc_time_is_valid+0xc>)
   b9d94:	681b      	ldr	r3, [r3, #0]
   b9d96:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   b9d98:	9301      	str	r3, [sp, #4]
   b9d9a:	bd08      	pop	{r3, pc}
   b9d9c:	00030218 	.word	0x00030218

000b9da0 <hal_rtc_get_time>:

DYNALIB_FN(BASE_IDX + 21, hal, hal_timer_millis, uint64_t(void*))
DYNALIB_FN(BASE_IDX + 22, hal, hal_timer_micros, uint64_t(void*))

DYNALIB_FN(BASE_IDX + 23, hal, hal_rtc_get_time, int(struct timeval*, void*))
   b9da0:	b508      	push	{r3, lr}
   b9da2:	4b02      	ldr	r3, [pc, #8]	; (b9dac <hal_rtc_get_time+0xc>)
   b9da4:	681b      	ldr	r3, [r3, #0]
   b9da6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
   b9da8:	9301      	str	r3, [sp, #4]
   b9daa:	bd08      	pop	{r3, pc}
   b9dac:	00030218 	.word	0x00030218

000b9db0 <hal_ble_stack_init>:

DYNALIB_BEGIN(hal_ble)

DYNALIB_FN(0, hal_ble, hal_ble_lock, int(void*))
DYNALIB_FN(1, hal_ble, hal_ble_unlock, int(void*))
DYNALIB_FN(2, hal_ble, hal_ble_stack_init, int(void*))
   b9db0:	b508      	push	{r3, lr}
   b9db2:	4b02      	ldr	r3, [pc, #8]	; (b9dbc <hal_ble_stack_init+0xc>)
   b9db4:	681b      	ldr	r3, [r3, #0]
   b9db6:	689b      	ldr	r3, [r3, #8]
   b9db8:	9301      	str	r3, [sp, #4]
   b9dba:	bd08      	pop	{r3, pc}
   b9dbc:	00030278 	.word	0x00030278

000b9dc0 <hal_ble_gap_set_tx_power>:
DYNALIB_FN(11, hal_ble, hal_ble_gap_get_appearance, int(ble_sig_appearance_t*, void*))
DYNALIB_FN(12, hal_ble, hal_ble_gap_set_ppcp, int(const hal_ble_conn_params_t*, void*))
DYNALIB_FN(13, hal_ble, hal_ble_gap_get_ppcp, int(hal_ble_conn_params_t*, void*))
DYNALIB_FN(14, hal_ble, hal_ble_gap_add_whitelist, int(const hal_ble_addr_t*, size_t, void*))
DYNALIB_FN(15, hal_ble, hal_ble_gap_delete_whitelist, int(void*))
DYNALIB_FN(16, hal_ble, hal_ble_gap_set_tx_power, int(int8_t, void*))
   b9dc0:	b508      	push	{r3, lr}
   b9dc2:	4b02      	ldr	r3, [pc, #8]	; (b9dcc <hal_ble_gap_set_tx_power+0xc>)
   b9dc4:	681b      	ldr	r3, [r3, #0]
   b9dc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   b9dc8:	9301      	str	r3, [sp, #4]
   b9dca:	bd08      	pop	{r3, pc}
   b9dcc:	00030278 	.word	0x00030278

000b9dd0 <hal_ble_gap_set_scan_parameters>:
DYNALIB_FN(24, hal_ble, hal_ble_gap_start_advertising, int(void*))
DYNALIB_FN(25, hal_ble, hal_ble_gap_set_auto_advertise, int(hal_ble_auto_adv_cfg_t, void*))
DYNALIB_FN(26, hal_ble, hal_ble_gap_get_auto_advertise, int(hal_ble_auto_adv_cfg_t*, void*))
DYNALIB_FN(27, hal_ble, hal_ble_gap_stop_advertising, int(void*))
DYNALIB_FN(28, hal_ble, hal_ble_gap_is_advertising, bool(void*))
DYNALIB_FN(29, hal_ble, hal_ble_gap_set_scan_parameters, int(const hal_ble_scan_params_t*, void*))
   b9dd0:	b508      	push	{r3, lr}
   b9dd2:	4b02      	ldr	r3, [pc, #8]	; (b9ddc <hal_ble_gap_set_scan_parameters+0xc>)
   b9dd4:	681b      	ldr	r3, [r3, #0]
   b9dd6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   b9dd8:	9301      	str	r3, [sp, #4]
   b9dda:	bd08      	pop	{r3, pc}
   b9ddc:	00030278 	.word	0x00030278

000b9de0 <hal_ble_gap_get_scan_parameters>:
DYNALIB_FN(30, hal_ble, hal_ble_gap_get_scan_parameters, int(hal_ble_scan_params_t*, void*))
   b9de0:	b508      	push	{r3, lr}
   b9de2:	4b02      	ldr	r3, [pc, #8]	; (b9dec <hal_ble_gap_get_scan_parameters+0xc>)
   b9de4:	681b      	ldr	r3, [r3, #0]
   b9de6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   b9de8:	9301      	str	r3, [sp, #4]
   b9dea:	bd08      	pop	{r3, pc}
   b9dec:	00030278 	.word	0x00030278

000b9df0 <hal_ble_gap_start_scan>:
DYNALIB_FN(31, hal_ble, hal_ble_gap_start_scan, int(hal_ble_on_scan_result_cb_t, void*, void*))
   b9df0:	b508      	push	{r3, lr}
   b9df2:	4b02      	ldr	r3, [pc, #8]	; (b9dfc <hal_ble_gap_start_scan+0xc>)
   b9df4:	681b      	ldr	r3, [r3, #0]
   b9df6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   b9df8:	9301      	str	r3, [sp, #4]
   b9dfa:	bd08      	pop	{r3, pc}
   b9dfc:	00030278 	.word	0x00030278

000b9e00 <hal_ble_gap_stop_scan>:
DYNALIB_FN(32, hal_ble, hal_ble_gap_is_scanning, bool(void*))
DYNALIB_FN(33, hal_ble, hal_ble_gap_stop_scan, int(void*))
   b9e00:	b508      	push	{r3, lr}
   b9e02:	4b03      	ldr	r3, [pc, #12]	; (b9e10 <hal_ble_gap_stop_scan+0x10>)
   b9e04:	681b      	ldr	r3, [r3, #0]
   b9e06:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   b9e0a:	9301      	str	r3, [sp, #4]
   b9e0c:	bd08      	pop	{r3, pc}
   b9e0e:	0000      	.short	0x0000
   b9e10:	00030278 	.word	0x00030278

000b9e14 <hal_ble_gap_disconnect>:
DYNALIB_FN(34, hal_ble, hal_ble_gap_connect_deprecated, int(const hal_ble_addr_t*, void*))
DYNALIB_FN(35, hal_ble, hal_ble_gap_is_connecting, bool(const hal_ble_addr_t*, void*))
DYNALIB_FN(36, hal_ble, hal_ble_gap_is_connected, bool(const hal_ble_addr_t*, void*))
DYNALIB_FN(37, hal_ble, hal_ble_gap_connect_cancel, int(const hal_ble_addr_t*, void*))
DYNALIB_FN(38, hal_ble, hal_ble_gap_disconnect, int(hal_ble_conn_handle_t, void*))
   b9e14:	b508      	push	{r3, lr}
   b9e16:	4b03      	ldr	r3, [pc, #12]	; (b9e24 <hal_ble_gap_disconnect+0x10>)
   b9e18:	681b      	ldr	r3, [r3, #0]
   b9e1a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   b9e1e:	9301      	str	r3, [sp, #4]
   b9e20:	bd08      	pop	{r3, pc}
   b9e22:	0000      	.short	0x0000
   b9e24:	00030278 	.word	0x00030278

000b9e28 <hal_ble_gatt_server_set_characteristic_value>:
DYNALIB_FN(40, hal_ble, hal_ble_gap_get_connection_params_deprecated, int(hal_ble_conn_handle_t, hal_ble_conn_params_t*, void*))
DYNALIB_FN(41, hal_ble, hal_ble_gap_get_rssi, int(hal_ble_conn_handle_t, void*))
DYNALIB_FN(42, hal_ble, hal_ble_gatt_server_add_service, int(uint8_t, const hal_ble_uuid_t*, hal_ble_attr_handle_t*, void*))
DYNALIB_FN(43, hal_ble, hal_ble_gatt_server_add_characteristic_deprecated, int(const hal_ble_char_init_deprecated_t*, hal_ble_char_handles_t*, void*))
DYNALIB_FN(44, hal_ble, hal_ble_gatt_server_add_descriptor, int(const hal_ble_desc_init_t*, hal_ble_attr_handle_t*, void*))
DYNALIB_FN(45, hal_ble, hal_ble_gatt_server_set_characteristic_value, ssize_t(hal_ble_attr_handle_t, const uint8_t*, size_t, void*))
   b9e28:	b508      	push	{r3, lr}
   b9e2a:	4b03      	ldr	r3, [pc, #12]	; (b9e38 <hal_ble_gatt_server_set_characteristic_value+0x10>)
   b9e2c:	681b      	ldr	r3, [r3, #0]
   b9e2e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
   b9e32:	9301      	str	r3, [sp, #4]
   b9e34:	bd08      	pop	{r3, pc}
   b9e36:	0000      	.short	0x0000
   b9e38:	00030278 	.word	0x00030278

000b9e3c <hal_ble_gatt_client_discover_all_services>:
DYNALIB_FN(46, hal_ble, hal_ble_gatt_server_get_characteristic_value, ssize_t(hal_ble_attr_handle_t, uint8_t*, size_t, void*))
DYNALIB_FN(47, hal_ble, hal_ble_gatt_client_discover_all_services, int(hal_ble_conn_handle_t, hal_ble_on_disc_service_cb_t, void*, void*))
   b9e3c:	b508      	push	{r3, lr}
   b9e3e:	4b03      	ldr	r3, [pc, #12]	; (b9e4c <hal_ble_gatt_client_discover_all_services+0x10>)
   b9e40:	681b      	ldr	r3, [r3, #0]
   b9e42:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
   b9e46:	9301      	str	r3, [sp, #4]
   b9e48:	bd08      	pop	{r3, pc}
   b9e4a:	0000      	.short	0x0000
   b9e4c:	00030278 	.word	0x00030278

000b9e50 <hal_ble_gatt_client_discover_characteristics>:
DYNALIB_FN(48, hal_ble, hal_ble_gatt_client_discover_service_by_uuid, int(hal_ble_conn_handle_t, const hal_ble_uuid_t*, hal_ble_on_disc_service_cb_t, void*, void*))
DYNALIB_FN(49, hal_ble, hal_ble_gatt_client_discover_characteristics, int(hal_ble_conn_handle_t, const hal_ble_svc_t*, hal_ble_on_disc_char_cb_t, void*, void*))
   b9e50:	b508      	push	{r3, lr}
   b9e52:	4b03      	ldr	r3, [pc, #12]	; (b9e60 <hal_ble_gatt_client_discover_characteristics+0x10>)
   b9e54:	681b      	ldr	r3, [r3, #0]
   b9e56:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
   b9e5a:	9301      	str	r3, [sp, #4]
   b9e5c:	bd08      	pop	{r3, pc}
   b9e5e:	0000      	.short	0x0000
   b9e60:	00030278 	.word	0x00030278

000b9e64 <hal_ble_gatt_client_write_with_response>:
DYNALIB_FN(50, hal_ble, hal_ble_gatt_client_discover_characteristics_by_uuid, int(hal_ble_conn_handle_t, const hal_ble_svc_t*, const hal_ble_uuid_t*, hal_ble_on_disc_char_cb_t, void*, void*))
DYNALIB_FN(51, hal_ble, hal_ble_gatt_client_is_discovering, bool(hal_ble_conn_handle_t, void*))
DYNALIB_FN(52, hal_ble, hal_ble_gatt_server_set_desired_att_mtu, int(size_t, void*))
DYNALIB_FN(53, hal_ble, hal_ble_gatt_client_configure_cccd_deprecated, int(hal_ble_conn_handle_t, hal_ble_attr_handle_t, ble_sig_cccd_value_t, void*))
DYNALIB_FN(54, hal_ble, hal_ble_gatt_client_write_with_response, ssize_t(hal_ble_conn_handle_t, hal_ble_attr_handle_t, const uint8_t*, size_t, void*))
   b9e64:	b508      	push	{r3, lr}
   b9e66:	4b03      	ldr	r3, [pc, #12]	; (b9e74 <hal_ble_gatt_client_write_with_response+0x10>)
   b9e68:	681b      	ldr	r3, [r3, #0]
   b9e6a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
   b9e6e:	9301      	str	r3, [sp, #4]
   b9e70:	bd08      	pop	{r3, pc}
   b9e72:	0000      	.short	0x0000
   b9e74:	00030278 	.word	0x00030278

000b9e78 <hal_ble_gatt_client_write_without_response>:
DYNALIB_FN(55, hal_ble, hal_ble_gatt_client_write_without_response, ssize_t(hal_ble_conn_handle_t, hal_ble_attr_handle_t, const uint8_t*, size_t, void*))
   b9e78:	b508      	push	{r3, lr}
   b9e7a:	4b03      	ldr	r3, [pc, #12]	; (b9e88 <hal_ble_gatt_client_write_without_response+0x10>)
   b9e7c:	681b      	ldr	r3, [r3, #0]
   b9e7e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
   b9e82:	9301      	str	r3, [sp, #4]
   b9e84:	bd08      	pop	{r3, pc}
   b9e86:	0000      	.short	0x0000
   b9e88:	00030278 	.word	0x00030278

000b9e8c <hal_ble_gatt_client_read>:
DYNALIB_FN(56, hal_ble, hal_ble_gatt_client_read, ssize_t(hal_ble_conn_handle_t, hal_ble_attr_handle_t, uint8_t*, size_t, void*))
   b9e8c:	b508      	push	{r3, lr}
   b9e8e:	4b03      	ldr	r3, [pc, #12]	; (b9e9c <hal_ble_gatt_client_read+0x10>)
   b9e90:	681b      	ldr	r3, [r3, #0]
   b9e92:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
   b9e96:	9301      	str	r3, [sp, #4]
   b9e98:	bd08      	pop	{r3, pc}
   b9e9a:	0000      	.short	0x0000
   b9e9c:	00030278 	.word	0x00030278

000b9ea0 <hal_ble_gap_connect>:

DYNALIB_FN(57, hal_ble, hal_ble_gap_connect, int(const hal_ble_conn_cfg_t*, hal_ble_conn_handle_t*, void*))
   b9ea0:	b508      	push	{r3, lr}
   b9ea2:	4b03      	ldr	r3, [pc, #12]	; (b9eb0 <hal_ble_gap_connect+0x10>)
   b9ea4:	681b      	ldr	r3, [r3, #0]
   b9ea6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
   b9eaa:	9301      	str	r3, [sp, #4]
   b9eac:	bd08      	pop	{r3, pc}
   b9eae:	0000      	.short	0x0000
   b9eb0:	00030278 	.word	0x00030278

000b9eb4 <hal_ble_set_callback_on_periph_link_events>:
DYNALIB_FN(58, hal_ble, hal_ble_gap_get_connection_info, int(hal_ble_conn_handle_t, hal_ble_conn_info_t*, void*))
DYNALIB_FN(59, hal_ble, hal_ble_gatt_server_add_characteristic, int(const hal_ble_char_init_t*, hal_ble_char_handles_t*, void*))
DYNALIB_FN(60, hal_ble, hal_ble_set_callback_on_periph_link_events, int(hal_ble_on_link_evt_cb_t, void*, void*))
   b9eb4:	b508      	push	{r3, lr}
   b9eb6:	4b03      	ldr	r3, [pc, #12]	; (b9ec4 <hal_ble_set_callback_on_periph_link_events+0x10>)
   b9eb8:	681b      	ldr	r3, [r3, #0]
   b9eba:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
   b9ebe:	9301      	str	r3, [sp, #4]
   b9ec0:	bd08      	pop	{r3, pc}
   b9ec2:	0000      	.short	0x0000
   b9ec4:	00030278 	.word	0x00030278

000b9ec8 <hal_ble_gatt_client_configure_cccd>:
DYNALIB_FN(61, hal_ble, hal_ble_gatt_client_configure_cccd, int(const hal_ble_cccd_config_t*, void*))
   b9ec8:	b508      	push	{r3, lr}
   b9eca:	4b03      	ldr	r3, [pc, #12]	; (b9ed8 <hal_ble_gatt_client_configure_cccd+0x10>)
   b9ecc:	681b      	ldr	r3, [r3, #0]
   b9ece:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
   b9ed2:	9301      	str	r3, [sp, #4]
   b9ed4:	bd08      	pop	{r3, pc}
   b9ed6:	0000      	.short	0x0000
   b9ed8:	00030278 	.word	0x00030278

000b9edc <hal_ble_gatt_server_notify_characteristic_value>:
DYNALIB_FN(62, hal_ble, hal_ble_set_callback_on_adv_events, int(hal_ble_on_adv_evt_cb_t, void*, void*))
DYNALIB_FN(63, hal_ble, hal_ble_cancel_callback_on_adv_events, int(hal_ble_on_adv_evt_cb_t, void*, void*))
DYNALIB_FN(64, hal_ble, hal_ble_gatt_server_notify_characteristic_value, ssize_t(hal_ble_attr_handle_t, const uint8_t*, size_t, void*))
   b9edc:	b508      	push	{r3, lr}
   b9ede:	4b03      	ldr	r3, [pc, #12]	; (b9eec <hal_ble_gatt_server_notify_characteristic_value+0x10>)
   b9ee0:	681b      	ldr	r3, [r3, #0]
   b9ee2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
   b9ee6:	9301      	str	r3, [sp, #4]
   b9ee8:	bd08      	pop	{r3, pc}
   b9eea:	0000      	.short	0x0000
   b9eec:	00030278 	.word	0x00030278

000b9ef0 <hal_ble_gatt_server_indicate_characteristic_value>:
DYNALIB_FN(65, hal_ble, hal_ble_gatt_server_indicate_characteristic_value, ssize_t(hal_ble_attr_handle_t, const uint8_t*, size_t, void*))
   b9ef0:	b508      	push	{r3, lr}
   b9ef2:	4b03      	ldr	r3, [pc, #12]	; (b9f00 <hal_ble_gatt_server_indicate_characteristic_value+0x10>)
   b9ef4:	681b      	ldr	r3, [r3, #0]
   b9ef6:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   b9efa:	9301      	str	r3, [sp, #4]
   b9efc:	bd08      	pop	{r3, pc}
   b9efe:	0000      	.short	0x0000
   b9f00:	00030278 	.word	0x00030278

000b9f04 <os_thread_yield>:

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
   b9f04:	b508      	push	{r3, lr}
   b9f06:	4b02      	ldr	r3, [pc, #8]	; (b9f10 <os_thread_yield+0xc>)
   b9f08:	681b      	ldr	r3, [r3, #0]
   b9f0a:	68db      	ldr	r3, [r3, #12]
   b9f0c:	9301      	str	r3, [sp, #4]
   b9f0e:	bd08      	pop	{r3, pc}
   b9f10:	00030248 	.word	0x00030248

000b9f14 <os_thread_scheduling>:
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))
   b9f14:	b508      	push	{r3, lr}
   b9f16:	4b02      	ldr	r3, [pc, #8]	; (b9f20 <os_thread_scheduling+0xc>)
   b9f18:	681b      	ldr	r3, [r3, #0]
   b9f1a:	69db      	ldr	r3, [r3, #28]
   b9f1c:	9301      	str	r3, [sp, #4]
   b9f1e:	bd08      	pop	{r3, pc}
   b9f20:	00030248 	.word	0x00030248

000b9f24 <os_timer_create>:

DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
   b9f24:	b508      	push	{r3, lr}
   b9f26:	4b02      	ldr	r3, [pc, #8]	; (b9f30 <os_timer_create+0xc>)
   b9f28:	681b      	ldr	r3, [r3, #0]
   b9f2a:	6a1b      	ldr	r3, [r3, #32]
   b9f2c:	9301      	str	r3, [sp, #4]
   b9f2e:	bd08      	pop	{r3, pc}
   b9f30:	00030248 	.word	0x00030248

000b9f34 <os_timer_destroy>:
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
   b9f34:	b508      	push	{r3, lr}
   b9f36:	4b02      	ldr	r3, [pc, #8]	; (b9f40 <os_timer_destroy+0xc>)
   b9f38:	681b      	ldr	r3, [r3, #0]
   b9f3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   b9f3c:	9301      	str	r3, [sp, #4]
   b9f3e:	bd08      	pop	{r3, pc}
   b9f40:	00030248 	.word	0x00030248

000b9f44 <os_timer_get_id>:
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
   b9f44:	b508      	push	{r3, lr}
   b9f46:	4b02      	ldr	r3, [pc, #8]	; (b9f50 <os_timer_get_id+0xc>)
   b9f48:	681b      	ldr	r3, [r3, #0]
   b9f4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   b9f4c:	9301      	str	r3, [sp, #4]
   b9f4e:	bd08      	pop	{r3, pc}
   b9f50:	00030248 	.word	0x00030248

000b9f54 <os_timer_change>:
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))
   b9f54:	b508      	push	{r3, lr}
   b9f56:	4b02      	ldr	r3, [pc, #8]	; (b9f60 <os_timer_change+0xc>)
   b9f58:	681b      	ldr	r3, [r3, #0]
   b9f5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   b9f5c:	9301      	str	r3, [sp, #4]
   b9f5e:	bd08      	pop	{r3, pc}
   b9f60:	00030248 	.word	0x00030248

000b9f64 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
   b9f64:	b508      	push	{r3, lr}
   b9f66:	4b02      	ldr	r3, [pc, #8]	; (b9f70 <os_mutex_recursive_create+0xc>)
   b9f68:	681b      	ldr	r3, [r3, #0]
   b9f6a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   b9f6c:	9301      	str	r3, [sp, #4]
   b9f6e:	bd08      	pop	{r3, pc}
   b9f70:	00030248 	.word	0x00030248

000b9f74 <os_mutex_recursive_lock>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
   b9f74:	b508      	push	{r3, lr}
   b9f76:	4b02      	ldr	r3, [pc, #8]	; (b9f80 <os_mutex_recursive_lock+0xc>)
   b9f78:	681b      	ldr	r3, [r3, #0]
   b9f7a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   b9f7c:	9301      	str	r3, [sp, #4]
   b9f7e:	bd08      	pop	{r3, pc}
   b9f80:	00030248 	.word	0x00030248

000b9f84 <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
   b9f84:	b508      	push	{r3, lr}
   b9f86:	4b02      	ldr	r3, [pc, #8]	; (b9f90 <os_mutex_recursive_unlock+0xc>)
   b9f88:	681b      	ldr	r3, [r3, #0]
   b9f8a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   b9f8c:	9301      	str	r3, [sp, #4]
   b9f8e:	bd08      	pop	{r3, pc}
   b9f90:	00030248 	.word	0x00030248

000b9f94 <os_timer_set_id>:
DYNALIB_FN(24, hal_concurrent, os_queue_destroy, int(os_queue_t, void*))
DYNALIB_FN(25, hal_concurrent, os_queue_put, int(os_queue_t, const void* item, system_tick_t, void*))
DYNALIB_FN(26, hal_concurrent, os_queue_take, int(os_queue_t, void* item, system_tick_t, void*))
DYNALIB_FN(27, hal_concurrent, os_thread_exit, os_result_t(os_thread_t))

DYNALIB_FN(28, hal_concurrent, os_timer_set_id, int(os_timer_t, void*))
   b9f94:	b508      	push	{r3, lr}
   b9f96:	4b02      	ldr	r3, [pc, #8]	; (b9fa0 <os_timer_set_id+0xc>)
   b9f98:	681b      	ldr	r3, [r3, #0]
   b9f9a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   b9f9c:	9301      	str	r3, [sp, #4]
   b9f9e:	bd08      	pop	{r3, pc}
   b9fa0:	00030248 	.word	0x00030248

000b9fa4 <inet_inet_ntop>:
DYNALIB_FN(0, hal_inet, inet_inet_addr, in_addr_t(const char*))
DYNALIB_FN(1, hal_inet, inet_inet_aton, int(const char*, struct in_addr*))
DYNALIB_FN(2, hal_inet, inet_inet_network, in_addr_t(const char*))
DYNALIB_FN(3, hal_inet, inet_inet_ntoa, char*(struct in_addr))
DYNALIB_FN(4, hal_inet, inet_inet_ntoa_r, char*(struct in_addr, char*, socklen_t))
DYNALIB_FN(5, hal_inet, inet_inet_ntop, const char*(int, const void*, char*, socklen_t))
   b9fa4:	b508      	push	{r3, lr}
   b9fa6:	4b02      	ldr	r3, [pc, #8]	; (b9fb0 <inet_inet_ntop+0xc>)
   b9fa8:	681b      	ldr	r3, [r3, #0]
   b9faa:	695b      	ldr	r3, [r3, #20]
   b9fac:	9301      	str	r3, [sp, #4]
   b9fae:	bd08      	pop	{r3, pc}
   b9fb0:	00030264 	.word	0x00030264

000b9fb4 <hal_usart_write>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
   b9fb4:	b508      	push	{r3, lr}
   b9fb6:	4b02      	ldr	r3, [pc, #8]	; (b9fc0 <hal_usart_write+0xc>)
   b9fb8:	681b      	ldr	r3, [r3, #0]
   b9fba:	68db      	ldr	r3, [r3, #12]
   b9fbc:	9301      	str	r3, [sp, #4]
   b9fbe:	bd08      	pop	{r3, pc}
   b9fc0:	0003023c 	.word	0x0003023c

000b9fc4 <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
   b9fc4:	b508      	push	{r3, lr}
   b9fc6:	4b02      	ldr	r3, [pc, #8]	; (b9fd0 <hal_usart_available+0xc>)
   b9fc8:	681b      	ldr	r3, [r3, #0]
   b9fca:	691b      	ldr	r3, [r3, #16]
   b9fcc:	9301      	str	r3, [sp, #4]
   b9fce:	bd08      	pop	{r3, pc}
   b9fd0:	0003023c 	.word	0x0003023c

000b9fd4 <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
   b9fd4:	b508      	push	{r3, lr}
   b9fd6:	4b02      	ldr	r3, [pc, #8]	; (b9fe0 <hal_usart_read+0xc>)
   b9fd8:	681b      	ldr	r3, [r3, #0]
   b9fda:	695b      	ldr	r3, [r3, #20]
   b9fdc:	9301      	str	r3, [sp, #4]
   b9fde:	bd08      	pop	{r3, pc}
   b9fe0:	0003023c 	.word	0x0003023c

000b9fe4 <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
   b9fe4:	b508      	push	{r3, lr}
   b9fe6:	4b02      	ldr	r3, [pc, #8]	; (b9ff0 <hal_usart_peek+0xc>)
   b9fe8:	681b      	ldr	r3, [r3, #0]
   b9fea:	699b      	ldr	r3, [r3, #24]
   b9fec:	9301      	str	r3, [sp, #4]
   b9fee:	bd08      	pop	{r3, pc}
   b9ff0:	0003023c 	.word	0x0003023c

000b9ff4 <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
   b9ff4:	b508      	push	{r3, lr}
   b9ff6:	4b02      	ldr	r3, [pc, #8]	; (ba000 <hal_usart_flush+0xc>)
   b9ff8:	681b      	ldr	r3, [r3, #0]
   b9ffa:	69db      	ldr	r3, [r3, #28]
   b9ffc:	9301      	str	r3, [sp, #4]
   b9ffe:	bd08      	pop	{r3, pc}
   ba000:	0003023c 	.word	0x0003023c

000ba004 <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
   ba004:	b508      	push	{r3, lr}
   ba006:	4b02      	ldr	r3, [pc, #8]	; (ba010 <hal_usart_is_enabled+0xc>)
   ba008:	681b      	ldr	r3, [r3, #0]
   ba00a:	6a1b      	ldr	r3, [r3, #32]
   ba00c:	9301      	str	r3, [sp, #4]
   ba00e:	bd08      	pop	{r3, pc}
   ba010:	0003023c 	.word	0x0003023c

000ba014 <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
   ba014:	b508      	push	{r3, lr}
   ba016:	4b02      	ldr	r3, [pc, #8]	; (ba020 <hal_usart_available_data_for_write+0xc>)
   ba018:	681b      	ldr	r3, [r3, #0]
   ba01a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   ba01c:	9301      	str	r3, [sp, #4]
   ba01e:	bd08      	pop	{r3, pc}
   ba020:	0003023c 	.word	0x0003023c

000ba024 <hal_usart_begin_config>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, hal_usart_begin_config, void(hal_usart_interface_t serial, uint32_t baud, uint32_t config, void *ptr))
   ba024:	b508      	push	{r3, lr}
   ba026:	4b02      	ldr	r3, [pc, #8]	; (ba030 <hal_usart_begin_config+0xc>)
   ba028:	681b      	ldr	r3, [r3, #0]
   ba02a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   ba02c:	9301      	str	r3, [sp, #4]
   ba02e:	bd08      	pop	{r3, pc}
   ba030:	0003023c 	.word	0x0003023c

000ba034 <hal_usart_init_ex>:
DYNALIB_FN(BASE_IDX2 + 1, hal_usart, hal_usart_write_nine_bits, uint32_t(hal_usart_interface_t serial, uint16_t data))
DYNALIB_FN(BASE_IDX2 + 2, hal_usart, hal_usart_send_break, void(hal_usart_interface_t, void*))
DYNALIB_FN(BASE_IDX2 + 3, hal_usart, hal_usart_break_detected, uint8_t(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX2 + 4, hal_usart, hal_usart_sleep, int(hal_usart_interface_t serial, bool, void*))
DYNALIB_FN(BASE_IDX2 + 5, hal_usart, hal_usart_init_ex, int(hal_usart_interface_t, const hal_usart_buffer_config_t*, void*))
   ba034:	b508      	push	{r3, lr}
   ba036:	4b02      	ldr	r3, [pc, #8]	; (ba040 <hal_usart_init_ex+0xc>)
   ba038:	681b      	ldr	r3, [r3, #0]
   ba03a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   ba03c:	9301      	str	r3, [sp, #4]
   ba03e:	bd08      	pop	{r3, pc}
   ba040:	0003023c 	.word	0x0003023c

000ba044 <hal_i2c_set_speed>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_i2c)

DYNALIB_FN(0, hal_i2c, hal_i2c_set_speed, void(hal_i2c_interface_t, uint32_t, void*))
   ba044:	b508      	push	{r3, lr}
   ba046:	4b02      	ldr	r3, [pc, #8]	; (ba050 <hal_i2c_set_speed+0xc>)
   ba048:	681b      	ldr	r3, [r3, #0]
   ba04a:	681b      	ldr	r3, [r3, #0]
   ba04c:	9301      	str	r3, [sp, #4]
   ba04e:	bd08      	pop	{r3, pc}
   ba050:	00030228 	.word	0x00030228

000ba054 <hal_i2c_begin>:
DYNALIB_FN(1, hal_i2c, hal_i2c_enable_dma_mode, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(2, hal_i2c, hal_i2c_stretch_clock, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
   ba054:	b508      	push	{r3, lr}
   ba056:	4b02      	ldr	r3, [pc, #8]	; (ba060 <hal_i2c_begin+0xc>)
   ba058:	681b      	ldr	r3, [r3, #0]
   ba05a:	68db      	ldr	r3, [r3, #12]
   ba05c:	9301      	str	r3, [sp, #4]
   ba05e:	bd08      	pop	{r3, pc}
   ba060:	00030228 	.word	0x00030228

000ba064 <hal_i2c_begin_transmission>:
DYNALIB_FN(4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
   ba064:	b508      	push	{r3, lr}
   ba066:	4b02      	ldr	r3, [pc, #8]	; (ba070 <hal_i2c_begin_transmission+0xc>)
   ba068:	681b      	ldr	r3, [r3, #0]
   ba06a:	699b      	ldr	r3, [r3, #24]
   ba06c:	9301      	str	r3, [sp, #4]
   ba06e:	bd08      	pop	{r3, pc}
   ba070:	00030228 	.word	0x00030228

000ba074 <hal_i2c_end_transmission>:
DYNALIB_FN(7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
   ba074:	b508      	push	{r3, lr}
   ba076:	4b02      	ldr	r3, [pc, #8]	; (ba080 <hal_i2c_end_transmission+0xc>)
   ba078:	681b      	ldr	r3, [r3, #0]
   ba07a:	69db      	ldr	r3, [r3, #28]
   ba07c:	9301      	str	r3, [sp, #4]
   ba07e:	bd08      	pop	{r3, pc}
   ba080:	00030228 	.word	0x00030228

000ba084 <hal_i2c_write>:
DYNALIB_FN(8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
   ba084:	b508      	push	{r3, lr}
   ba086:	4b02      	ldr	r3, [pc, #8]	; (ba090 <hal_i2c_write+0xc>)
   ba088:	681b      	ldr	r3, [r3, #0]
   ba08a:	6a1b      	ldr	r3, [r3, #32]
   ba08c:	9301      	str	r3, [sp, #4]
   ba08e:	bd08      	pop	{r3, pc}
   ba090:	00030228 	.word	0x00030228

000ba094 <hal_i2c_available>:
DYNALIB_FN(9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
   ba094:	b508      	push	{r3, lr}
   ba096:	4b02      	ldr	r3, [pc, #8]	; (ba0a0 <hal_i2c_available+0xc>)
   ba098:	681b      	ldr	r3, [r3, #0]
   ba09a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   ba09c:	9301      	str	r3, [sp, #4]
   ba09e:	bd08      	pop	{r3, pc}
   ba0a0:	00030228 	.word	0x00030228

000ba0a4 <hal_i2c_read>:
DYNALIB_FN(10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
   ba0a4:	b508      	push	{r3, lr}
   ba0a6:	4b02      	ldr	r3, [pc, #8]	; (ba0b0 <hal_i2c_read+0xc>)
   ba0a8:	681b      	ldr	r3, [r3, #0]
   ba0aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   ba0ac:	9301      	str	r3, [sp, #4]
   ba0ae:	bd08      	pop	{r3, pc}
   ba0b0:	00030228 	.word	0x00030228

000ba0b4 <hal_i2c_peek>:
DYNALIB_FN(11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
   ba0b4:	b508      	push	{r3, lr}
   ba0b6:	4b02      	ldr	r3, [pc, #8]	; (ba0c0 <hal_i2c_peek+0xc>)
   ba0b8:	681b      	ldr	r3, [r3, #0]
   ba0ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   ba0bc:	9301      	str	r3, [sp, #4]
   ba0be:	bd08      	pop	{r3, pc}
   ba0c0:	00030228 	.word	0x00030228

000ba0c4 <hal_i2c_flush>:
DYNALIB_FN(12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
   ba0c4:	b508      	push	{r3, lr}
   ba0c6:	4b02      	ldr	r3, [pc, #8]	; (ba0d0 <hal_i2c_flush+0xc>)
   ba0c8:	681b      	ldr	r3, [r3, #0]
   ba0ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   ba0cc:	9301      	str	r3, [sp, #4]
   ba0ce:	bd08      	pop	{r3, pc}
   ba0d0:	00030228 	.word	0x00030228

000ba0d4 <hal_i2c_is_enabled>:
DYNALIB_FN(13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
   ba0d4:	b508      	push	{r3, lr}
   ba0d6:	4b02      	ldr	r3, [pc, #8]	; (ba0e0 <hal_i2c_is_enabled+0xc>)
   ba0d8:	681b      	ldr	r3, [r3, #0]
   ba0da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   ba0dc:	9301      	str	r3, [sp, #4]
   ba0de:	bd08      	pop	{r3, pc}
   ba0e0:	00030228 	.word	0x00030228

000ba0e4 <hal_i2c_init>:
DYNALIB_FN(14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
   ba0e4:	b508      	push	{r3, lr}
   ba0e6:	4b02      	ldr	r3, [pc, #8]	; (ba0f0 <hal_i2c_init+0xc>)
   ba0e8:	681b      	ldr	r3, [r3, #0]
   ba0ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   ba0ec:	9301      	str	r3, [sp, #4]
   ba0ee:	bd08      	pop	{r3, pc}
   ba0f0:	00030228 	.word	0x00030228

000ba0f4 <hal_spi_begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, hal_spi_begin, void(hal_spi_interface_t, uint16_t))
   ba0f4:	b508      	push	{r3, lr}
   ba0f6:	4b02      	ldr	r3, [pc, #8]	; (ba100 <hal_spi_begin+0xc>)
   ba0f8:	681b      	ldr	r3, [r3, #0]
   ba0fa:	681b      	ldr	r3, [r3, #0]
   ba0fc:	9301      	str	r3, [sp, #4]
   ba0fe:	bd08      	pop	{r3, pc}
   ba100:	00030230 	.word	0x00030230

000ba104 <hal_spi_transfer>:
DYNALIB_FN(1, hal_spi, hal_spi_end, void(hal_spi_interface_t))
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
   ba104:	b508      	push	{r3, lr}
   ba106:	4b02      	ldr	r3, [pc, #8]	; (ba110 <hal_spi_transfer+0xc>)
   ba108:	681b      	ldr	r3, [r3, #0]
   ba10a:	695b      	ldr	r3, [r3, #20]
   ba10c:	9301      	str	r3, [sp, #4]
   ba10e:	bd08      	pop	{r3, pc}
   ba110:	00030230 	.word	0x00030230

000ba114 <hal_spi_init>:
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
   ba114:	b508      	push	{r3, lr}
   ba116:	4b02      	ldr	r3, [pc, #8]	; (ba120 <hal_spi_init+0xc>)
   ba118:	681b      	ldr	r3, [r3, #0]
   ba11a:	69db      	ldr	r3, [r3, #28]
   ba11c:	9301      	str	r3, [sp, #4]
   ba11e:	bd08      	pop	{r3, pc}
   ba120:	00030230 	.word	0x00030230

000ba124 <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
   ba124:	b508      	push	{r3, lr}
   ba126:	4b02      	ldr	r3, [pc, #8]	; (ba130 <hal_spi_is_enabled+0xc>)
   ba128:	681b      	ldr	r3, [r3, #0]
   ba12a:	6a1b      	ldr	r3, [r3, #32]
   ba12c:	9301      	str	r3, [sp, #4]
   ba12e:	bd08      	pop	{r3, pc}
   ba130:	00030230 	.word	0x00030230

000ba134 <hal_spi_info>:
DYNALIB_FN(9, hal_spi, hal_spi_info, void(hal_spi_interface_t, hal_spi_info_t*, void*))
   ba134:	b508      	push	{r3, lr}
   ba136:	4b02      	ldr	r3, [pc, #8]	; (ba140 <hal_spi_info+0xc>)
   ba138:	681b      	ldr	r3, [r3, #0]
   ba13a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   ba13c:	9301      	str	r3, [sp, #4]
   ba13e:	bd08      	pop	{r3, pc}
   ba140:	00030230 	.word	0x00030230

000ba144 <hal_spi_transfer_dma>:
DYNALIB_FN(10, hal_spi, hal_spi_transfer_dma, void(hal_spi_interface_t, const void*, void*, uint32_t, hal_spi_dma_user_callback))
   ba144:	b508      	push	{r3, lr}
   ba146:	4b02      	ldr	r3, [pc, #8]	; (ba150 <hal_spi_transfer_dma+0xc>)
   ba148:	681b      	ldr	r3, [r3, #0]
   ba14a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   ba14c:	9301      	str	r3, [sp, #4]
   ba14e:	bd08      	pop	{r3, pc}
   ba150:	00030230 	.word	0x00030230

000ba154 <hal_spi_transfer_dma_status>:
DYNALIB_FN(11, hal_spi, hal_spi_begin_ext, void(hal_spi_interface_t, hal_spi_mode_t, uint16_t, void*))
DYNALIB_FN(12, hal_spi, hal_spi_set_callback_on_selected, void(hal_spi_interface_t, hal_spi_select_user_callback, void*))
DYNALIB_FN(13, hal_spi, hal_spi_transfer_dma_cancel, void(hal_spi_interface_t))
DYNALIB_FN(14, hal_spi, hal_spi_transfer_dma_status, int32_t(hal_spi_interface_t, hal_spi_transfer_status_t*))
   ba154:	b508      	push	{r3, lr}
   ba156:	4b02      	ldr	r3, [pc, #8]	; (ba160 <hal_spi_transfer_dma_status+0xc>)
   ba158:	681b      	ldr	r3, [r3, #0]
   ba15a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   ba15c:	9301      	str	r3, [sp, #4]
   ba15e:	bd08      	pop	{r3, pc}
   ba160:	00030230 	.word	0x00030230

000ba164 <hal_spi_set_settings>:
DYNALIB_FN(15, hal_spi, hal_spi_set_settings, int32_t(hal_spi_interface_t, uint8_t, uint8_t, uint8_t, uint8_t, void*))
   ba164:	b508      	push	{r3, lr}
   ba166:	4b02      	ldr	r3, [pc, #8]	; (ba170 <hal_spi_set_settings+0xc>)
   ba168:	681b      	ldr	r3, [r3, #0]
   ba16a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   ba16c:	9301      	str	r3, [sp, #4]
   ba16e:	bd08      	pop	{r3, pc}
   ba170:	00030230 	.word	0x00030230

000ba174 <hal_spi_acquire>:
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
DYNALIB_FN(16, hal_spi, hal_spi_acquire, int32_t(hal_spi_interface_t, const hal_spi_acquire_config_t*))
   ba174:	b508      	push	{r3, lr}
   ba176:	4b02      	ldr	r3, [pc, #8]	; (ba180 <hal_spi_acquire+0xc>)
   ba178:	681b      	ldr	r3, [r3, #0]
   ba17a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   ba17c:	9301      	str	r3, [sp, #4]
   ba17e:	bd08      	pop	{r3, pc}
   ba180:	00030230 	.word	0x00030230

000ba184 <hal_spi_release>:
DYNALIB_FN(17, hal_spi, hal_spi_release, int32_t(hal_spi_interface_t, void*))
   ba184:	b508      	push	{r3, lr}
   ba186:	4b02      	ldr	r3, [pc, #8]	; (ba190 <hal_spi_release+0xc>)
   ba188:	681b      	ldr	r3, [r3, #0]
   ba18a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   ba18c:	9301      	str	r3, [sp, #4]
   ba18e:	bd08      	pop	{r3, pc}
   ba190:	00030230 	.word	0x00030230

000ba194 <HAL_USB_USART_Init>:
// GNINRAW

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
   ba194:	b508      	push	{r3, lr}
   ba196:	4b02      	ldr	r3, [pc, #8]	; (ba1a0 <HAL_USB_USART_Init+0xc>)
   ba198:	681b      	ldr	r3, [r3, #0]
   ba19a:	681b      	ldr	r3, [r3, #0]
   ba19c:	9301      	str	r3, [sp, #4]
   ba19e:	bd08      	pop	{r3, pc}
   ba1a0:	0003024c 	.word	0x0003024c

000ba1a4 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
   ba1a4:	b508      	push	{r3, lr}
   ba1a6:	4b02      	ldr	r3, [pc, #8]	; (ba1b0 <HAL_USB_USART_Begin+0xc>)
   ba1a8:	681b      	ldr	r3, [r3, #0]
   ba1aa:	685b      	ldr	r3, [r3, #4]
   ba1ac:	9301      	str	r3, [sp, #4]
   ba1ae:	bd08      	pop	{r3, pc}
   ba1b0:	0003024c 	.word	0x0003024c

000ba1b4 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
   ba1b4:	b508      	push	{r3, lr}
   ba1b6:	4b02      	ldr	r3, [pc, #8]	; (ba1c0 <HAL_USB_USART_Available_Data+0xc>)
   ba1b8:	681b      	ldr	r3, [r3, #0]
   ba1ba:	691b      	ldr	r3, [r3, #16]
   ba1bc:	9301      	str	r3, [sp, #4]
   ba1be:	bd08      	pop	{r3, pc}
   ba1c0:	0003024c 	.word	0x0003024c

000ba1c4 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
   ba1c4:	b508      	push	{r3, lr}
   ba1c6:	4b02      	ldr	r3, [pc, #8]	; (ba1d0 <HAL_USB_USART_Available_Data_For_Write+0xc>)
   ba1c8:	681b      	ldr	r3, [r3, #0]
   ba1ca:	695b      	ldr	r3, [r3, #20]
   ba1cc:	9301      	str	r3, [sp, #4]
   ba1ce:	bd08      	pop	{r3, pc}
   ba1d0:	0003024c 	.word	0x0003024c

000ba1d4 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   ba1d4:	b508      	push	{r3, lr}
   ba1d6:	4b02      	ldr	r3, [pc, #8]	; (ba1e0 <HAL_USB_USART_Receive_Data+0xc>)
   ba1d8:	681b      	ldr	r3, [r3, #0]
   ba1da:	699b      	ldr	r3, [r3, #24]
   ba1dc:	9301      	str	r3, [sp, #4]
   ba1de:	bd08      	pop	{r3, pc}
   ba1e0:	0003024c 	.word	0x0003024c

000ba1e4 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
   ba1e4:	b508      	push	{r3, lr}
   ba1e6:	4b02      	ldr	r3, [pc, #8]	; (ba1f0 <HAL_USB_USART_Send_Data+0xc>)
   ba1e8:	681b      	ldr	r3, [r3, #0]
   ba1ea:	69db      	ldr	r3, [r3, #28]
   ba1ec:	9301      	str	r3, [sp, #4]
   ba1ee:	bd08      	pop	{r3, pc}
   ba1f0:	0003024c 	.word	0x0003024c

000ba1f4 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
   ba1f4:	b508      	push	{r3, lr}
   ba1f6:	4b02      	ldr	r3, [pc, #8]	; (ba200 <HAL_USB_USART_Flush_Data+0xc>)
   ba1f8:	681b      	ldr	r3, [r3, #0]
   ba1fa:	6a1b      	ldr	r3, [r3, #32]
   ba1fc:	9301      	str	r3, [sp, #4]
   ba1fe:	bd08      	pop	{r3, pc}
   ba200:	0003024c 	.word	0x0003024c

000ba204 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
   ba204:	b508      	push	{r3, lr}
   ba206:	4b02      	ldr	r3, [pc, #8]	; (ba210 <panic_+0xc>)
   ba208:	681b      	ldr	r3, [r3, #0]
   ba20a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   ba20c:	9301      	str	r3, [sp, #4]
   ba20e:	bd08      	pop	{r3, pc}
   ba210:	00030260 	.word	0x00030260

000ba214 <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
   ba214:	b508      	push	{r3, lr}
   ba216:	4b02      	ldr	r3, [pc, #8]	; (ba220 <log_message+0xc>)
   ba218:	681b      	ldr	r3, [r3, #0]
   ba21a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
   ba21c:	9301      	str	r3, [sp, #4]
   ba21e:	bd08      	pop	{r3, pc}
   ba220:	00030260 	.word	0x00030260

000ba224 <system_mode>:
#include "system_ble_prov.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
   ba224:	b508      	push	{r3, lr}
   ba226:	4b02      	ldr	r3, [pc, #8]	; (ba230 <system_mode+0xc>)
   ba228:	681b      	ldr	r3, [r3, #0]
   ba22a:	681b      	ldr	r3, [r3, #0]
   ba22c:	9301      	str	r3, [sp, #4]
   ba22e:	bd08      	pop	{r3, pc}
   ba230:	00030220 	.word	0x00030220

000ba234 <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
   ba234:	b508      	push	{r3, lr}
   ba236:	4b02      	ldr	r3, [pc, #8]	; (ba240 <set_system_mode+0xc>)
   ba238:	681b      	ldr	r3, [r3, #0]
   ba23a:	685b      	ldr	r3, [r3, #4]
   ba23c:	9301      	str	r3, [sp, #4]
   ba23e:	bd08      	pop	{r3, pc}
   ba240:	00030220 	.word	0x00030220

000ba244 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
   ba244:	b508      	push	{r3, lr}
   ba246:	4b02      	ldr	r3, [pc, #8]	; (ba250 <system_delay_ms+0xc>)
   ba248:	681b      	ldr	r3, [r3, #0]
   ba24a:	695b      	ldr	r3, [r3, #20]
   ba24c:	9301      	str	r3, [sp, #4]
   ba24e:	bd08      	pop	{r3, pc}
   ba250:	00030220 	.word	0x00030220

000ba254 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
   ba254:	b508      	push	{r3, lr}
   ba256:	4b02      	ldr	r3, [pc, #8]	; (ba260 <application_thread_current+0xc>)
   ba258:	681b      	ldr	r3, [r3, #0]
   ba25a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   ba25c:	9301      	str	r3, [sp, #4]
   ba25e:	bd08      	pop	{r3, pc}
   ba260:	00030220 	.word	0x00030220

000ba264 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
   ba264:	b508      	push	{r3, lr}
   ba266:	4b02      	ldr	r3, [pc, #8]	; (ba270 <application_thread_invoke+0xc>)
   ba268:	681b      	ldr	r3, [r3, #0]
   ba26a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   ba26c:	9301      	str	r3, [sp, #4]
   ba26e:	bd08      	pop	{r3, pc}
   ba270:	00030220 	.word	0x00030220

000ba274 <system_thread_get_state>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
   ba274:	b508      	push	{r3, lr}
   ba276:	4b02      	ldr	r3, [pc, #8]	; (ba280 <system_thread_get_state+0xc>)
   ba278:	681b      	ldr	r3, [r3, #0]
   ba27a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
   ba27c:	9301      	str	r3, [sp, #4]
   ba27e:	bd08      	pop	{r3, pc}
   ba280:	00030220 	.word	0x00030220

000ba284 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
   ba284:	b508      	push	{r3, lr}
   ba286:	4b03      	ldr	r3, [pc, #12]	; (ba294 <system_ctrl_set_app_request_handler+0x10>)
   ba288:	681b      	ldr	r3, [r3, #0]
   ba28a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
   ba28e:	9301      	str	r3, [sp, #4]
   ba290:	bd08      	pop	{r3, pc}
   ba292:	0000      	.short	0x0000
   ba294:	00030220 	.word	0x00030220

000ba298 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
   ba298:	b508      	push	{r3, lr}
   ba29a:	4b03      	ldr	r3, [pc, #12]	; (ba2a8 <system_ctrl_set_result+0x10>)
   ba29c:	681b      	ldr	r3, [r3, #0]
   ba29e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   ba2a2:	9301      	str	r3, [sp, #4]
   ba2a4:	bd08      	pop	{r3, pc}
   ba2a6:	0000      	.short	0x0000
   ba2a8:	00030220 	.word	0x00030220

000ba2ac <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
   ba2ac:	b508      	push	{r3, lr}
   ba2ae:	4b02      	ldr	r3, [pc, #8]	; (ba2b8 <network_connect+0xc>)
   ba2b0:	681b      	ldr	r3, [r3, #0]
   ba2b2:	685b      	ldr	r3, [r3, #4]
   ba2b4:	9301      	str	r3, [sp, #4]
   ba2b6:	bd08      	pop	{r3, pc}
   ba2b8:	00030240 	.word	0x00030240

000ba2bc <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
   ba2bc:	b508      	push	{r3, lr}
   ba2be:	4b02      	ldr	r3, [pc, #8]	; (ba2c8 <network_connecting+0xc>)
   ba2c0:	681b      	ldr	r3, [r3, #0]
   ba2c2:	689b      	ldr	r3, [r3, #8]
   ba2c4:	9301      	str	r3, [sp, #4]
   ba2c6:	bd08      	pop	{r3, pc}
   ba2c8:	00030240 	.word	0x00030240

000ba2cc <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
   ba2cc:	b508      	push	{r3, lr}
   ba2ce:	4b02      	ldr	r3, [pc, #8]	; (ba2d8 <network_disconnect+0xc>)
   ba2d0:	681b      	ldr	r3, [r3, #0]
   ba2d2:	68db      	ldr	r3, [r3, #12]
   ba2d4:	9301      	str	r3, [sp, #4]
   ba2d6:	bd08      	pop	{r3, pc}
   ba2d8:	00030240 	.word	0x00030240

000ba2dc <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
   ba2dc:	b508      	push	{r3, lr}
   ba2de:	4b02      	ldr	r3, [pc, #8]	; (ba2e8 <network_ready+0xc>)
   ba2e0:	681b      	ldr	r3, [r3, #0]
   ba2e2:	691b      	ldr	r3, [r3, #16]
   ba2e4:	9301      	str	r3, [sp, #4]
   ba2e6:	bd08      	pop	{r3, pc}
   ba2e8:	00030240 	.word	0x00030240

000ba2ec <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
   ba2ec:	b508      	push	{r3, lr}
   ba2ee:	4b02      	ldr	r3, [pc, #8]	; (ba2f8 <network_on+0xc>)
   ba2f0:	681b      	ldr	r3, [r3, #0]
   ba2f2:	695b      	ldr	r3, [r3, #20]
   ba2f4:	9301      	str	r3, [sp, #4]
   ba2f6:	bd08      	pop	{r3, pc}
   ba2f8:	00030240 	.word	0x00030240

000ba2fc <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
   ba2fc:	b508      	push	{r3, lr}
   ba2fe:	4b02      	ldr	r3, [pc, #8]	; (ba308 <network_off+0xc>)
   ba300:	681b      	ldr	r3, [r3, #0]
   ba302:	699b      	ldr	r3, [r3, #24]
   ba304:	9301      	str	r3, [sp, #4]
   ba306:	bd08      	pop	{r3, pc}
   ba308:	00030240 	.word	0x00030240

000ba30c <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
   ba30c:	b508      	push	{r3, lr}
   ba30e:	4b02      	ldr	r3, [pc, #8]	; (ba318 <network_listen+0xc>)
   ba310:	681b      	ldr	r3, [r3, #0]
   ba312:	69db      	ldr	r3, [r3, #28]
   ba314:	9301      	str	r3, [sp, #4]
   ba316:	bd08      	pop	{r3, pc}
   ba318:	00030240 	.word	0x00030240

000ba31c <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
   ba31c:	b508      	push	{r3, lr}
   ba31e:	4b02      	ldr	r3, [pc, #8]	; (ba328 <network_listening+0xc>)
   ba320:	681b      	ldr	r3, [r3, #0]
   ba322:	6a1b      	ldr	r3, [r3, #32]
   ba324:	9301      	str	r3, [sp, #4]
   ba326:	bd08      	pop	{r3, pc}
   ba328:	00030240 	.word	0x00030240

000ba32c <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
   ba32c:	b508      	push	{r3, lr}
   ba32e:	4b02      	ldr	r3, [pc, #8]	; (ba338 <network_set_listen_timeout+0xc>)
   ba330:	681b      	ldr	r3, [r3, #0]
   ba332:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   ba334:	9301      	str	r3, [sp, #4]
   ba336:	bd08      	pop	{r3, pc}
   ba338:	00030240 	.word	0x00030240

000ba33c <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
   ba33c:	b508      	push	{r3, lr}
   ba33e:	4b02      	ldr	r3, [pc, #8]	; (ba348 <network_get_listen_timeout+0xc>)
   ba340:	681b      	ldr	r3, [r3, #0]
   ba342:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   ba344:	9301      	str	r3, [sp, #4]
   ba346:	bd08      	pop	{r3, pc}
   ba348:	00030240 	.word	0x00030240

000ba34c <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
   ba34c:	b508      	push	{r3, lr}
   ba34e:	4b02      	ldr	r3, [pc, #8]	; (ba358 <network_is_on+0xc>)
   ba350:	681b      	ldr	r3, [r3, #0]
   ba352:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   ba354:	9301      	str	r3, [sp, #4]
   ba356:	bd08      	pop	{r3, pc}
   ba358:	00030240 	.word	0x00030240

000ba35c <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
   ba35c:	b508      	push	{r3, lr}
   ba35e:	4b02      	ldr	r3, [pc, #8]	; (ba368 <network_is_off+0xc>)
   ba360:	681b      	ldr	r3, [r3, #0]
   ba362:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   ba364:	9301      	str	r3, [sp, #4]
   ba366:	bd08      	pop	{r3, pc}
   ba368:	00030240 	.word	0x00030240

000ba36c <spark_function>:


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
   ba36c:	b508      	push	{r3, lr}
   ba36e:	4b02      	ldr	r3, [pc, #8]	; (ba378 <spark_function+0xc>)
   ba370:	681b      	ldr	r3, [r3, #0]
   ba372:	685b      	ldr	r3, [r3, #4]
   ba374:	9301      	str	r3, [sp, #4]
   ba376:	bd08      	pop	{r3, pc}
   ba378:	00030244 	.word	0x00030244

000ba37c <spark_process>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
   ba37c:	b508      	push	{r3, lr}
   ba37e:	4b02      	ldr	r3, [pc, #8]	; (ba388 <spark_process+0xc>)
   ba380:	681b      	ldr	r3, [r3, #0]
   ba382:	689b      	ldr	r3, [r3, #8]
   ba384:	9301      	str	r3, [sp, #4]
   ba386:	bd08      	pop	{r3, pc}
   ba388:	00030244 	.word	0x00030244

000ba38c <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
   ba38c:	b508      	push	{r3, lr}
   ba38e:	4b02      	ldr	r3, [pc, #8]	; (ba398 <spark_cloud_flag_connect+0xc>)
   ba390:	681b      	ldr	r3, [r3, #0]
   ba392:	68db      	ldr	r3, [r3, #12]
   ba394:	9301      	str	r3, [sp, #4]
   ba396:	bd08      	pop	{r3, pc}
   ba398:	00030244 	.word	0x00030244

000ba39c <spark_cloud_flag_connected>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
   ba39c:	b508      	push	{r3, lr}
   ba39e:	4b02      	ldr	r3, [pc, #8]	; (ba3a8 <spark_cloud_flag_connected+0xc>)
   ba3a0:	681b      	ldr	r3, [r3, #0]
   ba3a2:	695b      	ldr	r3, [r3, #20]
   ba3a4:	9301      	str	r3, [sp, #4]
   ba3a6:	bd08      	pop	{r3, pc}
   ba3a8:	00030244 	.word	0x00030244

000ba3ac <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
   ba3ac:	b508      	push	{r3, lr}
   ba3ae:	4b02      	ldr	r3, [pc, #8]	; (ba3b8 <spark_send_event+0xc>)
   ba3b0:	681b      	ldr	r3, [r3, #0]
   ba3b2:	6a1b      	ldr	r3, [r3, #32]
   ba3b4:	9301      	str	r3, [sp, #4]
   ba3b6:	bd08      	pop	{r3, pc}
   ba3b8:	00030244 	.word	0x00030244

000ba3bc <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
   ba3bc:	b508      	push	{r3, lr}
   ba3be:	4b02      	ldr	r3, [pc, #8]	; (ba3c8 <spark_subscribe+0xc>)
   ba3c0:	681b      	ldr	r3, [r3, #0]
   ba3c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   ba3c4:	9301      	str	r3, [sp, #4]
   ba3c6:	bd08      	pop	{r3, pc}
   ba3c8:	00030244 	.word	0x00030244

000ba3cc <spark_sync_time_pending>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
   ba3cc:	b508      	push	{r3, lr}
   ba3ce:	4b02      	ldr	r3, [pc, #8]	; (ba3d8 <spark_sync_time_pending+0xc>)
   ba3d0:	681b      	ldr	r3, [r3, #0]
   ba3d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   ba3d4:	9301      	str	r3, [sp, #4]
   ba3d6:	bd08      	pop	{r3, pc}
   ba3d8:	00030244 	.word	0x00030244

000ba3dc <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
   ba3dc:	b508      	push	{r3, lr}
   ba3de:	4b02      	ldr	r3, [pc, #8]	; (ba3e8 <spark_set_random_seed_from_cloud_handler+0xc>)
   ba3e0:	681b      	ldr	r3, [r3, #0]
   ba3e2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   ba3e4:	9301      	str	r3, [sp, #4]
   ba3e6:	bd08      	pop	{r3, pc}
   ba3e8:	00030244 	.word	0x00030244

000ba3ec <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
   ba3ec:	b508      	push	{r3, lr}
   ba3ee:	4b02      	ldr	r3, [pc, #8]	; (ba3f8 <malloc+0xc>)
   ba3f0:	681b      	ldr	r3, [r3, #0]
   ba3f2:	681b      	ldr	r3, [r3, #0]
   ba3f4:	9301      	str	r3, [sp, #4]
   ba3f6:	bd08      	pop	{r3, pc}
   ba3f8:	0003021c 	.word	0x0003021c

000ba3fc <free>:
DYNALIB_FN(1, rt, free, void(void*))
   ba3fc:	b508      	push	{r3, lr}
   ba3fe:	4b02      	ldr	r3, [pc, #8]	; (ba408 <free+0xc>)
   ba400:	681b      	ldr	r3, [r3, #0]
   ba402:	685b      	ldr	r3, [r3, #4]
   ba404:	9301      	str	r3, [sp, #4]
   ba406:	bd08      	pop	{r3, pc}
   ba408:	0003021c 	.word	0x0003021c

000ba40c <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
   ba40c:	b508      	push	{r3, lr}
   ba40e:	4b02      	ldr	r3, [pc, #8]	; (ba418 <realloc+0xc>)
   ba410:	681b      	ldr	r3, [r3, #0]
   ba412:	689b      	ldr	r3, [r3, #8]
   ba414:	9301      	str	r3, [sp, #4]
   ba416:	bd08      	pop	{r3, pc}
   ba418:	0003021c 	.word	0x0003021c

000ba41c <sprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
   ba41c:	b508      	push	{r3, lr}
   ba41e:	4b02      	ldr	r3, [pc, #8]	; (ba428 <sprintf+0xc>)
   ba420:	681b      	ldr	r3, [r3, #0]
   ba422:	68db      	ldr	r3, [r3, #12]
   ba424:	9301      	str	r3, [sp, #4]
   ba426:	bd08      	pop	{r3, pc}
   ba428:	0003021c 	.word	0x0003021c

000ba42c <sscanf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
   ba42c:	b508      	push	{r3, lr}
   ba42e:	4b02      	ldr	r3, [pc, #8]	; (ba438 <sscanf+0xc>)
   ba430:	681b      	ldr	r3, [r3, #0]
   ba432:	695b      	ldr	r3, [r3, #20]
   ba434:	9301      	str	r3, [sp, #4]
   ba436:	bd08      	pop	{r3, pc}
   ba438:	0003021c 	.word	0x0003021c

000ba43c <snprintf>:
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
   ba43c:	b508      	push	{r3, lr}
   ba43e:	4b02      	ldr	r3, [pc, #8]	; (ba448 <snprintf+0xc>)
   ba440:	681b      	ldr	r3, [r3, #0]
   ba442:	69db      	ldr	r3, [r3, #28]
   ba444:	9301      	str	r3, [sp, #4]
   ba446:	bd08      	pop	{r3, pc}
   ba448:	0003021c 	.word	0x0003021c

000ba44c <vsnprintf>:
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
   ba44c:	b508      	push	{r3, lr}
   ba44e:	4b02      	ldr	r3, [pc, #8]	; (ba458 <vsnprintf+0xc>)
   ba450:	681b      	ldr	r3, [r3, #0]
   ba452:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   ba454:	9301      	str	r3, [sp, #4]
   ba456:	bd08      	pop	{r3, pc}
   ba458:	0003021c 	.word	0x0003021c

000ba45c <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
   ba45c:	b508      	push	{r3, lr}
   ba45e:	4b02      	ldr	r3, [pc, #8]	; (ba468 <abort+0xc>)
   ba460:	681b      	ldr	r3, [r3, #0]
   ba462:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   ba464:	9301      	str	r3, [sp, #4]
   ba466:	bd08      	pop	{r3, pc}
   ba468:	0003021c 	.word	0x0003021c

000ba46c <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
   ba46c:	b508      	push	{r3, lr}
   ba46e:	4b02      	ldr	r3, [pc, #8]	; (ba478 <_malloc_r+0xc>)
   ba470:	681b      	ldr	r3, [r3, #0]
   ba472:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   ba474:	9301      	str	r3, [sp, #4]
   ba476:	bd08      	pop	{r3, pc}
   ba478:	0003021c 	.word	0x0003021c

000ba47c <__errno>:
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
   ba47c:	b508      	push	{r3, lr}
   ba47e:	4b02      	ldr	r3, [pc, #8]	; (ba488 <__errno+0xc>)
   ba480:	681b      	ldr	r3, [r3, #0]
   ba482:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   ba484:	9301      	str	r3, [sp, #4]
   ba486:	bd08      	pop	{r3, pc}
   ba488:	0003021c 	.word	0x0003021c

000ba48c <__assert_func>:

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
   ba48c:	b508      	push	{r3, lr}
   ba48e:	4b02      	ldr	r3, [pc, #8]	; (ba498 <__assert_func+0xc>)
   ba490:	681b      	ldr	r3, [r3, #0]
   ba492:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   ba494:	9301      	str	r3, [sp, #4]
   ba496:	bd08      	pop	{r3, pc}
   ba498:	0003021c 	.word	0x0003021c

000ba49c <newlib_impure_ptr_callback>:
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
   ba49c:	b508      	push	{r3, lr}
   ba49e:	4b02      	ldr	r3, [pc, #8]	; (ba4a8 <newlib_impure_ptr_callback+0xc>)
   ba4a0:	681b      	ldr	r3, [r3, #0]
   ba4a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   ba4a4:	9301      	str	r3, [sp, #4]
   ba4a6:	bd08      	pop	{r3, pc}
   ba4a8:	0003021c 	.word	0x0003021c

000ba4ac <localtime_r>:

#if HAL_PLATFORM_EXPORT_STDLIB_RT_DYNALIB
DYNALIB_FN(18, rt, strftime, size_t(char* __restrict, size_t, const char* __restrict, const struct tm* __restrict))
DYNALIB_FN(19, rt, localtime_r, struct tm*(const time_t* __restrict, struct tm* __restrict))
   ba4ac:	b508      	push	{r3, lr}
   ba4ae:	4b02      	ldr	r3, [pc, #8]	; (ba4b8 <localtime_r+0xc>)
   ba4b0:	681b      	ldr	r3, [r3, #0]
   ba4b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   ba4b4:	9301      	str	r3, [sp, #4]
   ba4b6:	bd08      	pop	{r3, pc}
   ba4b8:	0003021c 	.word	0x0003021c

000ba4bc <_ZN5spark13EthernetClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
   ba4bc:	2200      	movs	r2, #0
   ba4be:	6840      	ldr	r0, [r0, #4]
   ba4c0:	4611      	mov	r1, r2
   ba4c2:	f7ff bf2b 	b.w	ba31c <network_listening>

000ba4c6 <_ZN5spark13EthernetClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
   ba4c6:	2200      	movs	r2, #0
   ba4c8:	6840      	ldr	r0, [r0, #4]
   ba4ca:	4611      	mov	r1, r2
   ba4cc:	f7ff bf36 	b.w	ba33c <network_get_listen_timeout>

000ba4d0 <_ZN5spark13EthernetClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
   ba4d0:	6840      	ldr	r0, [r0, #4]
   ba4d2:	2200      	movs	r2, #0
   ba4d4:	f7ff bf2a 	b.w	ba32c <network_set_listen_timeout>

000ba4d8 <_ZN5spark13EthernetClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
   ba4d8:	6840      	ldr	r0, [r0, #4]
   ba4da:	2200      	movs	r2, #0
   ba4dc:	f081 0101 	eor.w	r1, r1, #1
   ba4e0:	f7ff bf14 	b.w	ba30c <network_listen>

000ba4e4 <_ZN5spark13EthernetClass3offEv>:
        network_off(*this, 0, 0, NULL);
   ba4e4:	2300      	movs	r3, #0
   ba4e6:	6840      	ldr	r0, [r0, #4]
   ba4e8:	461a      	mov	r2, r3
   ba4ea:	4619      	mov	r1, r3
   ba4ec:	f7ff bf06 	b.w	ba2fc <network_off>

000ba4f0 <_ZN5spark13EthernetClass2onEv>:
        network_on(*this, 0, 0, NULL);
   ba4f0:	2300      	movs	r3, #0
   ba4f2:	6840      	ldr	r0, [r0, #4]
   ba4f4:	461a      	mov	r2, r3
   ba4f6:	4619      	mov	r1, r3
   ba4f8:	f7ff bef8 	b.w	ba2ec <network_on>

000ba4fc <_ZN5spark13EthernetClass5readyEv>:
    }

    bool ready() {
        return network_ready(*this, 0,  NULL);
   ba4fc:	2200      	movs	r2, #0
   ba4fe:	6840      	ldr	r0, [r0, #4]
   ba500:	4611      	mov	r1, r2
   ba502:	f7ff beeb 	b.w	ba2dc <network_ready>

000ba506 <_ZN5spark13EthernetClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
   ba506:	2200      	movs	r2, #0
   ba508:	6840      	ldr	r0, [r0, #4]
   ba50a:	4611      	mov	r1, r2
   ba50c:	f7ff bed6 	b.w	ba2bc <network_connecting>

000ba510 <_ZN5spark13EthernetClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   ba510:	6840      	ldr	r0, [r0, #4]
   ba512:	2200      	movs	r2, #0
   ba514:	2102      	movs	r1, #2
   ba516:	f7ff bed9 	b.w	ba2cc <network_disconnect>

000ba51a <_ZN5spark13EthernetClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
   ba51a:	2300      	movs	r3, #0
   ba51c:	6840      	ldr	r0, [r0, #4]
   ba51e:	461a      	mov	r2, r3
   ba520:	f7ff bec4 	b.w	ba2ac <network_connect>

000ba524 <_GLOBAL__sub_I__ZN5spark8EthernetE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
   ba524:	4b02      	ldr	r3, [pc, #8]	; (ba530 <_GLOBAL__sub_I__ZN5spark8EthernetE+0xc>)
   ba526:	2203      	movs	r2, #3
   ba528:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_ETHERNET) {
   ba52a:	4a02      	ldr	r2, [pc, #8]	; (ba534 <_GLOBAL__sub_I__ZN5spark8EthernetE+0x10>)
   ba52c:	601a      	str	r2, [r3, #0]

namespace spark {

EthernetClass Ethernet;

} // spark
   ba52e:	4770      	bx	lr
   ba530:	2003e658 	.word	0x2003e658
   ba534:	000c1da4 	.word	0x000c1da4

000ba538 <_ZN8SPIClass6unlockEv.isra.0>:
  }

  void unlock()
  {
#if HAL_PLATFORM_SPI_HAL_THREAD_SAFETY
    hal_spi_release(_spi, nullptr);
   ba538:	2100      	movs	r1, #0
   ba53a:	f7ff be23 	b.w	ba184 <hal_spi_release>

000ba53e <_ZN8SPIClass4lockEv.isra.0>:
    return hal_spi_acquire(_spi, nullptr);
   ba53e:	2100      	movs	r1, #0
   ba540:	f7ff be18 	b.w	ba174 <hal_spi_acquire>

000ba544 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
   ba544:	b510      	push	{r4, lr}
   ba546:	4604      	mov	r4, r0
   ba548:	4608      	mov	r0, r1
{
    _spi = spi;
   ba54a:	7021      	strb	r1, [r4, #0]
    hal_spi_init(_spi);
   ba54c:	f7ff fde2 	bl	ba114 <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
   ba550:	2300      	movs	r3, #0
   ba552:	6063      	str	r3, [r4, #4]
}
   ba554:	4620      	mov	r0, r4
   ba556:	bd10      	pop	{r4, pc}

000ba558 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
   ba558:	b513      	push	{r0, r1, r4, lr}
   ba55a:	4604      	mov	r4, r0
    // TODO: Fetch default pin from HAL
    if (!lock())
   ba55c:	7800      	ldrb	r0, [r0, #0]
   ba55e:	f7ff ffee 	bl	ba53e <_ZN8SPIClass4lockEv.isra.0>
   ba562:	b958      	cbnz	r0, ba57c <_ZN8SPIClass5beginEv+0x24>
   ba564:	7820      	ldrb	r0, [r4, #0]
    {
        hal_spi_begin(_spi, SPI_DEFAULT_SS);
   ba566:	9001      	str	r0, [sp, #4]
   ba568:	f64f 71ff 	movw	r1, #65535	; 0xffff
   ba56c:	f7ff fdc2 	bl	ba0f4 <hal_spi_begin>
        unlock();
   ba570:	9801      	ldr	r0, [sp, #4]
    }
}
   ba572:	b002      	add	sp, #8
   ba574:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   ba578:	f7ff bfde 	b.w	ba538 <_ZN8SPIClass6unlockEv.isra.0>
   ba57c:	b002      	add	sp, #8
   ba57e:	bd10      	pop	{r4, pc}

000ba580 <_ZN8SPIClass14endTransactionEv>:
}

void SPIClass::endTransaction()
{
    // Release peripheral
    unlock();
   ba580:	7800      	ldrb	r0, [r0, #0]
   ba582:	f7ff bfd9 	b.w	ba538 <_ZN8SPIClass6unlockEv.isra.0>
	...

000ba588 <_ZN8SPIClass19computeClockDividerEjjRhRj>:
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
   ba588:	0840      	lsrs	r0, r0, #1
{
   ba58a:	b530      	push	{r4, r5, lr}
    clock >>= 1; // div2 is the first
   ba58c:	6018      	str	r0, [r3, #0]
   ba58e:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale < 7)
   ba590:	6818      	ldr	r0, [r3, #0]
   ba592:	4288      	cmp	r0, r1
   ba594:	b2e5      	uxtb	r5, r4
   ba596:	d906      	bls.n	ba5a6 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
   ba598:	3401      	adds	r4, #1
   ba59a:	2c08      	cmp	r4, #8
   ba59c:	d002      	beq.n	ba5a4 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
   ba59e:	0840      	lsrs	r0, r0, #1
   ba5a0:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
   ba5a2:	e7f5      	b.n	ba590 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
   ba5a4:	2507      	movs	r5, #7
        scale++;
    }
    divider = clock_divisors[scale];
   ba5a6:	4b02      	ldr	r3, [pc, #8]	; (ba5b0 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
   ba5a8:	5d5b      	ldrb	r3, [r3, r5]
   ba5aa:	7013      	strb	r3, [r2, #0]
}
   ba5ac:	bd30      	pop	{r4, r5, pc}
   ba5ae:	bf00      	nop
   ba5b0:	000c1dd8 	.word	0x000c1dd8

000ba5b4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>:
{
   ba5b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   ba5b8:	4606      	mov	r6, r0
   ba5ba:	b08f      	sub	sp, #60	; 0x3c
    CHECK(lock());
   ba5bc:	7800      	ldrb	r0, [r0, #0]
{
   ba5be:	460c      	mov	r4, r1
    CHECK(lock());
   ba5c0:	f7ff ffbd 	bl	ba53e <_ZN8SPIClass4lockEv.isra.0>
   ba5c4:	2800      	cmp	r0, #0
   ba5c6:	db1b      	blt.n	ba600 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4c>
    querySpiInfo(_spi, &spi_info);
   ba5c8:	7835      	ldrb	r5, [r6, #0]
    memset(info, 0, sizeof(hal_spi_info_t));
   ba5ca:	2214      	movs	r2, #20
   ba5cc:	2100      	movs	r1, #0
   ba5ce:	a809      	add	r0, sp, #36	; 0x24
   ba5d0:	f004 fc93 	bl	beefa <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
   ba5d4:	230b      	movs	r3, #11
    hal_spi_info(spi, info, nullptr);
   ba5d6:	2200      	movs	r2, #0
   ba5d8:	a909      	add	r1, sp, #36	; 0x24
   ba5da:	4628      	mov	r0, r5
    info->version = HAL_SPI_INFO_VERSION_1;
   ba5dc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    hal_spi_info(spi, info, nullptr);
   ba5e0:	f7ff fda8 	bl	ba134 <hal_spi_info>
    if (!info || !info->enabled || info->default_settings)
   ba5e4:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
   ba5e8:	b113      	cbz	r3, ba5f0 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x3c>
   ba5ea:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
   ba5ee:	b155      	cbz	r5, ba606 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x52>
  {
   ba5f0:	2700      	movs	r7, #0
   ba5f2:	46b9      	mov	r9, r7
   ba5f4:	46b8      	mov	r8, r7
   ba5f6:	2501      	movs	r5, #1
    if (default_ && other.default_)
   ba5f8:	7923      	ldrb	r3, [r4, #4]
   ba5fa:	b15d      	cbz	r5, ba614 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x60>
   ba5fc:	b1c3      	cbz	r3, ba630 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x7c>
    return 0;
   ba5fe:	2000      	movs	r0, #0
}
   ba600:	b00f      	add	sp, #60	; 0x3c
   ba602:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
   ba606:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   ba60a:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
   ba60e:	f89d 7035 	ldrb.w	r7, [sp, #53]	; 0x35
  }
   ba612:	e7f1      	b.n	ba5f8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x44>
    if (default_ == other.default_ &&
   ba614:	2b00      	cmp	r3, #0
   ba616:	d135      	bne.n	ba684 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xd0>
   ba618:	68a3      	ldr	r3, [r4, #8]
   ba61a:	4543      	cmp	r3, r8
   ba61c:	d108      	bne.n	ba630 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x7c>
        bitOrder_ == other.bitOrder_ &&
   ba61e:	f88d 9020 	strb.w	r9, [sp, #32]
   ba622:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
   ba626:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   ba62a:	89a3      	ldrh	r3, [r4, #12]
   ba62c:	429a      	cmp	r2, r3
   ba62e:	d0e6      	beq.n	ba5fe <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
            uint8_t divisor = 0;
   ba630:	2300      	movs	r3, #0
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
   ba632:	68a1      	ldr	r1, [r4, #8]
            uint8_t divisor = 0;
   ba634:	f88d 300f 	strb.w	r3, [sp, #15]
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
   ba638:	980a      	ldr	r0, [sp, #40]	; 0x28
   ba63a:	ab04      	add	r3, sp, #16
   ba63c:	f10d 020f 	add.w	r2, sp, #15
   ba640:	f7ff ffa2 	bl	ba588 <_ZN8SPIClass19computeClockDividerEjjRhRj>
    if (default_ && other.default_)
   ba644:	7921      	ldrb	r1, [r4, #4]
   ba646:	b985      	cbnz	r5, ba66a <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
    if (default_ == other.default_ &&
   ba648:	b989      	cbnz	r1, ba66e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
   ba64a:	68a3      	ldr	r3, [r4, #8]
   ba64c:	4543      	cmp	r3, r8
   ba64e:	d30e      	bcc.n	ba66e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
        bitOrder_ == other.bitOrder_ &&
   ba650:	f88d 9020 	strb.w	r9, [sp, #32]
   ba654:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
   ba658:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   ba65c:	89a3      	ldrh	r3, [r4, #12]
   ba65e:	429a      	cmp	r2, r3
   ba660:	d105      	bne.n	ba66e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
   ba662:	9b04      	ldr	r3, [sp, #16]
   ba664:	4543      	cmp	r3, r8
   ba666:	d102      	bne.n	ba66e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xba>
   ba668:	e7c9      	b.n	ba5fe <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
    if (default_ && other.default_)
   ba66a:	2900      	cmp	r1, #0
   ba66c:	d1f9      	bne.n	ba662 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xae>
                hal_spi_set_settings(_spi, settings.default_, divisor, settings.bitOrder_,
   ba66e:	2300      	movs	r3, #0
   ba670:	9301      	str	r3, [sp, #4]
   ba672:	7b63      	ldrb	r3, [r4, #13]
   ba674:	9300      	str	r3, [sp, #0]
   ba676:	f89d 200f 	ldrb.w	r2, [sp, #15]
   ba67a:	7b23      	ldrb	r3, [r4, #12]
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
   ba67c:	7830      	ldrb	r0, [r6, #0]
   ba67e:	f7ff fd71 	bl	ba164 <hal_spi_set_settings>
   ba682:	e7bc      	b.n	ba5fe <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4a>
   ba684:	e9cd 5500 	strd	r5, r5, [sp]
   ba688:	462b      	mov	r3, r5
   ba68a:	462a      	mov	r2, r5
   ba68c:	2101      	movs	r1, #1
   ba68e:	e7f5      	b.n	ba67c <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xc8>

000ba690 <_ZN8SPIClass8transferEh>:

    return clock;
}

byte SPIClass::transfer(byte _data)
{
   ba690:	b508      	push	{r3, lr}
    return static_cast<byte>(hal_spi_transfer(_spi, _data));
   ba692:	7800      	ldrb	r0, [r0, #0]
   ba694:	f7ff fd36 	bl	ba104 <hal_spi_transfer>
}
   ba698:	b2c0      	uxtb	r0, r0
   ba69a:	bd08      	pop	{r3, pc}

000ba69c <_ZN8SPIClass8transferEPKvPvjPFvvE>:

void SPIClass::transfer(const void* tx_buffer, void* rx_buffer, size_t length,
                        wiring_spi_dma_transfercomplete_callback_t user_callback)
{
   ba69c:	b530      	push	{r4, r5, lr}
   ba69e:	b087      	sub	sp, #28
   ba6a0:	4604      	mov	r4, r0
   ba6a2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    hal_spi_transfer_dma(_spi, tx_buffer, rx_buffer, length, user_callback);
   ba6a4:	9500      	str	r5, [sp, #0]
   ba6a6:	7800      	ldrb	r0, [r0, #0]
   ba6a8:	f7ff fd4c 	bl	ba144 <hal_spi_transfer_dma>
    if (user_callback == NULL)
   ba6ac:	b93d      	cbnz	r5, ba6be <_ZN8SPIClass8transferEPKvPvjPFvvE+0x22>
    {
        hal_spi_transfer_status_t st;
        do
        {
            hal_spi_transfer_dma_status(_spi, &st);
   ba6ae:	7820      	ldrb	r0, [r4, #0]
   ba6b0:	a902      	add	r1, sp, #8
   ba6b2:	f7ff fd4f 	bl	ba154 <hal_spi_transfer_dma_status>
        } while (st.transfer_ongoing);
   ba6b6:	f89d 3014 	ldrb.w	r3, [sp, #20]
   ba6ba:	07db      	lsls	r3, r3, #31
   ba6bc:	d4f7      	bmi.n	ba6ae <_ZN8SPIClass8transferEPKvPvjPFvvE+0x12>
    }
}
   ba6be:	b007      	add	sp, #28
   ba6c0:	bd30      	pop	{r4, r5, pc}
	...

000ba6c4 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
   ba6c4:	4b05      	ldr	r3, [pc, #20]	; (ba6dc <_GLOBAL__sub_I_System+0x18>)
   ba6c6:	2202      	movs	r2, #2
   ba6c8:	601a      	str	r2, [r3, #0]

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
   ba6ca:	4b05      	ldr	r3, [pc, #20]	; (ba6e0 <_GLOBAL__sub_I_System+0x1c>)
    SleepResult() {}
   ba6cc:	4a05      	ldr	r2, [pc, #20]	; (ba6e4 <_GLOBAL__sub_I_System+0x20>)
   ba6ce:	609a      	str	r2, [r3, #8]
              error_(SYSTEM_ERROR_NONE) {
   ba6d0:	2000      	movs	r0, #0
   ba6d2:	e9c3 0000 	strd	r0, r0, [r3]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
   ba6d6:	f7ff bdad 	b.w	ba234 <set_system_mode>
   ba6da:	bf00      	nop
   ba6dc:	2003e66c 	.word	0x2003e66c
   ba6e0:	2003e660 	.word	0x2003e660
   ba6e4:	ffff0000 	.word	0xffff0000

000ba6e8 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
   ba6e8:	b510      	push	{r4, lr}
   ba6ea:	4604      	mov	r4, r0
{
	free(buffer);
   ba6ec:	6800      	ldr	r0, [r0, #0]
   ba6ee:	f7ff fe85 	bl	ba3fc <free>
}
   ba6f2:	4620      	mov	r0, r4
   ba6f4:	bd10      	pop	{r4, pc}

000ba6f6 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
   ba6f6:	b510      	push	{r4, lr}
   ba6f8:	4604      	mov	r4, r0
	if (buffer) free(buffer);
   ba6fa:	6800      	ldr	r0, [r0, #0]
   ba6fc:	b108      	cbz	r0, ba702 <_ZN6String10invalidateEv+0xc>
   ba6fe:	f7ff fe7d 	bl	ba3fc <free>
	buffer = NULL;
   ba702:	2300      	movs	r3, #0
	capacity = len = 0;
   ba704:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
   ba708:	6023      	str	r3, [r4, #0]
}
   ba70a:	bd10      	pop	{r4, pc}

000ba70c <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
   ba70c:	b538      	push	{r3, r4, r5, lr}
   ba70e:	4604      	mov	r4, r0
   ba710:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
   ba712:	6800      	ldr	r0, [r0, #0]
   ba714:	3101      	adds	r1, #1
   ba716:	f7ff fe79 	bl	ba40c <realloc>
	if (newbuffer) {
   ba71a:	b110      	cbz	r0, ba722 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
   ba71c:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
   ba720:	2001      	movs	r0, #1
	}
	return 0;
}
   ba722:	bd38      	pop	{r3, r4, r5, pc}

000ba724 <_ZN6String7reserveEj>:
{
   ba724:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
   ba726:	6803      	ldr	r3, [r0, #0]
{
   ba728:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
   ba72a:	b123      	cbz	r3, ba736 <_ZN6String7reserveEj+0x12>
   ba72c:	6843      	ldr	r3, [r0, #4]
   ba72e:	428b      	cmp	r3, r1
   ba730:	d301      	bcc.n	ba736 <_ZN6String7reserveEj+0x12>
   ba732:	2001      	movs	r0, #1
}
   ba734:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
   ba736:	4620      	mov	r0, r4
   ba738:	f7ff ffe8 	bl	ba70c <_ZN6String12changeBufferEj>
   ba73c:	2800      	cmp	r0, #0
   ba73e:	d0f9      	beq.n	ba734 <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
   ba740:	68a3      	ldr	r3, [r4, #8]
   ba742:	2b00      	cmp	r3, #0
   ba744:	d1f5      	bne.n	ba732 <_ZN6String7reserveEj+0xe>
   ba746:	6822      	ldr	r2, [r4, #0]
   ba748:	7013      	strb	r3, [r2, #0]
   ba74a:	e7f2      	b.n	ba732 <_ZN6String7reserveEj+0xe>

000ba74c <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   ba74c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   ba74e:	460d      	mov	r5, r1
	if (!reserve(length)) {
   ba750:	4611      	mov	r1, r2
   ba752:	9201      	str	r2, [sp, #4]
{
   ba754:	4604      	mov	r4, r0
	if (!reserve(length)) {
   ba756:	f7ff ffe5 	bl	ba724 <_ZN6String7reserveEj>
   ba75a:	9a01      	ldr	r2, [sp, #4]
   ba75c:	b928      	cbnz	r0, ba76a <_ZN6String4copyEPKcj+0x1e>
		invalidate();
   ba75e:	4620      	mov	r0, r4
   ba760:	f7ff ffc9 	bl	ba6f6 <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
   ba764:	4620      	mov	r0, r4
   ba766:	b003      	add	sp, #12
   ba768:	bd30      	pop	{r4, r5, pc}
	len = length;
   ba76a:	60a2      	str	r2, [r4, #8]
	memcpy(buffer, cstr, length);
   ba76c:	4629      	mov	r1, r5
   ba76e:	6820      	ldr	r0, [r4, #0]
   ba770:	f004 fb9b 	bl	beeaa <memcpy>
	buffer[len] = 0;
   ba774:	6822      	ldr	r2, [r4, #0]
   ba776:	68a3      	ldr	r3, [r4, #8]
   ba778:	2100      	movs	r1, #0
   ba77a:	54d1      	strb	r1, [r2, r3]
	return *this;
   ba77c:	e7f2      	b.n	ba764 <_ZN6String4copyEPKcj+0x18>

000ba77e <_ZN6StringC1EPK19__FlashStringHelper>:
	buffer = NULL;
   ba77e:	2300      	movs	r3, #0
String::String(const __FlashStringHelper *pstr)
   ba780:	b513      	push	{r0, r1, r4, lr}
	capacity = 0;
   ba782:	e9c0 3300 	strd	r3, r3, [r0]
String::String(const __FlashStringHelper *pstr)
   ba786:	4604      	mov	r4, r0
	len = 0;
   ba788:	6083      	str	r3, [r0, #8]
	flags = 0;
   ba78a:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
   ba78c:	b141      	cbz	r1, ba7a0 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
	if (cstr) copy(cstr, strlen(cstr));
   ba78e:	4608      	mov	r0, r1
   ba790:	9101      	str	r1, [sp, #4]
   ba792:	f004 fc28 	bl	befe6 <strlen>
   ba796:	9901      	ldr	r1, [sp, #4]
   ba798:	4602      	mov	r2, r0
   ba79a:	4620      	mov	r0, r4
   ba79c:	f7ff ffd6 	bl	ba74c <_ZN6String4copyEPKcj>
}
   ba7a0:	4620      	mov	r0, r4
   ba7a2:	b002      	add	sp, #8
   ba7a4:	bd10      	pop	{r4, pc}

000ba7a6 <_ZN6String4moveERS_>:
    return copy(reinterpret_cast<const char*>(pstr), length);
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
void String::move(String &rhs)
{
   ba7a6:	b538      	push	{r3, r4, r5, lr}
   ba7a8:	4605      	mov	r5, r0
	if (buffer) {
   ba7aa:	6800      	ldr	r0, [r0, #0]
{
   ba7ac:	460c      	mov	r4, r1
	if (buffer) {
   ba7ae:	b168      	cbz	r0, ba7cc <_ZN6String4moveERS_+0x26>
		if (capacity >= rhs.len) {
   ba7b0:	686a      	ldr	r2, [r5, #4]
   ba7b2:	688b      	ldr	r3, [r1, #8]
   ba7b4:	429a      	cmp	r2, r3
   ba7b6:	d307      	bcc.n	ba7c8 <_ZN6String4moveERS_+0x22>
			strcpy(buffer, rhs.buffer);
   ba7b8:	6809      	ldr	r1, [r1, #0]
   ba7ba:	f004 fbee 	bl	bef9a <strcpy>
			len = rhs.len;
   ba7be:	68a3      	ldr	r3, [r4, #8]
   ba7c0:	60ab      	str	r3, [r5, #8]
			rhs.len = 0;
   ba7c2:	2300      	movs	r3, #0
	buffer = rhs.buffer;
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
	rhs.capacity = 0;
	rhs.len = 0;
   ba7c4:	60a3      	str	r3, [r4, #8]
}
   ba7c6:	bd38      	pop	{r3, r4, r5, pc}
			free(buffer);
   ba7c8:	f7ff fe18 	bl	ba3fc <free>
	buffer = rhs.buffer;
   ba7cc:	6823      	ldr	r3, [r4, #0]
   ba7ce:	602b      	str	r3, [r5, #0]
	capacity = rhs.capacity;
   ba7d0:	6863      	ldr	r3, [r4, #4]
   ba7d2:	606b      	str	r3, [r5, #4]
	len = rhs.len;
   ba7d4:	68a3      	ldr	r3, [r4, #8]
   ba7d6:	60ab      	str	r3, [r5, #8]
	rhs.buffer = NULL;
   ba7d8:	2300      	movs	r3, #0
	rhs.capacity = 0;
   ba7da:	e9c4 3300 	strd	r3, r3, [r4]
   ba7de:	e7f1      	b.n	ba7c4 <_ZN6String4moveERS_+0x1e>

000ba7e0 <_ZN6StringC1EOS_>:
String::String(String &&rval)
   ba7e0:	b510      	push	{r4, lr}
	buffer = NULL;
   ba7e2:	2300      	movs	r3, #0
	capacity = 0;
   ba7e4:	e9c0 3300 	strd	r3, r3, [r0]
String::String(String &&rval)
   ba7e8:	4604      	mov	r4, r0
	len = 0;
   ba7ea:	6083      	str	r3, [r0, #8]
	flags = 0;
   ba7ec:	7303      	strb	r3, [r0, #12]
	move(rval);
   ba7ee:	f7ff ffda 	bl	ba7a6 <_ZN6String4moveERS_>
}
   ba7f2:	4620      	mov	r0, r4
   ba7f4:	bd10      	pop	{r4, pc}

000ba7f6 <_ZN6StringaSERKS_>:
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
   ba7f6:	4288      	cmp	r0, r1
{
   ba7f8:	b510      	push	{r4, lr}
   ba7fa:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
   ba7fc:	d005      	beq.n	ba80a <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
   ba7fe:	680b      	ldr	r3, [r1, #0]
   ba800:	b12b      	cbz	r3, ba80e <_ZN6StringaSERKS_+0x18>
   ba802:	688a      	ldr	r2, [r1, #8]
   ba804:	4619      	mov	r1, r3
   ba806:	f7ff ffa1 	bl	ba74c <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
   ba80a:	4620      	mov	r0, r4
   ba80c:	bd10      	pop	{r4, pc}
	else invalidate();
   ba80e:	f7ff ff72 	bl	ba6f6 <_ZN6String10invalidateEv>
   ba812:	e7fa      	b.n	ba80a <_ZN6StringaSERKS_+0x14>

000ba814 <_ZN6StringC1ERKS_>:
String::String(const String &value)
   ba814:	b510      	push	{r4, lr}
	buffer = NULL;
   ba816:	2300      	movs	r3, #0
String::String(const String &value)
   ba818:	4604      	mov	r4, r0
	capacity = 0;
   ba81a:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
   ba81e:	6083      	str	r3, [r0, #8]
	flags = 0;
   ba820:	7303      	strb	r3, [r0, #12]
	*this = value;
   ba822:	f7ff ffe8 	bl	ba7f6 <_ZN6StringaSERKS_>
}
   ba826:	4620      	mov	r0, r4
   ba828:	bd10      	pop	{r4, pc}

000ba82a <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
   ba82a:	b513      	push	{r0, r1, r4, lr}
   ba82c:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
   ba82e:	b159      	cbz	r1, ba848 <_ZN6StringaSEPKc+0x1e>
   ba830:	4608      	mov	r0, r1
   ba832:	9101      	str	r1, [sp, #4]
   ba834:	f004 fbd7 	bl	befe6 <strlen>
   ba838:	9901      	ldr	r1, [sp, #4]
   ba83a:	4602      	mov	r2, r0
   ba83c:	4620      	mov	r0, r4
   ba83e:	f7ff ff85 	bl	ba74c <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
   ba842:	4620      	mov	r0, r4
   ba844:	b002      	add	sp, #8
   ba846:	bd10      	pop	{r4, pc}
	else invalidate();
   ba848:	f7ff ff55 	bl	ba6f6 <_ZN6String10invalidateEv>
   ba84c:	e7f9      	b.n	ba842 <_ZN6StringaSEPKc+0x18>

000ba84e <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
   ba84e:	b570      	push	{r4, r5, r6, lr}
   ba850:	4605      	mov	r5, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
   ba852:	460e      	mov	r6, r1
   ba854:	b909      	cbnz	r1, ba85a <_ZN6String6concatEPKcj+0xc>
   ba856:	2000      	movs	r0, #0
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
   ba858:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
   ba85a:	b16a      	cbz	r2, ba878 <_ZN6String6concatEPKcj+0x2a>
	unsigned int newlen = len + length;
   ba85c:	6884      	ldr	r4, [r0, #8]
   ba85e:	4414      	add	r4, r2
	if (!reserve(newlen)) return 0;
   ba860:	4621      	mov	r1, r4
   ba862:	f7ff ff5f 	bl	ba724 <_ZN6String7reserveEj>
   ba866:	2800      	cmp	r0, #0
   ba868:	d0f5      	beq.n	ba856 <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
   ba86a:	6828      	ldr	r0, [r5, #0]
   ba86c:	68ab      	ldr	r3, [r5, #8]
   ba86e:	4631      	mov	r1, r6
   ba870:	4418      	add	r0, r3
   ba872:	f004 fb92 	bl	bef9a <strcpy>
	len = newlen;
   ba876:	60ac      	str	r4, [r5, #8]
	if (length == 0) return 1;
   ba878:	2001      	movs	r0, #1
   ba87a:	e7ed      	b.n	ba858 <_ZN6String6concatEPKcj+0xa>

000ba87c <_ZN6String6concatEc>:
unsigned char String::concat(const __FlashStringHelper * str) {
	return concat(reinterpret_cast<const char*>(str));
}

unsigned char String::concat(char c)
{
   ba87c:	b507      	push	{r0, r1, r2, lr}
	char buf[2];
	buf[0] = c;
	buf[1] = 0;
   ba87e:	2300      	movs	r3, #0
	buf[0] = c;
   ba880:	f88d 1004 	strb.w	r1, [sp, #4]
	return concat(buf, 1);
   ba884:	2201      	movs	r2, #1
   ba886:	a901      	add	r1, sp, #4
	buf[1] = 0;
   ba888:	f88d 3005 	strb.w	r3, [sp, #5]
	return concat(buf, 1);
   ba88c:	f7ff ffdf 	bl	ba84e <_ZN6String6concatEPKcj>
}
   ba890:	b003      	add	sp, #12
   ba892:	f85d fb04 	ldr.w	pc, [sp], #4

000ba896 <_ZNK6String9compareToERKS_>:
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
   ba896:	6802      	ldr	r2, [r0, #0]
{
   ba898:	460b      	mov	r3, r1
	if (!buffer || !s.buffer) {
   ba89a:	6809      	ldr	r1, [r1, #0]
   ba89c:	b162      	cbz	r2, ba8b8 <_ZNK6String9compareToERKS_+0x22>
   ba89e:	b941      	cbnz	r1, ba8b2 <_ZNK6String9compareToERKS_+0x1c>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
		if (buffer && len > 0) return *(unsigned char *)buffer;
   ba8a0:	6880      	ldr	r0, [r0, #8]
   ba8a2:	b160      	cbz	r0, ba8be <_ZNK6String9compareToERKS_+0x28>
   ba8a4:	7810      	ldrb	r0, [r2, #0]
   ba8a6:	4770      	bx	lr
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
   ba8a8:	6898      	ldr	r0, [r3, #8]
   ba8aa:	b140      	cbz	r0, ba8be <_ZNK6String9compareToERKS_+0x28>
   ba8ac:	7809      	ldrb	r1, [r1, #0]
   ba8ae:	4248      	negs	r0, r1
   ba8b0:	4770      	bx	lr
		return 0;
	}
	return strcmp(buffer, s.buffer);
   ba8b2:	4610      	mov	r0, r2
   ba8b4:	f004 bb67 	b.w	bef86 <strcmp>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
   ba8b8:	2900      	cmp	r1, #0
   ba8ba:	d1f5      	bne.n	ba8a8 <_ZNK6String9compareToERKS_+0x12>
		return 0;
   ba8bc:	4608      	mov	r0, r1
}
   ba8be:	4770      	bx	lr

000ba8c0 <_ZNK6String6equalsERKS_>:

unsigned char String::equals(const String &s2) const
{
   ba8c0:	b508      	push	{r3, lr}
	return (len == s2.len && compareTo(s2) == 0);
   ba8c2:	6882      	ldr	r2, [r0, #8]
   ba8c4:	688b      	ldr	r3, [r1, #8]
   ba8c6:	429a      	cmp	r2, r3
   ba8c8:	d105      	bne.n	ba8d6 <_ZNK6String6equalsERKS_+0x16>
   ba8ca:	f7ff ffe4 	bl	ba896 <_ZNK6String9compareToERKS_>
   ba8ce:	fab0 f080 	clz	r0, r0
   ba8d2:	0940      	lsrs	r0, r0, #5
}
   ba8d4:	bd08      	pop	{r3, pc}
	return (len == s2.len && compareTo(s2) == 0);
   ba8d6:	2000      	movs	r0, #0
   ba8d8:	e7fc      	b.n	ba8d4 <_ZNK6String6equalsERKS_+0x14>

000ba8da <_ZNK6StringixEj>:
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
   ba8da:	6883      	ldr	r3, [r0, #8]
   ba8dc:	428b      	cmp	r3, r1
   ba8de:	d903      	bls.n	ba8e8 <_ZNK6StringixEj+0xe>
   ba8e0:	6800      	ldr	r0, [r0, #0]
   ba8e2:	b110      	cbz	r0, ba8ea <_ZNK6StringixEj+0x10>
	return buffer[index];
   ba8e4:	5c40      	ldrb	r0, [r0, r1]
   ba8e6:	4770      	bx	lr
	if (index >= len || !buffer) return 0;
   ba8e8:	2000      	movs	r0, #0
}
   ba8ea:	4770      	bx	lr

000ba8ec <_ZNK6String6charAtEj>:
	return operator[](loc);
   ba8ec:	f7ff bff5 	b.w	ba8da <_ZNK6StringixEj>

000ba8f0 <_ZNK6String8getBytesEPhjj>:

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
   ba8f0:	b558      	push	{r3, r4, r6, lr}
   ba8f2:	460e      	mov	r6, r1
	if (!bufsize || !buf) return;
   ba8f4:	b12a      	cbz	r2, ba902 <_ZNK6String8getBytesEPhjj+0x12>
   ba8f6:	b121      	cbz	r1, ba902 <_ZNK6String8getBytesEPhjj+0x12>
	if (index >= len) {
   ba8f8:	6884      	ldr	r4, [r0, #8]
   ba8fa:	42a3      	cmp	r3, r4
   ba8fc:	d302      	bcc.n	ba904 <_ZNK6String8getBytesEPhjj+0x14>
		buf[0] = 0;
   ba8fe:	2300      	movs	r3, #0
   ba900:	700b      	strb	r3, [r1, #0]
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
	buf[n] = 0;
}
   ba902:	bd58      	pop	{r3, r4, r6, pc}
	if (n > len - index) n = len - index;
   ba904:	1ae4      	subs	r4, r4, r3
	unsigned int n = bufsize - 1;
   ba906:	3a01      	subs	r2, #1
	strncpy((char *)buf, buffer + index, n);
   ba908:	6801      	ldr	r1, [r0, #0]
   ba90a:	4294      	cmp	r4, r2
   ba90c:	bf28      	it	cs
   ba90e:	4614      	movcs	r4, r2
   ba910:	4419      	add	r1, r3
   ba912:	4622      	mov	r2, r4
   ba914:	4630      	mov	r0, r6
   ba916:	f004 fb82 	bl	bf01e <strncpy>
	buf[n] = 0;
   ba91a:	2300      	movs	r3, #0
   ba91c:	5533      	strb	r3, [r6, r4]
   ba91e:	e7f0      	b.n	ba902 <_ZNK6String8getBytesEPhjj+0x12>

000ba920 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_ptr_inplace() noexcept { }
   ba920:	4770      	bx	lr

000ba922 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
   ba922:	4770      	bx	lr

000ba924 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      }
   ba924:	4770      	bx	lr

000ba926 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~_Sp_counted_ptr_inplace() noexcept { }
   ba926:	4770      	bx	lr

000ba928 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
	    ||
   ba928:	4b06      	ldr	r3, [pc, #24]	; (ba944 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x1c>)
   ba92a:	4299      	cmp	r1, r3
      _M_get_deleter(const std::type_info& __ti) noexcept override
   ba92c:	b510      	push	{r4, lr}
      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
   ba92e:	f100 040c 	add.w	r4, r0, #12
	    ||
   ba932:	d005      	beq.n	ba940 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x18>
	    _Sp_make_shared_tag::_S_eq(__ti)
   ba934:	4608      	mov	r0, r1
   ba936:	f003 fc13 	bl	be160 <_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info>
	return nullptr;
   ba93a:	2800      	cmp	r0, #0
   ba93c:	bf08      	it	eq
   ba93e:	2400      	moveq	r4, #0
      }
   ba940:	4620      	mov	r0, r4
   ba942:	bd10      	pop	{r4, pc}
   ba944:	000c2050 	.word	0x000c2050

000ba948 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
	    ||
   ba948:	4b06      	ldr	r3, [pc, #24]	; (ba964 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x1c>)
   ba94a:	4299      	cmp	r1, r3
      _M_get_deleter(const std::type_info& __ti) noexcept override
   ba94c:	b510      	push	{r4, lr}
   ba94e:	f100 040c 	add.w	r4, r0, #12
	    ||
   ba952:	d005      	beq.n	ba960 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x18>
	    _Sp_make_shared_tag::_S_eq(__ti)
   ba954:	4608      	mov	r0, r1
   ba956:	f003 fc03 	bl	be160 <_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info>
	return nullptr;
   ba95a:	2800      	cmp	r0, #0
   ba95c:	bf08      	it	eq
   ba95e:	2400      	moveq	r4, #0
      }
   ba960:	4620      	mov	r0, r4
   ba962:	bd10      	pop	{r4, pc}
   ba964:	000c2050 	.word	0x000c2050

000ba968 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
	    ||
   ba968:	4b06      	ldr	r3, [pc, #24]	; (ba984 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x1c>)
   ba96a:	4299      	cmp	r1, r3
      _M_get_deleter(const std::type_info& __ti) noexcept override
   ba96c:	b510      	push	{r4, lr}
   ba96e:	f100 040c 	add.w	r4, r0, #12
	    ||
   ba972:	d005      	beq.n	ba980 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info+0x18>
	    _Sp_make_shared_tag::_S_eq(__ti)
   ba974:	4608      	mov	r0, r1
   ba976:	f003 fbf3 	bl	be160 <_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info>
	return nullptr;
   ba97a:	2800      	cmp	r0, #0
   ba97c:	bf08      	it	eq
   ba97e:	2400      	moveq	r4, #0
      }
   ba980:	4620      	mov	r0, r4
   ba982:	bd10      	pop	{r4, pc}
   ba984:	000c2050 	.word	0x000c2050

000ba988 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
      ~_Sp_counted_ptr_inplace() noexcept { }
   ba988:	b510      	push	{r4, lr}
   ba98a:	2168      	movs	r1, #104	; 0x68
   ba98c:	4604      	mov	r4, r0
   ba98e:	f7f9 fb86 	bl	b409e <_ZdlPvj>
   ba992:	4620      	mov	r0, r4
   ba994:	bd10      	pop	{r4, pc}

000ba996 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
   ba996:	b510      	push	{r4, lr}
   ba998:	2128      	movs	r1, #40	; 0x28
   ba99a:	4604      	mov	r4, r0
   ba99c:	f7f9 fb7f 	bl	b409e <_ZdlPvj>
   ba9a0:	4620      	mov	r0, r4
   ba9a2:	bd10      	pop	{r4, pc}

000ba9a4 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
   ba9a4:	b510      	push	{r4, lr}
   ba9a6:	2130      	movs	r1, #48	; 0x30
   ba9a8:	4604      	mov	r4, r0
   ba9aa:	f7f9 fb78 	bl	b409e <_ZdlPvj>
   ba9ae:	4620      	mov	r0, r4
   ba9b0:	bd10      	pop	{r4, pc}

000ba9b2 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
	::operator delete(__p
   ba9b2:	2168      	movs	r1, #104	; 0x68
   ba9b4:	f7f9 bb73 	b.w	b409e <_ZdlPvj>

000ba9b8 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
   ba9b8:	2128      	movs	r1, #40	; 0x28
   ba9ba:	f7f9 bb70 	b.w	b409e <_ZdlPvj>

000ba9be <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
   ba9be:	2130      	movs	r1, #48	; 0x30
   ba9c0:	f7f9 bb6d 	b.w	b409e <_ZdlPvj>

000ba9c4 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0>:
        break;
    }
    return uuids;
}

size_t BleAdvertisingData::locate(const uint8_t* buf, size_t len, BleAdvertisingDataType type, size_t* offset) {
   ba9c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (offset == nullptr) {
        return 0;
    }
    uint8_t adsType = static_cast<uint8_t>(type);
    size_t adsLen;
    for (size_t i = 0; (i + 3) <= len; i = i) {
   ba9c6:	2500      	movs	r5, #0
   ba9c8:	1cec      	adds	r4, r5, #3
   ba9ca:	428c      	cmp	r4, r1
   ba9cc:	d80d      	bhi.n	ba9ea <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0+0x26>
        adsLen = buf[i];
        if (buf[i + 1] == adsType) {
   ba9ce:	1c6e      	adds	r6, r5, #1
        adsLen = buf[i];
   ba9d0:	5d44      	ldrb	r4, [r0, r5]
        if (buf[i + 1] == adsType) {
   ba9d2:	5d87      	ldrb	r7, [r0, r6]
   ba9d4:	4297      	cmp	r7, r2
   ba9d6:	d105      	bne.n	ba9e4 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0+0x20>
            // The value of adsLen doesn't include the length field of an AD structure.
            if ((i + adsLen + 1) <= len) {
   ba9d8:	4426      	add	r6, r4
   ba9da:	42b1      	cmp	r1, r6
   ba9dc:	d305      	bcc.n	ba9ea <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0+0x26>
                *offset = i;
   ba9de:	601d      	str	r5, [r3, #0]
                adsLen += 1;
   ba9e0:	1c60      	adds	r0, r4, #1
            // Navigate to the next AD structure.
            i += (adsLen + 1);
        }
    }
    return 0;
}
   ba9e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            i += (adsLen + 1);
   ba9e4:	3401      	adds	r4, #1
   ba9e6:	4425      	add	r5, r4
    for (size_t i = 0; (i + 3) <= len; i = i) {
   ba9e8:	e7ee      	b.n	ba9c8 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0+0x4>
    return 0;
   ba9ea:	2000      	movs	r0, #0
   ba9ec:	e7f9      	b.n	ba9e2 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0+0x1e>
	...

000ba9f0 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.0>:
}

BleCharacteristic::BleCharacteristic(const BleCharacteristic& characteristic)
        : impl_(characteristic.impl_) {
    if (!impl()) {
        SPARK_ASSERT(false);
   ba9f0:	4a02      	ldr	r2, [pc, #8]	; (ba9fc <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.0+0xc>)
   ba9f2:	4903      	ldr	r1, [pc, #12]	; (baa00 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.0+0x10>)
   ba9f4:	200a      	movs	r0, #10
   ba9f6:	f7ff bc05 	b.w	ba204 <panic_>
   ba9fa:	bf00      	nop
   ba9fc:	000b9d61 	.word	0x000b9d61
   baa00:	000c1de0 	.word	0x000c1de0

000baa04 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE9_M_invokeERKSt9_Any_dataOS1_OjS5_>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   baa04:	b430      	push	{r4, r5}
   baa06:	460d      	mov	r5, r1
   baa08:	4611      	mov	r1, r2
   baa0a:	461a      	mov	r2, r3
	    return __source._M_access<_Functor*>();
   baa0c:	6803      	ldr	r3, [r0, #0]
   baa0e:	6809      	ldr	r1, [r1, #0]
   baa10:	6828      	ldr	r0, [r5, #0]
   baa12:	e9d3 4300 	ldrd	r4, r3, [r3]
   baa16:	46a4      	mov	ip, r4
      }
   baa18:	bc30      	pop	{r4, r5}
   baa1a:	4760      	bx	ip

000baa1c <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation>:
	switch (__op)
   baa1c:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   baa1e:	b538      	push	{r3, r4, r5, lr}
   baa20:	4604      	mov	r4, r0
	switch (__op)
   baa22:	d102      	bne.n	baa2a <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0xe>
	    return __source._M_access<_Functor*>();
   baa24:	680b      	ldr	r3, [r1, #0]
	  __dest._M_access<_Functor*>() =
   baa26:	6023      	str	r3, [r4, #0]
	}
   baa28:	e003      	b.n	baa32 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0x16>
	  switch (__op)
   baa2a:	2a02      	cmp	r2, #2
   baa2c:	d003      	beq.n	baa36 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0x1a>
   baa2e:	2a03      	cmp	r2, #3
   baa30:	d00d      	beq.n	baa4e <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0x32>
      }
   baa32:	2000      	movs	r0, #0
   baa34:	bd38      	pop	{r3, r4, r5, pc}
	    new _Functor(*__source._M_access<const _Functor*>());
   baa36:	2008      	movs	r0, #8
	  __dest._M_access<_Functor*>() =
   baa38:	680d      	ldr	r5, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
   baa3a:	f7f9 fb2c 	bl	b4096 <_Znwj>
   baa3e:	4603      	mov	r3, r0
   baa40:	2800      	cmp	r0, #0
   baa42:	d0f0      	beq.n	baa26 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0xa>
   baa44:	e895 0003 	ldmia.w	r5, {r0, r1}
   baa48:	e883 0003 	stmia.w	r3, {r0, r1}
   baa4c:	e7eb      	b.n	baa26 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0xa>
	  delete __victim._M_access<_Functor*>();
   baa4e:	6800      	ldr	r0, [r0, #0]
   baa50:	2800      	cmp	r0, #0
   baa52:	d0ee      	beq.n	baa32 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0x16>
   baa54:	2108      	movs	r1, #8
   baa56:	f7f9 fb22 	bl	b409e <_ZdlPvj>
   baa5a:	e7ea      	b.n	baa32 <_ZNSt17_Function_handlerIFvPKhjRKN8particle13BlePeerDeviceEESt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESB_ILi2EESB_ILi3EES8_EEE10_M_managerERSt9_Any_dataRKSI_St18_Manager_operation+0x16>

000baa5c <_ZNSt8functionIFvPKN8particle13BleScanResultEEEaSEDn.isra.0>:
      operator=(nullptr_t) noexcept
   baa5c:	b510      	push	{r4, lr}
	if (_M_manager)
   baa5e:	6883      	ldr	r3, [r0, #8]
      operator=(nullptr_t) noexcept
   baa60:	4604      	mov	r4, r0
	if (_M_manager)
   baa62:	b12b      	cbz	r3, baa70 <_ZNSt8functionIFvPKN8particle13BleScanResultEEEaSEDn.isra.0+0x14>
	    _M_manager(_M_functor, _M_functor, __destroy_functor);
   baa64:	2203      	movs	r2, #3
   baa66:	4601      	mov	r1, r0
   baa68:	4798      	blx	r3
	    _M_manager = nullptr;
   baa6a:	2300      	movs	r3, #0
	    _M_invoker = nullptr;
   baa6c:	e9c4 3302 	strd	r3, r3, [r4, #8]
      }
   baa70:	bd10      	pop	{r4, pc}

000baa72 <_ZNSt8functionIFvRKN8particle13BleScanResultEEEaSEDn.isra.0>:
      operator=(nullptr_t) noexcept
   baa72:	b510      	push	{r4, lr}
	if (_M_manager)
   baa74:	6883      	ldr	r3, [r0, #8]
      operator=(nullptr_t) noexcept
   baa76:	4604      	mov	r4, r0
	if (_M_manager)
   baa78:	b12b      	cbz	r3, baa86 <_ZNSt8functionIFvRKN8particle13BleScanResultEEEaSEDn.isra.0+0x14>
	    _M_manager(_M_functor, _M_functor, __destroy_functor);
   baa7a:	2203      	movs	r2, #3
   baa7c:	4601      	mov	r1, r0
   baa7e:	4798      	blx	r3
	    _M_manager = nullptr;
   baa80:	2300      	movs	r3, #0
	    _M_invoker = nullptr;
   baa82:	e9c4 3302 	strd	r3, r3, [r4, #8]
      }
   baa86:	bd10      	pop	{r4, pc}

000baa88 <_ZN8particle21BleDiscoveryDelegator19discoverAllServicesERNS_13BlePeerDeviceE.isra.0>:
class BleDiscoveryDelegator {
public:
    BleDiscoveryDelegator() = default;
    ~BleDiscoveryDelegator() = default;

    int discoverAllServices(BlePeerDevice& peer) {
   baa88:	b510      	push	{r4, lr}
        LOG(TRACE, "Start discovering services.");
   baa8a:	2300      	movs	r3, #0
    int discoverAllServices(BlePeerDevice& peer) {
   baa8c:	b08a      	sub	sp, #40	; 0x28
        LOG(TRACE, "Start discovering services.");
   baa8e:	2220      	movs	r2, #32
   baa90:	e9cd 2302 	strd	r2, r3, [sp, #8]
    int discoverAllServices(BlePeerDevice& peer) {
   baa94:	4604      	mov	r4, r0
        LOG(TRACE, "Start discovering services.");
   baa96:	4a08      	ldr	r2, [pc, #32]	; (baab8 <_ZN8particle21BleDiscoveryDelegator19discoverAllServicesERNS_13BlePeerDeviceE.isra.0+0x30>)
   baa98:	9200      	str	r2, [sp, #0]
   baa9a:	4908      	ldr	r1, [pc, #32]	; (baabc <_ZN8particle21BleDiscoveryDelegator19discoverAllServicesERNS_13BlePeerDeviceE.isra.0+0x34>)
   baa9c:	aa02      	add	r2, sp, #8
   baa9e:	2001      	movs	r0, #1
   baaa0:	f7ff fbb8 	bl	ba214 <log_message>
        return hal_ble_gatt_client_discover_all_services(peer.impl()->connHandle(), onServicesDiscovered, &peer, nullptr);
   baaa4:	6820      	ldr	r0, [r4, #0]
   baaa6:	4906      	ldr	r1, [pc, #24]	; (baac0 <_ZN8particle21BleDiscoveryDelegator19discoverAllServicesERNS_13BlePeerDeviceE.isra.0+0x38>)
   baaa8:	8800      	ldrh	r0, [r0, #0]
   baaaa:	2300      	movs	r3, #0
   baaac:	4622      	mov	r2, r4
    }
   baaae:	b00a      	add	sp, #40	; 0x28
   baab0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return hal_ble_gatt_client_discover_all_services(peer.impl()->connHandle(), onServicesDiscovered, &peer, nullptr);
   baab4:	f7ff b9c2 	b.w	b9e3c <hal_ble_gatt_client_discover_all_services>
   baab8:	000c1e02 	.word	0x000c1e02
   baabc:	000c1df7 	.word	0x000c1df7
   baac0:	000bc5f1 	.word	0x000bc5f1

000baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>:
{
    *p++ = ascii_nibble_lower_case(nibble);
    return p;
}

static inline char* bytes2hexbuf(const uint8_t* buf, unsigned len, char* out)
   baac4:	b510      	push	{r4, lr}
   baac6:	3801      	subs	r0, #1
   baac8:	eb02 0141 	add.w	r1, r2, r1, lsl #1
{
    unsigned i;
    char* result = out;
    for (i = 0; i < len; ++i)
    {
        out = concat_nibble(out, (buf[i] >> 4));
   baacc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   baad0:	091b      	lsrs	r3, r3, #4
    char hex_digit = nibble + 48;
   baad2:	f103 0430 	add.w	r4, r3, #48	; 0x30
    if (57 < hex_digit) {
   baad6:	2c39      	cmp	r4, #57	; 0x39
        hex_digit += 7;
   baad8:	bf88      	it	hi
   baada:	f103 0437 	addhi.w	r4, r3, #55	; 0x37
    *p++ = ascii_nibble(nibble);
   baade:	f802 4b02 	strb.w	r4, [r2], #2
        out = concat_nibble(out, (buf[i] & 0xF));
   baae2:	7803      	ldrb	r3, [r0, #0]
   baae4:	f003 030f 	and.w	r3, r3, #15
    char hex_digit = nibble + 48;
   baae8:	f103 0430 	add.w	r4, r3, #48	; 0x30
    if (57 < hex_digit) {
   baaec:	2c39      	cmp	r4, #57	; 0x39
        hex_digit += 7;
   baaee:	bf88      	it	hi
   baaf0:	f103 0437 	addhi.w	r4, r3, #55	; 0x37
    for (i = 0; i < len; ++i)
   baaf4:	4291      	cmp	r1, r2
    *p++ = ascii_nibble(nibble);
   baaf6:	f802 4c01 	strb.w	r4, [r2, #-1]
    for (i = 0; i < len; ++i)
   baafa:	d1e7      	bne.n	baacc <_ZL12bytes2hexbufPKhjPc.isra.0+0x8>
    }
    return result;
}
   baafc:	bd10      	pop	{r4, pc}

000baafe <_ZNSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
   baafe:	b510      	push	{r4, lr}
   bab00:	4604      	mov	r4, r0
    class function<_Res(_ArgTypes...)>
   bab02:	3058      	adds	r0, #88	; 0x58
   bab04:	f7f9 fcac 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
    ~BleCharacteristicImpl() = default;
   bab08:	f104 0048 	add.w	r0, r4, #72	; 0x48
      }
   bab0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   bab10:	f7ff bdea 	b.w	ba6e8 <_ZN6StringD1Ev>

000bab14 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0>:
      operator=(const __shared_count& __r) noexcept
   bab14:	b538      	push	{r3, r4, r5, lr}
	if (__tmp != _M_pi)
   bab16:	6803      	ldr	r3, [r0, #0]
   bab18:	428b      	cmp	r3, r1
      operator=(const __shared_count& __r) noexcept
   bab1a:	4605      	mov	r5, r0
   bab1c:	460c      	mov	r4, r1
	if (__tmp != _M_pi)
   bab1e:	d008      	beq.n	bab32 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0+0x1e>
	    if (__tmp != 0)
   bab20:	b111      	cbz	r1, bab28 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0+0x14>
    { ++_M_use_count; }
   bab22:	684b      	ldr	r3, [r1, #4]
   bab24:	3301      	adds	r3, #1
   bab26:	604b      	str	r3, [r1, #4]
	    if (_M_pi != 0)
   bab28:	6828      	ldr	r0, [r5, #0]
   bab2a:	b108      	cbz	r0, bab30 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0+0x1c>
	      _M_pi->_M_release();
   bab2c:	f7f9 fcd6 	bl	b44dc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
	    _M_pi = __tmp;
   bab30:	602c      	str	r4, [r5, #0]
      }
   bab32:	bd38      	pop	{r3, r4, r5, pc}

000bab34 <_ZN8particle11hexToNibbleEc>:
#include <cstdint>

namespace particle {

inline int hexToNibble(char c) {
    if (c >= '0' && c <= '9') {
   bab34:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   bab38:	b2da      	uxtb	r2, r3
   bab3a:	2a09      	cmp	r2, #9
   bab3c:	d801      	bhi.n	bab42 <_ZN8particle11hexToNibbleEc+0xe>
        return (c - '0');
   bab3e:	4618      	mov	r0, r3
   bab40:	4770      	bx	lr
    } else if (c >= 'a' && c <= 'f') {
   bab42:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   bab46:	2b05      	cmp	r3, #5
   bab48:	d801      	bhi.n	bab4e <_ZN8particle11hexToNibbleEc+0x1a>
        return (c - 'a' + 0x0a);
   bab4a:	3857      	subs	r0, #87	; 0x57
   bab4c:	4770      	bx	lr
    } else if (c >= 'A' && c <= 'F') {
   bab4e:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   bab52:	2b05      	cmp	r3, #5
        return (c - 'A' + 0x0a);
   bab54:	bf94      	ite	ls
   bab56:	3837      	subls	r0, #55	; 0x37
    }
    return -1;
   bab58:	f04f 30ff 	movhi.w	r0, #4294967295
}
   bab5c:	4770      	bx	lr
	...

000bab60 <_ZN8particle3ble13WiringBleLockC1Ev>:
    WiringBleLock() :
   bab60:	b510      	push	{r4, lr}
            locked_(false) {
   bab62:	2300      	movs	r3, #0
   bab64:	7003      	strb	r3, [r0, #0]
            os_mutex_recursive_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_recursive_lock(handle_); }
   bab66:	4b04      	ldr	r3, [pc, #16]	; (bab78 <_ZN8particle3ble13WiringBleLockC1Ev+0x18>)
    WiringBleLock() :
   bab68:	4604      	mov	r4, r0
   bab6a:	6818      	ldr	r0, [r3, #0]
   bab6c:	f7ff fa02 	bl	b9f74 <os_mutex_recursive_lock>
        locked_ = true;
   bab70:	2301      	movs	r3, #1
   bab72:	7023      	strb	r3, [r4, #0]
    }
   bab74:	4620      	mov	r0, r4
   bab76:	bd10      	pop	{r4, pc}
   bab78:	2003e674 	.word	0x2003e674

000bab7c <_ZN8particle3ble13WiringBleLockD1Ev>:
    ~WiringBleLock() {
   bab7c:	b510      	push	{r4, lr}
        if (locked_) {
   bab7e:	7803      	ldrb	r3, [r0, #0]
    ~WiringBleLock() {
   bab80:	4604      	mov	r4, r0
        if (locked_) {
   bab82:	b11b      	cbz	r3, bab8c <_ZN8particle3ble13WiringBleLockD1Ev+0x10>
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    bool try_lock() { return trylock(); }
    void unlock() { os_mutex_recursive_unlock(handle_); }
   bab84:	4b02      	ldr	r3, [pc, #8]	; (bab90 <_ZN8particle3ble13WiringBleLockD1Ev+0x14>)
   bab86:	6818      	ldr	r0, [r3, #0]
   bab88:	f7ff f9fc 	bl	b9f84 <os_mutex_recursive_unlock>
    }
   bab8c:	4620      	mov	r0, r4
   bab8e:	bd10      	pop	{r4, pc}
   bab90:	2003e674 	.word	0x2003e674

000bab94 <_ZN8particle10BleAddressaSERK14hal_ble_addr_t>:
BleAddress& BleAddress::operator=(const hal_ble_addr_t& addr) {
   bab94:	b082      	sub	sp, #8
   bab96:	4603      	mov	r3, r0
    address_ = addr;
   bab98:	6808      	ldr	r0, [r1, #0]
   bab9a:	6849      	ldr	r1, [r1, #4]
   bab9c:	466a      	mov	r2, sp
   bab9e:	c203      	stmia	r2!, {r0, r1}
    address_ = addr.address_;
   baba0:	466a      	mov	r2, sp
   baba2:	ca03      	ldmia	r2!, {r0, r1}
   baba4:	6018      	str	r0, [r3, #0]
}
   baba6:	4618      	mov	r0, r3
    address_ = addr.address_;
   baba8:	6059      	str	r1, [r3, #4]
}
   babaa:	b002      	add	sp, #8
   babac:	4770      	bx	lr

000babae <_ZNK8particle10BleAddresseqERKS0_>:
bool BleAddress::operator==(const BleAddress& addr) const {
   babae:	b508      	push	{r3, lr}
    if (address_.addr_type == addr.address_.addr_type && !memcmp(address_.addr, addr.address_.addr, BLE_SIG_ADDR_LEN)) {
   babb0:	7982      	ldrb	r2, [r0, #6]
   babb2:	798b      	ldrb	r3, [r1, #6]
   babb4:	429a      	cmp	r2, r3
   babb6:	d106      	bne.n	babc6 <_ZNK8particle10BleAddresseqERKS0_+0x18>
   babb8:	2206      	movs	r2, #6
   babba:	f004 f966 	bl	bee8a <memcmp>
   babbe:	fab0 f080 	clz	r0, r0
   babc2:	0940      	lsrs	r0, r0, #5
}
   babc4:	bd08      	pop	{r3, pc}
    return false;
   babc6:	2000      	movs	r0, #0
   babc8:	e7fc      	b.n	babc4 <_ZNK8particle10BleAddresseqERKS0_+0x16>

000babca <_ZN8particle10BleAddress5clearEv>:
    memset(address_.addr, 0xFF, BLE_SIG_ADDR_LEN);
   babca:	f04f 33ff 	mov.w	r3, #4294967295
   babce:	6003      	str	r3, [r0, #0]
   babd0:	8083      	strh	r3, [r0, #4]
}
   babd2:	2000      	movs	r0, #0
   babd4:	4770      	bx	lr

000babd6 <_ZN8particle10BleAddressC1Ev>:
BleAddress::BleAddress()
   babd6:	b508      	push	{r3, lr}
   babd8:	4602      	mov	r2, r0
        : address_{} {
   babda:	2100      	movs	r1, #0
   babdc:	6001      	str	r1, [r0, #0]
   babde:	6041      	str	r1, [r0, #4]
    clear();
   babe0:	f7ff fff3 	bl	babca <_ZN8particle10BleAddress5clearEv>
    address_.addr_type = BLE_SIG_ADDR_TYPE_PUBLIC;
   babe4:	7191      	strb	r1, [r2, #6]
}
   babe6:	4610      	mov	r0, r2
   babe8:	bd08      	pop	{r3, pc}
	...

000babec <_ZN8particle7BleUuidC1Ev>:
BleUuid::BleUuid()
   babec:	b510      	push	{r4, lr}
        : type_(BleUuidType::LONG) {
   babee:	2301      	movs	r3, #1
   babf0:	6103      	str	r3, [r0, #16]
    memcpy(uuid128_, BASE_UUID, BLE_SIG_UUID_128BIT_LEN);
   babf2:	4b05      	ldr	r3, [pc, #20]	; (bac08 <_ZN8particle7BleUuidC1Ev+0x1c>)
   babf4:	4602      	mov	r2, r0
   babf6:	f103 0110 	add.w	r1, r3, #16
   babfa:	f853 4b04 	ldr.w	r4, [r3], #4
   babfe:	f842 4b04 	str.w	r4, [r2], #4
   bac02:	428b      	cmp	r3, r1
   bac04:	d1f9      	bne.n	babfa <_ZN8particle7BleUuidC1Ev+0xe>
}
   bac06:	bd10      	pop	{r4, pc}
   bac08:	000c205e 	.word	0x000c205e

000bac0c <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t>:
    if (uuid.type == BLE_UUID_TYPE_16BIT || uuid.type == BLE_UUID_TYPE_128BIT_SHORTED) {
   bac0c:	7c0b      	ldrb	r3, [r1, #16]
   bac0e:	f013 03fd 	ands.w	r3, r3, #253	; 0xfd
BleUuid::BleUuid(const hal_ble_uuid_t& uuid) {
   bac12:	b530      	push	{r4, r5, lr}
    if (uuid.type == BLE_UUID_TYPE_16BIT || uuid.type == BLE_UUID_TYPE_128BIT_SHORTED) {
   bac14:	d10d      	bne.n	bac32 <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t+0x26>
        type_ = BleUuidType::SHORT;
   bac16:	6103      	str	r3, [r0, #16]
        memcpy(uuid128_, BASE_UUID, BLE_SIG_UUID_128BIT_LEN);
   bac18:	4b0c      	ldr	r3, [pc, #48]	; (bac4c <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t+0x40>)
   bac1a:	4602      	mov	r2, r0
   bac1c:	f103 0410 	add.w	r4, r3, #16
   bac20:	f853 5b04 	ldr.w	r5, [r3], #4
   bac24:	f842 5b04 	str.w	r5, [r2], #4
   bac28:	42a3      	cmp	r3, r4
   bac2a:	d1f9      	bne.n	bac20 <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t+0x14>
        uuid128_[UUID16_LO] = (uint8_t)uuid.uuid16;
   bac2c:	880b      	ldrh	r3, [r1, #0]
   bac2e:	8183      	strh	r3, [r0, #12]
}
   bac30:	bd30      	pop	{r4, r5, pc}
        type_ = BleUuidType::LONG;
   bac32:	2301      	movs	r3, #1
   bac34:	6103      	str	r3, [r0, #16]
        memcpy(uuid128_, uuid.uuid128, BLE_SIG_UUID_128BIT_LEN);
   bac36:	f101 0210 	add.w	r2, r1, #16
   bac3a:	4603      	mov	r3, r0
   bac3c:	f851 4b04 	ldr.w	r4, [r1], #4
   bac40:	f843 4b04 	str.w	r4, [r3], #4
   bac44:	4291      	cmp	r1, r2
   bac46:	d1f9      	bne.n	bac3c <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t+0x30>
   bac48:	e7f2      	b.n	bac30 <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t+0x24>
   bac4a:	bf00      	nop
   bac4c:	000c205e 	.word	0x000c205e

000bac50 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE>:
BleUuid::BleUuid(const uint8_t* uuid128, BleUuidOrder order) {
   bac50:	b510      	push	{r4, lr}
    if (uuid128) {
   bac52:	460b      	mov	r3, r1
BleUuid::BleUuid(const uint8_t* uuid128, BleUuidOrder order) {
   bac54:	4604      	mov	r4, r0
    if (uuid128) {
   bac56:	b1b1      	cbz	r1, bac86 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x36>
        if (order == BleUuidOrder::LSB) {
   bac58:	2a01      	cmp	r2, #1
   bac5a:	f101 0210 	add.w	r2, r1, #16
   bac5e:	d10a      	bne.n	bac76 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x26>
            memcpy(uuid128_, uuid128, BLE_SIG_UUID_128BIT_LEN);
   bac60:	4601      	mov	r1, r0
   bac62:	f853 0b04 	ldr.w	r0, [r3], #4
   bac66:	f841 0b04 	str.w	r0, [r1], #4
   bac6a:	4293      	cmp	r3, r2
   bac6c:	d1f9      	bne.n	bac62 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x12>
        type_ = BleUuidType::LONG;
   bac6e:	2301      	movs	r3, #1
   bac70:	6123      	str	r3, [r4, #16]
}
   bac72:	4620      	mov	r0, r4
   bac74:	bd10      	pop	{r4, pc}
   bac76:	1e41      	subs	r1, r0, #1
                uuid128_[i] = uuid128[j];
   bac78:	f812 0d01 	ldrb.w	r0, [r2, #-1]!
   bac7c:	f801 0f01 	strb.w	r0, [r1, #1]!
            for (uint8_t i = 0, j = BLE_SIG_UUID_128BIT_LEN - 1; i < BLE_SIG_UUID_128BIT_LEN; i++, j--) {
   bac80:	429a      	cmp	r2, r3
   bac82:	d1f9      	bne.n	bac78 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x28>
   bac84:	e7f3      	b.n	bac6e <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x1e>
        memset(uuid128_, 0x00, BLE_SIG_UUID_128BIT_LEN);
   bac86:	2210      	movs	r2, #16
   bac88:	f004 f937 	bl	beefa <memset>
   bac8c:	e7f1      	b.n	bac72 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE+0x22>

000bac8e <_ZN8particle7BleUuidC1Et>:
BleUuid::BleUuid(uint16_t uuid16)
   bac8e:	b538      	push	{r3, r4, r5, lr}
   bac90:	4604      	mov	r4, r0
   bac92:	460d      	mov	r5, r1
        : BleUuid() {
   bac94:	f7ff ffaa 	bl	babec <_ZN8particle7BleUuidC1Ev>
    type_ = BleUuidType::SHORT;
   bac98:	2300      	movs	r3, #0
   bac9a:	6123      	str	r3, [r4, #16]
    uuid128_[UUID16_LO] = (uint8_t)(uuid16 & 0x00FF);
   bac9c:	81a5      	strh	r5, [r4, #12]
}
   bac9e:	4620      	mov	r0, r4
   baca0:	bd38      	pop	{r3, r4, r5, pc}

000baca2 <_ZNK8particle7BleUuideqERKS0_>:
bool BleUuid::operator==(const BleUuid& uuid) const {
   baca2:	b508      	push	{r3, lr}
    return ((type_ == uuid.type_) && !memcmp(uuid128_, uuid.uuid128_, BLE_SIG_UUID_128BIT_LEN));
   baca4:	6902      	ldr	r2, [r0, #16]
   baca6:	690b      	ldr	r3, [r1, #16]
   baca8:	429a      	cmp	r2, r3
   bacaa:	d106      	bne.n	bacba <_ZNK8particle7BleUuideqERKS0_+0x18>
   bacac:	2210      	movs	r2, #16
   bacae:	f004 f8ec 	bl	bee8a <memcmp>
   bacb2:	fab0 f080 	clz	r0, r0
   bacb6:	0940      	lsrs	r0, r0, #5
}
   bacb8:	bd08      	pop	{r3, pc}
    return ((type_ == uuid.type_) && !memcmp(uuid128_, uuid.uuid128_, BLE_SIG_UUID_128BIT_LEN));
   bacba:	2000      	movs	r0, #0
   bacbc:	e7fc      	b.n	bacb8 <_ZNK8particle7BleUuideqERKS0_+0x16>
	...

000bacc0 <_ZN8particle7BleUuid9constructEPKc>:
    type_ = BleUuidType::LONG;
   bacc0:	2301      	movs	r3, #1
void BleUuid::construct(const char* uuid) {
   bacc2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    type_ = BleUuidType::LONG;
   bacc6:	6103      	str	r3, [r0, #16]
    memcpy(uuid128_, BASE_UUID, BLE_SIG_UUID_128BIT_LEN);
   bacc8:	4b34      	ldr	r3, [pc, #208]	; (bad9c <_ZN8particle7BleUuid9constructEPKc+0xdc>)
void BleUuid::construct(const char* uuid) {
   bacca:	460c      	mov	r4, r1
   baccc:	4606      	mov	r6, r0
    memcpy(uuid128_, BASE_UUID, BLE_SIG_UUID_128BIT_LEN);
   bacce:	4602      	mov	r2, r0
   bacd0:	f103 0110 	add.w	r1, r3, #16
   bacd4:	f853 0b04 	ldr.w	r0, [r3], #4
   bacd8:	f842 0b04 	str.w	r0, [r2], #4
   bacdc:	428b      	cmp	r3, r1
   bacde:	d1f9      	bne.n	bacd4 <_ZN8particle7BleUuid9constructEPKc+0x14>
    if (uuid == nullptr) {
   bace0:	b344      	cbz	r4, bad34 <_ZN8particle7BleUuid9constructEPKc+0x74>
    if (strnlen(uuid, BLE_SIG_UUID_128BIT_LEN * 2 + 4) == (BLE_SIG_UUID_16BIT_LEN * 2)) {
   bace2:	2124      	movs	r1, #36	; 0x24
   bace4:	4620      	mov	r0, r4
   bace6:	f004 f9ad 	bl	bf044 <strnlen>
   bacea:	2804      	cmp	r0, #4
   bacec:	f04f 0500 	mov.w	r5, #0
   bacf0:	d123      	bne.n	bad3a <_ZN8particle7BleUuid9constructEPKc+0x7a>
        char buf[2] = {};
   bacf2:	f8ad 5004 	strh.w	r5, [sp, #4]
   bacf6:	af01      	add	r7, sp, #4
   bacf8:	1ca5      	adds	r5, r4, #2
   bacfa:	3406      	adds	r4, #6

inline size_t hexToBytes(const char* src, char* dest, size_t size) {
    size_t n = 0;
    while (n < size) {
        const int h = hexToNibble(*src++);
   bacfc:	f815 0c02 	ldrb.w	r0, [r5, #-2]
   bad00:	f7ff ff18 	bl	bab34 <_ZN8particle11hexToNibbleEc>
        if (h < 0) {
   bad04:	f1b0 0800 	subs.w	r8, r0, #0
   bad08:	db12      	blt.n	bad30 <_ZN8particle7BleUuid9constructEPKc+0x70>
            break;
        }
        const int l = hexToNibble(*src++);
   bad0a:	f815 0c01 	ldrb.w	r0, [r5, #-1]
   bad0e:	f7ff ff11 	bl	bab34 <_ZN8particle11hexToNibbleEc>
        if (l < 0) {
   bad12:	2800      	cmp	r0, #0
   bad14:	db0c      	blt.n	bad30 <_ZN8particle7BleUuid9constructEPKc+0x70>
    while (n < size) {
   bad16:	3502      	adds	r5, #2
            break;
        }
        *dest++ = ((unsigned)h << 4) | (unsigned)l;
   bad18:	ea40 1008 	orr.w	r0, r0, r8, lsl #4
    while (n < size) {
   bad1c:	42a5      	cmp	r5, r4
        *dest++ = ((unsigned)h << 4) | (unsigned)l;
   bad1e:	f807 0b01 	strb.w	r0, [r7], #1
    while (n < size) {
   bad22:	d1eb      	bne.n	bacfc <_ZN8particle7BleUuid9constructEPKc+0x3c>
            uuid128_[UUID16_LO] = buf[1];
   bad24:	f89d 3005 	ldrb.w	r3, [sp, #5]
   bad28:	7333      	strb	r3, [r6, #12]
            uuid128_[UUID16_HI] = buf[0];
   bad2a:	f89d 3004 	ldrb.w	r3, [sp, #4]
   bad2e:	7373      	strb	r3, [r6, #13]
        type_ = BleUuidType::SHORT;
   bad30:	2300      	movs	r3, #0
   bad32:	6133      	str	r3, [r6, #16]
}
   bad34:	b002      	add	sp, #8
   bad36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    size_t len = BLE_SIG_UUID_128BIT_LEN;
   bad3a:	f04f 0810 	mov.w	r8, #16
    for (size_t i = 0; i < strnlen(uuid, BLE_SIG_UUID_128BIT_LEN * 2 + 4) && len > 0; i++) {
   bad3e:	2124      	movs	r1, #36	; 0x24
   bad40:	4620      	mov	r0, r4
   bad42:	f004 f97f 	bl	bf044 <strnlen>
   bad46:	42a8      	cmp	r0, r5
   bad48:	d807      	bhi.n	bad5a <_ZN8particle7BleUuid9constructEPKc+0x9a>
        uuid128_[len - 1] = 0x00;
   bad4a:	4642      	mov	r2, r8
   bad4c:	2100      	movs	r1, #0
   bad4e:	4630      	mov	r0, r6
}
   bad50:	b002      	add	sp, #8
   bad52:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        uuid128_[len - 1] = 0x00;
   bad56:	f004 b8d0 	b.w	beefa <memset>
    for (size_t i = 0; i < strnlen(uuid, BLE_SIG_UUID_128BIT_LEN * 2 + 4) && len > 0; i++) {
   bad5a:	f1b8 0f00 	cmp.w	r8, #0
   bad5e:	d0e9      	beq.n	bad34 <_ZN8particle7BleUuid9constructEPKc+0x74>
        int8_t hi = hexToNibble(uuid[i]);
   bad60:	5d60      	ldrb	r0, [r4, r5]
   bad62:	f7ff fee7 	bl	bab34 <_ZN8particle11hexToNibbleEc>
        if (hi >= 0) {
   bad66:	0603      	lsls	r3, r0, #24
   bad68:	d415      	bmi.n	bad96 <_ZN8particle7BleUuid9constructEPKc+0xd6>
            uuid128_[len - 1] = hi << 4;
   bad6a:	0100      	lsls	r0, r0, #4
   bad6c:	f108 38ff 	add.w	r8, r8, #4294967295
   bad70:	b2c7      	uxtb	r7, r0
   bad72:	f806 7008 	strb.w	r7, [r6, r8]
            if (++i < strnlen(uuid, BLE_SIG_UUID_128BIT_LEN * 2 + 4)) {
   bad76:	2124      	movs	r1, #36	; 0x24
   bad78:	4620      	mov	r0, r4
   bad7a:	f004 f963 	bl	bf044 <strnlen>
   bad7e:	3501      	adds	r5, #1
   bad80:	42a8      	cmp	r0, r5
   bad82:	d908      	bls.n	bad96 <_ZN8particle7BleUuid9constructEPKc+0xd6>
                int8_t lo = hexToNibble(uuid[i]);
   bad84:	5d60      	ldrb	r0, [r4, r5]
   bad86:	f7ff fed5 	bl	bab34 <_ZN8particle11hexToNibbleEc>
   bad8a:	b240      	sxtb	r0, r0
                if (lo >= 0) {
   bad8c:	2800      	cmp	r0, #0
                    uuid128_[len - 1] |= lo;
   bad8e:	bfa4      	itt	ge
   bad90:	4338      	orrge	r0, r7
   bad92:	f806 0008 	strbge.w	r0, [r6, r8]
    for (size_t i = 0; i < strnlen(uuid, BLE_SIG_UUID_128BIT_LEN * 2 + 4) && len > 0; i++) {
   bad96:	3501      	adds	r5, #1
   bad98:	e7d1      	b.n	bad3e <_ZN8particle7BleUuid9constructEPKc+0x7e>
   bad9a:	bf00      	nop
   bad9c:	000c205e 	.word	0x000c205e

000bada0 <_ZN8particle7BleUuidC1EPKc>:
BleUuid::BleUuid(const char* uuid)
   bada0:	b513      	push	{r0, r1, r4, lr}
   bada2:	4604      	mov	r4, r0
   bada4:	9101      	str	r1, [sp, #4]
        : BleUuid() {
   bada6:	f7ff ff21 	bl	babec <_ZN8particle7BleUuidC1Ev>
    construct(uuid);
   badaa:	4620      	mov	r0, r4
   badac:	9901      	ldr	r1, [sp, #4]
   badae:	f7ff ff87 	bl	bacc0 <_ZN8particle7BleUuid9constructEPKc>
}
   badb2:	4620      	mov	r0, r4
   badb4:	b002      	add	sp, #8
   badb6:	bd10      	pop	{r4, pc}

000badb8 <_ZNK8particle7BleUuid11toBigEndianEPh>:
void BleUuid::toBigEndian(uint8_t buf[BLE_SIG_UUID_128BIT_LEN]) const {
   badb8:	b510      	push	{r4, lr}
   badba:	f100 030f 	add.w	r3, r0, #15
   badbe:	3901      	subs	r1, #1
        buf[i] = uuid128_[j];
   badc0:	781c      	ldrb	r4, [r3, #0]
   badc2:	f801 4f01 	strb.w	r4, [r1, #1]!
    for (uint8_t i = 0, j = BLE_SIG_UUID_128BIT_LEN - 1; i < BLE_SIG_UUID_128BIT_LEN; i++, j--) {
   badc6:	4283      	cmp	r3, r0
   badc8:	f103 33ff 	add.w	r3, r3, #4294967295
   badcc:	d1f8      	bne.n	badc0 <_ZNK8particle7BleUuid11toBigEndianEPh+0x8>
}
   badce:	bd10      	pop	{r4, pc}

000badd0 <_ZNK8particle7BleUuid8toStringEPcjb>:
size_t BleUuid::toString(char* buf, size_t len, bool stripped) const {
   badd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   badd4:	461f      	mov	r7, r3
   badd6:	b08e      	sub	sp, #56	; 0x38
    if (!buf || len == 0) {
   badd8:	460d      	mov	r5, r1
   badda:	2900      	cmp	r1, #0
   baddc:	d05b      	beq.n	bae96 <_ZNK8particle7BleUuid8toStringEPcjb+0xc6>
   badde:	b1da      	cbz	r2, bae18 <_ZNK8particle7BleUuid8toStringEPcjb+0x48>
    if (type() == BleUuidType::SHORT) {
   bade0:	f8d0 8010 	ldr.w	r8, [r0, #16]
        len = std::min(len - 1, sizeof(cStr));
   bade4:	1e54      	subs	r4, r2, #1
    if (type() == BleUuidType::SHORT) {
   bade6:	f1b8 0f00 	cmp.w	r8, #0
   badea:	d119      	bne.n	bae20 <_ZNK8particle7BleUuid8toStringEPcjb+0x50>
        uint16_t bigEndian = (uint16_t)uuid128_[UUID16_LO] << 8 | uuid128_[UUID16_HI];
   badec:	8983      	ldrh	r3, [r0, #12]
        char cStr[BLE_SIG_UUID_16BIT_LEN * 2] = {};
   badee:	f8cd 8014 	str.w	r8, [sp, #20]
        uint16_t bigEndian = (uint16_t)uuid128_[UUID16_LO] << 8 | uuid128_[UUID16_HI];
   badf2:	ba5b      	rev16	r3, r3
        bytes2hexbuf((uint8_t*)&bigEndian, 2, cStr);
   badf4:	aa05      	add	r2, sp, #20
   badf6:	2102      	movs	r1, #2
   badf8:	a801      	add	r0, sp, #4
        uint16_t bigEndian = (uint16_t)uuid128_[UUID16_LO] << 8 | uuid128_[UUID16_HI];
   badfa:	f8ad 3004 	strh.w	r3, [sp, #4]
        bytes2hexbuf((uint8_t*)&bigEndian, 2, cStr);
   badfe:	f7ff fe61 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
        len = std::min(len - 1, sizeof(cStr));
   bae02:	2c04      	cmp	r4, #4
   bae04:	bf28      	it	cs
   bae06:	2404      	movcs	r4, #4
        memcpy(buf, cStr, len);
   bae08:	4622      	mov	r2, r4
   bae0a:	a905      	add	r1, sp, #20
   bae0c:	4628      	mov	r0, r5
   bae0e:	f004 f84c 	bl	beeaa <memcpy>
        buf[len++] = '\0';
   bae12:	f805 8004 	strb.w	r8, [r5, r4]
   bae16:	1c62      	adds	r2, r4, #1
}
   bae18:	4610      	mov	r0, r2
   bae1a:	b00e      	add	sp, #56	; 0x38
   bae1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    toBigEndian(temp);
   bae20:	a901      	add	r1, sp, #4
   bae22:	f7ff ffc9 	bl	badb8 <_ZNK8particle7BleUuid11toBigEndianEPh>
        bytes2hexbuf(temp, BLE_SIG_UUID_128BIT_LEN, cStr);
   bae26:	aa05      	add	r2, sp, #20
    if (stripped) {
   bae28:	b17f      	cbz	r7, bae4a <_ZNK8particle7BleUuid8toStringEPcjb+0x7a>
        bytes2hexbuf(temp, BLE_SIG_UUID_128BIT_LEN, cStr);
   bae2a:	2110      	movs	r1, #16
   bae2c:	a801      	add	r0, sp, #4
        bytes2hexbuf(&temp[idx], 6, &cStr[idx * 2 + 4]);
   bae2e:	f7ff fe49 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
    len = std::min(len - 1, sizeof(cStr));
   bae32:	2c24      	cmp	r4, #36	; 0x24
   bae34:	bf28      	it	cs
   bae36:	2424      	movcs	r4, #36	; 0x24
    memcpy(buf, cStr, len);
   bae38:	4622      	mov	r2, r4
   bae3a:	a905      	add	r1, sp, #20
   bae3c:	4628      	mov	r0, r5
   bae3e:	f004 f834 	bl	beeaa <memcpy>
    buf[len++] = '\0';
   bae42:	2300      	movs	r3, #0
   bae44:	552b      	strb	r3, [r5, r4]
   bae46:	1c62      	adds	r2, r4, #1
    return len;
   bae48:	e7e6      	b.n	bae18 <_ZNK8particle7BleUuid8toStringEPcjb+0x48>
        bytes2hexbuf(&temp[idx], 4, &cStr[0]);
   bae4a:	2104      	movs	r1, #4
   bae4c:	eb0d 0001 	add.w	r0, sp, r1
   bae50:	f7ff fe38 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
        cStr[idx * 2] = '-';
   bae54:	262d      	movs	r6, #45	; 0x2d
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 1]);
   bae56:	f10d 021d 	add.w	r2, sp, #29
   bae5a:	2102      	movs	r1, #2
   bae5c:	a802      	add	r0, sp, #8
        cStr[idx * 2] = '-';
   bae5e:	f88d 601c 	strb.w	r6, [sp, #28]
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 1]);
   bae62:	f7ff fe2f 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 2]);
   bae66:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   bae6a:	2102      	movs	r1, #2
   bae6c:	f10d 000a 	add.w	r0, sp, #10
        cStr[idx * 2 + 1] = '-';
   bae70:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 2]);
   bae74:	f7ff fe26 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 3]);
   bae78:	f10d 0227 	add.w	r2, sp, #39	; 0x27
   bae7c:	2102      	movs	r1, #2
   bae7e:	a803      	add	r0, sp, #12
        cStr[idx * 2 + 2] = '-';
   bae80:	f88d 6026 	strb.w	r6, [sp, #38]	; 0x26
        bytes2hexbuf(&temp[idx], 2, &cStr[idx * 2 + 3]);
   bae84:	f7ff fe1e 	bl	baac4 <_ZL12bytes2hexbufPKhjPc.isra.0>
        cStr[idx * 2 + 3] = '-';
   bae88:	f88d 602b 	strb.w	r6, [sp, #43]	; 0x2b
        bytes2hexbuf(&temp[idx], 6, &cStr[idx * 2 + 4]);
   bae8c:	aa0b      	add	r2, sp, #44	; 0x2c
   bae8e:	2106      	movs	r1, #6
   bae90:	f10d 000e 	add.w	r0, sp, #14
   bae94:	e7cb      	b.n	bae2e <_ZNK8particle7BleUuid8toStringEPcjb+0x5e>
        return 0;
   bae96:	460a      	mov	r2, r1
   bae98:	e7be      	b.n	bae18 <_ZNK8particle7BleUuid8toStringEPcjb+0x48>

000bae9a <_ZNK8particle7BleUuid8toStringEb>:
String BleUuid::toString(bool stripped) const {
   bae9a:	b510      	push	{r4, lr}
   bae9c:	b08a      	sub	sp, #40	; 0x28
   bae9e:	4604      	mov	r4, r0
    toString(cStr, sizeof(cStr));
   baea0:	2300      	movs	r3, #0
   baea2:	2225      	movs	r2, #37	; 0x25
String BleUuid::toString(bool stripped) const {
   baea4:	4608      	mov	r0, r1
    toString(cStr, sizeof(cStr));
   baea6:	4669      	mov	r1, sp
   baea8:	f7ff ff92 	bl	badd0 <_ZNK8particle7BleUuid8toStringEPcjb>
    return String(cStr);
   baeac:	4669      	mov	r1, sp
   baeae:	4620      	mov	r0, r4
   baeb0:	f7ff fc65 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
}
   baeb4:	4620      	mov	r0, r4
   baeb6:	b00a      	add	sp, #40	; 0x28
   baeb8:	bd10      	pop	{r4, pc}

000baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>:
size_t BleAdvertisingData::get(BleAdvertisingDataType type, uint8_t* buf, size_t len) const {
   baeba:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   baebc:	4605      	mov	r5, r0
   baebe:	4616      	mov	r6, r2
   baec0:	461f      	mov	r7, r3
   baec2:	460a      	mov	r2, r1
   baec4:	ab01      	add	r3, sp, #4
   baec6:	e9d0 0100 	ldrd	r0, r1, [r0]
   baeca:	f7ff fd7b 	bl	ba9c4 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0>
    if (adsLen > 0) {
   baece:	f030 0402 	bics.w	r4, r0, #2
   baed2:	d00c      	beq.n	baeee <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj+0x34>
            adsLen -= 2;
   baed4:	1e84      	subs	r4, r0, #2
   baed6:	42bc      	cmp	r4, r7
   baed8:	bf28      	it	cs
   baeda:	463c      	movcs	r4, r7
            if (buf != nullptr) {
   baedc:	b13e      	cbz	r6, baeee <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj+0x34>
                memcpy(buf, &selfData_[offset + 2], len);
   baede:	9901      	ldr	r1, [sp, #4]
    return data_[i];
}

template<typename T, typename AllocatorT>
inline const T& spark::Vector<T, AllocatorT>::operator[](int i) const {
    return data_[i];
   baee0:	682b      	ldr	r3, [r5, #0]
   baee2:	3102      	adds	r1, #2
   baee4:	4622      	mov	r2, r4
   baee6:	4419      	add	r1, r3
   baee8:	4630      	mov	r0, r6
   baeea:	f003 ffde 	bl	beeaa <memcpy>
}
   baeee:	4620      	mov	r0, r4
   baef0:	b003      	add	sp, #12
   baef2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000baef4 <_ZNK8particle18BleAdvertisingData10deviceNameEPcj>:
size_t BleAdvertisingData::deviceName(char* buf, size_t len) const {
   baef4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   baef6:	4613      	mov	r3, r2
   baef8:	460c      	mov	r4, r1
    size_t nameLen = get(BleAdvertisingDataType::SHORT_LOCAL_NAME, reinterpret_cast<uint8_t*>(buf), len);
   baefa:	9201      	str	r2, [sp, #4]
   baefc:	460a      	mov	r2, r1
   baefe:	2108      	movs	r1, #8
size_t BleAdvertisingData::deviceName(char* buf, size_t len) const {
   baf00:	4605      	mov	r5, r0
    size_t nameLen = get(BleAdvertisingDataType::SHORT_LOCAL_NAME, reinterpret_cast<uint8_t*>(buf), len);
   baf02:	f7ff ffda 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
    if (nameLen > 0) {
   baf06:	b940      	cbnz	r0, baf1a <_ZNK8particle18BleAdvertisingData10deviceNameEPcj+0x26>
    return get(BleAdvertisingDataType::COMPLETE_LOCAL_NAME, reinterpret_cast<uint8_t*>(buf), len);
   baf08:	9b01      	ldr	r3, [sp, #4]
   baf0a:	4622      	mov	r2, r4
   baf0c:	2109      	movs	r1, #9
   baf0e:	4628      	mov	r0, r5
}
   baf10:	b003      	add	sp, #12
   baf12:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    return get(BleAdvertisingDataType::COMPLETE_LOCAL_NAME, reinterpret_cast<uint8_t*>(buf), len);
   baf16:	f7ff bfd0 	b.w	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
}
   baf1a:	b003      	add	sp, #12
   baf1c:	bd30      	pop	{r4, r5, pc}
	...

000baf20 <_ZNK8particle18BleAdvertisingData10deviceNameEv>:
String BleAdvertisingData::deviceName() const {
   baf20:	b5f0      	push	{r4, r5, r6, r7, lr}
   baf22:	460c      	mov	r4, r1
   baf24:	b089      	sub	sp, #36	; 0x24
    String name;
   baf26:	490c      	ldr	r1, [pc, #48]	; (baf58 <_ZNK8particle18BleAdvertisingData10deviceNameEv+0x38>)
String BleAdvertisingData::deviceName() const {
   baf28:	4605      	mov	r5, r0
    String name;
   baf2a:	f7ff fc28 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
    size_t len = deviceName(buf, sizeof(buf));
   baf2e:	221f      	movs	r2, #31
   baf30:	4669      	mov	r1, sp
   baf32:	4620      	mov	r0, r4
   baf34:	f7ff ffde 	bl	baef4 <_ZNK8particle18BleAdvertisingData10deviceNameEPcj>
    if (len > 0) {
   baf38:	4606      	mov	r6, r0
   baf3a:	b150      	cbz	r0, baf52 <_ZNK8particle18BleAdvertisingData10deviceNameEv+0x32>
   baf3c:	466c      	mov	r4, sp
        for (size_t i = 0; i < len; i++) {
   baf3e:	2700      	movs	r7, #0
            if (!name.concat(buf[i])) {
   baf40:	f814 1b01 	ldrb.w	r1, [r4], #1
   baf44:	4628      	mov	r0, r5
   baf46:	f7ff fc99 	bl	ba87c <_ZN6String6concatEc>
   baf4a:	b110      	cbz	r0, baf52 <_ZNK8particle18BleAdvertisingData10deviceNameEv+0x32>
        for (size_t i = 0; i < len; i++) {
   baf4c:	3701      	adds	r7, #1
   baf4e:	42be      	cmp	r6, r7
   baf50:	d1f6      	bne.n	baf40 <_ZNK8particle18BleAdvertisingData10deviceNameEv+0x20>
}
   baf52:	4628      	mov	r0, r5
   baf54:	b009      	add	sp, #36	; 0x24
   baf56:	bdf0      	pop	{r4, r5, r6, r7, pc}
   baf58:	000c1076 	.word	0x000c1076

000baf5c <_ZNK8particle18BleAdvertisingData10customDataEPhj>:
size_t BleAdvertisingData::customData(uint8_t* buf, size_t len) const {
   baf5c:	4613      	mov	r3, r2
    return get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, buf, len);
   baf5e:	460a      	mov	r2, r1
   baf60:	21ff      	movs	r1, #255	; 0xff
   baf62:	f7ff bfaa 	b.w	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>

000baf66 <_ZNK8particle18BleAdvertisingData10appearanceEv>:
ble_sig_appearance_t BleAdvertisingData::appearance() const {
   baf66:	b507      	push	{r0, r1, r2, lr}
    size_t len = get(BleAdvertisingDataType::APPEARANCE, buf, sizeof(buf));
   baf68:	2302      	movs	r3, #2
   baf6a:	aa01      	add	r2, sp, #4
   baf6c:	2119      	movs	r1, #25
   baf6e:	f7ff ffa4 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
    if (len > 0) {
   baf72:	b108      	cbz	r0, baf78 <_ZNK8particle18BleAdvertisingData10appearanceEv+0x12>
        uint16_t temp = (uint16_t)buf[1] << 8 | buf[0];
   baf74:	f8bd 0004 	ldrh.w	r0, [sp, #4]
}
   baf78:	b003      	add	sp, #12
   baf7a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000baf80 <_ZN8particle21BleCharacteristicImplC1Ev>:
    BleCharacteristicImpl()
   baf80:	b538      	push	{r3, r4, r5, lr}
              dataReceivedCallback_(nullptr) {
   baf82:	f64f 73ff 	movw	r3, #65535	; 0xffff
   baf86:	2500      	movs	r5, #0
    BleCharacteristicImpl()
   baf88:	4604      	mov	r4, r0
              dataReceivedCallback_(nullptr) {
   baf8a:	8043      	strh	r3, [r0, #2]
   baf8c:	220e      	movs	r2, #14
   baf8e:	4629      	mov	r1, r5
   baf90:	7005      	strb	r5, [r0, #0]
        : value_(0) {
}

template<typename T>
inline particle::EnumFlags<T, typename std::enable_if_t<std::is_enum<T>::value>>::EnumFlags(const T& value) {
    value_ = static_cast<ValueType>(value);
   baf92:	7105      	strb	r5, [r0, #4]
   baf94:	3006      	adds	r0, #6
   baf96:	f003 ffb0 	bl	beefa <memset>
   baf9a:	f104 0014 	add.w	r0, r4, #20
   baf9e:	f7ff fe25 	bl	babec <_ZN8particle7BleUuidC1Ev>
   bafa2:	f104 0028 	add.w	r0, r4, #40	; 0x28
   bafa6:	f7ff fe21 	bl	babec <_ZN8particle7BleUuidC1Ev>
   bafaa:	4904      	ldr	r1, [pc, #16]	; (bafbc <_ZN8particle21BleCharacteristicImplC1Ev+0x3c>)
   bafac:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   bafb0:	f7ff fbe5 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
    _Function_base() : _M_manager(nullptr) { }
   bafb4:	6565      	str	r5, [r4, #84]	; 0x54
    }
   bafb6:	4620      	mov	r0, r4
   bafb8:	bd38      	pop	{r3, r4, r5, pc}
   bafba:	bf00      	nop
   bafbc:	000c1076 	.word	0x000c1076

000bafc0 <_ZN8particle14BleServiceImpl17hasCharacteristicERKNS_17BleCharacteristicE>:
    bool hasCharacteristic(const BleCharacteristic& characteristic) {
   bafc0:	b538      	push	{r3, r4, r5, lr}
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      /// Return the stored pointer.
      element_type*
      get() const noexcept
      { return _M_ptr; }
   bafc2:	680d      	ldr	r5, [r1, #0]
   bafc4:	4604      	mov	r4, r0
        if ( characteristic.impl()->svcUUID() == uuid_ && 
   bafc6:	4601      	mov	r1, r0
   bafc8:	f105 0028 	add.w	r0, r5, #40	; 0x28
   bafcc:	f7ff fe69 	bl	baca2 <_ZNK8particle7BleUuideqERKS0_>
              characteristic.impl()->attrHandles().value_handle >= startHandle_ &&
   bafd0:	b140      	cbz	r0, bafe4 <_ZN8particle14BleServiceImpl17hasCharacteristicERKNS_17BleCharacteristicE+0x24>
   bafd2:	89ab      	ldrh	r3, [r5, #12]
        if ( characteristic.impl()->svcUUID() == uuid_ && 
   bafd4:	8aa2      	ldrh	r2, [r4, #20]
   bafd6:	429a      	cmp	r2, r3
   bafd8:	d805      	bhi.n	bafe6 <_ZN8particle14BleServiceImpl17hasCharacteristicERKNS_17BleCharacteristicE+0x26>
              characteristic.impl()->attrHandles().value_handle >= startHandle_ &&
   bafda:	8ae0      	ldrh	r0, [r4, #22]
   bafdc:	4298      	cmp	r0, r3
   bafde:	bf34      	ite	cc
   bafe0:	2000      	movcc	r0, #0
   bafe2:	2001      	movcs	r0, #1
    }
   bafe4:	bd38      	pop	{r3, r4, r5, pc}
        return false;
   bafe6:	2000      	movs	r0, #0
   bafe8:	e7fc      	b.n	bafe4 <_ZN8particle14BleServiceImpl17hasCharacteristicERKNS_17BleCharacteristicE+0x24>

000bafea <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>:
    BlePeerDevice* findPeerDevice(BleConnectionHandle connHandle) {
   bafea:	b510      	push	{r4, lr}
    return data_ + size_;
   bafec:	e9d0 3206 	ldrd	r3, r2, [r0, #24]
   baff0:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        for (auto& peer : peers_) {
   baff4:	4293      	cmp	r3, r2
   baff6:	4618      	mov	r0, r3
   baff8:	d006      	beq.n	bb008 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt+0x1e>
            if (peer.impl()->connHandle() == connHandle) {
   baffa:	6804      	ldr	r4, [r0, #0]
   baffc:	8824      	ldrh	r4, [r4, #0]
   baffe:	428c      	cmp	r4, r1
   bb000:	f103 0308 	add.w	r3, r3, #8
   bb004:	d1f6      	bne.n	baff4 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt+0xa>
    }
   bb006:	bd10      	pop	{r4, pc}
        return nullptr;
   bb008:	2000      	movs	r0, #0
   bb00a:	e7fc      	b.n	bb006 <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt+0x1c>

000bb00c <_ZN8particle17BleCharacteristicC1Ev>:

    protected:
      // This constructor is non-standard, it is used by allocate_shared.
      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
   bb00c:	2300      	movs	r3, #0
BleCharacteristic::BleCharacteristic()
   bb00e:	b570      	push	{r4, r5, r6, lr}
   bb010:	6003      	str	r3, [r0, #0]
   bb012:	4605      	mov	r5, r0
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   bb014:	2068      	movs	r0, #104	; 0x68
   bb016:	f7f9 f83e 	bl	b4096 <_Znwj>
	  auto __pi = ::new (__mem)
   bb01a:	1e04      	subs	r4, r0, #0
   bb01c:	f104 060c 	add.w	r6, r4, #12
   bb020:	d007      	beq.n	bb032 <_ZN8particle17BleCharacteristicC1Ev+0x26>
      : _M_use_count(1), _M_weak_count(1) { }
   bb022:	2301      	movs	r3, #1
   bb024:	e9c4 3301 	strd	r3, r3, [r4, #4]
	: _M_impl(__a)
   bb028:	4b04      	ldr	r3, [pc, #16]	; (bb03c <_ZN8particle17BleCharacteristicC1Ev+0x30>)
   bb02a:	6023      	str	r3, [r4, #0]
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
   bb02c:	4630      	mov	r0, r6
   bb02e:	f7ff ffa7 	bl	baf80 <_ZN8particle21BleCharacteristicImplC1Ev>
	  __p = __pi->_M_ptr();
   bb032:	e9c5 6400 	strd	r6, r4, [r5]
}
   bb036:	4628      	mov	r0, r5
   bb038:	bd70      	pop	{r4, r5, r6, pc}
   bb03a:	bf00      	nop
   bb03c:	000c2004 	.word	0x000c2004

000bb040 <_ZNK8particle17BleCharacteristic4UUIDEv>:
BleUuid BleCharacteristic::UUID() const {
   bb040:	b570      	push	{r4, r5, r6, lr}
    return impl()->charUUID();
   bb042:	680c      	ldr	r4, [r1, #0]
   bb044:	3414      	adds	r4, #20
BleUuid BleCharacteristic::UUID() const {
   bb046:	4606      	mov	r6, r0
    return impl()->charUUID();
   bb048:	4605      	mov	r5, r0
   bb04a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   bb04c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   bb04e:	6823      	ldr	r3, [r4, #0]
   bb050:	602b      	str	r3, [r5, #0]
}
   bb052:	4630      	mov	r0, r6
   bb054:	bd70      	pop	{r4, r5, r6, pc}
	...

000bb058 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE>:
ssize_t BleCharacteristic::setValue(const uint8_t* buf, size_t len, BleTxRxType type) {
   bb058:	b5f0      	push	{r4, r5, r6, r7, lr}
   bb05a:	4606      	mov	r6, r0
   bb05c:	b085      	sub	sp, #20
   bb05e:	461f      	mov	r7, r3
    if (buf == nullptr || len == 0) {
   bb060:	460d      	mov	r5, r1
   bb062:	2900      	cmp	r1, #0
   bb064:	d050      	beq.n	bb108 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0xb0>
   bb066:	2a00      	cmp	r2, #0
   bb068:	d04e      	beq.n	bb108 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0xb0>
      { return _M_ptr; }
   bb06a:	6804      	ldr	r4, [r0, #0]
    if (impl()->isLocal()) {
   bb06c:	7823      	ldrb	r3, [r4, #0]
   bb06e:	2af4      	cmp	r2, #244	; 0xf4
   bb070:	bf28      	it	cs
   bb072:	22f4      	movcs	r2, #244	; 0xf4
   bb074:	b343      	cbz	r3, bb0c8 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x70>
    return (value_ > 0);
}

template<typename T>
inline bool particle::EnumFlags<T, typename std::enable_if_t<std::is_enum<T>::value>>::isSet(const EnumFlags<T>& flags) const {
    return ((value_ & flags.value_) == flags.value_);
   bb076:	7923      	ldrb	r3, [r4, #4]
        if (impl()->properties().isSet(BleCharacteristicProperty::READ)) {
   bb078:	0798      	lsls	r0, r3, #30
   bb07a:	d509      	bpl.n	bb090 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x38>
            ret = CHECK(hal_ble_gatt_server_set_characteristic_value(impl()->attrHandles().value_handle, buf, len, nullptr));
   bb07c:	89a0      	ldrh	r0, [r4, #12]
   bb07e:	9203      	str	r2, [sp, #12]
   bb080:	2300      	movs	r3, #0
   bb082:	f7fe fed1 	bl	b9e28 <hal_ble_gatt_server_set_characteristic_value>
   bb086:	2800      	cmp	r0, #0
   bb088:	9a03      	ldr	r2, [sp, #12]
   bb08a:	da03      	bge.n	bb094 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x3c>
}
   bb08c:	b005      	add	sp, #20
   bb08e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        int ret = SYSTEM_ERROR_NOT_SUPPORTED;
   bb090:	f06f 0077 	mvn.w	r0, #119	; 0x77
   bb094:	6834      	ldr	r4, [r6, #0]
   bb096:	7923      	ldrb	r3, [r4, #4]
        if (impl()->properties().isSet(BleCharacteristicProperty::NOTIFY) && type != BleTxRxType::ACK) {
   bb098:	06d9      	lsls	r1, r3, #27
   bb09a:	d509      	bpl.n	bb0b0 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x58>
   bb09c:	2f01      	cmp	r7, #1
   bb09e:	d007      	beq.n	bb0b0 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x58>
            return hal_ble_gatt_server_notify_characteristic_value(impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0a0:	89a0      	ldrh	r0, [r4, #12]
   bb0a2:	2300      	movs	r3, #0
   bb0a4:	4629      	mov	r1, r5
}
   bb0a6:	b005      	add	sp, #20
   bb0a8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return hal_ble_gatt_server_notify_characteristic_value(impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0ac:	f7fe bf16 	b.w	b9edc <hal_ble_gatt_server_notify_characteristic_value>
        if (impl()->properties().isSet(BleCharacteristicProperty::INDICATE) && type != BleTxRxType::NACK) {
   bb0b0:	069b      	lsls	r3, r3, #26
   bb0b2:	d5eb      	bpl.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
   bb0b4:	2f02      	cmp	r7, #2
   bb0b6:	d0e9      	beq.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
            return hal_ble_gatt_server_indicate_characteristic_value(impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0b8:	89a0      	ldrh	r0, [r4, #12]
   bb0ba:	2300      	movs	r3, #0
   bb0bc:	4629      	mov	r1, r5
}
   bb0be:	b005      	add	sp, #20
   bb0c0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            return hal_ble_gatt_server_indicate_characteristic_value(impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0c4:	f7fe bf14 	b.w	b9ef0 <hal_ble_gatt_server_indicate_characteristic_value>
    if (impl()->connHandle() != BLE_INVALID_CONN_HANDLE) {
   bb0c8:	8860      	ldrh	r0, [r4, #2]
   bb0ca:	f64f 71ff 	movw	r1, #65535	; 0xffff
   bb0ce:	4288      	cmp	r0, r1
   bb0d0:	d01c      	beq.n	bb10c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0xb4>
   bb0d2:	7921      	ldrb	r1, [r4, #4]
        if (impl()->properties().isSet(BleCharacteristicProperty::WRITE_WO_RSP) && type != BleTxRxType::ACK) {
   bb0d4:	074e      	lsls	r6, r1, #29
   bb0d6:	d501      	bpl.n	bb0dc <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x84>
   bb0d8:	2f01      	cmp	r7, #1
   bb0da:	d104      	bne.n	bb0e6 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x8e>
        if (impl()->properties().isSet(BleCharacteristicProperty::WRITE) && type != BleTxRxType::NACK) {
   bb0dc:	070b      	lsls	r3, r1, #28
   bb0de:	d409      	bmi.n	bb0f4 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x9c>
        return SYSTEM_ERROR_NOT_SUPPORTED;
   bb0e0:	f06f 0077 	mvn.w	r0, #119	; 0x77
   bb0e4:	e7d2      	b.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
            return hal_ble_gatt_client_write_without_response(impl()->connHandle(), impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0e6:	89a1      	ldrh	r1, [r4, #12]
   bb0e8:	9300      	str	r3, [sp, #0]
   bb0ea:	4613      	mov	r3, r2
   bb0ec:	462a      	mov	r2, r5
   bb0ee:	f7fe fec3 	bl	b9e78 <hal_ble_gatt_client_write_without_response>
   bb0f2:	e7cb      	b.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
        if (impl()->properties().isSet(BleCharacteristicProperty::WRITE) && type != BleTxRxType::NACK) {
   bb0f4:	2f02      	cmp	r7, #2
   bb0f6:	d0f3      	beq.n	bb0e0 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x88>
            return hal_ble_gatt_client_write_with_response(impl()->connHandle(), impl()->attrHandles().value_handle, buf, len, nullptr);
   bb0f8:	2300      	movs	r3, #0
   bb0fa:	89a1      	ldrh	r1, [r4, #12]
   bb0fc:	9300      	str	r3, [sp, #0]
   bb0fe:	4613      	mov	r3, r2
   bb100:	462a      	mov	r2, r5
   bb102:	f7fe feaf 	bl	b9e64 <hal_ble_gatt_client_write_with_response>
   bb106:	e7c1      	b.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
        return SYSTEM_ERROR_INVALID_ARGUMENT;
   bb108:	4802      	ldr	r0, [pc, #8]	; (bb114 <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0xbc>)
   bb10a:	e7bf      	b.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
    return SYSTEM_ERROR_INVALID_STATE;
   bb10c:	f06f 00d1 	mvn.w	r0, #209	; 0xd1
   bb110:	e7bc      	b.n	bb08c <_ZN8particle17BleCharacteristic8setValueEPKhjNS_11BleTxRxTypeE+0x34>
   bb112:	bf00      	nop
   bb114:	fffffef2 	.word	0xfffffef2

000bb118 <_ZNK8particle17BleCharacteristic9subscribeEb>:
int BleCharacteristic::subscribe(bool enable) const {
   bb118:	b510      	push	{r4, lr}
   bb11a:	6803      	ldr	r3, [r0, #0]
    CHECK_FALSE(impl()->isLocal(), SYSTEM_ERROR_INVALID_STATE);
   bb11c:	781a      	ldrb	r2, [r3, #0]
int BleCharacteristic::subscribe(bool enable) const {
   bb11e:	b086      	sub	sp, #24
    CHECK_FALSE(impl()->isLocal(), SYSTEM_ERROR_INVALID_STATE);
   bb120:	bb52      	cbnz	r2, bb178 <_ZNK8particle17BleCharacteristic9subscribeEb+0x60>
    CHECK_TRUE(impl()->connHandle() != BLE_INVALID_CONN_HANDLE, SYSTEM_ERROR_INVALID_STATE);
   bb122:	885c      	ldrh	r4, [r3, #2]
   bb124:	f64f 70ff 	movw	r0, #65535	; 0xffff
   bb128:	4284      	cmp	r4, r0
   bb12a:	d025      	beq.n	bb178 <_ZNK8particle17BleCharacteristic9subscribeEb+0x60>
    CHECK_TRUE(impl()->attrHandles().cccd_handle != BLE_INVALID_ATTR_HANDLE, SYSTEM_ERROR_NOT_SUPPORTED);
   bb12c:	8a18      	ldrh	r0, [r3, #16]
   bb12e:	b330      	cbz	r0, bb17e <_ZNK8particle17BleCharacteristic9subscribeEb+0x66>
    hal_ble_cccd_config_t config = {};
   bb130:	e9cd 2203 	strd	r2, r2, [sp, #12]
   bb134:	9205      	str	r2, [sp, #20]
    config.version = BLE_API_VERSION;
   bb136:	4a13      	ldr	r2, [pc, #76]	; (bb184 <_ZNK8particle17BleCharacteristic9subscribeEb+0x6c>)
   bb138:	9200      	str	r2, [sp, #0]
    config.callback = impl()->onBleCharEvents;
   bb13a:	4a13      	ldr	r2, [pc, #76]	; (bb188 <_ZNK8particle17BleCharacteristic9subscribeEb+0x70>)
    config.context = impl();
   bb13c:	e9cd 2301 	strd	r2, r3, [sp, #4]
    config.conn_handle = impl()->connHandle();
   bb140:	885a      	ldrh	r2, [r3, #2]
   bb142:	f8ad 200c 	strh.w	r2, [sp, #12]
    config.cccd_handle = impl()->attrHandles().cccd_handle;
   bb146:	8a1a      	ldrh	r2, [r3, #16]
   bb148:	f8ad 200e 	strh.w	r2, [sp, #14]
    config.value_handle = impl()->attrHandles().value_handle;
   bb14c:	899a      	ldrh	r2, [r3, #12]
   bb14e:	f8ad 2010 	strh.w	r2, [sp, #16]
    if (enable) {
   bb152:	b159      	cbz	r1, bb16c <_ZNK8particle17BleCharacteristic9subscribeEb+0x54>
   bb154:	791a      	ldrb	r2, [r3, #4]
        if (impl()->properties().isSet(BleCharacteristicProperty::INDICATE)) {
   bb156:	0692      	lsls	r2, r2, #26
            config.cccd_value = BLE_SIG_CCCD_VAL_INDICATION;
   bb158:	bf44      	itt	mi
   bb15a:	2202      	movmi	r2, #2
   bb15c:	9205      	strmi	r2, [sp, #20]
   bb15e:	791b      	ldrb	r3, [r3, #4]
        if (impl()->properties().isSet(BleCharacteristicProperty::NOTIFY)) {
   bb160:	06db      	lsls	r3, r3, #27
            config.cccd_value = (ble_sig_cccd_value_t)(config.cccd_value | BLE_SIG_CCCD_VAL_NOTIFICATION);
   bb162:	bf42      	ittt	mi
   bb164:	9b05      	ldrmi	r3, [sp, #20]
   bb166:	f043 0301 	orrmi.w	r3, r3, #1
   bb16a:	9305      	strmi	r3, [sp, #20]
    return hal_ble_gatt_client_configure_cccd(&config, nullptr);
   bb16c:	2100      	movs	r1, #0
   bb16e:	4668      	mov	r0, sp
   bb170:	f7fe feaa 	bl	b9ec8 <hal_ble_gatt_client_configure_cccd>
}
   bb174:	b006      	add	sp, #24
   bb176:	bd10      	pop	{r4, pc}
    CHECK_FALSE(impl()->isLocal(), SYSTEM_ERROR_INVALID_STATE);
   bb178:	f06f 00d1 	mvn.w	r0, #209	; 0xd1
   bb17c:	e7fa      	b.n	bb174 <_ZNK8particle17BleCharacteristic9subscribeEb+0x5c>
    CHECK_TRUE(impl()->attrHandles().cccd_handle != BLE_INVALID_ATTR_HANDLE, SYSTEM_ERROR_NOT_SUPPORTED);
   bb17e:	f06f 0077 	mvn.w	r0, #119	; 0x77
   bb182:	e7f7      	b.n	bb174 <_ZNK8particle17BleCharacteristic9subscribeEb+0x5c>
   bb184:	00180003 	.word	0x00180003
   bb188:	000bb35d 	.word	0x000bb35d

000bb18c <_ZN8particle10BleServiceC1Ev>:
BleService::BleService()
   bb18c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
   bb18e:	2600      	movs	r6, #0
   bb190:	6006      	str	r6, [r0, #0]
   bb192:	4605      	mov	r5, r0
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
   bb194:	2028      	movs	r0, #40	; 0x28
   bb196:	f7f8 ff7e 	bl	b4096 <_Znwj>
	  auto __pi = ::new (__mem)
   bb19a:	1e04      	subs	r4, r0, #0
   bb19c:	f104 070c 	add.w	r7, r4, #12
   bb1a0:	d00a      	beq.n	bb1b8 <_ZN8particle10BleServiceC1Ev+0x2c>
      : _M_use_count(1), _M_weak_count(1) { }
   bb1a2:	2301      	movs	r3, #1
   bb1a4:	e9c4 3301 	strd	r3, r3, [r4, #4]
	: _M_impl(__a)
   bb1a8:	4b05      	ldr	r3, [pc, #20]	; (bb1c0 <_ZN8particle10BleServiceC1Ev+0x34>)
   bb1aa:	6023      	str	r3, [r4, #0]
              characteristicsDiscovered_(false) {
   bb1ac:	4638      	mov	r0, r7
   bb1ae:	f7ff fd1d 	bl	babec <_ZN8particle7BleUuidC1Ev>
   bb1b2:	6226      	str	r6, [r4, #32]
   bb1b4:	f884 6024 	strb.w	r6, [r4, #36]	; 0x24
	  __p = __pi->_M_ptr();
   bb1b8:	e9c5 7400 	strd	r7, r4, [r5]
}
   bb1bc:	4628      	mov	r0, r5
   bb1be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   bb1c0:	000c2020 	.word	0x000c2020

000bb1c4 <_ZN8particle13BlePeerDeviceC1Ev>:


/*******************************************************
 * BlePeerDevice class
 */
BlePeerDevice::BlePeerDevice()
   bb1c4:	b570      	push	{r4, r5, r6, lr}
	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
   bb1c6:	2500      	movs	r5, #0
   bb1c8:	6005      	str	r5, [r0, #0]
   bb1ca:	4606      	mov	r6, r0
   bb1cc:	2030      	movs	r0, #48	; 0x30
   bb1ce:	f7f8 ff62 	bl	b4096 <_Znwj>
	  auto __pi = ::new (__mem)
   bb1d2:	4604      	mov	r4, r0
   bb1d4:	b188      	cbz	r0, bb1fa <_ZN8particle13BlePeerDeviceC1Ev+0x36>
      : _M_use_count(1), _M_weak_count(1) { }
   bb1d6:	2301      	movs	r3, #1
   bb1d8:	e9c0 3301 	strd	r3, r3, [r0, #4]
	: _M_impl(__a)
   bb1dc:	4b09      	ldr	r3, [pc, #36]	; (bb204 <_ZN8particle13BlePeerDeviceC1Ev+0x40>)
   bb1de:	6003      	str	r3, [r0, #0]
              servicesDiscovered_(false) {
   bb1e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   bb1e4:	8183      	strh	r3, [r0, #12]
   bb1e6:	300e      	adds	r0, #14
   bb1e8:	f7ff fcf5 	bl	babd6 <_ZN8particle10BleAddressC1Ev>
        capacity_(0) {
   bb1ec:	e9c4 5506 	strd	r5, r5, [r4, #24]
   bb1f0:	e9c4 5508 	strd	r5, r5, [r4, #32]
   bb1f4:	e9c4 550a 	strd	r5, r5, [r4, #40]	; 0x28
   bb1f8:	75a5      	strb	r5, [r4, #22]
	  _M_pi = __pi;
   bb1fa:	6074      	str	r4, [r6, #4]
   bb1fc:	340c      	adds	r4, #12
	  __p = __pi->_M_ptr();
   bb1fe:	6034      	str	r4, [r6, #0]
        : impl_(std::make_shared<BlePeerDeviceImpl>()) {
    if (!impl()) {
        SPARK_ASSERT(false);
    }
}
   bb200:	4630      	mov	r0, r6
   bb202:	bd70      	pop	{r4, r5, r6, pc}
   bb204:	000c203c 	.word	0x000c203c

000bb208 <_ZNK8particle13BlePeerDevice9connectedEv>:
        impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
    }
    return SYSTEM_ERROR_NONE;
}

bool BlePeerDevice::connected() const {
   bb208:	b513      	push	{r0, r1, r4, lr}
   bb20a:	4604      	mov	r4, r0
    WiringBleLock lk;
   bb20c:	a801      	add	r0, sp, #4
   bb20e:	f7ff fca7 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
    return impl()->connHandle() != BLE_INVALID_CONN_HANDLE;
   bb212:	6823      	ldr	r3, [r4, #0]
   bb214:	881c      	ldrh	r4, [r3, #0]
   bb216:	f64f 73ff 	movw	r3, #65535	; 0xffff
   bb21a:	1ae4      	subs	r4, r4, r3
    WiringBleLock lk;
   bb21c:	a801      	add	r0, sp, #4
    return impl()->connHandle() != BLE_INVALID_CONN_HANDLE;
   bb21e:	bf18      	it	ne
   bb220:	2401      	movne	r4, #1
    WiringBleLock lk;
   bb222:	f7ff fcab 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bb226:	4620      	mov	r0, r4
   bb228:	b002      	add	sp, #8
   bb22a:	bd10      	pop	{r4, pc}

000bb22c <_ZNK8particle13BlePeerDevice4bindERKNS_10BleAddressE>:

void BlePeerDevice::bind(const BleAddress& address) const {
   bb22c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   bb22e:	4605      	mov	r5, r0
   bb230:	460c      	mov	r4, r1
    WiringBleLock lk;
   bb232:	a801      	add	r0, sp, #4
   bb234:	f7ff fc94 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
      { return _M_ptr; }
   bb238:	682a      	ldr	r2, [r5, #0]
    address_ = addr.address_;
   bb23a:	6823      	ldr	r3, [r4, #0]
   bb23c:	f8c2 3002 	str.w	r3, [r2, #2]
   bb240:	6863      	ldr	r3, [r4, #4]
   bb242:	f8c2 3006 	str.w	r3, [r2, #6]
    WiringBleLock lk;
   bb246:	a801      	add	r0, sp, #4
   bb248:	f7ff fc98 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
    impl()->address() = address;
}
   bb24c:	b003      	add	sp, #12
   bb24e:	bd30      	pop	{r4, r5, pc}

000bb250 <_ZNK8particle13BlePeerDevice7addressEv>:

BleAddress BlePeerDevice::address() const {
   bb250:	b537      	push	{r0, r1, r2, r4, r5, lr}
   bb252:	460d      	mov	r5, r1
   bb254:	4604      	mov	r4, r0
    WiringBleLock lk;
   bb256:	a801      	add	r0, sp, #4
   bb258:	f7ff fc82 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
   bb25c:	682a      	ldr	r2, [r5, #0]
    address_ = addr.address_;
   bb25e:	f8d2 3002 	ldr.w	r3, [r2, #2]
   bb262:	6023      	str	r3, [r4, #0]
   bb264:	f8d2 3006 	ldr.w	r3, [r2, #6]
   bb268:	6063      	str	r3, [r4, #4]
    WiringBleLock lk;
   bb26a:	a801      	add	r0, sp, #4
   bb26c:	f7ff fc86 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
    return impl()->address();
}
   bb270:	4620      	mov	r0, r4
   bb272:	b003      	add	sp, #12
   bb274:	bd30      	pop	{r4, r5, pc}

000bb276 <_ZNK8particle13BlePeerDeviceeqERKS0_>:
bool BlePeerDevice::isValid() const {
    WiringBleLock lk;
    return impl()->connHandle() != BLE_INVALID_CONN_HANDLE;
}

bool BlePeerDevice::operator==(const BlePeerDevice& device) const {
   bb276:	b530      	push	{r4, r5, lr}
   bb278:	4605      	mov	r5, r0
   bb27a:	b087      	sub	sp, #28
   bb27c:	460c      	mov	r4, r1
    WiringBleLock lk;
   bb27e:	a801      	add	r0, sp, #4
   bb280:	f7ff fc6e 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
    if (impl()->connHandle() == device.impl()->connHandle() && address() == device.address()) {
   bb284:	682a      	ldr	r2, [r5, #0]
   bb286:	6823      	ldr	r3, [r4, #0]
   bb288:	8812      	ldrh	r2, [r2, #0]
   bb28a:	881b      	ldrh	r3, [r3, #0]
   bb28c:	429a      	cmp	r2, r3
   bb28e:	d10d      	bne.n	bb2ac <_ZNK8particle13BlePeerDeviceeqERKS0_+0x36>
   bb290:	4629      	mov	r1, r5
   bb292:	a802      	add	r0, sp, #8
   bb294:	f7ff ffdc 	bl	bb250 <_ZNK8particle13BlePeerDevice7addressEv>
   bb298:	4621      	mov	r1, r4
   bb29a:	a804      	add	r0, sp, #16
   bb29c:	f7ff ffd8 	bl	bb250 <_ZNK8particle13BlePeerDevice7addressEv>
   bb2a0:	a904      	add	r1, sp, #16
   bb2a2:	a802      	add	r0, sp, #8
   bb2a4:	f7ff fc83 	bl	babae <_ZNK8particle10BleAddresseqERKS0_>
   bb2a8:	4604      	mov	r4, r0
   bb2aa:	b900      	cbnz	r0, bb2ae <_ZNK8particle13BlePeerDeviceeqERKS0_+0x38>
        return true;
    }
    return false;
   bb2ac:	2400      	movs	r4, #0
    WiringBleLock lk;
   bb2ae:	a801      	add	r0, sp, #4
   bb2b0:	f7ff fc64 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bb2b4:	4620      	mov	r0, r4
   bb2b6:	b007      	add	sp, #28
   bb2b8:	bd30      	pop	{r4, r5, pc}
	...

000bb2bc <_ZN8particle14BleLocalDeviceC1Ev>:


/*******************************************************
 * BleLocalDevice class
 */
BleLocalDevice::BleLocalDevice()
   bb2bc:	b510      	push	{r4, lr}
   bb2be:	4604      	mov	r4, r0

  /// std::make_unique for single objects
  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
   bb2c0:	2064      	movs	r0, #100	; 0x64
   bb2c2:	f7f8 fee8 	bl	b4096 <_Znwj>
   bb2c6:	b168      	cbz	r0, bb2e4 <_ZN8particle14BleLocalDeviceC1Ev+0x28>
   bb2c8:	2300      	movs	r3, #0
   bb2ca:	e9c0 3300 	strd	r3, r3, [r0]
   bb2ce:	e9c0 3302 	strd	r3, r3, [r0, #8]
   bb2d2:	e9c0 3304 	strd	r3, r3, [r0, #16]
   bb2d6:	e9c0 3306 	strd	r3, r3, [r0, #24]
   bb2da:	6203      	str	r3, [r0, #32]
   bb2dc:	62c3      	str	r3, [r0, #44]	; 0x2c
   bb2de:	63c3      	str	r3, [r0, #60]	; 0x3c
   bb2e0:	64c3      	str	r3, [r0, #76]	; 0x4c
   bb2e2:	65c3      	str	r3, [r0, #92]	; 0x5c
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
   bb2e4:	6020      	str	r0, [r4, #0]
        : impl_(std::make_unique<BleLocalDeviceImpl>()) {
    if (!impl()) {
   bb2e6:	b920      	cbnz	r0, bb2f2 <_ZN8particle14BleLocalDeviceC1Ev+0x36>
        SPARK_ASSERT(false);
   bb2e8:	4a0a      	ldr	r2, [pc, #40]	; (bb314 <_ZN8particle14BleLocalDeviceC1Ev+0x58>)
   bb2ea:	490b      	ldr	r1, [pc, #44]	; (bb318 <_ZN8particle14BleLocalDeviceC1Ev+0x5c>)
   bb2ec:	200a      	movs	r0, #10
   bb2ee:	f7fe ff89 	bl	ba204 <panic_>
    }
    SPARK_ASSERT(hal_ble_stack_init(nullptr) == SYSTEM_ERROR_NONE);
   bb2f2:	2000      	movs	r0, #0
   bb2f4:	f7fe fd5c 	bl	b9db0 <hal_ble_stack_init>
   bb2f8:	b120      	cbz	r0, bb304 <_ZN8particle14BleLocalDeviceC1Ev+0x48>
   bb2fa:	4a06      	ldr	r2, [pc, #24]	; (bb314 <_ZN8particle14BleLocalDeviceC1Ev+0x58>)
   bb2fc:	4907      	ldr	r1, [pc, #28]	; (bb31c <_ZN8particle14BleLocalDeviceC1Ev+0x60>)
   bb2fe:	200a      	movs	r0, #10
   bb300:	f7fe ff80 	bl	ba204 <panic_>
    hal_ble_set_callback_on_periph_link_events(impl()->onBleLinkEvents, impl(), nullptr);
   bb304:	6821      	ldr	r1, [r4, #0]
   bb306:	4806      	ldr	r0, [pc, #24]	; (bb320 <_ZN8particle14BleLocalDeviceC1Ev+0x64>)
   bb308:	2200      	movs	r2, #0
   bb30a:	f7fe fdd3 	bl	b9eb4 <hal_ble_set_callback_on_periph_link_events>
}
   bb30e:	4620      	mov	r0, r4
   bb310:	bd10      	pop	{r4, pc}
   bb312:	bf00      	nop
   bb314:	000b9d61 	.word	0x000b9d61
   bb318:	000c1de0 	.word	0x000c1de0
   bb31c:	000c1e1e 	.word	0x000c1e1e
   bb320:	000bbd69 	.word	0x000bbd69

000bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>:

BleLocalDevice& BleLocalDevice::getInstance() {
   bb324:	b510      	push	{r4, lr}
    static BleLocalDevice instance;
   bb326:	4c0a      	ldr	r4, [pc, #40]	; (bb350 <_ZN8particle14BleLocalDevice11getInstanceEv+0x2c>)
   bb328:	7823      	ldrb	r3, [r4, #0]
   bb32a:	f3bf 8f5b 	dmb	ish
   bb32e:	07db      	lsls	r3, r3, #31
   bb330:	d40c      	bmi.n	bb34c <_ZN8particle14BleLocalDevice11getInstanceEv+0x28>
   bb332:	4620      	mov	r0, r4
   bb334:	f7f8 fec2 	bl	b40bc <__cxa_guard_acquire>
   bb338:	b140      	cbz	r0, bb34c <_ZN8particle14BleLocalDevice11getInstanceEv+0x28>
   bb33a:	4806      	ldr	r0, [pc, #24]	; (bb354 <_ZN8particle14BleLocalDevice11getInstanceEv+0x30>)
   bb33c:	f7ff ffbe 	bl	bb2bc <_ZN8particle14BleLocalDeviceC1Ev>
   bb340:	4620      	mov	r0, r4
   bb342:	f7f8 fec0 	bl	b40c6 <__cxa_guard_release>
   bb346:	4804      	ldr	r0, [pc, #16]	; (bb358 <_ZN8particle14BleLocalDevice11getInstanceEv+0x34>)
   bb348:	f003 fd92 	bl	bee70 <atexit>
    return instance;
}
   bb34c:	4801      	ldr	r0, [pc, #4]	; (bb354 <_ZN8particle14BleLocalDevice11getInstanceEv+0x30>)
   bb34e:	bd10      	pop	{r4, pc}
   bb350:	2003e670 	.word	0x2003e670
   bb354:	2003e678 	.word	0x2003e678
   bb358:	000bb66d 	.word	0x000bb66d

000bb35c <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv>:
void BleCharacteristicImpl::onBleCharEvents(const hal_ble_char_evt_t *event, void* context) {
   bb35c:	b530      	push	{r4, r5, lr}
    switch (event->type) {
   bb35e:	6803      	ldr	r3, [r0, #0]
   bb360:	3b09      	subs	r3, #9
   bb362:	2b01      	cmp	r3, #1
void BleCharacteristicImpl::onBleCharEvents(const hal_ble_char_evt_t *event, void* context) {
   bb364:	b08d      	sub	sp, #52	; 0x34
   bb366:	4604      	mov	r4, r0
   bb368:	460d      	mov	r5, r1
    switch (event->type) {
   bb36a:	d811      	bhi.n	bb390 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x34>
            auto peer = BleLocalDevice::getInstance().impl()->findPeerDevice(event->conn_handle);
   bb36c:	f7ff ffda 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   bb370:	88a1      	ldrh	r1, [r4, #4]
   bb372:	6800      	ldr	r0, [r0, #0]
   bb374:	f7ff fe39 	bl	bafea <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>
            if (!peer) {
   bb378:	4603      	mov	r3, r0
   bb37a:	b958      	cbnz	r0, bb394 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x38>
                LOG(ERROR, "Peer device is missing!");
   bb37c:	2220      	movs	r2, #32
   bb37e:	e9cd 2004 	strd	r2, r0, [sp, #16]
   bb382:	4a0b      	ldr	r2, [pc, #44]	; (bb3b0 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x54>)
   bb384:	9200      	str	r2, [sp, #0]
   bb386:	490b      	ldr	r1, [pc, #44]	; (bb3b4 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x58>)
   bb388:	aa04      	add	r2, sp, #16
   bb38a:	2032      	movs	r0, #50	; 0x32
   bb38c:	f7fe ff42 	bl	ba214 <log_message>
}
   bb390:	b00d      	add	sp, #52	; 0x34
   bb392:	bd30      	pop	{r4, r5, pc}
            if (impl->dataReceivedCallback_) {
   bb394:	6d6a      	ldr	r2, [r5, #84]	; 0x54
   bb396:	2a00      	cmp	r2, #0
   bb398:	d0fa      	beq.n	bb390 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x34>
                impl->dataReceivedCallback_(event->params.data_written.data, event->params.data_written.len, *peer);
   bb39a:	e9d4 2103 	ldrd	r2, r1, [r4, #12]
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bb39e:	f105 004c 	add.w	r0, r5, #76	; 0x4c
   bb3a2:	e9cd 1203 	strd	r1, r2, [sp, #12]
   bb3a6:	6dac      	ldr	r4, [r5, #88]	; 0x58
   bb3a8:	aa04      	add	r2, sp, #16
   bb3aa:	a903      	add	r1, sp, #12
   bb3ac:	47a0      	blx	r4
}
   bb3ae:	e7ef      	b.n	bb390 <_ZN8particle21BleCharacteristicImpl15onBleCharEventsEPK18hal_ble_char_evt_tPv+0x34>
   bb3b0:	000c1e60 	.word	0x000c1e60
   bb3b4:	000c1df7 	.word	0x000c1df7

000bb3b8 <_ZNK8particle14BleLocalDevice2onEv>:
    stopAdvertising(); // BLE HAL will guard that device keeps broadcasting if device is in the Listening/Provisioning mode.
    stopScanning();
    return SYSTEM_ERROR_NONE;
}

int BleLocalDevice::on() const {
   bb3b8:	b508      	push	{r3, lr}
    CHECK(hal_ble_stack_init(nullptr));
   bb3ba:	2000      	movs	r0, #0
   bb3bc:	f7fe fcf8 	bl	b9db0 <hal_ble_stack_init>
    return SYSTEM_ERROR_NONE;
}
   bb3c0:	ea00 70e0 	and.w	r0, r0, r0, asr #31
   bb3c4:	bd08      	pop	{r3, pc}

000bb3c6 <_ZNK8particle14BleLocalDevice10setTxPowerEa>:
        name.concat(buf);
    }
    return name;
}

int BleLocalDevice::setTxPower(int8_t txPower) const {
   bb3c6:	4608      	mov	r0, r1
    return hal_ble_gap_set_tx_power(txPower, nullptr);
   bb3c8:	2100      	movs	r1, #0
   bb3ca:	f7fe bcf9 	b.w	b9dc0 <hal_ble_gap_set_tx_power>
	...

000bb3d0 <_ZN8particle16BleScanDelegator5startEPNS_13BleScanResultEj>:
        scanResultCallbackRef_ = callback ? std::bind(callback, _1, context) : (BleOnScanResultStdFunction)nullptr;
        CHECK(hal_ble_gap_start_scan(onScanResultCallback, this, nullptr));
        return foundCount_;
    }

    int start(BleScanResult* results, size_t resultCount) {
   bb3d0:	b570      	push	{r4, r5, r6, lr}
   bb3d2:	4604      	mov	r4, r0
        scanResultCallback_ = nullptr;
   bb3d4:	3018      	adds	r0, #24
    int start(BleScanResult* results, size_t resultCount) {
   bb3d6:	460e      	mov	r6, r1
   bb3d8:	4615      	mov	r5, r2
        scanResultCallback_ = nullptr;
   bb3da:	f7ff fb3f 	bl	baa5c <_ZNSt8functionIFvPKN8particle13BleScanResultEEEaSEDn.isra.0>
        scanResultCallbackRef_ = nullptr;
   bb3de:	f104 0028 	add.w	r0, r4, #40	; 0x28
   bb3e2:	f7ff fb46 	bl	baa72 <_ZNSt8functionIFvRKN8particle13BleScanResultEEEaSEDn.isra.0>
        resultsPtr_ = results;
        targetCount_ = resultCount;
   bb3e6:	e9c4 6503 	strd	r6, r5, [r4, #12]
        CHECK(hal_ble_gap_start_scan(onScanResultCallback, this, nullptr));
   bb3ea:	2200      	movs	r2, #0
   bb3ec:	4621      	mov	r1, r4
   bb3ee:	4803      	ldr	r0, [pc, #12]	; (bb3fc <_ZN8particle16BleScanDelegator5startEPNS_13BleScanResultEj+0x2c>)
   bb3f0:	f7fe fcfe 	bl	b9df0 <hal_ble_gap_start_scan>
   bb3f4:	2800      	cmp	r0, #0
        return foundCount_;
   bb3f6:	bfa8      	it	ge
   bb3f8:	6960      	ldrge	r0, [r4, #20]
    }
   bb3fa:	bd70      	pop	{r4, r5, r6, pc}
   bb3fc:	000bcd2d 	.word	0x000bcd2d

000bb400 <_ZN8particle13BleScanResultD1Ev>:
private:
    std::shared_ptr<BleServiceImpl> impl_;
};


class BleScanResult {
   bb400:	b510      	push	{r4, lr}
   bb402:	4604      	mov	r4, r0
    ::free(ptr);
   bb404:	6940      	ldr	r0, [r0, #20]
   bb406:	f7fe fff9 	bl	ba3fc <free>
   bb40a:	68a0      	ldr	r0, [r4, #8]
   bb40c:	f7fe fff6 	bl	ba3fc <free>
   bb410:	4620      	mov	r0, r4
   bb412:	bd10      	pop	{r4, pc}

000bb414 <_ZN8particle16BleScanDelegatorC1Ev>:
        capacity_(0) {
   bb414:	2200      	movs	r2, #0
public:
    BleScanFilter()
            : minRssi_(BLE_RSSI_INVALID),
              maxRssi_(BLE_RSSI_INVALID),
              customData_(nullptr),
              customDataLen_(0) {
   bb416:	f647 717f 	movw	r1, #32639	; 0x7f7f
   bb41a:	e9c0 2200 	strd	r2, r2, [r0]
              scanResultCallbackRef_(nullptr) {
   bb41e:	e9c0 2202 	strd	r2, r2, [r0, #8]
   bb422:	e9c0 2204 	strd	r2, r2, [r0, #16]
   bb426:	e9c0 220e 	strd	r2, r2, [r0, #56]	; 0x38
   bb42a:	e9c0 2210 	strd	r2, r2, [r0, #64]	; 0x40
   bb42e:	e9c0 2212 	strd	r2, r2, [r0, #72]	; 0x48
   bb432:	e9c0 2214 	strd	r2, r2, [r0, #80]	; 0x50
   bb436:	e9c0 2216 	strd	r2, r2, [r0, #88]	; 0x58
   bb43a:	e9c0 2218 	strd	r2, r2, [r0, #96]	; 0x60
   bb43e:	e9c0 221b 	strd	r2, r2, [r0, #108]	; 0x6c
    _Function_base() : _M_manager(nullptr) { }
   bb442:	6202      	str	r2, [r0, #32]
   bb444:	6302      	str	r2, [r0, #48]	; 0x30
   bb446:	f8a0 1068 	strh.w	r1, [r0, #104]	; 0x68
    }
   bb44a:	4770      	bx	lr

000bb44c <_ZNK8particle14BleLocalDevice14setScanTimeoutEt>:
    std::function<void(const BleScanResult*)> scanResultCallback_;
    BleOnScanResultStdFunction scanResultCallbackRef_;
    BleScanFilter filter_;
};

int BleLocalDevice::setScanTimeout(uint16_t timeout) const {
   bb44c:	b530      	push	{r4, r5, lr}
   bb44e:	b085      	sub	sp, #20
    hal_ble_scan_params_t scanParams = {};
   bb450:	2400      	movs	r4, #0
    scanParams.size = sizeof(hal_ble_scan_params_t);
   bb452:	2310      	movs	r3, #16
int BleLocalDevice::setScanTimeout(uint16_t timeout) const {
   bb454:	460d      	mov	r5, r1
    scanParams.size = sizeof(hal_ble_scan_params_t);
   bb456:	f8ad 3002 	strh.w	r3, [sp, #2]
    scanParams.version = BLE_API_VERSION;
    hal_ble_gap_get_scan_parameters(&scanParams, nullptr);
   bb45a:	4621      	mov	r1, r4
    scanParams.version = BLE_API_VERSION;
   bb45c:	2303      	movs	r3, #3
    hal_ble_gap_get_scan_parameters(&scanParams, nullptr);
   bb45e:	4668      	mov	r0, sp
    scanParams.version = BLE_API_VERSION;
   bb460:	f8ad 3000 	strh.w	r3, [sp]
    hal_ble_scan_params_t scanParams = {};
   bb464:	e9cd 4401 	strd	r4, r4, [sp, #4]
   bb468:	9403      	str	r4, [sp, #12]
    hal_ble_gap_get_scan_parameters(&scanParams, nullptr);
   bb46a:	f7fe fcb9 	bl	b9de0 <hal_ble_gap_get_scan_parameters>
    scanParams.timeout = timeout;
    return hal_ble_gap_set_scan_parameters(&scanParams, nullptr);
   bb46e:	4621      	mov	r1, r4
   bb470:	4668      	mov	r0, sp
    scanParams.timeout = timeout;
   bb472:	f8ad 5008 	strh.w	r5, [sp, #8]
    return hal_ble_gap_set_scan_parameters(&scanParams, nullptr);
   bb476:	f7fe fcab 	bl	b9dd0 <hal_ble_gap_set_scan_parameters>
}
   bb47a:	b005      	add	sp, #20
   bb47c:	bd30      	pop	{r4, r5, pc}

000bb47e <_ZNK8particle14BleLocalDevice9connectedEv>:
    return size_;
   bb47e:	6803      	ldr	r3, [r0, #0]
void BleLocalDevice::onAttMtuExchanged(const BleOnAttMtuExchangedStdFunction& callback) const {
    impl()->onAttMtuExchangedCallback(callback);
}

bool BleLocalDevice::connected() const {
    return (impl()->peers().size() > 0);
   bb480:	69d8      	ldr	r0, [r3, #28]
}
   bb482:	2800      	cmp	r0, #0
   bb484:	bfd4      	ite	le
   bb486:	2000      	movle	r0, #0
   bb488:	2001      	movgt	r0, #1
   bb48a:	4770      	bx	lr

000bb48c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb48c:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   bb48e:	e9d0 5300 	ldrd	r5, r3, [r0]
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb492:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
   bb494:	eb05 1603 	add.w	r6, r5, r3, lsl #4
        for (; p != end; ++p) {
   bb498:	42ae      	cmp	r6, r5
   bb49a:	d004      	beq.n	bb4a6 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0x1a>
            p->~T();
   bb49c:	4628      	mov	r0, r5
   bb49e:	f7ff f923 	bl	ba6e8 <_ZN6StringD1Ev>
        for (; p != end; ++p) {
   bb4a2:	3510      	adds	r5, #16
   bb4a4:	e7f8      	b.n	bb498 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev+0xc>
    ::free(ptr);
   bb4a6:	6820      	ldr	r0, [r4, #0]
   bb4a8:	f7fe ffa8 	bl	ba3fc <free>
}
   bb4ac:	4620      	mov	r0, r4
   bb4ae:	bd70      	pop	{r4, r5, r6, pc}

000bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb4b0:	b510      	push	{r4, lr}
   bb4b2:	4604      	mov	r4, r0
    ::free(ptr);
   bb4b4:	6800      	ldr	r0, [r0, #0]
   bb4b6:	f7fe ffa1 	bl	ba3fc <free>
}
   bb4ba:	4620      	mov	r0, r4
   bb4bc:	bd10      	pop	{r4, pc}

000bb4be <_ZN8particle16BleScanDelegatorD1Ev>:
    ~BleScanDelegator() = default;
   bb4be:	b570      	push	{r4, r5, r6, lr}
   bb4c0:	4604      	mov	r4, r0
    ::free(ptr);
   bb4c2:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
   bb4c4:	f7fe ff9a 	bl	ba3fc <free>
   bb4c8:	6d20      	ldr	r0, [r4, #80]	; 0x50
   bb4ca:	f7fe ff97 	bl	ba3fc <free>
    }
    ~BleScanFilter() = default;
   bb4ce:	f104 0538 	add.w	r5, r4, #56	; 0x38
   bb4d2:	f104 0044 	add.w	r0, r4, #68	; 0x44
   bb4d6:	f7ff ffeb 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
   bb4da:	4628      	mov	r0, r5
   bb4dc:	f7ff ffd6 	bl	bb48c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
    class function<_Res(_ArgTypes...)>
   bb4e0:	f104 0028 	add.w	r0, r4, #40	; 0x28
   bb4e4:	f7f8 ffbc 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bb4e8:	f104 0018 	add.w	r0, r4, #24
   bb4ec:	f7f8 ffb8 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
    destruct(data_, data_ + size_);
   bb4f0:	e9d4 5300 	ldrd	r5, r3, [r4]
   bb4f4:	2624      	movs	r6, #36	; 0x24
   bb4f6:	fb06 5603 	mla	r6, r6, r3, r5
        for (; p != end; ++p) {
   bb4fa:	42ae      	cmp	r6, r5
   bb4fc:	d004      	beq.n	bb508 <_ZN8particle16BleScanDelegatorD1Ev+0x4a>
            p->~T();
   bb4fe:	4628      	mov	r0, r5
   bb500:	f7ff ff7e 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
        for (; p != end; ++p) {
   bb504:	3524      	adds	r5, #36	; 0x24
   bb506:	e7f8      	b.n	bb4fa <_ZN8particle16BleScanDelegatorD1Ev+0x3c>
    ::free(ptr);
   bb508:	6820      	ldr	r0, [r4, #0]
   bb50a:	f7fe ff77 	bl	ba3fc <free>
   bb50e:	4620      	mov	r0, r4
   bb510:	bd70      	pop	{r4, r5, r6, pc}
	...

000bb514 <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj>:
int BleLocalDevice::scan(BleScanResult* results, size_t resultCount) const {
   bb514:	b530      	push	{r4, r5, lr}
   bb516:	4615      	mov	r5, r2
   bb518:	b09f      	sub	sp, #124	; 0x7c
    if (results == nullptr || resultCount == 0) {
   bb51a:	460c      	mov	r4, r1
   bb51c:	b179      	cbz	r1, bb53e <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj+0x2a>
   bb51e:	b172      	cbz	r2, bb53e <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj+0x2a>
    BleScanDelegator scanner;
   bb520:	a801      	add	r0, sp, #4
   bb522:	f7ff ff77 	bl	bb414 <_ZN8particle16BleScanDelegatorC1Ev>
    return scanner.start(results, resultCount);
   bb526:	4621      	mov	r1, r4
   bb528:	462a      	mov	r2, r5
   bb52a:	a801      	add	r0, sp, #4
   bb52c:	f7ff ff50 	bl	bb3d0 <_ZN8particle16BleScanDelegator5startEPNS_13BleScanResultEj>
   bb530:	4604      	mov	r4, r0
    BleScanDelegator scanner;
   bb532:	a801      	add	r0, sp, #4
   bb534:	f7ff ffc3 	bl	bb4be <_ZN8particle16BleScanDelegatorD1Ev>
}
   bb538:	4620      	mov	r0, r4
   bb53a:	b01f      	add	sp, #124	; 0x7c
   bb53c:	bd30      	pop	{r4, r5, pc}
        return SYSTEM_ERROR_INVALID_ARGUMENT;
   bb53e:	4c01      	ldr	r4, [pc, #4]	; (bb544 <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj+0x30>)
   bb540:	e7fa      	b.n	bb538 <_ZNK8particle14BleLocalDevice4scanEPNS_13BleScanResultEj+0x24>
   bb542:	bf00      	nop
   bb544:	fffffef2 	.word	0xfffffef2

000bb548 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE8removeAtEii>:
inline void spark::Vector<T, AllocatorT>::removeAt(int i, int n) {
   bb548:	b538      	push	{r3, r4, r5, lr}
    if (n < 0 || i + n > size_) {
   bb54a:	1e14      	subs	r4, r2, #0
   bb54c:	6843      	ldr	r3, [r0, #4]
inline void spark::Vector<T, AllocatorT>::removeAt(int i, int n) {
   bb54e:	4605      	mov	r5, r0
    if (n < 0 || i + n > size_) {
   bb550:	db02      	blt.n	bb558 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE8removeAtEii+0x10>
   bb552:	1862      	adds	r2, r4, r1
   bb554:	429a      	cmp	r2, r3
   bb556:	dd00      	ble.n	bb55a <_ZN5spark6VectorIhNS_16DefaultAllocatorEE8removeAtEii+0x12>
        n = size_ - i;
   bb558:	1a5c      	subs	r4, r3, r1
    T* const p = data_ + i;
   bb55a:	682a      	ldr	r2, [r5, #0]
   bb55c:	1850      	adds	r0, r2, r1
    destruct(p, p + n);
   bb55e:	1901      	adds	r1, r0, r4
    move(p, p + n, data_ + size_);
   bb560:	441a      	add	r2, r3
        ::memmove(dest, p, (end - p) * sizeof(T));
   bb562:	1a52      	subs	r2, r2, r1
   bb564:	f003 fcaf 	bl	beec6 <memmove>
    size_ -= n;
   bb568:	686a      	ldr	r2, [r5, #4]
   bb56a:	1b12      	subs	r2, r2, r4
   bb56c:	606a      	str	r2, [r5, #4]
}
   bb56e:	bd38      	pop	{r3, r4, r5, pc}

000bb570 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEC1ISt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESD_ILi2EESD_ILi3EESA_EEvvEET_>:
      function<_Res(_ArgTypes...)>::
   bb570:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
   bb572:	2300      	movs	r3, #0
      function<_Res(_ArgTypes...)>::
   bb574:	4604      	mov	r4, r0
    _Function_base() : _M_manager(nullptr) { }
   bb576:	6083      	str	r3, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bb578:	2008      	movs	r0, #8
      function<_Res(_ArgTypes...)>::
   bb57a:	460d      	mov	r5, r1
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bb57c:	f7f8 fd8b 	bl	b4096 <_Znwj>
   bb580:	b118      	cbz	r0, bb58a <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEC1ISt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESD_ILi2EESD_ILi3EESA_EEvvEET_+0x1a>
	_Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
      _Bind(_Bind&&) = default;
   bb582:	682b      	ldr	r3, [r5, #0]
   bb584:	6003      	str	r3, [r0, #0]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   bb586:	686b      	ldr	r3, [r5, #4]
   bb588:	6043      	str	r3, [r0, #4]
	    _M_invoker = &_My_handler::_M_invoke;
   bb58a:	4b03      	ldr	r3, [pc, #12]	; (bb598 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEC1ISt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESD_ILi2EESD_ILi3EESA_EEvvEET_+0x28>)
   bb58c:	60e3      	str	r3, [r4, #12]
	    _M_manager = &_My_handler::_M_manager;
   bb58e:	4b03      	ldr	r3, [pc, #12]	; (bb59c <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEC1ISt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESD_ILi2EESD_ILi3EESA_EEvvEET_+0x2c>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bb590:	6020      	str	r0, [r4, #0]
	    _M_manager = &_My_handler::_M_manager;
   bb592:	60a3      	str	r3, [r4, #8]
      }
   bb594:	4620      	mov	r0, r4
   bb596:	bd38      	pop	{r3, r4, r5, pc}
   bb598:	000baa05 	.word	0x000baa05
   bb59c:	000baa1d 	.word	0x000baa1d

000bb5a0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
      : _M_pi(__r._M_pi)
   bb5a0:	680b      	ldr	r3, [r1, #0]
   bb5a2:	6003      	str	r3, [r0, #0]
	if (_M_pi != 0)
   bb5a4:	b113      	cbz	r3, bb5ac <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    { ++_M_use_count; }
   bb5a6:	685a      	ldr	r2, [r3, #4]
   bb5a8:	3201      	adds	r2, #1
   bb5aa:	605a      	str	r2, [r3, #4]
      }
   bb5ac:	4770      	bx	lr

000bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>:
BleCharacteristic::BleCharacteristic(const BleCharacteristic& characteristic)
   bb5ae:	b510      	push	{r4, lr}
      __shared_ptr(const __shared_ptr&) noexcept = default;
   bb5b0:	f851 3b04 	ldr.w	r3, [r1], #4
   bb5b4:	4604      	mov	r4, r0
   bb5b6:	f840 3b04 	str.w	r3, [r0], #4
   bb5ba:	f7ff fff1 	bl	bb5a0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    if (!impl()) {
   bb5be:	6823      	ldr	r3, [r4, #0]
   bb5c0:	b90b      	cbnz	r3, bb5c6 <_ZN8particle17BleCharacteristicC1ERKS0_+0x18>
   bb5c2:	f7ff fa15 	bl	ba9f0 <_ZN8particle10BleServiceC2ERKNS_7BleUuidE.part.0>
}
   bb5c6:	4620      	mov	r0, r4
   bb5c8:	bd10      	pop	{r4, pc}

000bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>:
   bb5ca:	b510      	push	{r4, lr}
   bb5cc:	f851 3b04 	ldr.w	r3, [r1], #4
   bb5d0:	4604      	mov	r4, r0
   bb5d2:	f840 3b04 	str.w	r3, [r0], #4
   bb5d6:	f7ff ffe3 	bl	bb5a0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
   bb5da:	4620      	mov	r0, r4
   bb5dc:	bd10      	pop	{r4, pc}

000bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>:
   bb5de:	b510      	push	{r4, lr}
   bb5e0:	f851 3b04 	ldr.w	r3, [r1], #4
   bb5e4:	4604      	mov	r4, r0
   bb5e6:	f840 3b04 	str.w	r3, [r0], #4
   bb5ea:	f7ff ffd9 	bl	bb5a0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
   bb5ee:	4620      	mov	r0, r4
   bb5f0:	bd10      	pop	{r4, pc}

000bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      ~__shared_count() noexcept
   bb5f2:	b510      	push	{r4, lr}
   bb5f4:	4604      	mov	r4, r0
	if (_M_pi != nullptr)
   bb5f6:	6800      	ldr	r0, [r0, #0]
   bb5f8:	b108      	cbz	r0, bb5fe <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0xc>
	  _M_pi->_M_release();
   bb5fa:	f7f8 ff6f 	bl	b44dc <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv>
      }
   bb5fe:	4620      	mov	r0, r4
   bb600:	bd10      	pop	{r4, pc}

000bb602 <_ZN8particle13BlePeerDeviceD1Ev>:
BlePeerDevice::~BlePeerDevice() {
   bb602:	b510      	push	{r4, lr}
   bb604:	4604      	mov	r4, r0
      ~__shared_ptr() = default;
   bb606:	3004      	adds	r0, #4
   bb608:	f7ff fff3 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   bb60c:	4620      	mov	r0, r4
   bb60e:	bd10      	pop	{r4, pc}

000bb610 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb610:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   bb612:	e9d0 5300 	ldrd	r5, r3, [r0]
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb616:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
   bb618:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
        for (; p != end; ++p) {
   bb61c:	42ae      	cmp	r6, r5
   bb61e:	d004      	beq.n	bb62a <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev+0x1a>
   bb620:	1d28      	adds	r0, r5, #4
   bb622:	f7ff ffe6 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bb626:	3508      	adds	r5, #8
   bb628:	e7f8      	b.n	bb61c <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev+0xc>
    ::free(ptr);
   bb62a:	6820      	ldr	r0, [r4, #0]
   bb62c:	f7fe fee6 	bl	ba3fc <free>
}
   bb630:	4620      	mov	r0, r4
   bb632:	bd70      	pop	{r4, r5, r6, pc}

000bb634 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>:
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb634:	b570      	push	{r4, r5, r6, lr}
    destruct(data_, data_ + size_);
   bb636:	e9d0 5300 	ldrd	r5, r3, [r0]
inline spark::Vector<T, AllocatorT>::~Vector() {
   bb63a:	4604      	mov	r4, r0
    destruct(data_, data_ + size_);
   bb63c:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
        for (; p != end; ++p) {
   bb640:	42ae      	cmp	r6, r5
   bb642:	d004      	beq.n	bb64e <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev+0x1a>
   bb644:	1d28      	adds	r0, r5, #4
   bb646:	f7ff ffd4 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bb64a:	3508      	adds	r5, #8
   bb64c:	e7f8      	b.n	bb640 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev+0xc>
    ::free(ptr);
   bb64e:	6820      	ldr	r0, [r4, #0]
   bb650:	f7fe fed4 	bl	ba3fc <free>
}
   bb654:	4620      	mov	r0, r4
   bb656:	bd70      	pop	{r4, r5, r6, pc}

000bb658 <_ZNSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
   bb658:	b510      	push	{r4, lr}
   bb65a:	4604      	mov	r4, r0
    ~BlePeerDeviceImpl() = default;
   bb65c:	3024      	adds	r0, #36	; 0x24
   bb65e:	f7ff ffe9 	bl	bb634 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
   bb662:	f104 0018 	add.w	r0, r4, #24
   bb666:	f7ff ffd3 	bl	bb610 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>
      }
   bb66a:	bd10      	pop	{r4, pc}

000bb66c <__tcf_0>:
    static BleLocalDevice instance;
   bb66c:	b570      	push	{r4, r5, r6, lr}
	if (__ptr != nullptr)
   bb66e:	4b17      	ldr	r3, [pc, #92]	; (bb6cc <__tcf_0+0x60>)
   bb670:	681c      	ldr	r4, [r3, #0]
   bb672:	b354      	cbz	r4, bb6ca <__tcf_0+0x5e>
    class function<_Res(_ArgTypes...)>
   bb674:	f104 0054 	add.w	r0, r4, #84	; 0x54
   bb678:	f7f8 fef2 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bb67c:	f104 0044 	add.w	r0, r4, #68	; 0x44
   bb680:	f7f8 feee 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bb684:	f104 0034 	add.w	r0, r4, #52	; 0x34
   bb688:	f7f8 feea 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bb68c:	f104 0024 	add.w	r0, r4, #36	; 0x24
   bb690:	f7f8 fee6 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
    destruct(data_, data_ + size_);
   bb694:	e9d4 5306 	ldrd	r5, r3, [r4, #24]
   bb698:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
        for (; p != end; ++p) {
   bb69c:	42ae      	cmp	r6, r5
   bb69e:	d004      	beq.n	bb6aa <__tcf_0+0x3e>
      ~__shared_ptr() = default;
   bb6a0:	1d28      	adds	r0, r5, #4
   bb6a2:	f7ff ffa6 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bb6a6:	3508      	adds	r5, #8
   bb6a8:	e7f8      	b.n	bb69c <__tcf_0+0x30>
    ::free(ptr);
   bb6aa:	69a0      	ldr	r0, [r4, #24]
   bb6ac:	f7fe fea6 	bl	ba3fc <free>
    ~BleLocalDeviceImpl() = default;
   bb6b0:	f104 000c 	add.w	r0, r4, #12
   bb6b4:	f7ff ffbe 	bl	bb634 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
   bb6b8:	4620      	mov	r0, r4
   bb6ba:	f7ff ffa9 	bl	bb610 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>
	delete __ptr;
   bb6be:	4620      	mov	r0, r4
   bb6c0:	2164      	movs	r1, #100	; 0x64
    static BleLocalDevice instance;
   bb6c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   bb6c6:	f7f8 bcea 	b.w	b409e <_ZdlPvj>
   bb6ca:	bd70      	pop	{r4, r5, r6, pc}
   bb6cc:	2003e678 	.word	0x2003e678

000bb6d0 <_ZNKSt8functionIFvRKN8particle13BlePeerDeviceEEEclES3_>:
      if (_M_empty())
   bb6d0:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
   bb6d2:	b510      	push	{r4, lr}
      if (_M_empty())
   bb6d4:	b90a      	cbnz	r2, bb6da <_ZNKSt8functionIFvRKN8particle13BlePeerDeviceEEEclES3_+0xa>
	__throw_bad_function_call();
   bb6d6:	f002 fd40 	bl	be15a <_ZSt25__throw_bad_function_callv>
    }
   bb6da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bb6de:	68c3      	ldr	r3, [r0, #12]
   bb6e0:	4718      	bx	r3

000bb6e2 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb6e2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        capacity_(0) {
   bb6e6:	2300      	movs	r3, #0
   bb6e8:	e9c0 3300 	strd	r3, r3, [r0]
   bb6ec:	6083      	str	r3, [r0, #8]
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb6ee:	f8d1 8004 	ldr.w	r8, [r1, #4]
   bb6f2:	4598      	cmp	r8, r3
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb6f4:	4605      	mov	r5, r0
   bb6f6:	460f      	mov	r7, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb6f8:	dd4a      	ble.n	bb790 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0xae>
    return ::malloc(size);
   bb6fa:	ea4f 1008 	mov.w	r0, r8, lsl #4
   bb6fe:	f7fe fe75 	bl	ba3ec <malloc>
            if (!d) {
   bb702:	4606      	mov	r6, r0
   bb704:	2800      	cmp	r0, #0
   bb706:	d043      	beq.n	bb790 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0xae>
            move(d, data_, data_ + size_);
   bb708:	e9d5 4100 	ldrd	r4, r1, [r5]
        if (dest > p && dest < end) {
   bb70c:	42a0      	cmp	r0, r4
            move(d, data_, data_ + size_);
   bb70e:	eb04 1a01 	add.w	sl, r4, r1, lsl #4
        if (dest > p && dest < end) {
   bb712:	d916      	bls.n	bb742 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x60>
   bb714:	4550      	cmp	r0, sl
   bb716:	d215      	bcs.n	bb744 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x62>
            --end;
   bb718:	f1aa 0a10 	sub.w	sl, sl, #16
            dest += end - p - 1;
   bb71c:	f1a4 0910 	sub.w	r9, r4, #16
   bb720:	ebaa 0404 	sub.w	r4, sl, r4
   bb724:	4404      	add	r4, r0
            for (; end != p; --end, --dest) {
   bb726:	45d1      	cmp	r9, sl
   bb728:	d01d      	beq.n	bb766 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x84>
                new(dest) T(std::move(*end));
   bb72a:	b11c      	cbz	r4, bb734 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x52>
   bb72c:	4651      	mov	r1, sl
   bb72e:	4620      	mov	r0, r4
   bb730:	f7ff f856 	bl	ba7e0 <_ZN6StringC1EOS_>
                end->~T();
   bb734:	4650      	mov	r0, sl
   bb736:	f7fe ffd7 	bl	ba6e8 <_ZN6StringD1Ev>
            for (; end != p; --end, --dest) {
   bb73a:	f1aa 0a10 	sub.w	sl, sl, #16
   bb73e:	3c10      	subs	r4, #16
   bb740:	e7f1      	b.n	bb726 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x44>
        } else if (dest != p) {
   bb742:	d010      	beq.n	bb766 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x84>
   bb744:	46b1      	mov	r9, r6
            for (; p != end; ++p, ++dest) {
   bb746:	45a2      	cmp	sl, r4
   bb748:	d00d      	beq.n	bb766 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x84>
                new(dest) T(std::move(*p));
   bb74a:	f1b9 0f00 	cmp.w	r9, #0
   bb74e:	d003      	beq.n	bb758 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x76>
   bb750:	4621      	mov	r1, r4
   bb752:	4648      	mov	r0, r9
   bb754:	f7ff f844 	bl	ba7e0 <_ZN6StringC1EOS_>
                p->~T();
   bb758:	4620      	mov	r0, r4
   bb75a:	f7fe ffc5 	bl	ba6e8 <_ZN6StringD1Ev>
            for (; p != end; ++p, ++dest) {
   bb75e:	3410      	adds	r4, #16
   bb760:	f109 0910 	add.w	r9, r9, #16
   bb764:	e7ef      	b.n	bb746 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x64>
    ::free(ptr);
   bb766:	6828      	ldr	r0, [r5, #0]
   bb768:	f7fe fe48 	bl	ba3fc <free>
        capacity_ = n;
   bb76c:	f8c5 8008 	str.w	r8, [r5, #8]
        data_ = d;
   bb770:	602e      	str	r6, [r5, #0]
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bb772:	e9d7 4300 	ldrd	r4, r3, [r7]
   bb776:	eb04 1803 	add.w	r8, r4, r3, lsl #4
        for (; it != end; ++it, ++dest) {
   bb77a:	45a0      	cmp	r8, r4
   bb77c:	d006      	beq.n	bb78c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0xaa>
            new(dest) T(*it);
   bb77e:	4621      	mov	r1, r4
   bb780:	4630      	mov	r0, r6
   bb782:	f7ff f847 	bl	ba814 <_ZN6StringC1ERKS_>
        for (; it != end; ++it, ++dest) {
   bb786:	3410      	adds	r4, #16
   bb788:	3610      	adds	r6, #16
   bb78a:	e7f6      	b.n	bb77a <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_+0x98>
        size_ = vector.size_;
   bb78c:	687b      	ldr	r3, [r7, #4]
   bb78e:	606b      	str	r3, [r5, #4]
}
   bb790:	4628      	mov	r0, r5
   bb792:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000bb796 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE>:
    bool filterByDeviceName(const BleScanResult& result) {
   bb796:	b530      	push	{r4, r5, lr}
   bb798:	b08d      	sub	sp, #52	; 0x34
   bb79a:	460c      	mov	r4, r1
        auto filterDeviceNames = filter_.deviceNames();
   bb79c:	f100 0138 	add.w	r1, r0, #56	; 0x38
   bb7a0:	a801      	add	r0, sp, #4
   bb7a2:	f7ff ff9e 	bl	bb6e2 <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEEC1ERKS3_>
        if (filterDeviceNames.size() > 0) {
   bb7a6:	9b02      	ldr	r3, [sp, #8]
   bb7a8:	2b00      	cmp	r3, #0
   bb7aa:	dd2f      	ble.n	bb80c <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x76>
            String srName = result.scanResponse().deviceName();
   bb7ac:	f104 0114 	add.w	r1, r4, #20
   bb7b0:	a804      	add	r0, sp, #16
   bb7b2:	f7ff fbb5 	bl	baf20 <_ZNK8particle18BleAdvertisingData10deviceNameEv>
            String advName = result.advertisingData().deviceName();
   bb7b6:	f104 0108 	add.w	r1, r4, #8
   bb7ba:	a808      	add	r0, sp, #32
   bb7bc:	f7ff fbb0 	bl	baf20 <_ZNK8particle18BleAdvertisingData10deviceNameEv>
            if (srName.length() == 0 && advName.length() == 0) {
   bb7c0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   bb7c2:	9b06      	ldr	r3, [sp, #24]
   bb7c4:	4313      	orrs	r3, r2
   bb7c6:	d01f      	beq.n	bb808 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x72>
    return data_ + size_;
   bb7c8:	e9dd 4501 	ldrd	r4, r5, [sp, #4]
   bb7cc:	eb04 1505 	add.w	r5, r4, r5, lsl #4
            for (const auto& name : filterDeviceNames) {
   bb7d0:	42ac      	cmp	r4, r5
   bb7d2:	d019      	beq.n	bb808 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x72>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
   bb7d4:	a904      	add	r1, sp, #16
   bb7d6:	4620      	mov	r0, r4
   bb7d8:	f7ff f872 	bl	ba8c0 <_ZNK6String6equalsERKS_>
                if (name == srName || name == advName) {
   bb7dc:	b160      	cbz	r0, bb7f8 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x62>
                    return true;
   bb7de:	2401      	movs	r4, #1
            String advName = result.advertisingData().deviceName();
   bb7e0:	a808      	add	r0, sp, #32
   bb7e2:	f7fe ff81 	bl	ba6e8 <_ZN6StringD1Ev>
            String srName = result.scanResponse().deviceName();
   bb7e6:	a804      	add	r0, sp, #16
   bb7e8:	f7fe ff7e 	bl	ba6e8 <_ZN6StringD1Ev>
        auto filterDeviceNames = filter_.deviceNames();
   bb7ec:	a801      	add	r0, sp, #4
   bb7ee:	f7ff fe4d 	bl	bb48c <_ZN5spark6VectorI6StringNS_16DefaultAllocatorEED1Ev>
    }
   bb7f2:	4620      	mov	r0, r4
   bb7f4:	b00d      	add	sp, #52	; 0x34
   bb7f6:	bd30      	pop	{r4, r5, pc}
   bb7f8:	4620      	mov	r0, r4
   bb7fa:	a908      	add	r1, sp, #32
   bb7fc:	f7ff f860 	bl	ba8c0 <_ZNK6String6equalsERKS_>
                if (name == srName || name == advName) {
   bb800:	3410      	adds	r4, #16
   bb802:	2800      	cmp	r0, #0
   bb804:	d0e4      	beq.n	bb7d0 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x3a>
   bb806:	e7ea      	b.n	bb7de <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x48>
                return false;
   bb808:	2400      	movs	r4, #0
   bb80a:	e7e9      	b.n	bb7e0 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x4a>
        return true;
   bb80c:	2401      	movs	r4, #1
   bb80e:	e7ed      	b.n	bb7ec <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE+0x56>

000bb810 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        capacity_(0) {
   bb812:	2300      	movs	r3, #0
   bb814:	e9c0 3300 	strd	r3, r3, [r0]
   bb818:	6083      	str	r3, [r0, #8]
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb81a:	684f      	ldr	r7, [r1, #4]
   bb81c:	429f      	cmp	r7, r3
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb81e:	4605      	mov	r5, r0
   bb820:	460e      	mov	r6, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb822:	dd3e      	ble.n	bb8a2 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x92>
    return ::malloc(size);
   bb824:	00f8      	lsls	r0, r7, #3
   bb826:	f7fe fde1 	bl	ba3ec <malloc>
            if (!d) {
   bb82a:	4604      	mov	r4, r0
   bb82c:	b3c8      	cbz	r0, bb8a2 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x92>
            move(d, data_, data_ + size_);
   bb82e:	e9d5 0300 	ldrd	r0, r3, [r5]
        if (dest > p && dest < end) {
   bb832:	4284      	cmp	r4, r0
            move(d, data_, data_ + size_);
   bb834:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
        if (dest > p && dest < end) {
   bb838:	d910      	bls.n	bb85c <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x4c>
   bb83a:	429c      	cmp	r4, r3
   bb83c:	d20f      	bcs.n	bb85e <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x4e>
            --end;
   bb83e:	3b08      	subs	r3, #8
            dest += end - p - 1;
   bb840:	1a1a      	subs	r2, r3, r0
   bb842:	f1a0 0c08 	sub.w	ip, r0, #8
   bb846:	4422      	add	r2, r4
            for (; end != p; --end, --dest) {
   bb848:	459c      	cmp	ip, r3
   bb84a:	d018      	beq.n	bb87e <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x6e>
                new(dest) T(std::move(*end));
   bb84c:	b11a      	cbz	r2, bb856 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x46>
    address_ = addr.address_;
   bb84e:	6819      	ldr	r1, [r3, #0]
   bb850:	6011      	str	r1, [r2, #0]
   bb852:	6859      	ldr	r1, [r3, #4]
   bb854:	6051      	str	r1, [r2, #4]
            for (; end != p; --end, --dest) {
   bb856:	3b08      	subs	r3, #8
   bb858:	3a08      	subs	r2, #8
   bb85a:	e7f5      	b.n	bb848 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x38>
        } else if (dest != p) {
   bb85c:	d00f      	beq.n	bb87e <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x6e>
   bb85e:	4601      	mov	r1, r0
   bb860:	4622      	mov	r2, r4
            for (; p != end; ++p, ++dest) {
   bb862:	428b      	cmp	r3, r1
   bb864:	d00b      	beq.n	bb87e <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x6e>
                new(dest) T(std::move(*p));
   bb866:	b13a      	cbz	r2, bb878 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x68>
   bb868:	f8d1 c000 	ldr.w	ip, [r1]
   bb86c:	f8c2 c000 	str.w	ip, [r2]
   bb870:	f8d1 c004 	ldr.w	ip, [r1, #4]
   bb874:	f8c2 c004 	str.w	ip, [r2, #4]
            for (; p != end; ++p, ++dest) {
   bb878:	3108      	adds	r1, #8
   bb87a:	3208      	adds	r2, #8
   bb87c:	e7f1      	b.n	bb862 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x52>
    ::free(ptr);
   bb87e:	f7fe fdbd 	bl	ba3fc <free>
        data_ = d;
   bb882:	602c      	str	r4, [r5, #0]
        capacity_ = n;
   bb884:	60af      	str	r7, [r5, #8]
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bb886:	e9d6 3100 	ldrd	r3, r1, [r6]
   bb88a:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
        for (; it != end; ++it, ++dest) {
   bb88e:	4298      	cmp	r0, r3
   bb890:	d006      	beq.n	bb8a0 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x90>
   bb892:	681a      	ldr	r2, [r3, #0]
   bb894:	6022      	str	r2, [r4, #0]
   bb896:	685a      	ldr	r2, [r3, #4]
   bb898:	6062      	str	r2, [r4, #4]
   bb89a:	3308      	adds	r3, #8
   bb89c:	3408      	adds	r4, #8
   bb89e:	e7f6      	b.n	bb88e <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_+0x7e>
        size_ = vector.size_;
   bb8a0:	6069      	str	r1, [r5, #4]
}
   bb8a2:	4628      	mov	r0, r5
   bb8a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bb8a6 <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb8a6:	b570      	push	{r4, r5, r6, lr}
   bb8a8:	4604      	mov	r4, r0
        capacity_(0) {
   bb8aa:	2000      	movs	r0, #0
   bb8ac:	e9c4 0000 	strd	r0, r0, [r4]
   bb8b0:	60a0      	str	r0, [r4, #8]
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb8b2:	684e      	ldr	r6, [r1, #4]
   bb8b4:	4286      	cmp	r6, r0
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bb8b6:	460d      	mov	r5, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bb8b8:	dd12      	ble.n	bb8e0 <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_+0x3a>
    return ::realloc(ptr, size);
   bb8ba:	0071      	lsls	r1, r6, #1
   bb8bc:	f7fe fda6 	bl	ba40c <realloc>
            if (!d) {
   bb8c0:	b170      	cbz	r0, bb8e0 <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_+0x3a>
        data_ = d;
   bb8c2:	6020      	str	r0, [r4, #0]
        capacity_ = n;
   bb8c4:	60a6      	str	r6, [r4, #8]
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bb8c6:	e9d5 3200 	ldrd	r3, r2, [r5]
   bb8ca:	eb03 0242 	add.w	r2, r3, r2, lsl #1
        for (; it != end; ++it, ++dest) {
   bb8ce:	429a      	cmp	r2, r3
   bb8d0:	d004      	beq.n	bb8dc <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_+0x36>
            new(dest) T(*it);
   bb8d2:	f833 1b02 	ldrh.w	r1, [r3], #2
   bb8d6:	f820 1b02 	strh.w	r1, [r0], #2
        for (; it != end; ++it, ++dest) {
   bb8da:	e7f8      	b.n	bb8ce <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_+0x28>
        size_ = vector.size_;
   bb8dc:	686b      	ldr	r3, [r5, #4]
   bb8de:	6063      	str	r3, [r4, #4]
}
   bb8e0:	4620      	mov	r0, r4
   bb8e2:	bd70      	pop	{r4, r5, r6, pc}

000bb8e4 <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE_ED1Ev>:
            func_(std::move(guard.func_)),
            dismissed_(guard.dismissed_) {
        guard.dismissed_ = true;
    }

    ~NamedScopeGuard() {
   bb8e4:	b510      	push	{r4, lr}
        if (!dismissed_) {
   bb8e6:	7903      	ldrb	r3, [r0, #4]
    ~NamedScopeGuard() {
   bb8e8:	4604      	mov	r4, r0
        if (!dismissed_) {
   bb8ea:	b923      	cbnz	r3, bb8f6 <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE_ED1Ev+0x12>
                SCOPE_GUARD({
   bb8ec:	6803      	ldr	r3, [r0, #0]
   bb8ee:	6818      	ldr	r0, [r3, #0]
   bb8f0:	b108      	cbz	r0, bb8f6 <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE_ED1Ev+0x12>
   bb8f2:	f7fe fd83 	bl	ba3fc <free>
            func_();
        }
    }
   bb8f6:	4620      	mov	r0, r4
   bb8f8:	bd10      	pop	{r4, pc}

000bb8fa <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE0_ED1Ev>:
    ~NamedScopeGuard() {
   bb8fa:	b510      	push	{r4, lr}
        if (!dismissed_) {
   bb8fc:	7903      	ldrb	r3, [r0, #4]
    ~NamedScopeGuard() {
   bb8fe:	4604      	mov	r4, r0
        if (!dismissed_) {
   bb900:	b923      	cbnz	r3, bb90c <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE0_ED1Ev+0x12>
                SCOPE_GUARD({
   bb902:	6803      	ldr	r3, [r0, #0]
   bb904:	6818      	ldr	r0, [r3, #0]
   bb906:	b108      	cbz	r0, bb90c <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE0_ED1Ev+0x12>
   bb908:	f7fe fd78 	bl	ba3fc <free>
    }
   bb90c:	4620      	mov	r0, r4
   bb90e:	bd10      	pop	{r4, pc}

000bb910 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE>:
    bool filterByCustomData(const BleScanResult& result) {
   bb910:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        customDataLen_ = len;
        return *this;
    }
    const uint8_t* customData(size_t* len) const {
        *len = customDataLen_;
        return customData_;
   bb914:	f8d0 806c 	ldr.w	r8, [r0, #108]	; 0x6c
   bb918:	b08f      	sub	sp, #60	; 0x3c
   bb91a:	460f      	mov	r7, r1
        if (filterCustomData != nullptr && filterCustomDatalen > 0) {
   bb91c:	f1b8 0f00 	cmp.w	r8, #0
   bb920:	d072      	beq.n	bba08 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xf8>
        *len = customDataLen_;
   bb922:	6f05      	ldr	r5, [r0, #112]	; 0x70
   bb924:	2d00      	cmp	r5, #0
   bb926:	d06f      	beq.n	bba08 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xf8>
        return scanResponse_;
   bb928:	f101 0914 	add.w	r9, r1, #20
            size_t srLen = result.scanResponse().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, nullptr, BLE_MAX_ADV_DATA_LEN);
   bb92c:	231f      	movs	r3, #31
   bb92e:	2200      	movs	r2, #0
   bb930:	21ff      	movs	r1, #255	; 0xff
   bb932:	4648      	mov	r0, r9
   bb934:	f7ff fac1 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
        return advertisingData_;
   bb938:	3708      	adds	r7, #8
            size_t advLen = result.advertisingData().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, nullptr, BLE_MAX_ADV_DATA_LEN_EXT);
   bb93a:	23ff      	movs	r3, #255	; 0xff
            size_t srLen = result.scanResponse().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, nullptr, BLE_MAX_ADV_DATA_LEN);
   bb93c:	4604      	mov	r4, r0
            size_t advLen = result.advertisingData().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, nullptr, BLE_MAX_ADV_DATA_LEN_EXT);
   bb93e:	2200      	movs	r2, #0
   bb940:	4619      	mov	r1, r3
   bb942:	4638      	mov	r0, r7
   bb944:	f7ff fab9 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
            if (srLen != filterCustomDatalen && advLen != filterCustomDatalen) {
   bb948:	42ac      	cmp	r4, r5
            size_t advLen = result.advertisingData().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, nullptr, BLE_MAX_ADV_DATA_LEN_EXT);
   bb94a:	4606      	mov	r6, r0
            if (srLen != filterCustomDatalen && advLen != filterCustomDatalen) {
   bb94c:	d006      	beq.n	bb95c <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x4c>
   bb94e:	42ae      	cmp	r6, r5
   bb950:	d030      	beq.n	bb9b4 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xa4>
                return false;
   bb952:	2400      	movs	r4, #0
    }
   bb954:	4620      	mov	r0, r4
   bb956:	b00f      	add	sp, #60	; 0x3c
   bb958:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                uint8_t* buf = (uint8_t*)malloc(srLen);
   bb95c:	4620      	mov	r0, r4
   bb95e:	f7fe fd45 	bl	ba3ec <malloc>
            dismissed_(false) {
   bb962:	ab03      	add	r3, sp, #12
   bb964:	9304      	str	r3, [sp, #16]
   bb966:	2300      	movs	r3, #0
   bb968:	4604      	mov	r4, r0
   bb96a:	9003      	str	r0, [sp, #12]
   bb96c:	f88d 3014 	strb.w	r3, [sp, #20]
                if (!buf) {
   bb970:	b970      	cbnz	r0, bb990 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x80>
                    LOG(ERROR, "Failed to allocate memory!");
   bb972:	2320      	movs	r3, #32
   bb974:	e9cd 3006 	strd	r3, r0, [sp, #24]
   bb978:	4b24      	ldr	r3, [pc, #144]	; (bba0c <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xfc>)
   bb97a:	9300      	str	r3, [sp, #0]
   bb97c:	4924      	ldr	r1, [pc, #144]	; (bba10 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x100>)
   bb97e:	4603      	mov	r3, r0
   bb980:	aa06      	add	r2, sp, #24
   bb982:	2032      	movs	r0, #50	; 0x32
   bb984:	f7fe fc46 	bl	ba214 <log_message>
                    return false;
   bb988:	a804      	add	r0, sp, #16
   bb98a:	f7ff ffab 	bl	bb8e4 <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE_ED1Ev>
   bb98e:	e7e1      	b.n	bb954 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x44>
                result.scanResponse().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, buf, srLen);
   bb990:	4602      	mov	r2, r0
   bb992:	21ff      	movs	r1, #255	; 0xff
   bb994:	462b      	mov	r3, r5
   bb996:	4648      	mov	r0, r9
   bb998:	f7ff fa8f 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
                if (!memcmp(buf, filterCustomData, srLen)) {
   bb99c:	9803      	ldr	r0, [sp, #12]
   bb99e:	462a      	mov	r2, r5
   bb9a0:	4641      	mov	r1, r8
   bb9a2:	f003 fa72 	bl	bee8a <memcmp>
   bb9a6:	b118      	cbz	r0, bb9b0 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xa0>
                SCOPE_GUARD({
   bb9a8:	a804      	add	r0, sp, #16
   bb9aa:	f7ff ff9b 	bl	bb8e4 <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE_ED1Ev>
            if (advLen == filterCustomDatalen) {
   bb9ae:	e7ce      	b.n	bb94e <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x3e>
                    return true;
   bb9b0:	2401      	movs	r4, #1
   bb9b2:	e7e9      	b.n	bb988 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x78>
                uint8_t* buf = (uint8_t*)malloc(advLen);
   bb9b4:	4628      	mov	r0, r5
   bb9b6:	f7fe fd19 	bl	ba3ec <malloc>
   bb9ba:	2400      	movs	r4, #0
   bb9bc:	ab03      	add	r3, sp, #12
   bb9be:	4606      	mov	r6, r0
   bb9c0:	9003      	str	r0, [sp, #12]
   bb9c2:	9304      	str	r3, [sp, #16]
   bb9c4:	f88d 4014 	strb.w	r4, [sp, #20]
                if (!buf) {
   bb9c8:	b978      	cbnz	r0, bb9ea <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xda>
                    LOG(ERROR, "Failed to allocate memory!");
   bb9ca:	2320      	movs	r3, #32
   bb9cc:	e9cd 3006 	strd	r3, r0, [sp, #24]
   bb9d0:	4b0e      	ldr	r3, [pc, #56]	; (bba0c <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xfc>)
   bb9d2:	9300      	str	r3, [sp, #0]
   bb9d4:	490e      	ldr	r1, [pc, #56]	; (bba10 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x100>)
   bb9d6:	4603      	mov	r3, r0
   bb9d8:	aa06      	add	r2, sp, #24
   bb9da:	2032      	movs	r0, #50	; 0x32
   bb9dc:	f7fe fc1a 	bl	ba214 <log_message>
                    return false;
   bb9e0:	4634      	mov	r4, r6
   bb9e2:	a804      	add	r0, sp, #16
   bb9e4:	f7ff ff89 	bl	bb8fa <_ZN8particle15NamedScopeGuardIZNS_16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultEEUlvE0_ED1Ev>
   bb9e8:	e7b4      	b.n	bb954 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x44>
                result.advertisingData().get(BleAdvertisingDataType::MANUFACTURER_SPECIFIC_DATA, buf, advLen);
   bb9ea:	4602      	mov	r2, r0
   bb9ec:	21ff      	movs	r1, #255	; 0xff
   bb9ee:	462b      	mov	r3, r5
   bb9f0:	4638      	mov	r0, r7
   bb9f2:	f7ff fa62 	bl	baeba <_ZNK8particle18BleAdvertisingData3getENS_22BleAdvertisingDataTypeEPhj>
                if (!memcmp(buf, filterCustomData, advLen)) {
   bb9f6:	9803      	ldr	r0, [sp, #12]
   bb9f8:	462a      	mov	r2, r5
   bb9fa:	4641      	mov	r1, r8
   bb9fc:	f003 fa45 	bl	bee8a <memcmp>
   bba00:	2800      	cmp	r0, #0
   bba02:	d1ee      	bne.n	bb9e2 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xd2>
                    return true;
   bba04:	2401      	movs	r4, #1
   bba06:	e7ec      	b.n	bb9e2 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0xd2>
        return true;
   bba08:	2401      	movs	r4, #1
   bba0a:	e7a3      	b.n	bb954 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE+0x44>
   bba0c:	000c1e78 	.word	0x000c1e78
   bba10:	000c1df7 	.word	0x000c1df7

000bba14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi>:
    bool realloc(int n) {
   bba14:	b538      	push	{r3, r4, r5, lr}
        if (n > 0) {
   bba16:	1e0d      	subs	r5, r1, #0
    bool realloc(int n) {
   bba18:	4604      	mov	r4, r0
            d = (T*)AllocatorT::realloc(data_, n * sizeof(T));
   bba1a:	6800      	ldr	r0, [r0, #0]
        if (n > 0) {
   bba1c:	dd03      	ble.n	bba26 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi+0x12>
    return ::realloc(ptr, size);
   bba1e:	f7fe fcf5 	bl	ba40c <realloc>
            if (!d) {
   bba22:	b918      	cbnz	r0, bba2c <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi+0x18>
    }
   bba24:	bd38      	pop	{r3, r4, r5, pc}
    ::free(ptr);
   bba26:	f7fe fce9 	bl	ba3fc <free>
        T* d = nullptr;
   bba2a:	2000      	movs	r0, #0
        data_ = d;
   bba2c:	6020      	str	r0, [r4, #0]
        capacity_ = n;
   bba2e:	60a5      	str	r5, [r4, #8]
        return true;
   bba30:	2001      	movs	r0, #1
   bba32:	e7f7      	b.n	bba24 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi+0x10>

000bba34 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reserveEi>:
inline bool spark::Vector<T, AllocatorT>::reserve(int n) {
   bba34:	b508      	push	{r3, lr}
    if (n > capacity_ && !realloc(n)) {
   bba36:	6883      	ldr	r3, [r0, #8]
   bba38:	428b      	cmp	r3, r1
   bba3a:	da02      	bge.n	bba42 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reserveEi+0xe>
   bba3c:	f7ff ffea 	bl	bba14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi>
}
   bba40:	bd08      	pop	{r3, pc}
    return true;
   bba42:	2001      	movs	r0, #1
   bba44:	e7fc      	b.n	bba40 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reserveEi+0xc>

000bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bba46:	b538      	push	{r3, r4, r5, lr}
        capacity_(0) {
   bba48:	2300      	movs	r3, #0
   bba4a:	e9c0 3300 	strd	r3, r3, [r0]
   bba4e:	6083      	str	r3, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bba50:	460d      	mov	r5, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bba52:	6849      	ldr	r1, [r1, #4]
   bba54:	4299      	cmp	r1, r3
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bba56:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bba58:	dd10      	ble.n	bba7c <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_+0x36>
   bba5a:	f7ff ffdb 	bl	bba14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi>
   bba5e:	b168      	cbz	r0, bba7c <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_+0x36>
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bba60:	e9d5 3100 	ldrd	r3, r1, [r5]
   bba64:	6822      	ldr	r2, [r4, #0]
   bba66:	4419      	add	r1, r3
        for (; it != end; ++it, ++dest) {
   bba68:	4299      	cmp	r1, r3
   bba6a:	d005      	beq.n	bba78 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_+0x32>
            new(dest) T(*it);
   bba6c:	b10a      	cbz	r2, bba72 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_+0x2c>
   bba6e:	7818      	ldrb	r0, [r3, #0]
   bba70:	7010      	strb	r0, [r2, #0]
        for (; it != end; ++it, ++dest) {
   bba72:	3301      	adds	r3, #1
   bba74:	3201      	adds	r2, #1
   bba76:	e7f7      	b.n	bba68 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_+0x22>
        size_ = vector.size_;
   bba78:	686b      	ldr	r3, [r5, #4]
   bba7a:	6063      	str	r3, [r4, #4]
}
   bba7c:	4620      	mov	r0, r4
   bba7e:	bd38      	pop	{r3, r4, r5, pc}

000bba80 <_ZN8particle13BleScanResultC1EOS0_>:
class BleScanResult {
   bba80:	b538      	push	{r3, r4, r5, lr}
    address_ = addr.address_;
   bba82:	680b      	ldr	r3, [r1, #0]
   bba84:	6003      	str	r3, [r0, #0]
   bba86:	684b      	ldr	r3, [r1, #4]
   bba88:	6043      	str	r3, [r0, #4]
   bba8a:	4604      	mov	r4, r0
   bba8c:	460d      	mov	r5, r1
class BleAdvertisingData {
   bba8e:	3008      	adds	r0, #8
   bba90:	3108      	adds	r1, #8
   bba92:	f7ff ffd8 	bl	bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>
   bba96:	f105 0114 	add.w	r1, r5, #20
   bba9a:	f104 0014 	add.w	r0, r4, #20
   bba9e:	f7ff ffd2 	bl	bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>
class BleScanResult {
   bbaa2:	f895 3020 	ldrb.w	r3, [r5, #32]
   bbaa6:	f884 3020 	strb.w	r3, [r4, #32]
   bbaaa:	4620      	mov	r0, r4
   bbaac:	bd38      	pop	{r3, r4, r5, pc}

000bbaae <_ZN8particle18BleAdvertisingDataaSERKS0_.isra.0>:
class BleAdvertisingData {
   bbaae:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   bbab0:	4604      	mov	r4, r0
   bbab2:	a801      	add	r0, sp, #4
   bbab4:	f7ff ffc7 	bl	bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>
   bbab8:	9b01      	ldr	r3, [sp, #4]
   bbaba:	9a02      	ldr	r2, [sp, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bbabc:	6820      	ldr	r0, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
   bbabe:	6023      	str	r3, [r4, #0]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bbac0:	6863      	ldr	r3, [r4, #4]
      __a = _GLIBCXX_MOVE(__b);
   bbac2:	6062      	str	r2, [r4, #4]
   bbac4:	9a03      	ldr	r2, [sp, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   bbac6:	9302      	str	r3, [sp, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bbac8:	68a3      	ldr	r3, [r4, #8]
      __a = _GLIBCXX_MOVE(__b);
   bbaca:	60a2      	str	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   bbacc:	9001      	str	r0, [sp, #4]
   bbace:	9303      	str	r3, [sp, #12]
    ::free(ptr);
   bbad0:	f7fe fc94 	bl	ba3fc <free>
   bbad4:	b004      	add	sp, #16
   bbad6:	bd10      	pop	{r4, pc}

000bbad8 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi>:
inline bool spark::Vector<T, AllocatorT>::insert(int i, const T* values, int n) {
   bbad8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   bbadc:	460f      	mov	r7, r1
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bbade:	6841      	ldr	r1, [r0, #4]
inline bool spark::Vector<T, AllocatorT>::insert(int i, const T* values, int n) {
   bbae0:	461d      	mov	r5, r3
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bbae2:	4419      	add	r1, r3
   bbae4:	6883      	ldr	r3, [r0, #8]
   bbae6:	4299      	cmp	r1, r3
inline bool spark::Vector<T, AllocatorT>::insert(int i, const T* values, int n) {
   bbae8:	4604      	mov	r4, r0
   bbaea:	4690      	mov	r8, r2
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bbaec:	dc12      	bgt.n	bbb14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi+0x3c>
    T* const p = data_ + i;
   bbaee:	6826      	ldr	r6, [r4, #0]
        ::memmove(dest, p, (end - p) * sizeof(T));
   bbaf0:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bbaf2:	443e      	add	r6, r7
        ::memmove(dest, p, (end - p) * sizeof(T));
   bbaf4:	1bd2      	subs	r2, r2, r7
   bbaf6:	4631      	mov	r1, r6
   bbaf8:	1970      	adds	r0, r6, r5
   bbafa:	f003 f9e4 	bl	beec6 <memmove>
        ::memcpy(dest, p, (end - p) * sizeof(T));
   bbafe:	462a      	mov	r2, r5
   bbb00:	4641      	mov	r1, r8
   bbb02:	4630      	mov	r0, r6
   bbb04:	f003 f9d1 	bl	beeaa <memcpy>
    size_ += n;
   bbb08:	6863      	ldr	r3, [r4, #4]
   bbb0a:	442b      	add	r3, r5
   bbb0c:	6063      	str	r3, [r4, #4]
    return true;
   bbb0e:	2001      	movs	r0, #1
}
   bbb10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bbb14:	f7ff ff7e 	bl	bba14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi>
   bbb18:	2800      	cmp	r0, #0
   bbb1a:	d1e8      	bne.n	bbaee <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi+0x16>
   bbb1c:	e7f8      	b.n	bbb10 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi+0x38>

000bbb1e <_ZN8particle18BleAdvertisingData3setEPKhj>:
size_t BleAdvertisingData::set(const uint8_t* buf, size_t len) {
   bbb1e:	4613      	mov	r3, r2
    if (buf == nullptr || len == 0) {
   bbb20:	460a      	mov	r2, r1
   bbb22:	2100      	movs	r1, #0
size_t BleAdvertisingData::set(const uint8_t* buf, size_t len) {
   bbb24:	b510      	push	{r4, lr}
   bbb26:	4604      	mov	r4, r0
    size_ = 0;
   bbb28:	6041      	str	r1, [r0, #4]
    if (buf == nullptr || len == 0) {
   bbb2a:	b102      	cbz	r2, bbb2e <_ZN8particle18BleAdvertisingData3setEPKhj+0x10>
   bbb2c:	b90b      	cbnz	r3, bbb32 <_ZN8particle18BleAdvertisingData3setEPKhj+0x14>
        return selfData_.size();
   bbb2e:	2000      	movs	r0, #0
}
   bbb30:	bd10      	pop	{r4, pc}
    return insert(size_, values, n);
   bbb32:	2bff      	cmp	r3, #255	; 0xff
   bbb34:	bf28      	it	cs
   bbb36:	23ff      	movcs	r3, #255	; 0xff
   bbb38:	f7ff ffce 	bl	bbad8 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi>
    CHECK_TRUE(selfData_.append(buf, len), 0);
   bbb3c:	2800      	cmp	r0, #0
   bbb3e:	d0f7      	beq.n	bbb30 <_ZN8particle18BleAdvertisingData3setEPKhj+0x12>
    return selfData_.size();
   bbb40:	6860      	ldr	r0, [r4, #4]
   bbb42:	e7f5      	b.n	bbb30 <_ZN8particle18BleAdvertisingData3setEPKhj+0x12>

000bbb44 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0>:
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
   bbb44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bbb46:	460d      	mov	r5, r1
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bbb48:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
   bbb4c:	4299      	cmp	r1, r3
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
   bbb4e:	4604      	mov	r4, r0
   bbb50:	4616      	mov	r6, r2
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bbb52:	da0b      	bge.n	bbb6c <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0+0x28>
    T* const p = data_ + i;
   bbb54:	6827      	ldr	r7, [r4, #0]
        ::memmove(dest, p, (end - p) * sizeof(T));
   bbb56:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bbb58:	1979      	adds	r1, r7, r5
        ::memmove(dest, p, (end - p) * sizeof(T));
   bbb5a:	1b52      	subs	r2, r2, r5
   bbb5c:	1c48      	adds	r0, r1, #1
   bbb5e:	f003 f9b2 	bl	beec6 <memmove>
    new(p) T(std::move(value));
   bbb62:	557e      	strb	r6, [r7, r5]
    ++size_;
   bbb64:	6863      	ldr	r3, [r4, #4]
   bbb66:	3301      	adds	r3, #1
   bbb68:	6063      	str	r3, [r4, #4]
}
   bbb6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bbb6c:	3101      	adds	r1, #1
   bbb6e:	f7ff ff51 	bl	bba14 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reallocIhLi0EEEbi>
   bbb72:	2800      	cmp	r0, #0
   bbb74:	d1ee      	bne.n	bbb54 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0+0x10>
   bbb76:	e7f8      	b.n	bbb6a <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0+0x26>

000bbb78 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6appendEh.isra.0>:
inline bool spark::Vector<T, AllocatorT>::append(T value) {
   bbb78:	460a      	mov	r2, r1
    return insert(size_, std::move(value));
   bbb7a:	6841      	ldr	r1, [r0, #4]
   bbb7c:	f7ff bfe2 	b.w	bbb44 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0>

000bbb80 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0>:
size_t BleAdvertisingData::append(BleAdvertisingDataType type, const uint8_t* buf, size_t len, bool force) {
   bbb80:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   bbb84:	4604      	mov	r4, r0
   bbb86:	461d      	mov	r5, r3
   bbb88:	460f      	mov	r7, r1
   bbb8a:	ab01      	add	r3, sp, #4
   bbb8c:	4690      	mov	r8, r2
   bbb8e:	460a      	mov	r2, r1
   bbb90:	e9d0 0100 	ldrd	r0, r1, [r0]
   bbb94:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
   bbb98:	f7fe ff14 	bl	ba9c4 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0>
   bbb9c:	1cae      	adds	r6, r5, #2
   bbb9e:	6863      	ldr	r3, [r4, #4]
   bbba0:	4602      	mov	r2, r0
    if (!force && adsLen > 0) {
   bbba2:	f1b9 0f00 	cmp.w	r9, #0
   bbba6:	d126      	bne.n	bbbf6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x76>
   bbba8:	b328      	cbz	r0, bbbf6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x76>
        if ((selfData_.size() - adsLen + len + 2) <= BLE_MAX_ADV_DATA_LEN_EXT) {
   bbbaa:	4433      	add	r3, r6
   bbbac:	1a1b      	subs	r3, r3, r0
   bbbae:	2bff      	cmp	r3, #255	; 0xff
   bbbb0:	d809      	bhi.n	bbbc6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x46>
            selfData_.removeAt(offset, adsLen);
   bbbb2:	9901      	ldr	r1, [sp, #4]
   bbbb4:	4620      	mov	r0, r4
   bbbb6:	f7ff fcc7 	bl	bb548 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE8removeAtEii>
            CHECK_TRUE(selfData_.reserve(selfData_.size() + len + 2), selfData_.size());
   bbbba:	6861      	ldr	r1, [r4, #4]
   bbbbc:	4620      	mov	r0, r4
   bbbbe:	4431      	add	r1, r6
   bbbc0:	f7ff ff38 	bl	bba34 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reserveEi>
   bbbc4:	b918      	cbnz	r0, bbbce <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x4e>
    return selfData_.size();
   bbbc6:	6860      	ldr	r0, [r4, #4]
}
   bbbc8:	b003      	add	sp, #12
   bbbca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            selfData_.insert(offset, len + 1);
   bbbce:	1c6a      	adds	r2, r5, #1
   bbbd0:	9901      	ldr	r1, [sp, #4]
   bbbd2:	b2d2      	uxtb	r2, r2
   bbbd4:	4620      	mov	r0, r4
   bbbd6:	f7ff ffb5 	bl	bbb44 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0>
            selfData_.insert(offset + 1, static_cast<uint8_t>(type));
   bbbda:	9901      	ldr	r1, [sp, #4]
   bbbdc:	463a      	mov	r2, r7
   bbbde:	3101      	adds	r1, #1
   bbbe0:	4620      	mov	r0, r4
   bbbe2:	f7ff ffaf 	bl	bbb44 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEih.isra.0>
            selfData_.insert(offset + 2, buf, len);
   bbbe6:	9901      	ldr	r1, [sp, #4]
   bbbe8:	462b      	mov	r3, r5
   bbbea:	4642      	mov	r2, r8
   bbbec:	3102      	adds	r1, #2
    return insert(size_, values, n);
   bbbee:	4620      	mov	r0, r4
   bbbf0:	f7ff ff72 	bl	bbad8 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6insertEiPKhi>
   bbbf4:	e7e7      	b.n	bbbc6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x46>
    else if ((selfData_.size() + len + 2) <= BLE_MAX_ADV_DATA_LEN_EXT) {
   bbbf6:	18f1      	adds	r1, r6, r3
   bbbf8:	29ff      	cmp	r1, #255	; 0xff
   bbbfa:	d8e4      	bhi.n	bbbc6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x46>
        CHECK_TRUE(selfData_.reserve(selfData_.size() + len + 2), selfData_.size());
   bbbfc:	4620      	mov	r0, r4
   bbbfe:	f7ff ff19 	bl	bba34 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE7reserveEi>
   bbc02:	2800      	cmp	r0, #0
   bbc04:	d0df      	beq.n	bbbc6 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x46>
        selfData_.append(len + 1);
   bbc06:	1c69      	adds	r1, r5, #1
   bbc08:	b2c9      	uxtb	r1, r1
   bbc0a:	4620      	mov	r0, r4
   bbc0c:	f7ff ffb4 	bl	bbb78 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6appendEh.isra.0>
        selfData_.append(static_cast<uint8_t>(type));
   bbc10:	4639      	mov	r1, r7
   bbc12:	4620      	mov	r0, r4
   bbc14:	f7ff ffb0 	bl	bbb78 <_ZN5spark6VectorIhNS_16DefaultAllocatorEE6appendEh.isra.0>
   bbc18:	6861      	ldr	r1, [r4, #4]
   bbc1a:	462b      	mov	r3, r5
   bbc1c:	4642      	mov	r2, r8
   bbc1e:	e7e6      	b.n	bbbee <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0+0x6e>

000bbc20 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb>:
size_t BleAdvertisingData::append(BleAdvertisingDataType type, const uint8_t* buf, size_t len, bool force) {
   bbc20:	b430      	push	{r4, r5}
   bbc22:	f89d 5008 	ldrb.w	r5, [sp, #8]
    if (buf == nullptr) {
   bbc26:	b11a      	cbz	r2, bbc30 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb+0x10>
   bbc28:	9502      	str	r5, [sp, #8]
}
   bbc2a:	bc30      	pop	{r4, r5}
   bbc2c:	f7ff bfa8 	b.w	bbb80 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb.part.0>
        return selfData_.size();
   bbc30:	6840      	ldr	r0, [r0, #4]
}
   bbc32:	bc30      	pop	{r4, r5}
   bbc34:	4770      	bx	lr

000bbc36 <_ZN8particle18BleAdvertisingDataC1Ev>:
BleAdvertisingData::BleAdvertisingData()
   bbc36:	b51f      	push	{r0, r1, r2, r3, r4, lr}
        capacity_(0) {
   bbc38:	2300      	movs	r3, #0
   bbc3a:	e9c0 3300 	strd	r3, r3, [r0]
   bbc3e:	6083      	str	r3, [r0, #8]
    uint8_t flag = BLE_SIG_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
   bbc40:	2206      	movs	r2, #6
    append(BleAdvertisingDataType::FLAGS, &flag, sizeof(uint8_t));
   bbc42:	9300      	str	r3, [sp, #0]
   bbc44:	2301      	movs	r3, #1
    uint8_t flag = BLE_SIG_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;
   bbc46:	f88d 200f 	strb.w	r2, [sp, #15]
    append(BleAdvertisingDataType::FLAGS, &flag, sizeof(uint8_t));
   bbc4a:	4619      	mov	r1, r3
   bbc4c:	f10d 020f 	add.w	r2, sp, #15
BleAdvertisingData::BleAdvertisingData()
   bbc50:	4604      	mov	r4, r0
    append(BleAdvertisingDataType::FLAGS, &flag, sizeof(uint8_t));
   bbc52:	f7ff ffe5 	bl	bbc20 <_ZN8particle18BleAdvertisingData6appendENS_22BleAdvertisingDataTypeEPKhjb>
}
   bbc56:	4620      	mov	r0, r4
   bbc58:	b004      	add	sp, #16
   bbc5a:	bd10      	pop	{r4, pc}

000bbc5c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>:
        if (dest > p && dest < end) {
   bbc5c:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
   bbc5e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bbc60:	4604      	mov	r4, r0
   bbc62:	460d      	mov	r5, r1
   bbc64:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
   bbc66:	d914      	bls.n	bbc92 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x36>
   bbc68:	4290      	cmp	r0, r2
   bbc6a:	d213      	bcs.n	bbc94 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
            --end;
   bbc6c:	f1a2 0608 	sub.w	r6, r2, #8
            dest += end - p - 1;
   bbc70:	1a75      	subs	r5, r6, r1
   bbc72:	f1a1 0708 	sub.w	r7, r1, #8
   bbc76:	442c      	add	r4, r5
            for (; end != p; --end, --dest) {
   bbc78:	42b7      	cmp	r7, r6
   bbc7a:	d018      	beq.n	bbcae <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*end));
   bbc7c:	b11c      	cbz	r4, bbc86 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x2a>
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default; ///< Copy constructor
   bbc7e:	4631      	mov	r1, r6
   bbc80:	4620      	mov	r0, r4
   bbc82:	f7ff fcac 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
   bbc86:	1d30      	adds	r0, r6, #4
   bbc88:	f7ff fcb3 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; end != p; --end, --dest) {
   bbc8c:	3e08      	subs	r6, #8
   bbc8e:	3c08      	subs	r4, #8
   bbc90:	e7f2      	b.n	bbc78 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x1c>
        } else if (dest != p) {
   bbc92:	d00c      	beq.n	bbcae <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
            for (; p != end; ++p, ++dest) {
   bbc94:	42b5      	cmp	r5, r6
   bbc96:	d00a      	beq.n	bbcae <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*p));
   bbc98:	b11c      	cbz	r4, bbca2 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x46>
   bbc9a:	4629      	mov	r1, r5
   bbc9c:	4620      	mov	r0, r4
   bbc9e:	f7ff fc9e 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
   bbca2:	1d28      	adds	r0, r5, #4
   bbca4:	f7ff fca5 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; p != end; ++p, ++dest) {
   bbca8:	3508      	adds	r5, #8
   bbcaa:	3408      	adds	r4, #8
   bbcac:	e7f2      	b.n	bbc94 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
    }
   bbcae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bbcb0 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_>:
inline bool spark::Vector<T, AllocatorT>::append(T value) {
   bbcb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   bbcb2:	4604      	mov	r4, r0
    return insert(size_, std::move(value));
   bbcb4:	6846      	ldr	r6, [r0, #4]
   bbcb6:	4668      	mov	r0, sp
   bbcb8:	f7ff fc91 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bbcbc:	e9d4 7301 	ldrd	r7, r3, [r4, #4]
   bbcc0:	429f      	cmp	r7, r3
   bbcc2:	db12      	blt.n	bbcea <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x3a>
   bbcc4:	3701      	adds	r7, #1
        if (n > 0) {
   bbcc6:	2f00      	cmp	r7, #0
   bbcc8:	dd29      	ble.n	bbd1e <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x6e>
    return ::malloc(size);
   bbcca:	00f8      	lsls	r0, r7, #3
   bbccc:	f7fe fb8e 	bl	ba3ec <malloc>
            if (!d) {
   bbcd0:	4605      	mov	r5, r0
   bbcd2:	b1f0      	cbz	r0, bbd12 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x62>
            move(d, data_, data_ + size_);
   bbcd4:	e9d4 1200 	ldrd	r1, r2, [r4]
   bbcd8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   bbcdc:	f7ff ffbe 	bl	bbc5c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    ::free(ptr);
   bbce0:	6820      	ldr	r0, [r4, #0]
   bbce2:	f7fe fb8b 	bl	ba3fc <free>
        data_ = d;
   bbce6:	6025      	str	r5, [r4, #0]
        capacity_ = n;
   bbce8:	60a7      	str	r7, [r4, #8]
    T* const p = data_ + i;
   bbcea:	6823      	ldr	r3, [r4, #0]
    move(p + 1, p, data_ + size_);
   bbcec:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bbcee:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
    move(p + 1, p, data_ + size_);
   bbcf2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   bbcf6:	4631      	mov	r1, r6
   bbcf8:	f106 0008 	add.w	r0, r6, #8
   bbcfc:	f7ff ffae 	bl	bbc5c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    new(p) T(std::move(value));
   bbd00:	b11e      	cbz	r6, bbd0a <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x5a>
   bbd02:	4669      	mov	r1, sp
   bbd04:	4630      	mov	r0, r6
   bbd06:	f7ff fc6a 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
    ++size_;
   bbd0a:	6863      	ldr	r3, [r4, #4]
   bbd0c:	3301      	adds	r3, #1
   bbd0e:	6063      	str	r3, [r4, #4]
    return true;
   bbd10:	2501      	movs	r5, #1
   bbd12:	a801      	add	r0, sp, #4
   bbd14:	f7ff fc6d 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   bbd18:	4628      	mov	r0, r5
   bbd1a:	b003      	add	sp, #12
   bbd1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        T* d = nullptr;
   bbd1e:	2500      	movs	r5, #0
   bbd20:	e7de      	b.n	bbce0 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_+0x30>

000bbd22 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0>:
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
   bbd22:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    T* const p = find(data_, data_ + size_, value);
   bbd24:	e9d0 4300 	ldrd	r4, r3, [r0]
inline bool spark::Vector<T, AllocatorT>::removeOne(const T &value) {
   bbd28:	4605      	mov	r5, r0
   bbd2a:	460f      	mov	r7, r1
    T* const p = find(data_, data_ + size_, value);
   bbd2c:	eb04 06c3 	add.w	r6, r4, r3, lsl #3
        for (; p != end; ++p) {
   bbd30:	42a6      	cmp	r6, r4
   bbd32:	d005      	beq.n	bbd40 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0+0x1e>
            if (*p == value) {
   bbd34:	4639      	mov	r1, r7
   bbd36:	4620      	mov	r0, r4
   bbd38:	f7ff fa9d 	bl	bb276 <_ZNK8particle13BlePeerDeviceeqERKS0_>
   bbd3c:	b108      	cbz	r0, bbd42 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0+0x20>
    if (!p) {
   bbd3e:	b914      	cbnz	r4, bbd46 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0+0x24>
}
   bbd40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for (; p != end; ++p) {
   bbd42:	3408      	adds	r4, #8
   bbd44:	e7f4      	b.n	bbd30 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0+0xe>
   bbd46:	1d20      	adds	r0, r4, #4
   bbd48:	f7ff fc53 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    move(p, p + 1, data_ + size_);
   bbd4c:	e9d5 3200 	ldrd	r3, r2, [r5]
   bbd50:	f104 0108 	add.w	r1, r4, #8
   bbd54:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   bbd58:	4620      	mov	r0, r4
   bbd5a:	f7ff ff7f 	bl	bbc5c <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    --size_;
   bbd5e:	686b      	ldr	r3, [r5, #4]
   bbd60:	3b01      	subs	r3, #1
   bbd62:	606b      	str	r3, [r5, #4]
    return true;
   bbd64:	e7ec      	b.n	bbd40 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0+0x1e>
	...

000bbd68 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv>:
    static void onBleLinkEvents(const hal_ble_link_evt_t* event, void* context) {
   bbd68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   bbd6c:	4605      	mov	r5, r0
   bbd6e:	b08e      	sub	sp, #56	; 0x38
        WiringBleLock lk;
   bbd70:	a803      	add	r0, sp, #12
    static void onBleLinkEvents(const hal_ble_link_evt_t* event, void* context) {
   bbd72:	460c      	mov	r4, r1
        WiringBleLock lk;
   bbd74:	f7fe fef4 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        switch (event->type) {
   bbd78:	682e      	ldr	r6, [r5, #0]
   bbd7a:	1ef3      	subs	r3, r6, #3
   bbd7c:	2b0d      	cmp	r3, #13
   bbd7e:	d83c      	bhi.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
   bbd80:	e8df f013 	tbh	[pc, r3, lsl #1]
   bbd84:	0053000e 	.word	0x0053000e
   bbd88:	00d1003b 	.word	0x00d1003b
   bbd8c:	003b003b 	.word	0x003b003b
   bbd90:	003b003b 	.word	0x003b003b
   bbd94:	009b003b 	.word	0x009b003b
   bbd98:	009b009b 	.word	0x009b009b
   bbd9c:	009b009b 	.word	0x009b009b
                BlePeerDevice peer;
   bbda0:	a804      	add	r0, sp, #16
   bbda2:	f7ff fa0f 	bl	bb1c4 <_ZN8particle13BlePeerDeviceC1Ev>
                peer.impl()->connHandle() = event->conn_handle;
   bbda6:	9b04      	ldr	r3, [sp, #16]
   bbda8:	89aa      	ldrh	r2, [r5, #12]
   bbdaa:	801a      	strh	r2, [r3, #0]
                peer.impl()->address() = event->params.connected.info->address;
   bbdac:	6869      	ldr	r1, [r5, #4]
   bbdae:	9804      	ldr	r0, [sp, #16]
   bbdb0:	3108      	adds	r1, #8
   bbdb2:	3002      	adds	r0, #2
   bbdb4:	f7fe feee 	bl	bab94 <_ZN8particle10BleAddressaSERK14hal_ble_addr_t>
   bbdb8:	a904      	add	r1, sp, #16
   bbdba:	a806      	add	r0, sp, #24
   bbdbc:	f7ff fc0f 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
                if (!impl->peers_.append(peer)) {
   bbdc0:	a906      	add	r1, sp, #24
   bbdc2:	f104 0018 	add.w	r0, r4, #24
   bbdc6:	f7ff ff73 	bl	bbcb0 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_>
   bbdca:	4605      	mov	r5, r0
   bbdcc:	a807      	add	r0, sp, #28
   bbdce:	f7ff fc10 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bbdd2:	2320      	movs	r3, #32
                    LOG(ERROR, "Failed to append peer Central device.");
   bbdd4:	9306      	str	r3, [sp, #24]
                if (!impl->peers_.append(peer)) {
   bbdd6:	b9b5      	cbnz	r5, bbe06 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x9e>
                    LOG(ERROR, "Failed to append peer Central device.");
   bbdd8:	4b5d      	ldr	r3, [pc, #372]	; (bbf50 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1e8>)
   bbdda:	495e      	ldr	r1, [pc, #376]	; (bbf54 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1ec>)
   bbddc:	9300      	str	r3, [sp, #0]
   bbdde:	2032      	movs	r0, #50	; 0x32
   bbde0:	462b      	mov	r3, r5
   bbde2:	aa06      	add	r2, sp, #24
   bbde4:	9507      	str	r5, [sp, #28]
   bbde6:	f7fe fa15 	bl	ba214 <log_message>
                    hal_ble_gap_disconnect(peer.impl()->connHandle(), nullptr);
   bbdea:	9b04      	ldr	r3, [sp, #16]
   bbdec:	4629      	mov	r1, r5
   bbdee:	8818      	ldrh	r0, [r3, #0]
   bbdf0:	f7fe f810 	bl	b9e14 <hal_ble_gap_disconnect>
   bbdf4:	a805      	add	r0, sp, #20
   bbdf6:	f7ff fbfc 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        WiringBleLock lk;
   bbdfa:	a803      	add	r0, sp, #12
   bbdfc:	f7fe febe 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
    }
   bbe00:	b00e      	add	sp, #56	; 0x38
   bbe02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                LOG(TRACE, "Connected by Central device.");
   bbe06:	4a54      	ldr	r2, [pc, #336]	; (bbf58 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1f0>)
   bbe08:	9200      	str	r2, [sp, #0]
   bbe0a:	2300      	movs	r3, #0
   bbe0c:	4951      	ldr	r1, [pc, #324]	; (bbf54 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1ec>)
   bbe0e:	9307      	str	r3, [sp, #28]
   bbe10:	aa06      	add	r2, sp, #24
   bbe12:	2001      	movs	r0, #1
   bbe14:	f7fe f9fe 	bl	ba214 <log_message>
                if (impl->connectedCallback_) {
   bbe18:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   bbe1a:	2b00      	cmp	r3, #0
   bbe1c:	d0ea      	beq.n	bbdf4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x8c>
                    impl->connectedCallback_(peer);
   bbe1e:	a904      	add	r1, sp, #16
   bbe20:	f104 0024 	add.w	r0, r4, #36	; 0x24
   bbe24:	f7ff fc54 	bl	bb6d0 <_ZNKSt8functionIFvRKN8particle13BlePeerDeviceEEEclES3_>
   bbe28:	e7e4      	b.n	bbdf4 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x8c>
                BlePeerDevice* peer = impl->findPeerDevice(event->conn_handle);
   bbe2a:	89a9      	ldrh	r1, [r5, #12]
   bbe2c:	4620      	mov	r0, r4
   bbe2e:	f7ff f8dc 	bl	bafea <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>
                if (peer) {
   bbe32:	4606      	mov	r6, r0
   bbe34:	2800      	cmp	r0, #0
   bbe36:	d0e0      	beq.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
      { return _M_ptr; }
   bbe38:	6805      	ldr	r5, [r0, #0]
    return data_ + size_;
   bbe3a:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
        connHandle_ = BLE_INVALID_CONN_HANDLE;
   bbe3e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   bbe42:	8029      	strh	r1, [r5, #0]
   bbe44:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        for (auto& characteristic : characteristics()) {
   bbe48:	429a      	cmp	r2, r3
   bbe4a:	d003      	beq.n	bbe54 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xec>
   bbe4c:	f853 0b08 	ldr.w	r0, [r3], #8
            characteristic.impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
   bbe50:	8041      	strh	r1, [r0, #2]
        for (auto& characteristic : characteristics()) {
   bbe52:	e7f9      	b.n	bbe48 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xe0>
    destruct(data_, data_ + size_);
   bbe54:	e9d5 7303 	ldrd	r7, r3, [r5, #12]
   bbe58:	eb07 08c3 	add.w	r8, r7, r3, lsl #3
        for (; p != end; ++p) {
   bbe5c:	45b8      	cmp	r8, r7
   bbe5e:	d004      	beq.n	bbe6a <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x102>
      ~__shared_ptr() = default;
   bbe60:	1d38      	adds	r0, r7, #4
   bbe62:	f7ff fbc6 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bbe66:	3708      	adds	r7, #8
   bbe68:	e7f8      	b.n	bbe5c <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0xf4>
    size_ = 0;
   bbe6a:	2300      	movs	r3, #0
   bbe6c:	612b      	str	r3, [r5, #16]
    destruct(data_, data_ + size_);
   bbe6e:	e9d5 7306 	ldrd	r7, r3, [r5, #24]
   bbe72:	eb07 08c3 	add.w	r8, r7, r3, lsl #3
        for (; p != end; ++p) {
   bbe76:	45b8      	cmp	r8, r7
   bbe78:	d004      	beq.n	bbe84 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x11c>
   bbe7a:	1d38      	adds	r0, r7, #4
   bbe7c:	f7ff fbb9 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bbe80:	3708      	adds	r7, #8
   bbe82:	e7f8      	b.n	bbe76 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x10e>
    size_ = 0;
   bbe84:	2300      	movs	r3, #0
   bbe86:	61eb      	str	r3, [r5, #28]
        servicesDiscovered_ = false;
   bbe88:	72ab      	strb	r3, [r5, #10]
                    if (impl->disconnectedCallback_) {
   bbe8a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   bbe8c:	b123      	cbz	r3, bbe98 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x130>
                        impl->disconnectedCallback_(*peer);
   bbe8e:	4631      	mov	r1, r6
   bbe90:	f104 0034 	add.w	r0, r4, #52	; 0x34
   bbe94:	f7ff fc1c 	bl	bb6d0 <_ZNKSt8functionIFvRKN8particle13BlePeerDeviceEEEclES3_>
                    LOG(TRACE, "Disconnected by remote device.");
   bbe98:	2300      	movs	r3, #0
   bbe9a:	2220      	movs	r2, #32
   bbe9c:	e9cd 2306 	strd	r2, r3, [sp, #24]
   bbea0:	4a2e      	ldr	r2, [pc, #184]	; (bbf5c <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1f4>)
   bbea2:	9200      	str	r2, [sp, #0]
   bbea4:	492b      	ldr	r1, [pc, #172]	; (bbf54 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1ec>)
   bbea6:	aa06      	add	r2, sp, #24
   bbea8:	2001      	movs	r0, #1
   bbeaa:	f7fe f9b3 	bl	ba214 <log_message>
                    impl->peers_.removeOne(*peer);
   bbeae:	4631      	mov	r1, r6
   bbeb0:	f104 0018 	add.w	r0, r4, #24
   bbeb4:	f7ff ff35 	bl	bbd22 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0>
   bbeb8:	e79f      	b.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
                BlePeerDevice* peer = impl->findPeerDevice(event->conn_handle);
   bbeba:	89a9      	ldrh	r1, [r5, #12]
   bbebc:	4620      	mov	r0, r4
   bbebe:	f7ff f894 	bl	bafea <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>
                if (peer) {
   bbec2:	2800      	cmp	r0, #0
   bbec4:	d099      	beq.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
                    if (impl->pairingEventCallback_) {
   bbec6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   bbec8:	2b00      	cmp	r3, #0
   bbeca:	d096      	beq.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
                        BlePairingEventPayload payload = {};
   bbecc:	2300      	movs	r3, #0
                        if (event->type == BLE_EVT_PAIRING_PASSKEY_DISPLAY || event->type == BLE_EVT_PAIRING_NUMERIC_COMPARISON) {
   bbece:	2e0d      	cmp	r6, #13
                        BlePairingEventPayload payload = {};
   bbed0:	f8ad 3016 	strh.w	r3, [sp, #22]
                        if (event->type == BLE_EVT_PAIRING_PASSKEY_DISPLAY || event->type == BLE_EVT_PAIRING_NUMERIC_COMPARISON) {
   bbed4:	d001      	beq.n	bbeda <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x172>
   bbed6:	2e10      	cmp	r6, #16
   bbed8:	d117      	bne.n	bbf0a <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x1a2>
                        BlePairingEventPayload payload = {};
   bbeda:	2300      	movs	r3, #0
                            payload.passkey = event->params.passkey_display.passkey;
   bbedc:	6869      	ldr	r1, [r5, #4]
                        BlePairingEventPayload payload = {};
   bbede:	461a      	mov	r2, r3
                            payloadLen = BLE_PAIRING_PASSKEY_LEN;
   bbee0:	2506      	movs	r5, #6
                        };
   bbee2:	f88d 3015 	strb.w	r3, [sp, #21]
   bbee6:	9104      	str	r1, [sp, #16]
   bbee8:	f88d 2014 	strb.w	r2, [sp, #20]
   bbeec:	9006      	str	r0, [sp, #24]
   bbeee:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   bbef2:	ab09      	add	r3, sp, #36	; 0x24
                            .type = static_cast<BlePairingEventType>(event->type),
   bbef4:	f88d 601c 	strb.w	r6, [sp, #28]
                        };
   bbef8:	9508      	str	r5, [sp, #32]
   bbefa:	e883 0003 	stmia.w	r3, {r0, r1}
   bbefe:	6d23      	ldr	r3, [r4, #80]	; 0x50
   bbf00:	a906      	add	r1, sp, #24
   bbf02:	f104 0044 	add.w	r0, r4, #68	; 0x44
   bbf06:	4798      	blx	r3
   bbf08:	e777      	b.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
                        } else if (event->type == BLE_EVT_PAIRING_STATUS_UPDATED) {
   bbf0a:	2e0f      	cmp	r6, #15
                            payload.status.bonded = event->params.pairing_status.bonded;
   bbf0c:	bf01      	itttt	eq
   bbf0e:	7a2b      	ldrbeq	r3, [r5, #8]
                            payload.status.status = event->params.pairing_status.status;
   bbf10:	6869      	ldreq	r1, [r5, #4]
                            payload.status.bonded = event->params.pairing_status.bonded;
   bbf12:	f003 0201 	andeq.w	r2, r3, #1
                            payloadLen = sizeof(BlePairingStatus);
   bbf16:	2508      	moveq	r5, #8
                            payload.status.lesc = event->params.pairing_status.lesc;
   bbf18:	bf0f      	iteee	eq
   bbf1a:	f3c3 0340 	ubfxeq	r3, r3, #1, #1
                        BlePairingEventPayload payload = {};
   bbf1e:	461a      	movne	r2, r3
   bbf20:	4619      	movne	r1, r3
                        size_t payloadLen = 0;
   bbf22:	461d      	movne	r5, r3
   bbf24:	e7dd      	b.n	bbee2 <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x17a>
                BlePeerDevice* peer = impl->findPeerDevice(event->conn_handle);
   bbf26:	89a9      	ldrh	r1, [r5, #12]
   bbf28:	4620      	mov	r0, r4
   bbf2a:	f7ff f85e 	bl	bafea <_ZN8particle18BleLocalDeviceImpl14findPeerDeviceEt>
                if (peer && impl->attMtuExchangedCallback_) {
   bbf2e:	4601      	mov	r1, r0
   bbf30:	2800      	cmp	r0, #0
   bbf32:	f43f af62 	beq.w	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
   bbf36:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   bbf38:	2b00      	cmp	r3, #0
   bbf3a:	f43f af5e 	beq.w	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
                    impl->attMtuExchangedCallback_(*peer, event->params.att_mtu_updated.att_mtu_size);
   bbf3e:	686b      	ldr	r3, [r5, #4]
   bbf40:	9306      	str	r3, [sp, #24]
   bbf42:	aa06      	add	r2, sp, #24
   bbf44:	6e23      	ldr	r3, [r4, #96]	; 0x60
   bbf46:	f104 0054 	add.w	r0, r4, #84	; 0x54
   bbf4a:	4798      	blx	r3
   bbf4c:	e755      	b.n	bbdfa <_ZN8particle18BleLocalDeviceImpl15onBleLinkEventsEPK18hal_ble_link_evt_tPv+0x92>
   bbf4e:	bf00      	nop
   bbf50:	000c1e93 	.word	0x000c1e93
   bbf54:	000c1df7 	.word	0x000c1df7
   bbf58:	000c1eb9 	.word	0x000c1eb9
   bbf5c:	000c1ed6 	.word	0x000c1ed6

000bbf60 <_ZNK8particle13BlePeerDevice10disconnectEv>:
int BlePeerDevice::disconnect() const {
   bbf60:	b513      	push	{r0, r1, r4, lr}
   bbf62:	4604      	mov	r4, r0
    CHECK_TRUE(connected(), SYSTEM_ERROR_INVALID_STATE);
   bbf64:	f7ff f950 	bl	bb208 <_ZNK8particle13BlePeerDevice9connectedEv>
   bbf68:	b1d0      	cbz	r0, bbfa0 <_ZNK8particle13BlePeerDevice10disconnectEv+0x40>
    CHECK(hal_ble_gap_disconnect(impl()->connHandle(), nullptr));
   bbf6a:	6823      	ldr	r3, [r4, #0]
   bbf6c:	2100      	movs	r1, #0
   bbf6e:	8818      	ldrh	r0, [r3, #0]
   bbf70:	f7fd ff50 	bl	b9e14 <hal_ble_gap_disconnect>
   bbf74:	2800      	cmp	r0, #0
   bbf76:	db11      	blt.n	bbf9c <_ZNK8particle13BlePeerDevice10disconnectEv+0x3c>
        WiringBleLock lk;
   bbf78:	a801      	add	r0, sp, #4
   bbf7a:	f7fe fdf1 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        BleLocalDevice::getInstance().impl()->peers().removeOne(*this);
   bbf7e:	f7ff f9d1 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
        return peers_;
   bbf82:	6800      	ldr	r0, [r0, #0]
        BleLocalDevice::getInstance().impl()->peers().removeOne(*this);
   bbf84:	4621      	mov	r1, r4
   bbf86:	3018      	adds	r0, #24
   bbf88:	f7ff fecb 	bl	bbd22 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE9removeOneERKS2_.isra.0>
      { return _M_ptr; }
   bbf8c:	6823      	ldr	r3, [r4, #0]
        impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
   bbf8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   bbf92:	801a      	strh	r2, [r3, #0]
        WiringBleLock lk;
   bbf94:	a801      	add	r0, sp, #4
   bbf96:	f7fe fdf1 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
    return SYSTEM_ERROR_NONE;
   bbf9a:	2000      	movs	r0, #0
}
   bbf9c:	b002      	add	sp, #8
   bbf9e:	bd10      	pop	{r4, pc}
    CHECK_TRUE(connected(), SYSTEM_ERROR_INVALID_STATE);
   bbfa0:	f06f 00d1 	mvn.w	r0, #209	; 0xd1
   bbfa4:	e7fa      	b.n	bbf9c <_ZNK8particle13BlePeerDevice10disconnectEv+0x3c>

000bbfa6 <_ZNK8particle14BleLocalDevice10disconnectERKNS_13BlePeerDeviceE>:
    }
    return SYSTEM_ERROR_NOT_FOUND;
}

int BleLocalDevice::disconnect(const BlePeerDevice& peer) const {
    return peer.disconnect();
   bbfa6:	4608      	mov	r0, r1
   bbfa8:	f7ff bfda 	b.w	bbf60 <_ZNK8particle13BlePeerDevice10disconnectEv>

000bbfac <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>:
    bool realloc(int n) {
   bbfac:	b538      	push	{r3, r4, r5, lr}
        if (n > 0) {
   bbfae:	1e0d      	subs	r5, r1, #0
    bool realloc(int n) {
   bbfb0:	4604      	mov	r4, r0
            d = (T*)AllocatorT::realloc(data_, n * sizeof(T));
   bbfb2:	6800      	ldr	r0, [r0, #0]
        if (n > 0) {
   bbfb4:	dd05      	ble.n	bbfc2 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x16>
    return ::realloc(ptr, size);
   bbfb6:	2114      	movs	r1, #20
   bbfb8:	4369      	muls	r1, r5
   bbfba:	f7fe fa27 	bl	ba40c <realloc>
            if (!d) {
   bbfbe:	b918      	cbnz	r0, bbfc8 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x1c>
    }
   bbfc0:	bd38      	pop	{r3, r4, r5, pc}
    ::free(ptr);
   bbfc2:	f7fe fa1b 	bl	ba3fc <free>
        T* d = nullptr;
   bbfc6:	2000      	movs	r0, #0
        data_ = d;
   bbfc8:	6020      	str	r0, [r4, #0]
        capacity_ = n;
   bbfca:	60a5      	str	r5, [r4, #8]
        return true;
   bbfcc:	2001      	movs	r0, #1
   bbfce:	e7f7      	b.n	bbfc0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x14>

000bbfd0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bbfd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        capacity_(0) {
   bbfd4:	2400      	movs	r4, #0
   bbfd6:	e9c0 4400 	strd	r4, r4, [r0]
   bbfda:	6084      	str	r4, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bbfdc:	4688      	mov	r8, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bbfde:	6849      	ldr	r1, [r1, #4]
   bbfe0:	42a1      	cmp	r1, r4
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bbfe2:	4607      	mov	r7, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bbfe4:	dd1a      	ble.n	bc01c <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_+0x4c>
   bbfe6:	f7ff ffe1 	bl	bbfac <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bbfea:	b1b8      	cbz	r0, bc01c <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_+0x4c>
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bbfec:	e9d8 9300 	ldrd	r9, r3, [r8]
   bbff0:	f04f 0c14 	mov.w	ip, #20
   bbff4:	f8d7 e000 	ldr.w	lr, [r7]
   bbff8:	fb0c 9c03 	mla	ip, ip, r3, r9
        for (; it != end; ++it, ++dest) {
   bbffc:	eb09 0504 	add.w	r5, r9, r4
   bc000:	45ac      	cmp	ip, r5
   bc002:	d008      	beq.n	bc016 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_+0x46>
            new(dest) T(*it);
   bc004:	eb1e 0604 	adds.w	r6, lr, r4
   bc008:	bf1f      	itttt	ne
   bc00a:	cd0f      	ldmiane	r5!, {r0, r1, r2, r3}
   bc00c:	c60f      	stmiane	r6!, {r0, r1, r2, r3}
   bc00e:	682b      	ldrne	r3, [r5, #0]
   bc010:	6033      	strne	r3, [r6, #0]
        for (; it != end; ++it, ++dest) {
   bc012:	3414      	adds	r4, #20
   bc014:	e7f2      	b.n	bbffc <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_+0x2c>
        size_ = vector.size_;
   bc016:	f8d8 3004 	ldr.w	r3, [r8, #4]
   bc01a:	607b      	str	r3, [r7, #4]
}
   bc01c:	4638      	mov	r0, r7
   bc01e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>:
inline bool spark::Vector<T, AllocatorT>::append(const Vector<T, AllocatorT> &vector) {
   bc022:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    return insert(i, vector.data_, vector.size_);
   bc026:	e9d1 8700 	ldrd	r8, r7, [r1]
    return insert(size_, vector);
   bc02a:	6845      	ldr	r5, [r0, #4]
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bc02c:	6883      	ldr	r3, [r0, #8]
   bc02e:	19e9      	adds	r1, r5, r7
   bc030:	4299      	cmp	r1, r3
inline bool spark::Vector<T, AllocatorT>::append(const Vector<T, AllocatorT> &vector) {
   bc032:	4604      	mov	r4, r0
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bc034:	dc17      	bgt.n	bc066 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0+0x44>
    T* const p = data_ + i;
   bc036:	2314      	movs	r3, #20
   bc038:	6826      	ldr	r6, [r4, #0]
    move(p + n, p, data_ + size_);
   bc03a:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bc03c:	435d      	muls	r5, r3
    move(p + n, p, data_ + size_);
   bc03e:	fb03 f907 	mul.w	r9, r3, r7
   bc042:	435a      	muls	r2, r3
    T* const p = data_ + i;
   bc044:	442e      	add	r6, r5
        ::memmove(dest, p, (end - p) * sizeof(T));
   bc046:	1b52      	subs	r2, r2, r5
   bc048:	4631      	mov	r1, r6
   bc04a:	eb06 0009 	add.w	r0, r6, r9
   bc04e:	f002 ff3a 	bl	beec6 <memmove>
        ::memcpy(dest, p, (end - p) * sizeof(T));
   bc052:	464a      	mov	r2, r9
   bc054:	4641      	mov	r1, r8
   bc056:	4630      	mov	r0, r6
   bc058:	f002 ff27 	bl	beeaa <memcpy>
    size_ += n;
   bc05c:	6863      	ldr	r3, [r4, #4]
   bc05e:	443b      	add	r3, r7
   bc060:	6063      	str	r3, [r4, #4]
}
   bc062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (size_ + n > capacity_ && !realloc(size_ + n)) {
   bc066:	f7ff ffa1 	bl	bbfac <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc06a:	2800      	cmp	r0, #0
   bc06c:	d1e3      	bne.n	bc036 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0+0x14>
   bc06e:	e7f8      	b.n	bc062 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0+0x40>

000bc070 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0>:
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
   bc070:	b082      	sub	sp, #8
   bc072:	b570      	push	{r4, r5, r6, lr}
   bc074:	460c      	mov	r4, r1
   bc076:	a904      	add	r1, sp, #16
   bc078:	e881 000c 	stmia.w	r1, {r2, r3}
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc07c:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
   bc080:	4299      	cmp	r1, r3
inline bool spark::Vector<T, AllocatorT>::insert(int i, T value) {
   bc082:	4605      	mov	r5, r0
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc084:	da17      	bge.n	bc0b6 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0+0x46>
    T* const p = data_ + i;
   bc086:	2314      	movs	r3, #20
   bc088:	fb03 f104 	mul.w	r1, r3, r4
    move(p + 1, p, data_ + size_);
   bc08c:	686a      	ldr	r2, [r5, #4]
    T* const p = data_ + i;
   bc08e:	682c      	ldr	r4, [r5, #0]
    move(p + 1, p, data_ + size_);
   bc090:	435a      	muls	r2, r3
    T* const p = data_ + i;
   bc092:	440c      	add	r4, r1
        ::memmove(dest, p, (end - p) * sizeof(T));
   bc094:	1a52      	subs	r2, r2, r1
   bc096:	18e0      	adds	r0, r4, r3
   bc098:	4621      	mov	r1, r4
    new(p) T(std::move(value));
   bc09a:	ae04      	add	r6, sp, #16
        ::memmove(dest, p, (end - p) * sizeof(T));
   bc09c:	f002 ff13 	bl	beec6 <memmove>
    new(p) T(std::move(value));
   bc0a0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   bc0a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bc0a4:	6833      	ldr	r3, [r6, #0]
   bc0a6:	6023      	str	r3, [r4, #0]
    ++size_;
   bc0a8:	686b      	ldr	r3, [r5, #4]
   bc0aa:	3301      	adds	r3, #1
   bc0ac:	606b      	str	r3, [r5, #4]
}
   bc0ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   bc0b2:	b002      	add	sp, #8
   bc0b4:	4770      	bx	lr
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc0b6:	3101      	adds	r1, #1
   bc0b8:	f7ff ff78 	bl	bbfac <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc0bc:	2800      	cmp	r0, #0
   bc0be:	d1e2      	bne.n	bc086 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0+0x16>
   bc0c0:	e7f5      	b.n	bc0ae <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0+0x3e>

000bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>:
Vector<BleUuid> BleAdvertisingData::serviceUUID(BleAdvertisingDataType type) const {
   bc0c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        capacity_(0) {
   bc0c6:	2400      	movs	r4, #0
   bc0c8:	b093      	sub	sp, #76	; 0x4c
            if (type == BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE || type == BleAdvertisingDataType::SERVICE_UUID_16BIT_COMPLETE) {
   bc0ca:	1e93      	subs	r3, r2, #2
   bc0cc:	e9c0 4400 	strd	r4, r4, [r0]
   bc0d0:	b2db      	uxtb	r3, r3
Vector<BleUuid> BleAdvertisingData::serviceUUID(BleAdvertisingDataType type) const {
   bc0d2:	4605      	mov	r5, r0
   bc0d4:	460f      	mov	r7, r1
   bc0d6:	4690      	mov	r8, r2
   bc0d8:	6084      	str	r4, [r0, #8]
            if (type == BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE || type == BleAdvertisingDataType::SERVICE_UUID_16BIT_COMPLETE) {
   bc0da:	9305      	str	r3, [sp, #20]
    return size_;
   bc0dc:	6879      	ldr	r1, [r7, #4]
    for (int i = 0; i < selfData_.size(); i += (offset + adsLen)) {
   bc0de:	428c      	cmp	r4, r1
   bc0e0:	da72      	bge.n	bc1c8 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0x106>
    return data_[i];
   bc0e2:	6838      	ldr	r0, [r7, #0]
   bc0e4:	ab07      	add	r3, sp, #28
   bc0e6:	4642      	mov	r2, r8
   bc0e8:	1b09      	subs	r1, r1, r4
   bc0ea:	4420      	add	r0, r4
   bc0ec:	f7fe fc6a 	bl	ba9c4 <_ZN8particle18BleAdvertisingData6locateEPKhjNS_22BleAdvertisingDataTypeEPj.part.0>
        if (adsLen > 0) {
   bc0f0:	4606      	mov	r6, r0
   bc0f2:	2800      	cmp	r0, #0
   bc0f4:	d068      	beq.n	bc1c8 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0x106>
            if (type == BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE || type == BleAdvertisingDataType::SERVICE_UUID_16BIT_COMPLETE) {
   bc0f6:	9b05      	ldr	r3, [sp, #20]
   bc0f8:	2b01      	cmp	r3, #1
   bc0fa:	d82f      	bhi.n	bc15c <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0x9a>
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_16BIT_LEN); array++) {
   bc0fc:	f1a0 0b02 	sub.w	fp, r0, #2
   bc100:	ea4f 0b5b 	mov.w	fp, fp, lsr #1
   bc104:	f04f 0900 	mov.w	r9, #0
    return insert(size_, std::move(value));
   bc108:	f10d 0a3c 	add.w	sl, sp, #60	; 0x3c
                    BleUuid uuid = (uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 2] | ((uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 3] << 8);
   bc10c:	9b07      	ldr	r3, [sp, #28]
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_16BIT_LEN); array++) {
   bc10e:	45cb      	cmp	fp, r9
                    BleUuid uuid = (uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 2] | ((uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 3] << 8);
   bc110:	4423      	add	r3, r4
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_16BIT_LEN); array++) {
   bc112:	d055      	beq.n	bc1c0 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0xfe>
    return data_[i];
   bc114:	683a      	ldr	r2, [r7, #0]
                    BleUuid uuid = (uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 2] | ((uint16_t)selfData_[i + offset + array * BLE_SIG_UUID_16BIT_LEN + 3] << 8);
   bc116:	eb03 0349 	add.w	r3, r3, r9, lsl #1
   bc11a:	4413      	add	r3, r2
   bc11c:	a808      	add	r0, sp, #32
   bc11e:	78d9      	ldrb	r1, [r3, #3]
   bc120:	789b      	ldrb	r3, [r3, #2]
   bc122:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
   bc126:	f7fe fdb2 	bl	bac8e <_ZN8particle7BleUuidC1Et>
                    uuids.append(uuid);
   bc12a:	f10d 0e20 	add.w	lr, sp, #32
   bc12e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   bc132:	f10d 0c34 	add.w	ip, sp, #52	; 0x34
   bc136:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   bc13a:	f8de 3000 	ldr.w	r3, [lr]
   bc13e:	f8cc 3000 	str.w	r3, [ip]
    return insert(size_, std::move(value));
   bc142:	e89a 0007 	ldmia.w	sl, {r0, r1, r2}
   bc146:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   bc14a:	ab0d      	add	r3, sp, #52	; 0x34
   bc14c:	cb0c      	ldmia	r3, {r2, r3}
   bc14e:	6869      	ldr	r1, [r5, #4]
   bc150:	4628      	mov	r0, r5
   bc152:	f7ff ff8d 	bl	bc070 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0>
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_16BIT_LEN); array++) {
   bc156:	f109 0901 	add.w	r9, r9, #1
   bc15a:	e7d7      	b.n	bc10c <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0x4a>
            } else if (type == BleAdvertisingDataType::SERVICE_UUID_128BIT_MORE_AVAILABLE || type == BleAdvertisingDataType::SERVICE_UUID_128BIT_COMPLETE) {
   bc15c:	f1a8 0306 	sub.w	r3, r8, #6
   bc160:	2b01      	cmp	r3, #1
   bc162:	d82d      	bhi.n	bc1c0 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0xfe>
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_128BIT_LEN); array++) {
   bc164:	f1a0 0b02 	sub.w	fp, r0, #2
   bc168:	ea4f 1b1b 	mov.w	fp, fp, lsr #4
   bc16c:	f04f 0900 	mov.w	r9, #0
   bc170:	f10d 0a3c 	add.w	sl, sp, #60	; 0x3c
   bc174:	45cb      	cmp	fp, r9
                    BleUuid uuid = &selfData_[i + offset + array * BLE_SIG_UUID_128BIT_LEN + 2];
   bc176:	9b07      	ldr	r3, [sp, #28]
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_128BIT_LEN); array++) {
   bc178:	d022      	beq.n	bc1c0 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0xfe>
                    BleUuid uuid = &selfData_[i + offset + array * BLE_SIG_UUID_128BIT_LEN + 2];
   bc17a:	3302      	adds	r3, #2
    return data_[i];
   bc17c:	6839      	ldr	r1, [r7, #0]
   bc17e:	4423      	add	r3, r4
   bc180:	eb03 1309 	add.w	r3, r3, r9, lsl #4
   bc184:	2201      	movs	r2, #1
   bc186:	4419      	add	r1, r3
   bc188:	a808      	add	r0, sp, #32
   bc18a:	f7fe fd61 	bl	bac50 <_ZN8particle7BleUuidC1EPKhNS_12BleUuidOrderE>
                    uuids.append(uuid);
   bc18e:	f10d 0e20 	add.w	lr, sp, #32
   bc192:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   bc196:	f10d 0c34 	add.w	ip, sp, #52	; 0x34
   bc19a:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   bc19e:	f8de 3000 	ldr.w	r3, [lr]
   bc1a2:	f8cc 3000 	str.w	r3, [ip]
    return insert(size_, std::move(value));
   bc1a6:	e89a 0007 	ldmia.w	sl, {r0, r1, r2}
   bc1aa:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
   bc1ae:	e9dd 230d 	ldrd	r2, r3, [sp, #52]	; 0x34
   bc1b2:	6869      	ldr	r1, [r5, #4]
   bc1b4:	4628      	mov	r0, r5
   bc1b6:	f7ff ff5b 	bl	bc070 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6insertEiS2_.isra.0>
                for(size_t array = 0; (array < (adsLen - 2) / BLE_SIG_UUID_128BIT_LEN); array++) {
   bc1ba:	f109 0901 	add.w	r9, r9, #1
   bc1be:	e7d9      	b.n	bc174 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0xb2>
    for (int i = 0; i < selfData_.size(); i += (offset + adsLen)) {
   bc1c0:	9b07      	ldr	r3, [sp, #28]
   bc1c2:	441c      	add	r4, r3
   bc1c4:	4434      	add	r4, r6
   bc1c6:	e789      	b.n	bc0dc <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE+0x1a>
}
   bc1c8:	4628      	mov	r0, r5
   bc1ca:	b013      	add	sp, #76	; 0x4c
   bc1cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000bc1d0 <_ZNK8particle18BleAdvertisingData11serviceUUIDEv>:
Vector<BleUuid> BleAdvertisingData::serviceUUID() const {
   bc1d0:	b530      	push	{r4, r5, lr}
        capacity_(0) {
   bc1d2:	2300      	movs	r3, #0
   bc1d4:	b085      	sub	sp, #20
   bc1d6:	e9c0 3300 	strd	r3, r3, [r0]
   bc1da:	6083      	str	r3, [r0, #8]
   bc1dc:	4604      	mov	r4, r0
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE));
   bc1de:	2202      	movs	r2, #2
   bc1e0:	a801      	add	r0, sp, #4
Vector<BleUuid> BleAdvertisingData::serviceUUID() const {
   bc1e2:	460d      	mov	r5, r1
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE));
   bc1e4:	f7ff ff6d 	bl	bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>
   bc1e8:	a901      	add	r1, sp, #4
   bc1ea:	4620      	mov	r0, r4
   bc1ec:	f7ff ff19 	bl	bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>
   bc1f0:	a801      	add	r0, sp, #4
   bc1f2:	f7ff f95d 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_16BIT_MORE_AVAILABLE));
   bc1f6:	2202      	movs	r2, #2
   bc1f8:	4629      	mov	r1, r5
   bc1fa:	a801      	add	r0, sp, #4
   bc1fc:	f7ff ff61 	bl	bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>
   bc200:	a901      	add	r1, sp, #4
   bc202:	4620      	mov	r0, r4
   bc204:	f7ff ff0d 	bl	bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>
   bc208:	a801      	add	r0, sp, #4
   bc20a:	f7ff f951 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_16BIT_COMPLETE));
   bc20e:	2203      	movs	r2, #3
   bc210:	4629      	mov	r1, r5
   bc212:	a801      	add	r0, sp, #4
   bc214:	f7ff ff55 	bl	bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>
   bc218:	a901      	add	r1, sp, #4
   bc21a:	4620      	mov	r0, r4
   bc21c:	f7ff ff01 	bl	bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>
   bc220:	a801      	add	r0, sp, #4
   bc222:	f7ff f945 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_128BIT_MORE_AVAILABLE));
   bc226:	2206      	movs	r2, #6
   bc228:	4629      	mov	r1, r5
   bc22a:	a801      	add	r0, sp, #4
   bc22c:	f7ff ff49 	bl	bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>
   bc230:	a901      	add	r1, sp, #4
   bc232:	4620      	mov	r0, r4
   bc234:	f7ff fef5 	bl	bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>
   bc238:	a801      	add	r0, sp, #4
   bc23a:	f7ff f939 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
    foundUuids.append(serviceUUID(BleAdvertisingDataType::SERVICE_UUID_128BIT_COMPLETE));
   bc23e:	2207      	movs	r2, #7
   bc240:	4629      	mov	r1, r5
   bc242:	a801      	add	r0, sp, #4
   bc244:	f7ff ff3d 	bl	bc0c2 <_ZNK8particle18BleAdvertisingData11serviceUUIDENS_22BleAdvertisingDataTypeE>
   bc248:	a901      	add	r1, sp, #4
   bc24a:	4620      	mov	r0, r4
   bc24c:	f7ff fee9 	bl	bc022 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEE6appendERKS4_.isra.0>
   bc250:	a801      	add	r0, sp, #4
   bc252:	f7ff f92d 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
}
   bc256:	4620      	mov	r0, r4
   bc258:	b005      	add	sp, #20
   bc25a:	bd30      	pop	{r4, r5, pc}

000bc25c <_ZNK8particle18BleAdvertisingData11serviceUUIDEPNS_7BleUuidEj>:
size_t BleAdvertisingData::serviceUUID(BleUuid* uuids, size_t count) const {
   bc25c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bc260:	b085      	sub	sp, #20
   bc262:	4688      	mov	r8, r1
    const Vector<BleUuid>& foundUuids = serviceUUID();
   bc264:	4601      	mov	r1, r0
   bc266:	a801      	add	r0, sp, #4
size_t BleAdvertisingData::serviceUUID(BleUuid* uuids, size_t count) const {
   bc268:	4691      	mov	r9, r2
    const Vector<BleUuid>& foundUuids = serviceUUID();
   bc26a:	f7ff ffb1 	bl	bc1d0 <_ZNK8particle18BleAdvertisingData11serviceUUIDEv>
    return data_;
   bc26e:	9e01      	ldr	r6, [sp, #4]
    return data_ + size_;
   bc270:	9b02      	ldr	r3, [sp, #8]
   bc272:	f04f 0e14 	mov.w	lr, #20
   bc276:	fb0e 6c03 	mla	ip, lr, r3, r6
   bc27a:	2700      	movs	r7, #0
    for (const auto& uuid : foundUuids) {
   bc27c:	45b4      	cmp	ip, r6
   bc27e:	d00d      	beq.n	bc29c <_ZNK8particle18BleAdvertisingData11serviceUUIDEPNS_7BleUuidEj+0x40>
        if (found >= count) {
   bc280:	45b9      	cmp	r9, r7
   bc282:	f106 0614 	add.w	r6, r6, #20
   bc286:	d009      	beq.n	bc29c <_ZNK8particle18BleAdvertisingData11serviceUUIDEPNS_7BleUuidEj+0x40>
        uuids[found++] = uuid;
   bc288:	f1a6 0514 	sub.w	r5, r6, #20
   bc28c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   bc28e:	fb0e 8407 	mla	r4, lr, r7, r8
   bc292:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bc294:	682b      	ldr	r3, [r5, #0]
   bc296:	6023      	str	r3, [r4, #0]
    for (const auto& uuid : foundUuids) {
   bc298:	3701      	adds	r7, #1
   bc29a:	e7ef      	b.n	bc27c <_ZNK8particle18BleAdvertisingData11serviceUUIDEPNS_7BleUuidEj+0x20>
    const Vector<BleUuid>& foundUuids = serviceUUID();
   bc29c:	a801      	add	r0, sp, #4
   bc29e:	f7ff f907 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
}
   bc2a2:	4638      	mov	r0, r7
   bc2a4:	b005      	add	sp, #20
   bc2a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000bc2aa <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE>:
    bool filterByServiceUUID(const BleScanResult& result) {
   bc2aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   bc2ae:	b08b      	sub	sp, #44	; 0x2c
   bc2b0:	460c      	mov	r4, r1
        auto filterServiceUuids = filter_.serviceUUIDs();
   bc2b2:	f100 0144 	add.w	r1, r0, #68	; 0x44
   bc2b6:	a801      	add	r0, sp, #4
   bc2b8:	f7ff fe8a 	bl	bbfd0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEEC1ERKS4_>
        if (filterServiceUuids.size() > 0) {
   bc2bc:	9b02      	ldr	r3, [sp, #8]
   bc2be:	2b00      	cmp	r3, #0
   bc2c0:	dd4a      	ble.n	bc358 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0xae>
            const Vector<BleUuid>& srUuids = result.scanResponse().serviceUUID();
   bc2c2:	f104 0114 	add.w	r1, r4, #20
   bc2c6:	a804      	add	r0, sp, #16
   bc2c8:	f7ff ff82 	bl	bc1d0 <_ZNK8particle18BleAdvertisingData11serviceUUIDEv>
            const Vector<BleUuid>& advUuids = result.advertisingData().serviceUUID();
   bc2cc:	f104 0108 	add.w	r1, r4, #8
   bc2d0:	a807      	add	r0, sp, #28
   bc2d2:	f7ff ff7d 	bl	bc1d0 <_ZNK8particle18BleAdvertisingData11serviceUUIDEv>
    return size_;
   bc2d6:	9d05      	ldr	r5, [sp, #20]
   bc2d8:	9e08      	ldr	r6, [sp, #32]
            if (srUuids.size() <= 0 && advUuids.size() <= 0) {
   bc2da:	2d00      	cmp	r5, #0
   bc2dc:	dc01      	bgt.n	bc2e2 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x38>
   bc2de:	2e00      	cmp	r6, #0
   bc2e0:	dd38      	ble.n	bc354 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0xaa>
    return data_;
   bc2e2:	9a01      	ldr	r2, [sp, #4]
    return data_ + size_;
   bc2e4:	9f02      	ldr	r7, [sp, #8]
    return data_;
   bc2e6:	f8dd 8010 	ldr.w	r8, [sp, #16]
   bc2ea:	f8dd 901c 	ldr.w	r9, [sp, #28]
    return data_ + size_;
   bc2ee:	2314      	movs	r3, #20
   bc2f0:	fb03 2707 	mla	r7, r3, r7, r2
    return data_ + size_;
   bc2f4:	fb03 8505 	mla	r5, r3, r5, r8
   bc2f8:	fb03 9606 	mla	r6, r3, r6, r9
   bc2fc:	4692      	mov	sl, r2
            for (const auto& uuid : filterServiceUuids) {
   bc2fe:	45ba      	cmp	sl, r7
   bc300:	d028      	beq.n	bc354 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0xaa>
const T* spark::Vector<T, AllocatorT>::end() const {
   bc302:	46c3      	mov	fp, r8
                for (const auto& found : srUuids) {
   bc304:	45ab      	cmp	fp, r5
   bc306:	d015      	beq.n	bc334 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x8a>
                    if (uuid == found) {
   bc308:	4659      	mov	r1, fp
   bc30a:	4650      	mov	r0, sl
   bc30c:	f7fe fcc9 	bl	baca2 <_ZNK8particle7BleUuideqERKS0_>
   bc310:	f10b 0b14 	add.w	fp, fp, #20
   bc314:	4604      	mov	r4, r0
   bc316:	2800      	cmp	r0, #0
   bc318:	d0f4      	beq.n	bc304 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x5a>
            const Vector<BleUuid>& advUuids = result.advertisingData().serviceUUID();
   bc31a:	a807      	add	r0, sp, #28
   bc31c:	f7ff f8c8 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
            const Vector<BleUuid>& srUuids = result.scanResponse().serviceUUID();
   bc320:	a804      	add	r0, sp, #16
   bc322:	f7ff f8c5 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
        auto filterServiceUuids = filter_.serviceUUIDs();
   bc326:	a801      	add	r0, sp, #4
   bc328:	f7ff f8c2 	bl	bb4b0 <_ZN5spark6VectorIN8particle7BleUuidENS_16DefaultAllocatorEED1Ev>
    }
   bc32c:	4620      	mov	r0, r4
   bc32e:	b00b      	add	sp, #44	; 0x2c
   bc330:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   bc334:	46cb      	mov	fp, r9
                for (const auto& found : advUuids) {
   bc336:	45b3      	cmp	fp, r6
   bc338:	d009      	beq.n	bc34e <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0xa4>
                    if (uuid == found) {
   bc33a:	4659      	mov	r1, fp
   bc33c:	4650      	mov	r0, sl
   bc33e:	f7fe fcb0 	bl	baca2 <_ZNK8particle7BleUuideqERKS0_>
   bc342:	f10b 0b14 	add.w	fp, fp, #20
   bc346:	4604      	mov	r4, r0
   bc348:	2800      	cmp	r0, #0
   bc34a:	d0f4      	beq.n	bc336 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x8c>
   bc34c:	e7e5      	b.n	bc31a <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x70>
            for (const auto& uuid : filterServiceUuids) {
   bc34e:	f10a 0a14 	add.w	sl, sl, #20
   bc352:	e7d4      	b.n	bc2fe <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x54>
                return false;
   bc354:	2400      	movs	r4, #0
   bc356:	e7e0      	b.n	bc31a <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x70>
        return true;
   bc358:	2401      	movs	r4, #1
   bc35a:	e7e4      	b.n	bc326 <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE+0x7c>

000bc35c <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
    swap(_Tp& __a, _Tp& __b)
   bc35c:	b513      	push	{r0, r1, r4, lr}
   bc35e:	460b      	mov	r3, r1
   bc360:	4602      	mov	r2, r0
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bc362:	e9d0 0100 	ldrd	r0, r1, [r0]
   bc366:	466c      	mov	r4, sp
   bc368:	e884 0003 	stmia.w	r4, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
   bc36c:	e893 0003 	ldmia.w	r3, {r0, r1}
   bc370:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
   bc374:	e894 0003 	ldmia.w	r4, {r0, r1}
   bc378:	e883 0003 	stmia.w	r3, {r0, r1}
    }
   bc37c:	b002      	add	sp, #8
   bc37e:	bd10      	pop	{r4, pc}

000bc380 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEE4swapERS7_>:
      void swap(function& __x) noexcept
   bc380:	b538      	push	{r3, r4, r5, lr}
   bc382:	4605      	mov	r5, r0
   bc384:	460c      	mov	r4, r1
	std::swap(_M_functor, __x._M_functor);
   bc386:	f7ff ffe9 	bl	bc35c <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bc38a:	68ab      	ldr	r3, [r5, #8]
      __a = _GLIBCXX_MOVE(__b);
   bc38c:	68a2      	ldr	r2, [r4, #8]
   bc38e:	60aa      	str	r2, [r5, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   bc390:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bc392:	68eb      	ldr	r3, [r5, #12]
      __a = _GLIBCXX_MOVE(__b);
   bc394:	68e2      	ldr	r2, [r4, #12]
   bc396:	60ea      	str	r2, [r5, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   bc398:	60e3      	str	r3, [r4, #12]
      }
   bc39a:	bd38      	pop	{r3, r4, r5, pc}

000bc39c <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEaSERKS7_.isra.0>:
      operator=(const function& __x)
   bc39c:	b530      	push	{r4, r5, lr}
   bc39e:	b085      	sub	sp, #20
    _Function_base() : _M_manager(nullptr) { }
   bc3a0:	2300      	movs	r3, #0
   bc3a2:	9302      	str	r3, [sp, #8]
    bool _M_empty() const { return !_M_manager; }
   bc3a4:	688b      	ldr	r3, [r1, #8]
      operator=(const function& __x)
   bc3a6:	4605      	mov	r5, r0
   bc3a8:	460c      	mov	r4, r1
      if (static_cast<bool>(__x))
   bc3aa:	b133      	cbz	r3, bc3ba <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEaSERKS7_.isra.0+0x1e>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   bc3ac:	2202      	movs	r2, #2
   bc3ae:	4668      	mov	r0, sp
   bc3b0:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   bc3b2:	68e3      	ldr	r3, [r4, #12]
   bc3b4:	9303      	str	r3, [sp, #12]
	  _M_manager = __x._M_manager;
   bc3b6:	68a3      	ldr	r3, [r4, #8]
   bc3b8:	9302      	str	r3, [sp, #8]
	function(__x).swap(*this);
   bc3ba:	4629      	mov	r1, r5
   bc3bc:	4668      	mov	r0, sp
   bc3be:	f7ff ffdf 	bl	bc380 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEE4swapERS7_>
    class function<_Res(_ArgTypes...)>
   bc3c2:	4668      	mov	r0, sp
   bc3c4:	f7f8 f84c 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
      }
   bc3c8:	b005      	add	sp, #20
   bc3ca:	bd30      	pop	{r4, r5, pc}

000bc3cc <_ZN8particle17BleCharacteristicaSERKS0_>:
BleCharacteristic& BleCharacteristic::operator=(const BleCharacteristic& characteristic) {
   bc3cc:	b538      	push	{r3, r4, r5, lr}
   bc3ce:	460d      	mov	r5, r1
   bc3d0:	6801      	ldr	r1, [r0, #0]
        if (charImpl.dataReceivedCallback_) {
   bc3d2:	6d4b      	ldr	r3, [r1, #84]	; 0x54
BleCharacteristic& BleCharacteristic::operator=(const BleCharacteristic& characteristic) {
   bc3d4:	4604      	mov	r4, r0
        if (charImpl.dataReceivedCallback_) {
   bc3d6:	b123      	cbz	r3, bc3e2 <_ZN8particle17BleCharacteristicaSERKS0_+0x16>
            dataReceivedCallback_ = charImpl.dataReceivedCallback_;
   bc3d8:	6828      	ldr	r0, [r5, #0]
   bc3da:	314c      	adds	r1, #76	; 0x4c
   bc3dc:	304c      	adds	r0, #76	; 0x4c
   bc3de:	f7ff ffdd 	bl	bc39c <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEaSERKS7_.isra.0>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
   bc3e2:	4620      	mov	r0, r4
   bc3e4:	682b      	ldr	r3, [r5, #0]
   bc3e6:	f840 3b04 	str.w	r3, [r0], #4
   bc3ea:	6869      	ldr	r1, [r5, #4]
   bc3ec:	f7fe fb92 	bl	bab14 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0>
}
   bc3f0:	4620      	mov	r0, r4
   bc3f2:	bd38      	pop	{r3, r4, r5, pc}

000bc3f4 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE>:
bool BlePeerDevice::getCharacteristicByUUID(BleCharacteristic& characteristic, const BleUuid& uuid) const {
   bc3f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bc3f8:	4604      	mov	r4, r0
   bc3fa:	b087      	sub	sp, #28
    WiringBleLock lk;
   bc3fc:	4668      	mov	r0, sp
bool BlePeerDevice::getCharacteristicByUUID(BleCharacteristic& characteristic, const BleUuid& uuid) const {
   bc3fe:	460e      	mov	r6, r1
   bc400:	4617      	mov	r7, r2
    WiringBleLock lk;
   bc402:	f7fe fbad 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
      { return _M_ptr; }
   bc406:	6823      	ldr	r3, [r4, #0]
    return data_ + size_;
   bc408:	e9d3 4306 	ldrd	r4, r3, [r3, #24]
   bc40c:	eb04 08c3 	add.w	r8, r4, r3, lsl #3
    for (auto& existChar : impl()->characteristics()) {
   bc410:	4544      	cmp	r4, r8
   bc412:	46a1      	mov	r9, r4
   bc414:	d016      	beq.n	bc444 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE+0x50>
        if (existChar.UUID() == uuid) {
   bc416:	4621      	mov	r1, r4
   bc418:	a801      	add	r0, sp, #4
   bc41a:	f7fe fe11 	bl	bb040 <_ZNK8particle17BleCharacteristic4UUIDEv>
   bc41e:	4639      	mov	r1, r7
   bc420:	a801      	add	r0, sp, #4
   bc422:	f7fe fc3e 	bl	baca2 <_ZNK8particle7BleUuideqERKS0_>
   bc426:	3408      	adds	r4, #8
   bc428:	4605      	mov	r5, r0
   bc42a:	2800      	cmp	r0, #0
   bc42c:	d0f0      	beq.n	bc410 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE+0x1c>
            characteristic = existChar;
   bc42e:	4649      	mov	r1, r9
   bc430:	4630      	mov	r0, r6
   bc432:	f7ff ffcb 	bl	bc3cc <_ZN8particle17BleCharacteristicaSERKS0_>
    WiringBleLock lk;
   bc436:	4668      	mov	r0, sp
   bc438:	f7fe fba0 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bc43c:	4628      	mov	r0, r5
   bc43e:	b007      	add	sp, #28
   bc440:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return false;
   bc444:	2500      	movs	r5, #0
   bc446:	e7f6      	b.n	bc436 <_ZNK8particle13BlePeerDevice23getCharacteristicByUUIDERNS_17BleCharacteristicERKNS_7BleUuidE+0x42>

000bc448 <_ZN8particle17BleCharacteristic14onDataReceivedEPFvPKhjRKNS_13BlePeerDeviceEPvES6_>:
void BleCharacteristic::onDataReceived(BleOnDataReceivedCallback callback, void* context) {
   bc448:	b510      	push	{r4, lr}
        dataReceivedCallback_ = callback ? std::bind(callback, _1, _2, _3, context) : (BleOnDataReceivedStdFunction)nullptr;
   bc44a:	6804      	ldr	r4, [r0, #0]
void BleCharacteristic::onDataReceived(BleOnDataReceivedCallback callback, void* context) {
   bc44c:	b08a      	sub	sp, #40	; 0x28
        dataReceivedCallback_ = callback ? std::bind(callback, _1, _2, _3, context) : (BleOnDataReceivedStdFunction)nullptr;
   bc44e:	344c      	adds	r4, #76	; 0x4c
   bc450:	b1b9      	cbz	r1, bc482 <_ZN8particle17BleCharacteristic14onDataReceivedEPFvPKhjRKNS_13BlePeerDeviceEPvES6_+0x3a>
   bc452:	e9cd 1200 	strd	r1, r2, [sp]
   bc456:	a802      	add	r0, sp, #8
   bc458:	4669      	mov	r1, sp
   bc45a:	f7ff f889 	bl	bb570 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEEC1ISt5_BindIFPFvS1_jS5_PvESt12_PlaceholderILi1EESD_ILi2EESD_ILi3EESA_EEvvEET_>
    _Function_base() : _M_manager(nullptr) { }
   bc45e:	2300      	movs	r3, #0
	__x.swap(*this);
   bc460:	a906      	add	r1, sp, #24
   bc462:	a802      	add	r0, sp, #8
    _Function_base() : _M_manager(nullptr) { }
   bc464:	9308      	str	r3, [sp, #32]
	__x.swap(*this);
   bc466:	f7ff ff8b 	bl	bc380 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEE4swapERS7_>
	function(std::move(__x)).swap(*this);
   bc46a:	4621      	mov	r1, r4
   bc46c:	a806      	add	r0, sp, #24
   bc46e:	f7ff ff87 	bl	bc380 <_ZNSt8functionIFvPKhjRKN8particle13BlePeerDeviceEEE4swapERS7_>
    class function<_Res(_ArgTypes...)>
   bc472:	a806      	add	r0, sp, #24
   bc474:	f7f7 fff4 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bc478:	a802      	add	r0, sp, #8
   bc47a:	f7f7 fff1 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
}
   bc47e:	b00a      	add	sp, #40	; 0x28
   bc480:	bd10      	pop	{r4, pc}
    _Function_base() : _M_manager(nullptr) { }
   bc482:	9104      	str	r1, [sp, #16]
      : _Function_base() { }
   bc484:	e7eb      	b.n	bc45e <_ZN8particle17BleCharacteristic14onDataReceivedEPFvPKhjRKNS_13BlePeerDeviceEPvES6_+0x16>

000bc486 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>:
        if (dest > p && dest < end) {
   bc486:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
   bc488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bc48a:	4604      	mov	r4, r0
   bc48c:	460d      	mov	r5, r1
   bc48e:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
   bc490:	d914      	bls.n	bc4bc <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x36>
   bc492:	4290      	cmp	r0, r2
   bc494:	d213      	bcs.n	bc4be <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
            --end;
   bc496:	f1a2 0608 	sub.w	r6, r2, #8
            dest += end - p - 1;
   bc49a:	1a75      	subs	r5, r6, r1
   bc49c:	f1a1 0708 	sub.w	r7, r1, #8
   bc4a0:	442c      	add	r4, r5
            for (; end != p; --end, --dest) {
   bc4a2:	42b7      	cmp	r7, r6
   bc4a4:	d018      	beq.n	bc4d8 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*end));
   bc4a6:	b11c      	cbz	r4, bc4b0 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x2a>
   bc4a8:	4631      	mov	r1, r6
   bc4aa:	4620      	mov	r0, r4
   bc4ac:	f7ff f88d 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
      ~__shared_ptr() = default;
   bc4b0:	1d30      	adds	r0, r6, #4
   bc4b2:	f7ff f89e 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; end != p; --end, --dest) {
   bc4b6:	3e08      	subs	r6, #8
   bc4b8:	3c08      	subs	r4, #8
   bc4ba:	e7f2      	b.n	bc4a2 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x1c>
        } else if (dest != p) {
   bc4bc:	d00c      	beq.n	bc4d8 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
            for (; p != end; ++p, ++dest) {
   bc4be:	42b5      	cmp	r5, r6
   bc4c0:	d00a      	beq.n	bc4d8 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*p));
   bc4c2:	b11c      	cbz	r4, bc4cc <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x46>
   bc4c4:	4629      	mov	r1, r5
   bc4c6:	4620      	mov	r0, r4
   bc4c8:	f7ff f87f 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
   bc4cc:	1d28      	adds	r0, r5, #4
   bc4ce:	f7ff f890 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; p != end; ++p, ++dest) {
   bc4d2:	3508      	adds	r5, #8
   bc4d4:	3408      	adds	r4, #8
   bc4d6:	e7f2      	b.n	bc4be <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
    }
   bc4d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bc4da <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>:
    bool realloc(int n) {
   bc4da:	b570      	push	{r4, r5, r6, lr}
        if (n > 0) {
   bc4dc:	1e0e      	subs	r6, r1, #0
    bool realloc(int n) {
   bc4de:	4605      	mov	r5, r0
        if (n > 0) {
   bc4e0:	dd11      	ble.n	bc506 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x2c>
    return ::malloc(size);
   bc4e2:	00f0      	lsls	r0, r6, #3
   bc4e4:	f7fd ff82 	bl	ba3ec <malloc>
            if (!d) {
   bc4e8:	4604      	mov	r4, r0
   bc4ea:	b158      	cbz	r0, bc504 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x2a>
            move(d, data_, data_ + size_);
   bc4ec:	e9d5 1200 	ldrd	r1, r2, [r5]
   bc4f0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   bc4f4:	f7ff ffc7 	bl	bc486 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    ::free(ptr);
   bc4f8:	6828      	ldr	r0, [r5, #0]
   bc4fa:	f7fd ff7f 	bl	ba3fc <free>
        data_ = d;
   bc4fe:	602c      	str	r4, [r5, #0]
        capacity_ = n;
   bc500:	60ae      	str	r6, [r5, #8]
        return true;
   bc502:	2001      	movs	r0, #1
    }
   bc504:	bd70      	pop	{r4, r5, r6, pc}
        T* d = nullptr;
   bc506:	2400      	movs	r4, #0
   bc508:	e7f6      	b.n	bc4f8 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x1e>

000bc50a <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc50a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        capacity_(0) {
   bc50e:	2300      	movs	r3, #0
   bc510:	e9c0 3300 	strd	r3, r3, [r0]
   bc514:	6083      	str	r3, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc516:	460d      	mov	r5, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bc518:	6849      	ldr	r1, [r1, #4]
   bc51a:	4299      	cmp	r1, r3
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc51c:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bc51e:	dd13      	ble.n	bc548 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_+0x3e>
   bc520:	f7ff ffdb 	bl	bc4da <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc524:	b180      	cbz	r0, bc548 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_+0x3e>
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bc526:	e9d5 6300 	ldrd	r6, r3, [r5]
   bc52a:	6827      	ldr	r7, [r4, #0]
   bc52c:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
        for (; it != end; ++it, ++dest) {
   bc530:	45b0      	cmp	r8, r6
   bc532:	d007      	beq.n	bc544 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_+0x3a>
            new(dest) T(*it);
   bc534:	b11f      	cbz	r7, bc53e <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_+0x34>
   bc536:	4631      	mov	r1, r6
   bc538:	4638      	mov	r0, r7
   bc53a:	f7ff f846 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
        for (; it != end; ++it, ++dest) {
   bc53e:	3608      	adds	r6, #8
   bc540:	3708      	adds	r7, #8
   bc542:	e7f5      	b.n	bc530 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_+0x26>
        size_ = vector.size_;
   bc544:	686b      	ldr	r3, [r5, #4]
   bc546:	6063      	str	r3, [r4, #4]
}
   bc548:	4620      	mov	r0, r4
   bc54a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000bc54e <_ZNK8particle13BlePeerDevice8servicesEv>:
Vector<BleService> BlePeerDevice::services() const {
   bc54e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   bc550:	460d      	mov	r5, r1
   bc552:	4604      	mov	r4, r0
    WiringBleLock lk;
   bc554:	a801      	add	r0, sp, #4
   bc556:	f7fe fb03 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        return services_;
   bc55a:	6829      	ldr	r1, [r5, #0]
    return impl()->services();
   bc55c:	4620      	mov	r0, r4
   bc55e:	310c      	adds	r1, #12
   bc560:	f7ff ffd3 	bl	bc50a <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEEC1ERKS4_>
    WiringBleLock lk;
   bc564:	a801      	add	r0, sp, #4
   bc566:	f7fe fb09 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bc56a:	4620      	mov	r0, r4
   bc56c:	b003      	add	sp, #12
   bc56e:	bd30      	pop	{r4, r5, pc}

000bc570 <_ZN8particle13BlePeerDevice19discoverAllServicesEv>:
Vector<BleService> BlePeerDevice::discoverAllServices() {
   bc570:	b538      	push	{r3, r4, r5, lr}
        return servicesDiscovered_;
   bc572:	680b      	ldr	r3, [r1, #0]
    if (!impl()->servicesDiscovered()) {
   bc574:	7a9b      	ldrb	r3, [r3, #10]
Vector<BleService> BlePeerDevice::discoverAllServices() {
   bc576:	4605      	mov	r5, r0
   bc578:	460c      	mov	r4, r1
    if (!impl()->servicesDiscovered()) {
   bc57a:	b933      	cbnz	r3, bc58a <_ZN8particle13BlePeerDevice19discoverAllServicesEv+0x1a>
        if (discovery.discoverAllServices(*this) == SYSTEM_ERROR_NONE) {
   bc57c:	4608      	mov	r0, r1
   bc57e:	f7fe fa83 	bl	baa88 <_ZN8particle21BleDiscoveryDelegator19discoverAllServicesERNS_13BlePeerDeviceE.isra.0>
   bc582:	b910      	cbnz	r0, bc58a <_ZN8particle13BlePeerDevice19discoverAllServicesEv+0x1a>
      { return _M_ptr; }
   bc584:	6823      	ldr	r3, [r4, #0]
        servicesDiscovered_ = discovered;
   bc586:	2201      	movs	r2, #1
   bc588:	729a      	strb	r2, [r3, #10]
    return services();
   bc58a:	4628      	mov	r0, r5
   bc58c:	4621      	mov	r1, r4
   bc58e:	f7ff ffde 	bl	bc54e <_ZNK8particle13BlePeerDevice8servicesEv>
}
   bc592:	4628      	mov	r0, r5
   bc594:	bd38      	pop	{r3, r4, r5, pc}

000bc596 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_>:
inline bool spark::Vector<T, AllocatorT>::append(T value) {
   bc596:	b573      	push	{r0, r1, r4, r5, r6, lr}
   bc598:	4604      	mov	r4, r0
    return insert(size_, std::move(value));
   bc59a:	6845      	ldr	r5, [r0, #4]
   bc59c:	4668      	mov	r0, sp
   bc59e:	f7ff f814 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc5a2:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   bc5a6:	4299      	cmp	r1, r3
   bc5a8:	da10      	bge.n	bc5cc <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_+0x36>
    T* const p = data_ + i;
   bc5aa:	6823      	ldr	r3, [r4, #0]
    move(p + 1, p, data_ + size_);
   bc5ac:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bc5ae:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    move(p + 1, p, data_ + size_);
   bc5b2:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   bc5b6:	4629      	mov	r1, r5
   bc5b8:	f105 0008 	add.w	r0, r5, #8
   bc5bc:	f7ff ff63 	bl	bc486 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    new(p) T(std::move(value));
   bc5c0:	b98d      	cbnz	r5, bc5e6 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_+0x50>
    ++size_;
   bc5c2:	6863      	ldr	r3, [r4, #4]
   bc5c4:	3301      	adds	r3, #1
   bc5c6:	6063      	str	r3, [r4, #4]
    return true;
   bc5c8:	2601      	movs	r6, #1
   bc5ca:	e006      	b.n	bc5da <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_+0x44>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc5cc:	3101      	adds	r1, #1
   bc5ce:	4620      	mov	r0, r4
   bc5d0:	f7ff ff83 	bl	bc4da <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc5d4:	4606      	mov	r6, r0
   bc5d6:	2800      	cmp	r0, #0
   bc5d8:	d1e7      	bne.n	bc5aa <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_+0x14>
      ~__shared_ptr() = default;
   bc5da:	a801      	add	r0, sp, #4
   bc5dc:	f7ff f809 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   bc5e0:	4630      	mov	r0, r6
   bc5e2:	b002      	add	sp, #8
   bc5e4:	bd70      	pop	{r4, r5, r6, pc}
   bc5e6:	4669      	mov	r1, sp
   bc5e8:	4628      	mov	r0, r5
   bc5ea:	f7fe ffee 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
   bc5ee:	e7e8      	b.n	bc5c2 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_+0x2c>

000bc5f0 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv>:
    static void onServicesDiscovered(const hal_ble_svc_discovered_evt_t* event, void* context) {
   bc5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                LOG(ERROR, "Failed to append discovered service.");
   bc5f4:	f8df 90b8 	ldr.w	r9, [pc, #184]	; bc6b0 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0xc0>
   bc5f8:	f8df a0b8 	ldr.w	sl, [pc, #184]	; bc6b4 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0xc4>
    static void onServicesDiscovered(const hal_ble_svc_discovered_evt_t* event, void* context) {
   bc5fc:	b093      	sub	sp, #76	; 0x4c
   bc5fe:	4605      	mov	r5, r0
   bc600:	4688      	mov	r8, r1
        for (size_t i = 0; i < event->count; i++) {
   bc602:	2700      	movs	r7, #0
   bc604:	682b      	ldr	r3, [r5, #0]
   bc606:	42bb      	cmp	r3, r7
   bc608:	d94e      	bls.n	bc6a8 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0xb8>
            BleService service;
   bc60a:	a803      	add	r0, sp, #12
   bc60c:	f7fe fdbe 	bl	bb18c <_ZN8particle10BleServiceC1Ev>
      get() const noexcept
   bc610:	261c      	movs	r6, #28
   bc612:	686a      	ldr	r2, [r5, #4]
      { return _M_ptr; }
   bc614:	9c03      	ldr	r4, [sp, #12]
        return uuid_;
   bc616:	437e      	muls	r6, r7
   bc618:	4432      	add	r2, r6
   bc61a:	f10d 0c14 	add.w	ip, sp, #20
   bc61e:	1d13      	adds	r3, r2, #4
   bc620:	46e3      	mov	fp, ip
   bc622:	3214      	adds	r2, #20
   bc624:	6818      	ldr	r0, [r3, #0]
   bc626:	6859      	ldr	r1, [r3, #4]
   bc628:	46e6      	mov	lr, ip
   bc62a:	e8ae 0003 	stmia.w	lr!, {r0, r1}
   bc62e:	3308      	adds	r3, #8
   bc630:	4293      	cmp	r3, r2
   bc632:	46f4      	mov	ip, lr
   bc634:	d1f6      	bne.n	bc624 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0x34>
   bc636:	6818      	ldr	r0, [r3, #0]
   bc638:	f8ce 0000 	str.w	r0, [lr]
        return *this = BleUuid(uuid);
   bc63c:	4659      	mov	r1, fp
   bc63e:	a80a      	add	r0, sp, #40	; 0x28
   bc640:	f7fe fae4 	bl	bac0c <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t>
   bc644:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
   bc648:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   bc64c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bc64e:	f8dc 3000 	ldr.w	r3, [ip]
   bc652:	6023      	str	r3, [r4, #0]
            service.impl()->startHandle() = event->services[i].start_handle;
   bc654:	686b      	ldr	r3, [r5, #4]
   bc656:	9a03      	ldr	r2, [sp, #12]
   bc658:	4433      	add	r3, r6
   bc65a:	a903      	add	r1, sp, #12
   bc65c:	8b1b      	ldrh	r3, [r3, #24]
   bc65e:	8293      	strh	r3, [r2, #20]
            service.impl()->endHandle() = event->services[i].end_handle;
   bc660:	686b      	ldr	r3, [r5, #4]
   bc662:	4433      	add	r3, r6
   bc664:	8b5b      	ldrh	r3, [r3, #26]
   bc666:	82d3      	strh	r3, [r2, #22]
        return services_;
   bc668:	f8d8 0000 	ldr.w	r0, [r8]
   bc66c:	f100 040c 	add.w	r4, r0, #12
   bc670:	a80a      	add	r0, sp, #40	; 0x28
   bc672:	f7fe ffaa 	bl	bb5ca <_ZNSt12__shared_ptrIN8particle14BleServiceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
            if (!peer->impl()->services().append(service)) {
   bc676:	4620      	mov	r0, r4
   bc678:	a90a      	add	r1, sp, #40	; 0x28
   bc67a:	f7ff ff8c 	bl	bc596 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEE6appendES2_>
   bc67e:	4604      	mov	r4, r0
      ~__shared_ptr() = default;
   bc680:	a80b      	add	r0, sp, #44	; 0x2c
   bc682:	f7fe ffb6 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bc686:	b954      	cbnz	r4, bc69e <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0xae>
                LOG(ERROR, "Failed to append discovered service.");
   bc688:	2320      	movs	r3, #32
   bc68a:	e9cd 340a 	strd	r3, r4, [sp, #40]	; 0x28
   bc68e:	f8cd 9000 	str.w	r9, [sp]
   bc692:	4623      	mov	r3, r4
   bc694:	aa0a      	add	r2, sp, #40	; 0x28
   bc696:	4651      	mov	r1, sl
   bc698:	2032      	movs	r0, #50	; 0x32
   bc69a:	f7fd fdbb 	bl	ba214 <log_message>
   bc69e:	a804      	add	r0, sp, #16
   bc6a0:	f7fe ffa7 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        for (size_t i = 0; i < event->count; i++) {
   bc6a4:	3701      	adds	r7, #1
   bc6a6:	e7ad      	b.n	bc604 <_ZN8particle21BleDiscoveryDelegator20onServicesDiscoveredEPK28hal_ble_svc_discovered_evt_tPv+0x14>
    }
   bc6a8:	b013      	add	sp, #76	; 0x4c
   bc6aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   bc6ae:	bf00      	nop
   bc6b0:	000c1ef5 	.word	0x000c1ef5
   bc6b4:	000c1df7 	.word	0x000c1df7

000bc6b8 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>:
        if (dest > p && dest < end) {
   bc6b8:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
   bc6ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bc6bc:	4604      	mov	r4, r0
   bc6be:	460d      	mov	r5, r1
   bc6c0:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
   bc6c2:	d914      	bls.n	bc6ee <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x36>
   bc6c4:	4290      	cmp	r0, r2
   bc6c6:	d213      	bcs.n	bc6f0 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
            --end;
   bc6c8:	f1a2 0608 	sub.w	r6, r2, #8
            dest += end - p - 1;
   bc6cc:	1a75      	subs	r5, r6, r1
   bc6ce:	f1a1 0708 	sub.w	r7, r1, #8
   bc6d2:	442c      	add	r4, r5
            for (; end != p; --end, --dest) {
   bc6d4:	42b7      	cmp	r7, r6
   bc6d6:	d018      	beq.n	bc70a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*end));
   bc6d8:	b11c      	cbz	r4, bc6e2 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x2a>
   bc6da:	4631      	mov	r1, r6
   bc6dc:	4620      	mov	r0, r4
   bc6de:	f7fe ff66 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
   bc6e2:	1d30      	adds	r0, r6, #4
   bc6e4:	f7fe ff85 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; end != p; --end, --dest) {
   bc6e8:	3e08      	subs	r6, #8
   bc6ea:	3c08      	subs	r4, #8
   bc6ec:	e7f2      	b.n	bc6d4 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x1c>
        } else if (dest != p) {
   bc6ee:	d00c      	beq.n	bc70a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
            for (; p != end; ++p, ++dest) {
   bc6f0:	42b5      	cmp	r5, r6
   bc6f2:	d00a      	beq.n	bc70a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*p));
   bc6f4:	b11c      	cbz	r4, bc6fe <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x46>
   bc6f6:	4629      	mov	r1, r5
   bc6f8:	4620      	mov	r0, r4
   bc6fa:	f7fe ff58 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
   bc6fe:	1d28      	adds	r0, r5, #4
   bc700:	f7fe ff77 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
            for (; p != end; ++p, ++dest) {
   bc704:	3508      	adds	r5, #8
   bc706:	3408      	adds	r4, #8
   bc708:	e7f2      	b.n	bc6f0 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
    }
   bc70a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bc70c <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>:
    bool realloc(int n) {
   bc70c:	b570      	push	{r4, r5, r6, lr}
        if (n > 0) {
   bc70e:	1e0e      	subs	r6, r1, #0
    bool realloc(int n) {
   bc710:	4605      	mov	r5, r0
        if (n > 0) {
   bc712:	dd11      	ble.n	bc738 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x2c>
    return ::malloc(size);
   bc714:	00f0      	lsls	r0, r6, #3
   bc716:	f7fd fe69 	bl	ba3ec <malloc>
            if (!d) {
   bc71a:	4604      	mov	r4, r0
   bc71c:	b158      	cbz	r0, bc736 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x2a>
            move(d, data_, data_ + size_);
   bc71e:	e9d5 1200 	ldrd	r1, r2, [r5]
   bc722:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   bc726:	f7ff ffc7 	bl	bc6b8 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    ::free(ptr);
   bc72a:	6828      	ldr	r0, [r5, #0]
   bc72c:	f7fd fe66 	bl	ba3fc <free>
        data_ = d;
   bc730:	602c      	str	r4, [r5, #0]
        capacity_ = n;
   bc732:	60ae      	str	r6, [r5, #8]
        return true;
   bc734:	2001      	movs	r0, #1
    }
   bc736:	bd70      	pop	{r4, r5, r6, pc}
        T* d = nullptr;
   bc738:	2400      	movs	r4, #0
   bc73a:	e7f6      	b.n	bc72a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x1e>

000bc73c <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_>:
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc73c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        capacity_(0) {
   bc740:	2300      	movs	r3, #0
   bc742:	e9c0 3300 	strd	r3, r3, [r0]
   bc746:	6083      	str	r3, [r0, #8]
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc748:	460d      	mov	r5, r1
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bc74a:	6849      	ldr	r1, [r1, #4]
   bc74c:	4299      	cmp	r1, r3
inline spark::Vector<T, AllocatorT>::Vector(const Vector<T, AllocatorT>& vector) : Vector() {
   bc74e:	4604      	mov	r4, r0
    if (vector.size_ > 0 && realloc(vector.size_)) {
   bc750:	dd13      	ble.n	bc77a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_+0x3e>
   bc752:	f7ff ffdb 	bl	bc70c <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc756:	b180      	cbz	r0, bc77a <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_+0x3e>
        copy(data_, vector.data_, vector.data_ + vector.size_);
   bc758:	e9d5 6300 	ldrd	r6, r3, [r5]
   bc75c:	6827      	ldr	r7, [r4, #0]
   bc75e:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
        for (; it != end; ++it, ++dest) {
   bc762:	45b0      	cmp	r8, r6
   bc764:	d007      	beq.n	bc776 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_+0x3a>
            new(dest) T(*it);
   bc766:	b11f      	cbz	r7, bc770 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_+0x34>
   bc768:	4631      	mov	r1, r6
   bc76a:	4638      	mov	r0, r7
   bc76c:	f7fe ff1f 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
        for (; it != end; ++it, ++dest) {
   bc770:	3608      	adds	r6, #8
   bc772:	3708      	adds	r7, #8
   bc774:	e7f5      	b.n	bc762 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_+0x26>
        size_ = vector.size_;
   bc776:	686b      	ldr	r3, [r5, #4]
   bc778:	6063      	str	r3, [r4, #4]
}
   bc77a:	4620      	mov	r0, r4
   bc77c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000bc780 <_ZNK8particle13BlePeerDevice15characteristicsEv>:
Vector<BleCharacteristic> BlePeerDevice::characteristics() const {
   bc780:	b537      	push	{r0, r1, r2, r4, r5, lr}
   bc782:	460d      	mov	r5, r1
   bc784:	4604      	mov	r4, r0
    WiringBleLock lk;
   bc786:	a801      	add	r0, sp, #4
   bc788:	f7fe f9ea 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        return characteristics_;
   bc78c:	6829      	ldr	r1, [r5, #0]
    return impl()->characteristics();
   bc78e:	4620      	mov	r0, r4
   bc790:	3118      	adds	r1, #24
   bc792:	f7ff ffd3 	bl	bc73c <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEEC1ERKS4_>
    WiringBleLock lk;
   bc796:	a801      	add	r0, sp, #4
   bc798:	f7fe f9f0 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bc79c:	4620      	mov	r0, r4
   bc79e:	b003      	add	sp, #12
   bc7a0:	bd30      	pop	{r4, r5, pc}

000bc7a2 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_>:
inline bool spark::Vector<T, AllocatorT>::append(T value) {
   bc7a2:	b573      	push	{r0, r1, r4, r5, r6, lr}
   bc7a4:	4604      	mov	r4, r0
    return insert(size_, std::move(value));
   bc7a6:	6845      	ldr	r5, [r0, #4]
   bc7a8:	4668      	mov	r0, sp
   bc7aa:	f7fe ff00 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc7ae:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   bc7b2:	4299      	cmp	r1, r3
   bc7b4:	da10      	bge.n	bc7d8 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_+0x36>
    T* const p = data_ + i;
   bc7b6:	6823      	ldr	r3, [r4, #0]
    move(p + 1, p, data_ + size_);
   bc7b8:	6862      	ldr	r2, [r4, #4]
    T* const p = data_ + i;
   bc7ba:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
    move(p + 1, p, data_ + size_);
   bc7be:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   bc7c2:	4629      	mov	r1, r5
   bc7c4:	f105 0008 	add.w	r0, r5, #8
   bc7c8:	f7ff ff76 	bl	bc6b8 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    new(p) T(std::move(value));
   bc7cc:	b98d      	cbnz	r5, bc7f2 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_+0x50>
    ++size_;
   bc7ce:	6863      	ldr	r3, [r4, #4]
   bc7d0:	3301      	adds	r3, #1
   bc7d2:	6063      	str	r3, [r4, #4]
    return true;
   bc7d4:	2601      	movs	r6, #1
   bc7d6:	e006      	b.n	bc7e6 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_+0x44>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bc7d8:	3101      	adds	r1, #1
   bc7da:	4620      	mov	r0, r4
   bc7dc:	f7ff ff96 	bl	bc70c <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bc7e0:	4606      	mov	r6, r0
   bc7e2:	2800      	cmp	r0, #0
   bc7e4:	d1e7      	bne.n	bc7b6 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_+0x14>
   bc7e6:	a801      	add	r0, sp, #4
   bc7e8:	f7fe ff03 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   bc7ec:	4630      	mov	r0, r6
   bc7ee:	b002      	add	sp, #8
   bc7f0:	bd70      	pop	{r4, r5, r6, pc}
    new(p) T(std::move(value));
   bc7f2:	4669      	mov	r1, sp
   bc7f4:	4628      	mov	r0, r5
   bc7f6:	f7fe feda 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
   bc7fa:	e7e8      	b.n	bc7ce <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_+0x2c>

000bc7fc <_ZNK8particle13BlePeerDevice15characteristicsERKNS_10BleServiceE>:
Vector<BleCharacteristic> BlePeerDevice::characteristics(const BleService& service) const {
   bc7fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   bc7fe:	b085      	sub	sp, #20
   bc800:	4605      	mov	r5, r0
    WiringBleLock lk;
   bc802:	a801      	add	r0, sp, #4
Vector<BleCharacteristic> BlePeerDevice::characteristics(const BleService& service) const {
   bc804:	460c      	mov	r4, r1
   bc806:	4617      	mov	r7, r2
    WiringBleLock lk;
   bc808:	f7fe f9aa 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        capacity_(0) {
   bc80c:	2300      	movs	r3, #0
   bc80e:	e9c5 3300 	strd	r3, r3, [r5]
   bc812:	60ab      	str	r3, [r5, #8]
      { return _M_ptr; }
   bc814:	6823      	ldr	r3, [r4, #0]
    return data_ + size_;
   bc816:	e9d3 4606 	ldrd	r4, r6, [r3, #24]
   bc81a:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
    for (const auto& characteristic : impl()->characteristics()) {
   bc81e:	42b4      	cmp	r4, r6
   bc820:	d011      	beq.n	bc846 <_ZNK8particle13BlePeerDevice15characteristicsERKNS_10BleServiceE+0x4a>
        if (service.impl()->hasCharacteristic(characteristic)) {
   bc822:	6838      	ldr	r0, [r7, #0]
   bc824:	4621      	mov	r1, r4
   bc826:	f7fe fbcb 	bl	bafc0 <_ZN8particle14BleServiceImpl17hasCharacteristicERKNS_17BleCharacteristicE>
   bc82a:	b150      	cbz	r0, bc842 <_ZNK8particle13BlePeerDevice15characteristicsERKNS_10BleServiceE+0x46>
            characteristics.append(characteristic);
   bc82c:	4621      	mov	r1, r4
   bc82e:	a802      	add	r0, sp, #8
   bc830:	f7fe febd 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
   bc834:	a902      	add	r1, sp, #8
   bc836:	4628      	mov	r0, r5
   bc838:	f7ff ffb3 	bl	bc7a2 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_>
      ~__shared_ptr() = default;
   bc83c:	a803      	add	r0, sp, #12
   bc83e:	f7fe fed8 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    for (const auto& characteristic : impl()->characteristics()) {
   bc842:	3408      	adds	r4, #8
   bc844:	e7eb      	b.n	bc81e <_ZNK8particle13BlePeerDevice15characteristicsERKNS_10BleServiceE+0x22>
    WiringBleLock lk;
   bc846:	a801      	add	r0, sp, #4
   bc848:	f7fe f998 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
}
   bc84c:	4628      	mov	r0, r5
   bc84e:	b005      	add	sp, #20
   bc850:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000bc854 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE>:
Vector<BleCharacteristic> BlePeerDevice::discoverCharacteristicsOfService(const BleService& service) {
   bc854:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return servicesDiscovered_;
   bc858:	680b      	ldr	r3, [r1, #0]
    if (!impl()->servicesDiscovered()) {
   bc85a:	7a9b      	ldrb	r3, [r3, #10]
Vector<BleCharacteristic> BlePeerDevice::discoverCharacteristicsOfService(const BleService& service) {
   bc85c:	b091      	sub	sp, #68	; 0x44
   bc85e:	4606      	mov	r6, r0
   bc860:	460f      	mov	r7, r1
   bc862:	4690      	mov	r8, r2
    if (!impl()->servicesDiscovered()) {
   bc864:	b933      	cbnz	r3, bc874 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0x20>
        capacity_(0) {
   bc866:	e9c0 3300 	strd	r3, r3, [r0]
   bc86a:	6083      	str	r3, [r0, #8]
}
   bc86c:	4630      	mov	r0, r6
   bc86e:	b011      	add	sp, #68	; 0x44
   bc870:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      { return _M_ptr; }
   bc874:	6811      	ldr	r1, [r2, #0]
    if (!service.impl()->characteristicsDiscovered()) {
   bc876:	7e0d      	ldrb	r5, [r1, #24]
   bc878:	2d00      	cmp	r5, #0
   bc87a:	d158      	bne.n	bc92e <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xda>
        LOG(TRACE, "Start discovering characteristics of service: %s.", service.impl()->UUID().toString().c_str());
   bc87c:	2320      	movs	r3, #32
   bc87e:	462a      	mov	r2, r5
   bc880:	a803      	add	r0, sp, #12
   bc882:	e9cd 3508 	strd	r3, r5, [sp, #32]
   bc886:	f7fe fb08 	bl	bae9a <_ZNK8particle7BleUuid8toStringEb>
   bc88a:	9b03      	ldr	r3, [sp, #12]
   bc88c:	9301      	str	r3, [sp, #4]
   bc88e:	4b2b      	ldr	r3, [pc, #172]	; (bc93c <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xe8>)
   bc890:	492b      	ldr	r1, [pc, #172]	; (bc940 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xec>)
   bc892:	9300      	str	r3, [sp, #0]
   bc894:	aa08      	add	r2, sp, #32
   bc896:	462b      	mov	r3, r5
   bc898:	2001      	movs	r0, #1
   bc89a:	f7fd fcbb 	bl	ba214 <log_message>
   bc89e:	a803      	add	r0, sp, #12
   bc8a0:	f7fd ff22 	bl	ba6e8 <_ZN6StringD1Ev>
        halService.size = sizeof(hal_ble_svc_t);
   bc8a4:	231c      	movs	r3, #28
   bc8a6:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
   bc8aa:	f8d8 3000 	ldr.w	r3, [r8]
        halService.start_handle = service.impl()->startHandle();
   bc8ae:	8a9a      	ldrh	r2, [r3, #20]
   bc8b0:	f8ad 2038 	strh.w	r2, [sp, #56]	; 0x38
        halService.end_handle = service.impl()->endHandle();
   bc8b4:	8adb      	ldrh	r3, [r3, #22]
   bc8b6:	f8ad 303a 	strh.w	r3, [sp, #58]	; 0x3a
   bc8ba:	683b      	ldr	r3, [r7, #0]
        CHECK(hal_ble_gatt_client_discover_characteristics(peer.impl()->connHandle(), &halService, onCharacteristicsDiscovered, peer.impl(), nullptr));
   bc8bc:	4a21      	ldr	r2, [pc, #132]	; (bc944 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xf0>)
   bc8be:	8818      	ldrh	r0, [r3, #0]
   bc8c0:	9500      	str	r5, [sp, #0]
   bc8c2:	a908      	add	r1, sp, #32
   bc8c4:	f7fd fac4 	bl	b9e50 <hal_ble_gatt_client_discover_characteristics>
   bc8c8:	2800      	cmp	r0, #0
   bc8ca:	db30      	blt.n	bc92e <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xda>
   bc8cc:	683b      	ldr	r3, [r7, #0]
    return data_ + size_;
   bc8ce:	e9d3 4306 	ldrd	r4, r3, [r3, #24]
   bc8d2:	eb04 09c3 	add.w	r9, r4, r3, lsl #3
   bc8d6:	3408      	adds	r4, #8
        for (auto& characteristic : peer.impl()->characteristics()) {
   bc8d8:	f1a4 0308 	sub.w	r3, r4, #8
   bc8dc:	4599      	cmp	r9, r3
   bc8de:	d022      	beq.n	bc926 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0xd2>
            if (characteristic.impl()->attrHandles().user_desc_handle != BLE_INVALID_ATTR_HANDLE) {
   bc8e0:	f854 3c08 	ldr.w	r3, [r4, #-8]
   bc8e4:	89db      	ldrh	r3, [r3, #14]
   bc8e6:	2b00      	cmp	r3, #0
   bc8e8:	d0f5      	beq.n	bc8d6 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0x82>
                char desc[BLE_MAX_DESC_LEN] = {};
   bc8ea:	2210      	movs	r2, #16
   bc8ec:	2100      	movs	r1, #0
   bc8ee:	eb0d 0002 	add.w	r0, sp, r2
   bc8f2:	9503      	str	r5, [sp, #12]
   bc8f4:	f002 fb01 	bl	beefa <memset>
                size_t len = hal_ble_gatt_client_read(peer.impl()->connHandle(), characteristic.impl()->attrHandles().user_desc_handle, (uint8_t*)desc, sizeof(desc) - 1, nullptr);
   bc8f8:	f854 3c08 	ldr.w	r3, [r4, #-8]
   bc8fc:	89d9      	ldrh	r1, [r3, #14]
   bc8fe:	683b      	ldr	r3, [r7, #0]
   bc900:	aa03      	add	r2, sp, #12
   bc902:	8818      	ldrh	r0, [r3, #0]
   bc904:	9500      	str	r5, [sp, #0]
   bc906:	2313      	movs	r3, #19
   bc908:	f7fd fac0 	bl	b9e8c <hal_ble_gatt_client_read>
                if (len > 0) {
   bc90c:	2800      	cmp	r0, #0
   bc90e:	d0e2      	beq.n	bc8d6 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0x82>
                    desc[len] = '\0';
   bc910:	ab10      	add	r3, sp, #64	; 0x40
   bc912:	4418      	add	r0, r3
                    characteristic.impl()->description() = desc;
   bc914:	a903      	add	r1, sp, #12
                    desc[len] = '\0';
   bc916:	f800 5c34 	strb.w	r5, [r0, #-52]
        return description_;
   bc91a:	f854 0c08 	ldr.w	r0, [r4, #-8]
                    characteristic.impl()->description() = desc;
   bc91e:	303c      	adds	r0, #60	; 0x3c
   bc920:	f7fd ff83 	bl	ba82a <_ZN6StringaSEPKc>
        for (auto& characteristic : peer.impl()->characteristics()) {
   bc924:	e7d7      	b.n	bc8d6 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0x82>
   bc926:	f8d8 3000 	ldr.w	r3, [r8]
        characteristicsDiscovered_ = discovered;
   bc92a:	2201      	movs	r2, #1
   bc92c:	761a      	strb	r2, [r3, #24]
    return characteristics(service);
   bc92e:	4642      	mov	r2, r8
   bc930:	4639      	mov	r1, r7
   bc932:	4630      	mov	r0, r6
   bc934:	f7ff ff62 	bl	bc7fc <_ZNK8particle13BlePeerDevice15characteristicsERKNS_10BleServiceE>
   bc938:	e798      	b.n	bc86c <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE+0x18>
   bc93a:	bf00      	nop
   bc93c:	000c1f1a 	.word	0x000c1f1a
   bc940:	000c1df7 	.word	0x000c1df7
   bc944:	000bcaed 	.word	0x000bcaed

000bc948 <_ZN8particle13BlePeerDevice26discoverAllCharacteristicsEv>:
Vector<BleCharacteristic> BlePeerDevice::discoverAllCharacteristics() {
   bc948:	b5f0      	push	{r4, r5, r6, r7, lr}
        return servicesDiscovered_;
   bc94a:	680b      	ldr	r3, [r1, #0]
    if (!impl()->servicesDiscovered()) {
   bc94c:	7a9b      	ldrb	r3, [r3, #10]
Vector<BleCharacteristic> BlePeerDevice::discoverAllCharacteristics() {
   bc94e:	b085      	sub	sp, #20
   bc950:	4606      	mov	r6, r0
   bc952:	460d      	mov	r5, r1
    if (!impl()->servicesDiscovered()) {
   bc954:	b92b      	cbnz	r3, bc962 <_ZN8particle13BlePeerDevice26discoverAllCharacteristicsEv+0x1a>
        discoverAllServices();
   bc956:	a801      	add	r0, sp, #4
   bc958:	f7ff fe0a 	bl	bc570 <_ZN8particle13BlePeerDevice19discoverAllServicesEv>
   bc95c:	a801      	add	r0, sp, #4
   bc95e:	f7fe fe57 	bl	bb610 <_ZN5spark6VectorIN8particle10BleServiceENS_16DefaultAllocatorEED1Ev>
   bc962:	682b      	ldr	r3, [r5, #0]
   bc964:	e9d3 4703 	ldrd	r4, r7, [r3, #12]
   bc968:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
    for (const auto& service : impl()->services()) {
   bc96c:	42bc      	cmp	r4, r7
   bc96e:	d009      	beq.n	bc984 <_ZN8particle13BlePeerDevice26discoverAllCharacteristicsEv+0x3c>
        discoverCharacteristicsOfService(service);
   bc970:	4622      	mov	r2, r4
   bc972:	4629      	mov	r1, r5
   bc974:	a801      	add	r0, sp, #4
   bc976:	f7ff ff6d 	bl	bc854 <_ZN8particle13BlePeerDevice32discoverCharacteristicsOfServiceERKNS_10BleServiceE>
   bc97a:	a801      	add	r0, sp, #4
   bc97c:	f7fe fe5a 	bl	bb634 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
    for (const auto& service : impl()->services()) {
   bc980:	3408      	adds	r4, #8
   bc982:	e7f3      	b.n	bc96c <_ZN8particle13BlePeerDevice26discoverAllCharacteristicsEv+0x24>
    return characteristics();
   bc984:	4630      	mov	r0, r6
   bc986:	4629      	mov	r1, r5
   bc988:	f7ff fefa 	bl	bc780 <_ZNK8particle13BlePeerDevice15characteristicsEv>
}
   bc98c:	4630      	mov	r0, r6
   bc98e:	b005      	add	sp, #20
   bc990:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

000bc994 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb>:
int BlePeerDevice::connect(const BleAddress& addr, const BleConnectionParams* params, bool automatic) {
   bc994:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bc998:	4605      	mov	r5, r0
   bc99a:	b093      	sub	sp, #76	; 0x4c
    return address_;
   bc99c:	6808      	ldr	r0, [r1, #0]
    connCfg.conn_params = params;
   bc99e:	9207      	str	r2, [sp, #28]
int BlePeerDevice::connect(const BleAddress& addr, const BleConnectionParams* params, bool automatic) {
   bc9a0:	460f      	mov	r7, r1
    return address_;
   bc9a2:	6849      	ldr	r1, [r1, #4]
int BlePeerDevice::connect(const BleAddress& addr, const BleConnectionParams* params, bool automatic) {
   bc9a4:	4698      	mov	r8, r3
    return address_;
   bc9a6:	ac0a      	add	r4, sp, #40	; 0x28
    connCfg.version = BLE_API_VERSION;
   bc9a8:	4b41      	ldr	r3, [pc, #260]	; (bcab0 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x11c>)
   bc9aa:	9304      	str	r3, [sp, #16]
    return address_;
   bc9ac:	c403      	stmia	r4!, {r0, r1}
    connCfg.address = addr.halAddress();
   bc9ae:	ab05      	add	r3, sp, #20
    hal_ble_conn_cfg_t connCfg = {};
   bc9b0:	f04f 0900 	mov.w	r9, #0
    connCfg.address = addr.halAddress();
   bc9b4:	e883 0003 	stmia.w	r3, {r0, r1}
    hal_ble_conn_cfg_t connCfg = {};
   bc9b8:	e9cd 9908 	strd	r9, r9, [sp, #32]
    connCfg.callback = BleLocalDevice::getInstance().impl()->onBleLinkEvents;
   bc9bc:	f7fe fcb2 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
   bc9c0:	4b3c      	ldr	r3, [pc, #240]	; (bcab4 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x120>)
   bc9c2:	9308      	str	r3, [sp, #32]
    connCfg.context = BleLocalDevice::getInstance().impl();
   bc9c4:	f7fe fcae 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
    int ret = hal_ble_gap_connect(&connCfg, &impl()->connHandle(), nullptr);
   bc9c8:	6829      	ldr	r1, [r5, #0]
      pointer    _M_ptr() const { return std::get<0>(_M_t); }
   bc9ca:	6803      	ldr	r3, [r0, #0]
    connCfg.context = BleLocalDevice::getInstance().impl();
   bc9cc:	9309      	str	r3, [sp, #36]	; 0x24
    int ret = hal_ble_gap_connect(&connCfg, &impl()->connHandle(), nullptr);
   bc9ce:	464a      	mov	r2, r9
   bc9d0:	a804      	add	r0, sp, #16
   bc9d2:	f7fd fa65 	bl	b9ea0 <hal_ble_gap_connect>
    connCfg.address = addr.halAddress();
   bc9d6:	ae0a      	add	r6, sp, #40	; 0x28
    if (ret != SYSTEM_ERROR_NONE) {
   bc9d8:	4604      	mov	r4, r0
   bc9da:	b138      	cbz	r0, bc9ec <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x58>
   bc9dc:	682b      	ldr	r3, [r5, #0]
        impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
   bc9de:	f64f 72ff 	movw	r2, #65535	; 0xffff
   bc9e2:	801a      	strh	r2, [r3, #0]
}
   bc9e4:	4620      	mov	r0, r4
   bc9e6:	b013      	add	sp, #76	; 0x4c
   bc9e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    bind(addr);
   bc9ec:	4639      	mov	r1, r7
   bc9ee:	4628      	mov	r0, r5
   bc9f0:	f7fe fc1c 	bl	bb22c <_ZNK8particle13BlePeerDevice4bindERKNS_10BleAddressE>
        WiringBleLock lk;
   bc9f4:	a803      	add	r0, sp, #12
   bc9f6:	f7fe f8b3 	bl	bab60 <_ZN8particle3ble13WiringBleLockC1Ev>
        if (!BleLocalDevice::getInstance().impl()->peers().append(*this)) {
   bc9fa:	f7fe fc93 	bl	bb324 <_ZN8particle14BleLocalDevice11getInstanceEv>
        return peers_;
   bc9fe:	6807      	ldr	r7, [r0, #0]
   bca00:	4629      	mov	r1, r5
   bca02:	3718      	adds	r7, #24
   bca04:	4630      	mov	r0, r6
   bca06:	f7fe fdea 	bl	bb5de <_ZNSt12__shared_ptrIN8particle17BlePeerDeviceImplELN9__gnu_cxx12_Lock_policyE0EEC1ERKS4_>
        if (!BleLocalDevice::getInstance().impl()->peers().append(*this)) {
   bca0a:	4631      	mov	r1, r6
   bca0c:	4638      	mov	r0, r7
   bca0e:	f7ff f94f 	bl	bbcb0 <_ZN5spark6VectorIN8particle13BlePeerDeviceENS_16DefaultAllocatorEE6appendES2_>
   bca12:	4607      	mov	r7, r0
      ~__shared_ptr() = default;
   bca14:	a80b      	add	r0, sp, #44	; 0x2c
   bca16:	f7fe fdec 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bca1a:	f04f 0920 	mov.w	r9, #32
   bca1e:	bb1f      	cbnz	r7, bca68 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0xd4>
            LOG(ERROR, "Cannot add new peer device.");
   bca20:	4632      	mov	r2, r6
   bca22:	4b25      	ldr	r3, [pc, #148]	; (bcab8 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x124>)
   bca24:	4e25      	ldr	r6, [pc, #148]	; (bcabc <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x128>)
   bca26:	4926      	ldr	r1, [pc, #152]	; (bcac0 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x12c>)
   bca28:	9300      	str	r3, [sp, #0]
   bca2a:	2032      	movs	r0, #50	; 0x32
   bca2c:	4623      	mov	r3, r4
   bca2e:	e9cd 940a 	strd	r9, r4, [sp, #40]	; 0x28
   bca32:	f7fd fbef 	bl	ba214 <log_message>
   bca36:	6830      	ldr	r0, [r6, #0]
   bca38:	f7fd faa4 	bl	b9f84 <os_mutex_recursive_unlock>
            hal_ble_gap_disconnect(impl()->connHandle(), nullptr);
   bca3c:	682b      	ldr	r3, [r5, #0]
        locked_ = false;
   bca3e:	f88d 400c 	strb.w	r4, [sp, #12]
            hal_ble_gap_disconnect(impl()->connHandle(), nullptr);
   bca42:	4621      	mov	r1, r4
   bca44:	8818      	ldrh	r0, [r3, #0]
            return SYSTEM_ERROR_NO_MEMORY;
   bca46:	4c1f      	ldr	r4, [pc, #124]	; (bcac4 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x130>)
            hal_ble_gap_disconnect(impl()->connHandle(), nullptr);
   bca48:	f7fd f9e4 	bl	b9e14 <hal_ble_gap_disconnect>
    void lock() { os_mutex_recursive_lock(handle_); }
   bca4c:	6830      	ldr	r0, [r6, #0]
   bca4e:	f7fd fa91 	bl	b9f74 <os_mutex_recursive_lock>
        locked_ = true;
   bca52:	2301      	movs	r3, #1
   bca54:	f88d 300c 	strb.w	r3, [sp, #12]
      { return _M_ptr; }
   bca58:	682b      	ldr	r3, [r5, #0]
            impl()->connHandle() = BLE_INVALID_CONN_HANDLE;
   bca5a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   bca5e:	801a      	strh	r2, [r3, #0]
            return SYSTEM_ERROR_NO_MEMORY;
   bca60:	a803      	add	r0, sp, #12
   bca62:	f7fe f88b 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
   bca66:	e7bd      	b.n	bc9e4 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x50>
        WiringBleLock lk;
   bca68:	a803      	add	r0, sp, #12
   bca6a:	f7fe f887 	bl	bab7c <_ZN8particle3ble13WiringBleLockD1Ev>
    LOG(TRACE, "New peripheral is connected.");
   bca6e:	4b16      	ldr	r3, [pc, #88]	; (bcac8 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x134>)
   bca70:	9300      	str	r3, [sp, #0]
   bca72:	4913      	ldr	r1, [pc, #76]	; (bcac0 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x12c>)
   bca74:	4623      	mov	r3, r4
   bca76:	4632      	mov	r2, r6
   bca78:	2001      	movs	r0, #1
   bca7a:	e9cd 940a 	strd	r9, r4, [sp, #40]	; 0x28
   bca7e:	f7fd fbc9 	bl	ba214 <log_message>
    if (automatic) {
   bca82:	f1b8 0f00 	cmp.w	r8, #0
   bca86:	d0ad      	beq.n	bc9e4 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x50>
        Vector<BleCharacteristic> characteristics = discoverAllCharacteristics();
   bca88:	4629      	mov	r1, r5
   bca8a:	4630      	mov	r0, r6
   bca8c:	f7ff ff5c 	bl	bc948 <_ZN8particle13BlePeerDevice26discoverAllCharacteristicsEv>
   bca90:	e9dd 530a 	ldrd	r5, r3, [sp, #40]	; 0x28
   bca94:	eb05 07c3 	add.w	r7, r5, r3, lsl #3
        for (auto& characteristic : characteristics) {
   bca98:	42bd      	cmp	r5, r7
   bca9a:	d005      	beq.n	bcaa8 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x114>
            characteristic.subscribe(true);
   bca9c:	4628      	mov	r0, r5
   bca9e:	2101      	movs	r1, #1
   bcaa0:	f7fe fb3a 	bl	bb118 <_ZNK8particle17BleCharacteristic9subscribeEb>
        for (auto& characteristic : characteristics) {
   bcaa4:	3508      	adds	r5, #8
   bcaa6:	e7f7      	b.n	bca98 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x104>
        Vector<BleCharacteristic> characteristics = discoverAllCharacteristics();
   bcaa8:	4630      	mov	r0, r6
   bcaaa:	f7fe fdc3 	bl	bb634 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEED1Ev>
   bcaae:	e799      	b.n	bc9e4 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb+0x50>
   bcab0:	00180003 	.word	0x00180003
   bcab4:	000bbd69 	.word	0x000bbd69
   bcab8:	000c1f4c 	.word	0x000c1f4c
   bcabc:	2003e674 	.word	0x2003e674
   bcac0:	000c1df7 	.word	0x000c1df7
   bcac4:	fffffefc 	.word	0xfffffefc
   bcac8:	000c1f68 	.word	0x000c1f68

000bcacc <_ZNK8particle14BleLocalDevice7connectERKNS_10BleAddressEb>:
BlePeerDevice BleLocalDevice::connect(const BleAddress& addr, bool automatic) const {
   bcacc:	b513      	push	{r0, r1, r4, lr}
   bcace:	4604      	mov	r4, r0
   bcad0:	e9cd 3200 	strd	r3, r2, [sp]
    BlePeerDevice peer;
   bcad4:	f7fe fb76 	bl	bb1c4 <_ZN8particle13BlePeerDeviceC1Ev>
    peer.connect(addr, params, automatic);
   bcad8:	9b00      	ldr	r3, [sp, #0]
   bcada:	9901      	ldr	r1, [sp, #4]
   bcadc:	2200      	movs	r2, #0
   bcade:	4620      	mov	r0, r4
   bcae0:	f7ff ff58 	bl	bc994 <_ZN8particle13BlePeerDevice7connectERKNS_10BleAddressEPKNS_19BleConnectionParamsEb>
}
   bcae4:	4620      	mov	r0, r4
   bcae6:	b002      	add	sp, #8
   bcae8:	bd10      	pop	{r4, pc}
	...

000bcaec <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv>:
    static void onCharacteristicsDiscovered(const hal_ble_char_discovered_evt_t* event, void* context) {
   bcaec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        LOG(TRACE, "Characteristic discovered.");
   bcaf0:	2320      	movs	r3, #32
    static void onCharacteristicsDiscovered(const hal_ble_char_discovered_evt_t* event, void* context) {
   bcaf2:	b095      	sub	sp, #84	; 0x54
        LOG(TRACE, "Characteristic discovered.");
   bcaf4:	2600      	movs	r6, #0
   bcaf6:	e9cd 360c 	strd	r3, r6, [sp, #48]	; 0x30
   bcafa:	4b66      	ldr	r3, [pc, #408]	; (bcc94 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1a8>)
   bcafc:	9300      	str	r3, [sp, #0]
    static void onCharacteristicsDiscovered(const hal_ble_char_discovered_evt_t* event, void* context) {
   bcafe:	4605      	mov	r5, r0
   bcb00:	460f      	mov	r7, r1
        LOG(TRACE, "Characteristic discovered.");
   bcb02:	4633      	mov	r3, r6
   bcb04:	4964      	ldr	r1, [pc, #400]	; (bcc98 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1ac>)
                LOG(ERROR, "Discovered characteristic's handle is invalid.");
   bcb06:	f8df 9194 	ldr.w	r9, [pc, #404]	; bcc9c <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1b0>
   bcb0a:	f8df 818c 	ldr.w	r8, [pc, #396]	; bcc98 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1ac>
                    LOG(ERROR, "Failed to append discovered characteristic.");
   bcb0e:	f8df a190 	ldr.w	sl, [pc, #400]	; bcca0 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1b4>
        LOG(TRACE, "Characteristic discovered.");
   bcb12:	aa0c      	add	r2, sp, #48	; 0x30
   bcb14:	2001      	movs	r0, #1
   bcb16:	f7fd fb7d 	bl	ba214 <log_message>
        for (size_t i = 0; i < event->count; i++) {
   bcb1a:	682b      	ldr	r3, [r5, #0]
   bcb1c:	42b3      	cmp	r3, r6
   bcb1e:	f240 80b5 	bls.w	bcc8c <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x1a0>
            BleCharacteristic characteristic;
   bcb22:	a803      	add	r0, sp, #12
   bcb24:	f7fe fa72 	bl	bb00c <_ZN8particle17BleCharacteristicC1Ev>
            BleService service;
   bcb28:	a805      	add	r0, sp, #20
   bcb2a:	f7fe fb2f 	bl	bb18c <_ZN8particle10BleServiceC1Ev>
      get() const noexcept
   bcb2e:	f04f 0b2a 	mov.w	fp, #42	; 0x2a
            characteristic.impl()->attrHandles() = event->characteristics[i].charHandles;
   bcb32:	686b      	ldr	r3, [r5, #4]
      { return _M_ptr; }
   bcb34:	9a03      	ldr	r2, [sp, #12]
        return attrHandles_;
   bcb36:	fb0b fb06 	mul.w	fp, fp, r6
            characteristic.impl()->attrHandles() = event->characteristics[i].charHandles;
   bcb3a:	445b      	add	r3, fp
        this->size = halHandles.size;
   bcb3c:	8bd9      	ldrh	r1, [r3, #30]
   bcb3e:	8111      	strh	r1, [r2, #8]
        this->decl_handle = halHandles.decl_handle;
   bcb40:	8c19      	ldrh	r1, [r3, #32]
   bcb42:	8151      	strh	r1, [r2, #10]
        this->value_handle = halHandles.value_handle;
   bcb44:	8c59      	ldrh	r1, [r3, #34]	; 0x22
   bcb46:	8191      	strh	r1, [r2, #12]
        this->user_desc_handle = halHandles.user_desc_handle;
   bcb48:	8c98      	ldrh	r0, [r3, #36]	; 0x24
   bcb4a:	81d0      	strh	r0, [r2, #14]
        this->cccd_handle = halHandles.cccd_handle;
   bcb4c:	8cd8      	ldrh	r0, [r3, #38]	; 0x26
   bcb4e:	8210      	strh	r0, [r2, #16]
        this->sccd_handle = halHandles.sccd_handle;
   bcb50:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
   bcb52:	8253      	strh	r3, [r2, #18]
   bcb54:	e9d7 3203 	ldrd	r3, r2, [r7, #12]
   bcb58:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        for (const auto& svc : services_) {
   bcb5c:	429a      	cmp	r2, r3
   bcb5e:	d07d      	beq.n	bcc5c <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x170>
   bcb60:	6818      	ldr	r0, [r3, #0]
            if (handles.value_handle <= svc.impl()->endHandle() && handles.value_handle >= svc.impl()->startHandle()) {
   bcb62:	8ac4      	ldrh	r4, [r0, #22]
   bcb64:	428c      	cmp	r4, r1
   bcb66:	d377      	bcc.n	bcc58 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x16c>
   bcb68:	8a84      	ldrh	r4, [r0, #20]
   bcb6a:	428c      	cmp	r4, r1
   bcb6c:	d874      	bhi.n	bcc58 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x16c>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
   bcb6e:	6859      	ldr	r1, [r3, #4]
   bcb70:	9005      	str	r0, [sp, #20]
   bcb72:	a806      	add	r0, sp, #24
   bcb74:	f7fd ffce 	bl	bab14 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEaSERKS2_.isra.0>
                characteristic.impl()->svcUUID() = service.impl()->UUID();
   bcb78:	f8dd c014 	ldr.w	ip, [sp, #20]
      { return _M_ptr; }
   bcb7c:	f8dd e00c 	ldr.w	lr, [sp, #12]
   bcb80:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   bcb84:	f10e 0428 	add.w	r4, lr, #40	; 0x28
   bcb88:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bcb8a:	f8dc 3000 	ldr.w	r3, [ip]
   bcb8e:	6023      	str	r3, [r4, #0]
                characteristic.impl()->connHandle() = event->conn_handle;
   bcb90:	892b      	ldrh	r3, [r5, #8]
   bcb92:	f8ae 3002 	strh.w	r3, [lr, #2]
                if (event->characteristics[i].properties & BLE_SIG_CHAR_PROP_READ) {
   bcb96:	686b      	ldr	r3, [r5, #4]
   bcb98:	9c03      	ldr	r4, [sp, #12]
   bcb9a:	445b      	add	r3, fp
   bcb9c:	7e5b      	ldrb	r3, [r3, #25]
   bcb9e:	f013 0f02 	tst.w	r3, #2
   bcba2:	d16e      	bne.n	bcc82 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x196>
                if (event->characteristics[i].properties & BLE_SIG_CHAR_PROP_WRITE_WO_RESP) {
   bcba4:	686b      	ldr	r3, [r5, #4]
   bcba6:	445b      	add	r3, fp
   bcba8:	7e5b      	ldrb	r3, [r3, #25]
   bcbaa:	0758      	lsls	r0, r3, #29
    return EnumFlags<T>(value_ | flags.value_);
}

template<typename T>
inline particle::EnumFlags<T>& particle::EnumFlags<T, typename std::enable_if_t<std::is_enum<T>::value>>::operator|=(const EnumFlags<T>& flags) {
    value_ |= flags.value_;
   bcbac:	bf42      	ittt	mi
   bcbae:	7923      	ldrbmi	r3, [r4, #4]
   bcbb0:	f043 0304 	orrmi.w	r3, r3, #4
   bcbb4:	7123      	strbmi	r3, [r4, #4]
                if (event->characteristics[i].properties & BLE_SIG_CHAR_PROP_WRITE) {
   bcbb6:	686b      	ldr	r3, [r5, #4]
   bcbb8:	445b      	add	r3, fp
   bcbba:	7e5b      	ldrb	r3, [r3, #25]
   bcbbc:	0719      	lsls	r1, r3, #28
   bcbbe:	bf42      	ittt	mi
   bcbc0:	7923      	ldrbmi	r3, [r4, #4]
   bcbc2:	f043 0308 	orrmi.w	r3, r3, #8
   bcbc6:	7123      	strbmi	r3, [r4, #4]
                if (event->characteristics[i].properties & BLE_SIG_CHAR_PROP_NOTIFY) {
   bcbc8:	686b      	ldr	r3, [r5, #4]
   bcbca:	445b      	add	r3, fp
   bcbcc:	7e5b      	ldrb	r3, [r3, #25]
   bcbce:	06da      	lsls	r2, r3, #27
   bcbd0:	bf42      	ittt	mi
   bcbd2:	7923      	ldrbmi	r3, [r4, #4]
   bcbd4:	f043 0310 	orrmi.w	r3, r3, #16
   bcbd8:	7123      	strbmi	r3, [r4, #4]
                if (event->characteristics[i].properties & BLE_SIG_CHAR_PROP_INDICATE) {
   bcbda:	686b      	ldr	r3, [r5, #4]
   bcbdc:	445b      	add	r3, fp
   bcbde:	aa07      	add	r2, sp, #28
   bcbe0:	7e5b      	ldrb	r3, [r3, #25]
   bcbe2:	069b      	lsls	r3, r3, #26
   bcbe4:	bf42      	ittt	mi
   bcbe6:	7923      	ldrbmi	r3, [r4, #4]
   bcbe8:	f043 0320 	orrmi.w	r3, r3, #32
   bcbec:	7123      	strbmi	r3, [r4, #4]
        return charUuid_;
   bcbee:	686b      	ldr	r3, [r5, #4]
   bcbf0:	449b      	add	fp, r3
   bcbf2:	f10b 0304 	add.w	r3, fp, #4
   bcbf6:	4696      	mov	lr, r2
   bcbf8:	f10b 0b14 	add.w	fp, fp, #20
   bcbfc:	6818      	ldr	r0, [r3, #0]
   bcbfe:	6859      	ldr	r1, [r3, #4]
   bcc00:	4694      	mov	ip, r2
   bcc02:	e8ac 0003 	stmia.w	ip!, {r0, r1}
   bcc06:	3308      	adds	r3, #8
   bcc08:	455b      	cmp	r3, fp
   bcc0a:	4662      	mov	r2, ip
   bcc0c:	d1f6      	bne.n	bcbfc <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x110>
   bcc0e:	6818      	ldr	r0, [r3, #0]
   bcc10:	f8cc 0000 	str.w	r0, [ip]
        return *this = BleUuid(uuid);
   bcc14:	4671      	mov	r1, lr
   bcc16:	a80c      	add	r0, sp, #48	; 0x30
   bcc18:	f7fd fff8 	bl	bac0c <_ZN8particle7BleUuidC1ERK14hal_ble_uuid_t>
   bcc1c:	f10d 0c30 	add.w	ip, sp, #48	; 0x30
   bcc20:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   bcc24:	3414      	adds	r4, #20
   bcc26:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bcc28:	f8dc 3000 	ldr.w	r3, [ip]
   bcc2c:	6023      	str	r3, [r4, #0]
                if (!peerImpl->characteristics().append(characteristic)) {
   bcc2e:	a903      	add	r1, sp, #12
   bcc30:	a80c      	add	r0, sp, #48	; 0x30
   bcc32:	f7fe fcbc 	bl	bb5ae <_ZN8particle17BleCharacteristicC1ERKS0_>
   bcc36:	a90c      	add	r1, sp, #48	; 0x30
   bcc38:	f107 0018 	add.w	r0, r7, #24
   bcc3c:	f7ff fdb1 	bl	bc7a2 <_ZN5spark6VectorIN8particle17BleCharacteristicENS_16DefaultAllocatorEE6appendES2_>
   bcc40:	4604      	mov	r4, r0
      ~__shared_ptr() = default;
   bcc42:	a80d      	add	r0, sp, #52	; 0x34
   bcc44:	f7fe fcd5 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bcc48:	b99c      	cbnz	r4, bcc72 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x186>
                    LOG(ERROR, "Failed to append discovered characteristic.");
   bcc4a:	2320      	movs	r3, #32
   bcc4c:	e9cd 340c 	strd	r3, r4, [sp, #48]	; 0x30
   bcc50:	f8cd a000 	str.w	sl, [sp]
   bcc54:	4623      	mov	r3, r4
   bcc56:	e007      	b.n	bcc68 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x17c>
        for (const auto& svc : services_) {
   bcc58:	3308      	adds	r3, #8
   bcc5a:	e77f      	b.n	bcb5c <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x70>
                LOG(ERROR, "Discovered characteristic's handle is invalid.");
   bcc5c:	2420      	movs	r4, #32
   bcc5e:	2300      	movs	r3, #0
   bcc60:	e9cd 430c 	strd	r4, r3, [sp, #48]	; 0x30
   bcc64:	f8cd 9000 	str.w	r9, [sp]
                    LOG(ERROR, "Failed to append discovered characteristic.");
   bcc68:	aa0c      	add	r2, sp, #48	; 0x30
   bcc6a:	4641      	mov	r1, r8
   bcc6c:	2032      	movs	r0, #50	; 0x32
   bcc6e:	f7fd fad1 	bl	ba214 <log_message>
   bcc72:	a806      	add	r0, sp, #24
   bcc74:	f7fe fcbd 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bcc78:	a804      	add	r0, sp, #16
   bcc7a:	f7fe fcba 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        for (size_t i = 0; i < event->count; i++) {
   bcc7e:	3601      	adds	r6, #1
   bcc80:	e74b      	b.n	bcb1a <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0x2e>
   bcc82:	7923      	ldrb	r3, [r4, #4]
   bcc84:	f043 0302 	orr.w	r3, r3, #2
   bcc88:	7123      	strb	r3, [r4, #4]
   bcc8a:	e78b      	b.n	bcba4 <_ZN8particle21BleDiscoveryDelegator27onCharacteristicsDiscoveredEPK29hal_ble_char_discovered_evt_tPv+0xb8>
    }
   bcc8c:	b015      	add	sp, #84	; 0x54
   bcc8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   bcc92:	bf00      	nop
   bcc94:	000c1f85 	.word	0x000c1f85
   bcc98:	000c1df7 	.word	0x000c1df7
   bcc9c:	000c1fa0 	.word	0x000c1fa0
   bcca0:	000c1fcf 	.word	0x000c1fcf

000bcca4 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>:
        if (dest > p && dest < end) {
   bcca4:	4288      	cmp	r0, r1
    static void move(T* dest, T* p, T* end) {
   bcca6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bcca8:	4604      	mov	r4, r0
   bccaa:	460d      	mov	r5, r1
   bccac:	4616      	mov	r6, r2
        if (dest > p && dest < end) {
   bccae:	d914      	bls.n	bccda <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x36>
   bccb0:	4290      	cmp	r0, r2
   bccb2:	d213      	bcs.n	bccdc <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
            --end;
   bccb4:	f1a2 0624 	sub.w	r6, r2, #36	; 0x24
            dest += end - p - 1;
   bccb8:	1a75      	subs	r5, r6, r1
   bccba:	f1a1 0724 	sub.w	r7, r1, #36	; 0x24
   bccbe:	442c      	add	r4, r5
            for (; end != p; --end, --dest) {
   bccc0:	42b7      	cmp	r7, r6
   bccc2:	d018      	beq.n	bccf6 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*end));
   bccc4:	b11c      	cbz	r4, bccce <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x2a>
   bccc6:	4631      	mov	r1, r6
   bccc8:	4620      	mov	r0, r4
   bccca:	f7fe fed9 	bl	bba80 <_ZN8particle13BleScanResultC1EOS0_>
                end->~T();
   bccce:	4630      	mov	r0, r6
   bccd0:	f7fe fb96 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
            for (; end != p; --end, --dest) {
   bccd4:	3e24      	subs	r6, #36	; 0x24
   bccd6:	3c24      	subs	r4, #36	; 0x24
   bccd8:	e7f2      	b.n	bccc0 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x1c>
        } else if (dest != p) {
   bccda:	d00c      	beq.n	bccf6 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
            for (; p != end; ++p, ++dest) {
   bccdc:	42b5      	cmp	r5, r6
   bccde:	d00a      	beq.n	bccf6 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x52>
                new(dest) T(std::move(*p));
   bcce0:	b11c      	cbz	r4, bccea <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x46>
   bcce2:	4629      	mov	r1, r5
   bcce4:	4620      	mov	r0, r4
   bcce6:	f7fe fecb 	bl	bba80 <_ZN8particle13BleScanResultC1EOS0_>
                p->~T();
   bccea:	4628      	mov	r0, r5
   bccec:	f7fe fb88 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
            for (; p != end; ++p, ++dest) {
   bccf0:	3524      	adds	r5, #36	; 0x24
   bccf2:	3424      	adds	r4, #36	; 0x24
   bccf4:	e7f2      	b.n	bccdc <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_+0x38>
    }
   bccf6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bccf8 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>:
    bool realloc(int n) {
   bccf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (n > 0) {
   bccfa:	1e0e      	subs	r6, r1, #0
    bool realloc(int n) {
   bccfc:	4605      	mov	r5, r0
        if (n > 0) {
   bccfe:	dd13      	ble.n	bcd28 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x30>
            d = (T*)AllocatorT::malloc(n * sizeof(T));
   bcd00:	2724      	movs	r7, #36	; 0x24
    return ::malloc(size);
   bcd02:	fb07 f006 	mul.w	r0, r7, r6
   bcd06:	f7fd fb71 	bl	ba3ec <malloc>
            if (!d) {
   bcd0a:	4604      	mov	r4, r0
   bcd0c:	b158      	cbz	r0, bcd26 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x2e>
            move(d, data_, data_ + size_);
   bcd0e:	e9d5 1200 	ldrd	r1, r2, [r5]
   bcd12:	fb07 1202 	mla	r2, r7, r2, r1
   bcd16:	f7ff ffc5 	bl	bcca4 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    ::free(ptr);
   bcd1a:	6828      	ldr	r0, [r5, #0]
   bcd1c:	f7fd fb6e 	bl	ba3fc <free>
        data_ = d;
   bcd20:	602c      	str	r4, [r5, #0]
        capacity_ = n;
   bcd22:	60ae      	str	r6, [r5, #8]
        return true;
   bcd24:	2001      	movs	r0, #1
    }
   bcd26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        T* d = nullptr;
   bcd28:	2400      	movs	r4, #0
   bcd2a:	e7f6      	b.n	bcd1a <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi+0x22>

000bcd2c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv>:
    static void onScanResultCallback(const hal_ble_scan_result_evt_t* event, void* context) {
   bcd2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bcd30:	b09d      	sub	sp, #116	; 0x74
            : rssi_(BLE_RSSI_INVALID) {
   bcd32:	ad01      	add	r5, sp, #4
   bcd34:	4606      	mov	r6, r0
   bcd36:	4628      	mov	r0, r5
   bcd38:	460c      	mov	r4, r1
   bcd3a:	f7fd ff4c 	bl	babd6 <_ZN8particle10BleAddressC1Ev>
   bcd3e:	a803      	add	r0, sp, #12
   bcd40:	f7fe ff79 	bl	bbc36 <_ZN8particle18BleAdvertisingDataC1Ev>
   bcd44:	a806      	add	r0, sp, #24
   bcd46:	f7fe ff76 	bl	bbc36 <_ZN8particle18BleAdvertisingDataC1Ev>
    address_ = addr;
   bcd4a:	6930      	ldr	r0, [r6, #16]
   bcd4c:	6971      	ldr	r1, [r6, #20]
        scanResponse_.set(buf, len);
   bcd4e:	89f2      	ldrh	r2, [r6, #14]
   bcd50:	ab13      	add	r3, sp, #76	; 0x4c
   bcd52:	c303      	stmia	r3!, {r0, r1}
    address_ = addr.address_;
   bcd54:	e885 0003 	stmia.w	r5, {r0, r1}
        rssi_ = value;
   bcd58:	7833      	ldrb	r3, [r6, #0]
        scanResponse_.set(buf, len);
   bcd5a:	68b1      	ldr	r1, [r6, #8]
        rssi_ = value;
   bcd5c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        scanResponse_.set(buf, len);
   bcd60:	a806      	add	r0, sp, #24
   bcd62:	f7fe fedc 	bl	bbb1e <_ZN8particle18BleAdvertisingData3setEPKhj>
        advertisingData_.set(buf, len);
   bcd66:	89b2      	ldrh	r2, [r6, #12]
   bcd68:	6871      	ldr	r1, [r6, #4]
   bcd6a:	a803      	add	r0, sp, #12
   bcd6c:	f7fe fed7 	bl	bbb1e <_ZN8particle18BleAdvertisingData3setEPKhj>
        return minRssi_;
   bcd70:	f994 3068 	ldrsb.w	r3, [r4, #104]	; 0x68
        if (filterRssi != BLE_RSSI_INVALID && result.rssi() < filterRssi) {
   bcd74:	2b7f      	cmp	r3, #127	; 0x7f
    address_ = addr.address_;
   bcd76:	af13      	add	r7, sp, #76	; 0x4c
        if (filterRssi != BLE_RSSI_INVALID && result.rssi() < filterRssi) {
   bcd78:	d003      	beq.n	bcd82 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x56>
   bcd7a:	f99d 2024 	ldrsb.w	r2, [sp, #36]	; 0x24
   bcd7e:	429a      	cmp	r2, r3
   bcd80:	db5c      	blt.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
        return maxRssi_;
   bcd82:	f994 3069 	ldrsb.w	r3, [r4, #105]	; 0x69
        if (filterRssi != BLE_RSSI_INVALID && result.rssi() > filterRssi) {
   bcd86:	2b7f      	cmp	r3, #127	; 0x7f
   bcd88:	d003      	beq.n	bcd92 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x66>
   bcd8a:	f99d 2024 	ldrsb.w	r2, [sp, #36]	; 0x24
   bcd8e:	429a      	cmp	r2, r3
   bcd90:	dc54      	bgt.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
        auto filerAddresses = filter_.addresses();
   bcd92:	f104 0150 	add.w	r1, r4, #80	; 0x50
   bcd96:	4638      	mov	r0, r7
   bcd98:	f7fe fd3a 	bl	bb810 <_ZN5spark6VectorIN8particle10BleAddressENS_16DefaultAllocatorEEC1ERKS4_>
    return size_;
   bcd9c:	9b14      	ldr	r3, [sp, #80]	; 0x50
        if (filerAddresses.size() > 0) {
   bcd9e:	2b00      	cmp	r3, #0
   bcda0:	dd52      	ble.n	bce48 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x11c>
    return data_;
   bcda2:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    return data_ + size_;
   bcda4:	eb06 09c3 	add.w	r9, r6, r3, lsl #3
            for (const auto& address : filerAddresses) {
   bcda8:	45b1      	cmp	r9, r6
   bcdaa:	d050      	beq.n	bce4e <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x122>
                if (address == result.address()) {
   bcdac:	4630      	mov	r0, r6
   bcdae:	4629      	mov	r1, r5
   bcdb0:	f7fd fefd 	bl	babae <_ZNK8particle10BleAddresseqERKS0_>
   bcdb4:	3608      	adds	r6, #8
   bcdb6:	4680      	mov	r8, r0
   bcdb8:	2800      	cmp	r0, #0
   bcdba:	d0f5      	beq.n	bcda8 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x7c>
    ::free(ptr);
   bcdbc:	9813      	ldr	r0, [sp, #76]	; 0x4c
   bcdbe:	f7fd fb1d 	bl	ba3fc <free>
        if (!delegator->filterByRssi(result) ||
   bcdc2:	f1b8 0f00 	cmp.w	r8, #0
   bcdc6:	d039      	beq.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
              !delegator->filterByDeviceName(result) ||
   bcdc8:	4629      	mov	r1, r5
   bcdca:	4620      	mov	r0, r4
   bcdcc:	f7fe fce3 	bl	bb796 <_ZN8particle16BleScanDelegator18filterByDeviceNameERKNS_13BleScanResultE>
              !delegator->filterByAddress(result) ||
   bcdd0:	b3a0      	cbz	r0, bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
              !delegator->filterByServiceUUID(result) ||
   bcdd2:	4629      	mov	r1, r5
   bcdd4:	4620      	mov	r0, r4
   bcdd6:	f7ff fa68 	bl	bc2aa <_ZN8particle16BleScanDelegator19filterByServiceUUIDERKNS_13BleScanResultE>
              !delegator->filterByDeviceName(result) ||
   bcdda:	4606      	mov	r6, r0
   bcddc:	b370      	cbz	r0, bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
        auto filterAppearances = filter_.appearances();
   bcdde:	f104 015c 	add.w	r1, r4, #92	; 0x5c
   bcde2:	4638      	mov	r0, r7
   bcde4:	f7fe fd5f 	bl	bb8a6 <_ZN5spark6VectorI20ble_sig_appearance_tNS_16DefaultAllocatorEEC1ERKS3_>
        if (filterAppearances.size() > 0) {
   bcde8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   bcdea:	2b00      	cmp	r3, #0
   bcdec:	dd12      	ble.n	bce14 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0xe8>
            ble_sig_appearance_t srAppearance = result.scanResponse().appearance();
   bcdee:	a806      	add	r0, sp, #24
   bcdf0:	f7fe f8b9 	bl	baf66 <_ZNK8particle18BleAdvertisingData10appearanceEv>
   bcdf4:	4680      	mov	r8, r0
            ble_sig_appearance_t advAppearance = result.advertisingData().appearance();
   bcdf6:	a803      	add	r0, sp, #12
   bcdf8:	f7fe f8b5 	bl	baf66 <_ZNK8particle18BleAdvertisingData10appearanceEv>
    return data_ + size_;
   bcdfc:	e9dd 3213 	ldrd	r3, r2, [sp, #76]	; 0x4c
   bce00:	eb03 0242 	add.w	r2, r3, r2, lsl #1
            for (const auto& appearance : filterAppearances) {
   bce04:	429a      	cmp	r2, r3
   bce06:	d025      	beq.n	bce54 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x128>
                if (appearance == srAppearance || appearance == advAppearance) {
   bce08:	f833 1b02 	ldrh.w	r1, [r3], #2
   bce0c:	4588      	cmp	r8, r1
   bce0e:	d001      	beq.n	bce14 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0xe8>
   bce10:	4288      	cmp	r0, r1
   bce12:	d1f7      	bne.n	bce04 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0xd8>
    ::free(ptr);
   bce14:	9813      	ldr	r0, [sp, #76]	; 0x4c
   bce16:	f7fd faf1 	bl	ba3fc <free>
              !delegator->filterByServiceUUID(result) ||
   bce1a:	b17e      	cbz	r6, bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
              !delegator->filterByCustomData(result)) {
   bce1c:	4629      	mov	r1, r5
   bce1e:	4620      	mov	r0, r4
   bce20:	f7fe fd76 	bl	bb910 <_ZN8particle16BleScanDelegator18filterByCustomDataERKNS_13BleScanResultE>
              !delegator->filterByAppearance(result) ||
   bce24:	b150      	cbz	r0, bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
        if (delegator->scanResultCallback_) {
   bce26:	6a23      	ldr	r3, [r4, #32]
   bce28:	b1b3      	cbz	r3, bce58 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x12c>
            delegator->foundCount_++;
   bce2a:	6963      	ldr	r3, [r4, #20]
   bce2c:	9513      	str	r5, [sp, #76]	; 0x4c
   bce2e:	3301      	adds	r3, #1
   bce30:	6163      	str	r3, [r4, #20]
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bce32:	6a63      	ldr	r3, [r4, #36]	; 0x24
   bce34:	4639      	mov	r1, r7
   bce36:	f104 0018 	add.w	r0, r4, #24
   bce3a:	4798      	blx	r3
            return;
   bce3c:	4628      	mov	r0, r5
   bce3e:	f7fe fadf 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
    }
   bce42:	b01d      	add	sp, #116	; 0x74
   bce44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return true;
   bce48:	f04f 0801 	mov.w	r8, #1
   bce4c:	e7b6      	b.n	bcdbc <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x90>
            return false;
   bce4e:	f04f 0800 	mov.w	r8, #0
   bce52:	e7b3      	b.n	bcdbc <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x90>
            return false;
   bce54:	2600      	movs	r6, #0
   bce56:	e7dd      	b.n	bce14 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0xe8>
        } else if (delegator->scanResultCallbackRef_) {
   bce58:	f8d4 8030 	ldr.w	r8, [r4, #48]	; 0x30
   bce5c:	f1b8 0f00 	cmp.w	r8, #0
   bce60:	d007      	beq.n	bce72 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x146>
            delegator->foundCount_++;
   bce62:	6963      	ldr	r3, [r4, #20]
   bce64:	3301      	adds	r3, #1
   bce66:	6163      	str	r3, [r4, #20]
   bce68:	4629      	mov	r1, r5
   bce6a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   bce6c:	f104 0028 	add.w	r0, r4, #40	; 0x28
   bce70:	e7e3      	b.n	bce3a <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x10e>
        if (delegator->resultsPtr_) {
   bce72:	f8d4 c00c 	ldr.w	ip, [r4, #12]
   bce76:	f1bc 0f00 	cmp.w	ip, #0
   bce7a:	d025      	beq.n	bcec8 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x19c>
            delegator->foundCount_++;
   bce7c:	6963      	ldr	r3, [r4, #20]
            if (delegator->foundCount_ <= delegator->targetCount_) {
   bce7e:	6922      	ldr	r2, [r4, #16]
            delegator->foundCount_++;
   bce80:	3301      	adds	r3, #1
            if (delegator->foundCount_ <= delegator->targetCount_) {
   bce82:	4293      	cmp	r3, r2
            delegator->foundCount_++;
   bce84:	6163      	str	r3, [r4, #20]
            if (delegator->foundCount_ <= delegator->targetCount_) {
   bce86:	d8d9      	bhi.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
                delegator->resultsPtr_[delegator->foundCount_ - 1] = result;
   bce88:	2224      	movs	r2, #36	; 0x24
   bce8a:	4353      	muls	r3, r2
    address_ = addr.address_;
   bce8c:	462a      	mov	r2, r5
   bce8e:	ca03      	ldmia	r2!, {r0, r1}
                delegator->resultsPtr_[delegator->foundCount_ - 1] = result;
   bce90:	3b24      	subs	r3, #36	; 0x24
   bce92:	eb0c 0603 	add.w	r6, ip, r3
    address_ = addr.address_;
   bce96:	f84c 0003 	str.w	r0, [ip, r3]
   bce9a:	6071      	str	r1, [r6, #4]
class BleScanResult {
   bce9c:	f106 0008 	add.w	r0, r6, #8
   bcea0:	a903      	add	r1, sp, #12
   bcea2:	f7fe fe04 	bl	bbaae <_ZN8particle18BleAdvertisingDataaSERKS0_.isra.0>
   bcea6:	a906      	add	r1, sp, #24
   bcea8:	f106 0014 	add.w	r0, r6, #20
   bceac:	f7fe fdff 	bl	bbaae <_ZN8particle18BleAdvertisingDataaSERKS0_.isra.0>
   bceb0:	f99d 3024 	ldrsb.w	r3, [sp, #36]	; 0x24
   bceb4:	f886 3020 	strb.w	r3, [r6, #32]
                if (delegator->foundCount_ >= delegator->targetCount_) {
   bceb8:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   bcebc:	429a      	cmp	r2, r3
   bcebe:	d3bd      	bcc.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
                    hal_ble_gap_stop_scan(nullptr);
   bcec0:	4640      	mov	r0, r8
   bcec2:	f7fc ff9d 	bl	b9e00 <hal_ble_gap_stop_scan>
   bcec6:	e7b9      	b.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
    address_ = addr.address_;
   bcec8:	e895 0003 	ldmia.w	r5, {r0, r1}
   bcecc:	f10d 0828 	add.w	r8, sp, #40	; 0x28
   bced0:	e888 0003 	stmia.w	r8, {r0, r1}
class BleAdvertisingData {
   bced4:	a903      	add	r1, sp, #12
   bced6:	a80c      	add	r0, sp, #48	; 0x30
   bced8:	f7fe fdb5 	bl	bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>
   bcedc:	a906      	add	r1, sp, #24
   bcede:	a80f      	add	r0, sp, #60	; 0x3c
   bcee0:	f7fe fdb1 	bl	bba46 <_ZN5spark6VectorIhNS_16DefaultAllocatorEEC1ERKS2_>
class BleScanResult {
   bcee4:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   bcee8:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
    return insert(size_, std::move(value));
   bceec:	4641      	mov	r1, r8
   bceee:	4638      	mov	r0, r7
   bcef0:	6866      	ldr	r6, [r4, #4]
   bcef2:	f7fe fdc5 	bl	bba80 <_ZN8particle13BleScanResultC1EOS0_>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bcef6:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   bcefa:	4299      	cmp	r1, r3
   bcefc:	da10      	bge.n	bcf20 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x1f4>
    T* const p = data_ + i;
   bcefe:	6823      	ldr	r3, [r4, #0]
    move(p + 1, p, data_ + size_);
   bcf00:	6861      	ldr	r1, [r4, #4]
    T* const p = data_ + i;
   bcf02:	2224      	movs	r2, #36	; 0x24
   bcf04:	fb02 3606 	mla	r6, r2, r6, r3
    move(p + 1, p, data_ + size_);
   bcf08:	f106 0024 	add.w	r0, r6, #36	; 0x24
   bcf0c:	fb02 3201 	mla	r2, r2, r1, r3
   bcf10:	4631      	mov	r1, r6
   bcf12:	f7ff fec7 	bl	bcca4 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE4moveIS2_Li0EEEvPS2_S6_S6_>
    new(p) T(std::move(value));
   bcf16:	b986      	cbnz	r6, bcf3a <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x20e>
    ++size_;
   bcf18:	6863      	ldr	r3, [r4, #4]
   bcf1a:	3301      	adds	r3, #1
   bcf1c:	6063      	str	r3, [r4, #4]
    return true;
   bcf1e:	e005      	b.n	bcf2c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x200>
    if (size_ + 1 > capacity_ && !realloc(size_ + 1)) {
   bcf20:	3101      	adds	r1, #1
   bcf22:	4620      	mov	r0, r4
   bcf24:	f7ff fee8 	bl	bccf8 <_ZN5spark6VectorIN8particle13BleScanResultENS_16DefaultAllocatorEE7reallocIS2_Li0EEEbi>
   bcf28:	2800      	cmp	r0, #0
   bcf2a:	d1e8      	bne.n	bcefe <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x1d2>
    return insert(size_, std::move(value));
   bcf2c:	4638      	mov	r0, r7
   bcf2e:	f7fe fa67 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
        delegator->resultsVector_.append(result);
   bcf32:	4640      	mov	r0, r8
   bcf34:	f7fe fa64 	bl	bb400 <_ZN8particle13BleScanResultD1Ev>
   bcf38:	e780      	b.n	bce3c <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x110>
    new(p) T(std::move(value));
   bcf3a:	4639      	mov	r1, r7
   bcf3c:	4630      	mov	r0, r6
   bcf3e:	f7fe fd9f 	bl	bba80 <_ZN8particle13BleScanResultC1EOS0_>
   bcf42:	e7e9      	b.n	bcf18 <_ZN8particle16BleScanDelegator20onScanResultCallbackEPK25hal_ble_scan_result_evt_tPv+0x1ec>

000bcf44 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E>:
    RecursiveMutex() : handle_(nullptr)
   bcf44:	4802      	ldr	r0, [pc, #8]	; (bcf50 <_GLOBAL__sub_I__ZN8particle3ble13WiringBleLock6mutex_E+0xc>)
   bcf46:	2300      	movs	r3, #0
   bcf48:	6003      	str	r3, [r0, #0]
        os_mutex_recursive_create(&handle_);
   bcf4a:	f7fd b80b 	b.w	b9f64 <os_mutex_recursive_create>
   bcf4e:	bf00      	nop
   bcf50:	2003e674 	.word	0x2003e674

000bcf54 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
   bcf54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bcf56:	4606      	mov	r6, r0
   bcf58:	460d      	mov	r5, r1
  size_t n = 0;
   bcf5a:	188f      	adds	r7, r1, r2
   bcf5c:	2400      	movs	r4, #0
  while (size--) {
   bcf5e:	42bd      	cmp	r5, r7
   bcf60:	d00c      	beq.n	bcf7c <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
   bcf62:	6833      	ldr	r3, [r6, #0]
   bcf64:	f815 1b01 	ldrb.w	r1, [r5], #1
   bcf68:	689b      	ldr	r3, [r3, #8]
   bcf6a:	4630      	mov	r0, r6
   bcf6c:	4798      	blx	r3
     if (chunk>=0)
   bcf6e:	1e03      	subs	r3, r0, #0
   bcf70:	db01      	blt.n	bcf76 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
   bcf72:	441c      	add	r4, r3
  while (size--) {
   bcf74:	e7f3      	b.n	bcf5e <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
   bcf76:	2c00      	cmp	r4, #0
   bcf78:	bf08      	it	eq
   bcf7a:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
   bcf7c:	4620      	mov	r0, r4
   bcf7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bcf80 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
   bcf80:	b508      	push	{r3, lr}
  return write(str);
   bcf82:	f7fc f8a5 	bl	b90d0 <_ZN5Print5writeEPKc>
}
   bcf86:	bd08      	pop	{r3, pc}

000bcf88 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
   bcf88:	6803      	ldr	r3, [r0, #0]
   bcf8a:	689b      	ldr	r3, [r3, #8]
   bcf8c:	4718      	bx	r3

000bcf8e <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
   bcf8e:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
   bcf90:	210d      	movs	r1, #13
{
   bcf92:	4605      	mov	r5, r0
  size_t n = print('\r');
   bcf94:	f7ff fff8 	bl	bcf88 <_ZN5Print5printEc>
  n += print('\n');
   bcf98:	210a      	movs	r1, #10
  size_t n = print('\r');
   bcf9a:	4604      	mov	r4, r0
  n += print('\n');
   bcf9c:	4628      	mov	r0, r5
   bcf9e:	f7ff fff3 	bl	bcf88 <_ZN5Print5printEc>
  return n;
}
   bcfa2:	4420      	add	r0, r4
   bcfa4:	bd38      	pop	{r3, r4, r5, pc}

000bcfa6 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
   bcfa6:	b538      	push	{r3, r4, r5, lr}
   bcfa8:	4605      	mov	r5, r0
  return write(str);
   bcfaa:	f7fc f891 	bl	b90d0 <_ZN5Print5writeEPKc>
   bcfae:	4604      	mov	r4, r0
  size_t n = print(c);
  n += println();
   bcfb0:	4628      	mov	r0, r5
   bcfb2:	f7ff ffec 	bl	bcf8e <_ZN5Print7printlnEv>
  return n;
}
   bcfb6:	4420      	add	r0, r4
   bcfb8:	bd38      	pop	{r3, r4, r5, pc}

000bcfba <_ZN5Print11printNumberEmh>:
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
   bcfba:	b530      	push	{r4, r5, lr}
   bcfbc:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
   bcfbe:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
   bcfc0:	2a01      	cmp	r2, #1
  *str = '\0';
   bcfc2:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
   bcfc6:	bf98      	it	ls
   bcfc8:	220a      	movls	r2, #10
   bcfca:	ac09      	add	r4, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
   bcfcc:	460d      	mov	r5, r1
   bcfce:	fbb1 f1f2 	udiv	r1, r1, r2
   char c = m - base * n;
   bcfd2:	fb01 5312 	mls	r3, r1, r2, r5
   bcfd6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   bcfda:	2b09      	cmp	r3, #9
   bcfdc:	bf94      	ite	ls
   bcfde:	3330      	addls	r3, #48	; 0x30
   bcfe0:	3337      	addhi	r3, #55	; 0x37
   bcfe2:	b2db      	uxtb	r3, r3
  } while(n);
   bcfe4:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
   bcfe6:	f804 3d01 	strb.w	r3, [r4, #-1]!
  } while(n);
   bcfea:	d9ef      	bls.n	bcfcc <_ZN5Print11printNumberEmh+0x12>

  return write(str);
   bcfec:	4621      	mov	r1, r4
   bcfee:	f7fc f86f 	bl	b90d0 <_ZN5Print5writeEPKc>
}
   bcff2:	b00b      	add	sp, #44	; 0x2c
   bcff4:	bd30      	pop	{r4, r5, pc}

000bcff6 <_ZN5Print7vprintfEbPKcSt9__va_list>:

  return n;
}

size_t Print::vprintf(bool newline, const char* format, va_list args)
{
   bcff6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   bcffa:	b086      	sub	sp, #24
   bcffc:	af00      	add	r7, sp, #0
   bcffe:	4605      	mov	r5, r0
   bd000:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list args2;
    va_copy(args2, args);
    size_t n = vsnprintf(test, bufsize, format, args);
   bd002:	1d38      	adds	r0, r7, #4
   bd004:	2114      	movs	r1, #20
{
   bd006:	4614      	mov	r4, r2
    va_copy(args2, args);
   bd008:	603b      	str	r3, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, args);
   bd00a:	f7fd fa1f 	bl	ba44c <vsnprintf>

    if (n<bufsize)
   bd00e:	2813      	cmp	r0, #19
   bd010:	d80e      	bhi.n	bd030 <_ZN5Print7vprintfEbPKcSt9__va_list+0x3a>
  return write(str);
   bd012:	1d39      	adds	r1, r7, #4
   bd014:	4628      	mov	r0, r5
   bd016:	f7fc f85b 	bl	b90d0 <_ZN5Print5writeEPKc>
   bd01a:	4604      	mov	r4, r0
    {
        char bigger[n+1];
        n = vsnprintf(bigger, n+1, format, args2);
        n = print(bigger);
    }
    if (newline)
   bd01c:	b11e      	cbz	r6, bd026 <_ZN5Print7vprintfEbPKcSt9__va_list+0x30>
        n += println();
   bd01e:	4628      	mov	r0, r5
   bd020:	f7ff ffb5 	bl	bcf8e <_ZN5Print7printlnEv>
   bd024:	4404      	add	r4, r0

    va_end(args2);
    return n;
}
   bd026:	4620      	mov	r0, r4
   bd028:	3718      	adds	r7, #24
   bd02a:	46bd      	mov	sp, r7
   bd02c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        char bigger[n+1];
   bd030:	f100 0308 	add.w	r3, r0, #8
   bd034:	f023 0307 	bic.w	r3, r3, #7
        n = print(bigger);
   bd038:	46e8      	mov	r8, sp
        char bigger[n+1];
   bd03a:	ebad 0d03 	sub.w	sp, sp, r3
        n = vsnprintf(bigger, n+1, format, args2);
   bd03e:	4622      	mov	r2, r4
   bd040:	1c41      	adds	r1, r0, #1
   bd042:	683b      	ldr	r3, [r7, #0]
   bd044:	4668      	mov	r0, sp
   bd046:	f7fd fa01 	bl	ba44c <vsnprintf>
  return write(str);
   bd04a:	4669      	mov	r1, sp
   bd04c:	4628      	mov	r0, r5
   bd04e:	f7fc f83f 	bl	b90d0 <_ZN5Print5writeEPKc>
   bd052:	4604      	mov	r4, r0
   bd054:	46c5      	mov	sp, r8
   bd056:	e7e1      	b.n	bd01c <_ZN5Print7vprintfEbPKcSt9__va_list+0x26>

000bd058 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
   bd058:	b510      	push	{r4, lr}
   bd05a:	4604      	mov	r4, r0

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
   bd05c:	f7fc fe90 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
   bd060:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
   bd062:	6823      	ldr	r3, [r4, #0]
   bd064:	4620      	mov	r0, r4
   bd066:	695b      	ldr	r3, [r3, #20]
   bd068:	4798      	blx	r3
    if (c >= 0) return c;
   bd06a:	2800      	cmp	r0, #0
   bd06c:	da08      	bge.n	bd080 <_ZN6Stream9timedReadEv+0x28>
   bd06e:	f7fc fe87 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
  } while(millis() - _startMillis < _timeout);
   bd072:	68e3      	ldr	r3, [r4, #12]
   bd074:	1ac0      	subs	r0, r0, r3
   bd076:	68a3      	ldr	r3, [r4, #8]
   bd078:	4298      	cmp	r0, r3
   bd07a:	d3f2      	bcc.n	bd062 <_ZN6Stream9timedReadEv+0xa>
  return -1;     // -1 indicates timeout
   bd07c:	f04f 30ff 	mov.w	r0, #4294967295
}
   bd080:	bd10      	pop	{r4, pc}
	...

000bd084 <_ZN6Stream15readStringUntilEc>:
  }
  return ret;
}

String Stream::readStringUntil(char terminator)
{
   bd084:	b570      	push	{r4, r5, r6, lr}
   bd086:	460d      	mov	r5, r1
  String ret;
   bd088:	4909      	ldr	r1, [pc, #36]	; (bd0b0 <_ZN6Stream15readStringUntilEc+0x2c>)
{
   bd08a:	4604      	mov	r4, r0
   bd08c:	4616      	mov	r6, r2
  String ret;
   bd08e:	f7fd fb76 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
  int c = timedRead();
   bd092:	4628      	mov	r0, r5
   bd094:	f7ff ffe0 	bl	bd058 <_ZN6Stream9timedReadEv>
  while (c >= 0 && c != terminator)
   bd098:	2800      	cmp	r0, #0
   bd09a:	db06      	blt.n	bd0aa <_ZN6Stream15readStringUntilEc+0x26>
   bd09c:	4286      	cmp	r6, r0
   bd09e:	d004      	beq.n	bd0aa <_ZN6Stream15readStringUntilEc+0x26>
	String & operator += (char c)			{concat(c); return (*this);}
   bd0a0:	b2c1      	uxtb	r1, r0
   bd0a2:	4620      	mov	r0, r4
   bd0a4:	f7fd fbea 	bl	ba87c <_ZN6String6concatEc>
  {
    ret += (char)c;
    c = timedRead();
   bd0a8:	e7f3      	b.n	bd092 <_ZN6Stream15readStringUntilEc+0xe>
  }
  return ret;
}
   bd0aa:	4620      	mov	r0, r4
   bd0ac:	bd70      	pop	{r4, r5, r6, pc}
   bd0ae:	bf00      	nop
   bd0b0:	000c1076 	.word	0x000c1076

000bd0b4 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
   bd0b4:	4b01      	ldr	r3, [pc, #4]	; (bd0bc <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
   bd0b6:	4a02      	ldr	r2, [pc, #8]	; (bd0c0 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
   bd0b8:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
   bd0ba:	4770      	bx	lr
   bd0bc:	2003e67c 	.word	0x2003e67c
   bd0c0:	000c206e 	.word	0x000c206e

000bd0c4 <_ZL22Refresh_UnixTime_Cachex>:
	return calendar_time;
}

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
   bd0c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unix_time += time_zone_cache;
   bd0c8:	4a15      	ldr	r2, [pc, #84]	; (bd120 <_ZL22Refresh_UnixTime_Cachex+0x5c>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
   bd0ca:	f8df 8060 	ldr.w	r8, [pc, #96]	; bd12c <_ZL22Refresh_UnixTime_Cachex+0x68>
    unix_time += time_zone_cache;
   bd0ce:	e9d2 6300 	ldrd	r6, r3, [r2]
   bd0d2:	1980      	adds	r0, r0, r6
   bd0d4:	eb43 0101 	adc.w	r1, r3, r1
    unix_time += dst_current_cache;
   bd0d8:	4b12      	ldr	r3, [pc, #72]	; (bd124 <_ZL22Refresh_UnixTime_Cachex+0x60>)
   bd0da:	e9d3 6700 	ldrd	r6, r7, [r3]
    if(unix_time != unix_time_cache)
   bd0de:	e9d8 2300 	ldrd	r2, r3, [r8]
    unix_time += dst_current_cache;
   bd0e2:	1986      	adds	r6, r0, r6
   bd0e4:	eb41 0707 	adc.w	r7, r1, r7
    if(unix_time != unix_time_cache)
   bd0e8:	42bb      	cmp	r3, r7
   bd0ea:	bf08      	it	eq
   bd0ec:	42b2      	cmpeq	r2, r6
{
   bd0ee:	b08c      	sub	sp, #48	; 0x30
    if(unix_time != unix_time_cache)
   bd0f0:	d013      	beq.n	bd11a <_ZL22Refresh_UnixTime_Cachex+0x56>
	localtime_r(&unix_time, &calendar_time);
   bd0f2:	a903      	add	r1, sp, #12
   bd0f4:	4668      	mov	r0, sp
   bd0f6:	e9cd 6700 	strd	r6, r7, [sp]
   bd0fa:	f7fd f9d7 	bl	ba4ac <localtime_r>
	calendar_time.tm_year += 1900;
   bd0fe:	9b08      	ldr	r3, [sp, #32]
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   bd100:	4d09      	ldr	r5, [pc, #36]	; (bd128 <_ZL22Refresh_UnixTime_Cachex+0x64>)
	calendar_time.tm_year += 1900;
   bd102:	f203 736c 	addw	r3, r3, #1900	; 0x76c
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   bd106:	ac03      	add	r4, sp, #12
	calendar_time.tm_year += 1900;
   bd108:	9308      	str	r3, [sp, #32]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   bd10a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   bd10c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   bd10e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   bd110:	c50f      	stmia	r5!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
   bd112:	e9c8 6700 	strd	r6, r7, [r8]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
   bd116:	6823      	ldr	r3, [r4, #0]
   bd118:	602b      	str	r3, [r5, #0]
    }
}
   bd11a:	b00c      	add	sp, #48	; 0x30
   bd11c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   bd120:	2003e6b0 	.word	0x2003e6b0
   bd124:	2003e6a8 	.word	0x2003e6a8
   bd128:	2003e684 	.word	0x2003e684
   bd12c:	2003e6b8 	.word	0x2003e6b8

000bd130 <_ZN10CloudClass12syncTimeDoneEv.isra.0>:
    bool syncTimePending(void)
    {
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
   bd130:	b508      	push	{r3, lr}
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
   bd132:	2000      	movs	r0, #0
   bd134:	f7fd f94a 	bl	ba3cc <spark_sync_time_pending>
   bd138:	b128      	cbz	r0, bd146 <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
   bd13a:	f7fd f92f 	bl	ba39c <spark_cloud_flag_connected>
        return !spark_sync_time_pending(nullptr) || disconnected();
   bd13e:	f080 0001 	eor.w	r0, r0, #1
   bd142:	b2c0      	uxtb	r0, r0
    }
   bd144:	bd08      	pop	{r3, pc}
        return !spark_sync_time_pending(nullptr) || disconnected();
   bd146:	2001      	movs	r0, #1
   bd148:	e7fc      	b.n	bd144 <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x14>
	...

000bd14c <_ZN9TimeClass5monthEx>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
   bd14c:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
   bd14e:	f7ff ffb9 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
   bd152:	4b02      	ldr	r3, [pc, #8]	; (bd15c <_ZN9TimeClass5monthEx+0x10>)
   bd154:	6918      	ldr	r0, [r3, #16]
}
   bd156:	3001      	adds	r0, #1
   bd158:	bd08      	pop	{r3, pc}
   bd15a:	bf00      	nop
   bd15c:	2003e684 	.word	0x2003e684

000bd160 <_ZN9TimeClass7isValidEv>:
    strftime(buf, sizeof(buf), format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
   bd160:	b510      	push	{r4, lr}
    bool rtcstate = hal_rtc_time_is_valid(nullptr);
   bd162:	2000      	movs	r0, #0
   bd164:	f7fc fe14 	bl	b9d90 <hal_rtc_time_is_valid>
    if (rtcstate)
   bd168:	4604      	mov	r4, r0
   bd16a:	b9a0      	cbnz	r0, bd196 <_ZN9TimeClass7isValidEv+0x36>
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
   bd16c:	f7fd f85a 	bl	ba224 <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
   bd170:	2801      	cmp	r0, #1
   bd172:	d110      	bne.n	bd196 <_ZN9TimeClass7isValidEv+0x36>
   bd174:	4620      	mov	r0, r4
   bd176:	f7fd f87d 	bl	ba274 <system_thread_get_state>
   bd17a:	b960      	cbnz	r0, bd196 <_ZN9TimeClass7isValidEv+0x36>
    {
        waitUntil(Particle.syncTimeDone);
   bd17c:	f7ff ffd8 	bl	bd130 <_ZN10CloudClass12syncTimeDoneEv.isra.0>

    static uint32_t freeMemory();

    template<typename Condition, typename While>
    static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
   bd180:	b910      	cbnz	r0, bd188 <_ZN9TimeClass7isValidEv+0x28>
            spark_process();
   bd182:	f7fd f8fb 	bl	ba37c <spark_process>
        while (_while() && !_condition()) {
   bd186:	e7f9      	b.n	bd17c <_ZN9TimeClass7isValidEv+0x1c>
   bd188:	f7ff ffd2 	bl	bd130 <_ZN10CloudClass12syncTimeDoneEv.isra.0>
        return hal_rtc_time_is_valid(nullptr);
    }
    return rtcstate;
}
   bd18c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return hal_rtc_time_is_valid(nullptr);
   bd190:	2000      	movs	r0, #0
   bd192:	f7fc bdfd 	b.w	b9d90 <hal_rtc_time_is_valid>
}
   bd196:	4620      	mov	r0, r4
   bd198:	bd10      	pop	{r4, pc}

000bd19a <_ZN9TimeClass3nowEv>:
{
   bd19a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    (void)isValid();
   bd19c:	f7ff ffe0 	bl	bd160 <_ZN9TimeClass7isValidEv>
    struct timeval tv = {};
   bd1a0:	2210      	movs	r2, #16
   bd1a2:	2100      	movs	r1, #0
   bd1a4:	4668      	mov	r0, sp
   bd1a6:	f001 fea8 	bl	beefa <memset>
    hal_rtc_get_time(&tv, nullptr);
   bd1aa:	2100      	movs	r1, #0
   bd1ac:	4668      	mov	r0, sp
   bd1ae:	f7fc fdf7 	bl	b9da0 <hal_rtc_get_time>
}
   bd1b2:	9800      	ldr	r0, [sp, #0]
   bd1b4:	b005      	add	sp, #20
   bd1b6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000bd1bc <_ZN9TimeClass4hourEv>:
{
   bd1bc:	b508      	push	{r3, lr}
	return hour(now());
   bd1be:	f7ff ffec 	bl	bd19a <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   bd1c2:	17c1      	asrs	r1, r0, #31
   bd1c4:	f7ff ff7e 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
}
   bd1c8:	4b01      	ldr	r3, [pc, #4]	; (bd1d0 <_ZN9TimeClass4hourEv+0x14>)
   bd1ca:	6898      	ldr	r0, [r3, #8]
   bd1cc:	bd08      	pop	{r3, pc}
   bd1ce:	bf00      	nop
   bd1d0:	2003e684 	.word	0x2003e684

000bd1d4 <_ZN9TimeClass6minuteEv>:
{
   bd1d4:	b508      	push	{r3, lr}
	return minute(now());
   bd1d6:	f7ff ffe0 	bl	bd19a <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   bd1da:	17c1      	asrs	r1, r0, #31
   bd1dc:	f7ff ff72 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
}
   bd1e0:	4b01      	ldr	r3, [pc, #4]	; (bd1e8 <_ZN9TimeClass6minuteEv+0x14>)
   bd1e2:	6858      	ldr	r0, [r3, #4]
   bd1e4:	bd08      	pop	{r3, pc}
   bd1e6:	bf00      	nop
   bd1e8:	2003e684 	.word	0x2003e684

000bd1ec <_ZN9TimeClass6secondEv>:
{
   bd1ec:	b508      	push	{r3, lr}
	return second(now());
   bd1ee:	f7ff ffd4 	bl	bd19a <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   bd1f2:	17c1      	asrs	r1, r0, #31
   bd1f4:	f7ff ff66 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
}
   bd1f8:	4b01      	ldr	r3, [pc, #4]	; (bd200 <_ZN9TimeClass6secondEv+0x14>)
   bd1fa:	6818      	ldr	r0, [r3, #0]
   bd1fc:	bd08      	pop	{r3, pc}
   bd1fe:	bf00      	nop
   bd200:	2003e684 	.word	0x2003e684

000bd204 <_ZN9TimeClass3dayEv>:
{
   bd204:	b508      	push	{r3, lr}
	return day(now());
   bd206:	f7ff ffc8 	bl	bd19a <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   bd20a:	17c1      	asrs	r1, r0, #31
   bd20c:	f7ff ff5a 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
}
   bd210:	4b01      	ldr	r3, [pc, #4]	; (bd218 <_ZN9TimeClass3dayEv+0x14>)
   bd212:	68d8      	ldr	r0, [r3, #12]
   bd214:	bd08      	pop	{r3, pc}
   bd216:	bf00      	nop
   bd218:	2003e684 	.word	0x2003e684

000bd21c <_ZN9TimeClass5monthEv>:
{
   bd21c:	b508      	push	{r3, lr}
	return month(now());
   bd21e:	f7ff ffbc 	bl	bd19a <_ZN9TimeClass3nowEv>
}
   bd222:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return month(now());
   bd226:	17c1      	asrs	r1, r0, #31
   bd228:	f7ff bf90 	b.w	bd14c <_ZN9TimeClass5monthEx>

000bd22c <_ZN9TimeClass4yearEv>:
{
   bd22c:	b508      	push	{r3, lr}
	return year(now());
   bd22e:	f7ff ffb4 	bl	bd19a <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
   bd232:	17c1      	asrs	r1, r0, #31
   bd234:	f7ff ff46 	bl	bd0c4 <_ZL22Refresh_UnixTime_Cachex>
}
   bd238:	4b01      	ldr	r3, [pc, #4]	; (bd240 <_ZN9TimeClass4yearEv+0x14>)
   bd23a:	6958      	ldr	r0, [r3, #20]
   bd23c:	bd08      	pop	{r3, pc}
   bd23e:	bf00      	nop
   bd240:	2003e684 	.word	0x2003e684

000bd244 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
   bd244:	4b02      	ldr	r3, [pc, #8]	; (bd250 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
   bd246:	681a      	ldr	r2, [r3, #0]
   bd248:	4b02      	ldr	r3, [pc, #8]	; (bd254 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
   bd24a:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
   bd24c:	4770      	bx	lr
   bd24e:	bf00      	nop
   bd250:	2003daac 	.word	0x2003daac
   bd254:	2003e680 	.word	0x2003e680

000bd258 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
   bd258:	2100      	movs	r1, #0
   bd25a:	f7fc bff3 	b.w	ba244 <system_delay_ms>
	...

000bd260 <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
   bd260:	4b01      	ldr	r3, [pc, #4]	; (bd268 <_GLOBAL__sub_I_RGB+0x8>)
   bd262:	2200      	movs	r2, #0
   bd264:	609a      	str	r2, [r3, #8]
{
    RGBClass* const d = static_cast<RGBClass*>(data);
    if (d->changeHandler_) {
        d->changeHandler_(r, g, b);
    }
}
   bd266:	4770      	bx	lr
   bd268:	2003e6c0 	.word	0x2003e6c0

000bd26c <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
   bd26c:	4b01      	ldr	r3, [pc, #4]	; (bd274 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
   bd26e:	6018      	str	r0, [r3, #0]
    }, nullptr);
   bd270:	4770      	bx	lr
   bd272:	bf00      	nop
   bd274:	2003dab0 	.word	0x2003dab0

000bd278 <serialEventRun>:
{
   bd278:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
   bd27a:	4b0b      	ldr	r3, [pc, #44]	; (bd2a8 <serialEventRun+0x30>)
   bd27c:	b143      	cbz	r3, bd290 <serialEventRun+0x18>
   bd27e:	f000 fc25 	bl	bdacc <_Z16_fetch_usbserialv>
   bd282:	6803      	ldr	r3, [r0, #0]
   bd284:	691b      	ldr	r3, [r3, #16]
   bd286:	4798      	blx	r3
   bd288:	2800      	cmp	r0, #0
   bd28a:	dd01      	ble.n	bd290 <serialEventRun+0x18>
        serialEvent();
   bd28c:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
   bd290:	4b06      	ldr	r3, [pc, #24]	; (bd2ac <serialEventRun+0x34>)
   bd292:	b143      	cbz	r3, bd2a6 <serialEventRun+0x2e>
   bd294:	f000 feda 	bl	be04c <_Z22__fetch_global_Serial1v>
   bd298:	6803      	ldr	r3, [r0, #0]
   bd29a:	691b      	ldr	r3, [r3, #16]
   bd29c:	4798      	blx	r3
   bd29e:	2800      	cmp	r0, #0
   bd2a0:	dd01      	ble.n	bd2a6 <serialEventRun+0x2e>
        serialEvent1();
   bd2a2:	f3af 8000 	nop.w
}
   bd2a6:	bd08      	pop	{r3, pc}
	...

000bd2b0 <_post_loop>:
{
   bd2b0:	b508      	push	{r3, lr}
	serialEventRun();
   bd2b2:	f7ff ffe1 	bl	bd278 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
   bd2b6:	f7fc fd63 	bl	b9d80 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
   bd2ba:	4b01      	ldr	r3, [pc, #4]	; (bd2c0 <_post_loop+0x10>)
   bd2bc:	6018      	str	r0, [r3, #0]
}
   bd2be:	bd08      	pop	{r3, pc}
   bd2c0:	2003e740 	.word	0x2003e740

000bd2c4 <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   bd2c4:	4805      	ldr	r0, [pc, #20]	; (bd2dc <_Z33system_initialize_user_backup_ramv+0x18>)
   bd2c6:	4a06      	ldr	r2, [pc, #24]	; (bd2e0 <_Z33system_initialize_user_backup_ramv+0x1c>)
   bd2c8:	4906      	ldr	r1, [pc, #24]	; (bd2e4 <_Z33system_initialize_user_backup_ramv+0x20>)
{
   bd2ca:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
   bd2cc:	1a12      	subs	r2, r2, r0
   bd2ce:	f001 fdec 	bl	beeaa <memcpy>
    __backup_sram_signature = signature;
   bd2d2:	4b05      	ldr	r3, [pc, #20]	; (bd2e8 <_Z33system_initialize_user_backup_ramv+0x24>)
   bd2d4:	4a05      	ldr	r2, [pc, #20]	; (bd2ec <_Z33system_initialize_user_backup_ramv+0x28>)
   bd2d6:	601a      	str	r2, [r3, #0]
}
   bd2d8:	bd08      	pop	{r3, pc}
   bd2da:	bf00      	nop
   bd2dc:	2003f400 	.word	0x2003f400
   bd2e0:	2003f404 	.word	0x2003f404
   bd2e4:	000c2794 	.word	0x000c2794
   bd2e8:	2003f400 	.word	0x2003f400
   bd2ec:	9a271c1e 	.word	0x9a271c1e

000bd2f0 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
   bd2f0:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   bd2f2:	2300      	movs	r3, #0
   bd2f4:	9300      	str	r3, [sp, #0]
   bd2f6:	461a      	mov	r2, r3
   bd2f8:	f06f 0177 	mvn.w	r1, #119	; 0x77
   bd2fc:	f7fc ffcc 	bl	ba298 <system_ctrl_set_result>
}
   bd300:	b003      	add	sp, #12
   bd302:	f85d fb04 	ldr.w	pc, [sp], #4
	...

000bd308 <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
   bd308:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
   bd30a:	8843      	ldrh	r3, [r0, #2]
   bd30c:	2b0a      	cmp	r3, #10
   bd30e:	d008      	beq.n	bd322 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
   bd310:	2b50      	cmp	r3, #80	; 0x50
   bd312:	d10b      	bne.n	bd32c <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
   bd314:	4b09      	ldr	r3, [pc, #36]	; (bd33c <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
   bd316:	681b      	ldr	r3, [r3, #0]
   bd318:	b14b      	cbz	r3, bd32e <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
   bd31a:	b003      	add	sp, #12
   bd31c:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
   bd320:	4718      	bx	r3
        ctrl_request_custom_handler(req);
   bd322:	f7ff ffe5 	bl	bd2f0 <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
   bd326:	b003      	add	sp, #12
   bd328:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
   bd32c:	2300      	movs	r3, #0
   bd32e:	9300      	str	r3, [sp, #0]
   bd330:	461a      	mov	r2, r3
   bd332:	f06f 0177 	mvn.w	r1, #119	; 0x77
   bd336:	f7fc ffaf 	bl	ba298 <system_ctrl_set_result>
}
   bd33a:	e7f4      	b.n	bd326 <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
   bd33c:	2003e6d4 	.word	0x2003e6d4

000bd340 <module_user_init_hook>:
{
   bd340:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
   bd342:	4812      	ldr	r0, [pc, #72]	; (bd38c <module_user_init_hook+0x4c>)
   bd344:	2100      	movs	r1, #0
   bd346:	f7fd f8a9 	bl	ba49c <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
   bd34a:	4b11      	ldr	r3, [pc, #68]	; (bd390 <module_user_init_hook+0x50>)
   bd34c:	681a      	ldr	r2, [r3, #0]
   bd34e:	4b11      	ldr	r3, [pc, #68]	; (bd394 <module_user_init_hook+0x54>)
   bd350:	429a      	cmp	r2, r3
   bd352:	4b11      	ldr	r3, [pc, #68]	; (bd398 <module_user_init_hook+0x58>)
   bd354:	bf0c      	ite	eq
   bd356:	2201      	moveq	r2, #1
   bd358:	2200      	movne	r2, #0
   bd35a:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
   bd35c:	d001      	beq.n	bd362 <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
   bd35e:	f7ff ffb1 	bl	bd2c4 <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
   bd362:	f7fc fcf5 	bl	b9d50 <HAL_RNG_GetRandomNumber>
   bd366:	4604      	mov	r4, r0
    srand(seed);
   bd368:	f001 fdd0 	bl	bef0c <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
   bd36c:	4b0b      	ldr	r3, [pc, #44]	; (bd39c <module_user_init_hook+0x5c>)
   bd36e:	b113      	cbz	r3, bd376 <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
   bd370:	4620      	mov	r0, r4
   bd372:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
   bd376:	2100      	movs	r1, #0
   bd378:	4808      	ldr	r0, [pc, #32]	; (bd39c <module_user_init_hook+0x5c>)
   bd37a:	f7fd f82f 	bl	ba3dc <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
   bd37e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
   bd382:	4807      	ldr	r0, [pc, #28]	; (bd3a0 <module_user_init_hook+0x60>)
   bd384:	2100      	movs	r1, #0
   bd386:	f7fc bf7d 	b.w	ba284 <system_ctrl_set_app_request_handler>
   bd38a:	bf00      	nop
   bd38c:	000bd26d 	.word	0x000bd26d
   bd390:	2003f400 	.word	0x2003f400
   bd394:	9a271c1e 	.word	0x9a271c1e
   bd398:	2003e6d0 	.word	0x2003e6d0
   bd39c:	00000000 	.word	0x00000000
   bd3a0:	000bd309 	.word	0x000bd309

000bd3a4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   bd3a4:	4770      	bx	lr

000bd3a6 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      { return nullptr; }
   bd3a6:	2000      	movs	r0, #0
   bd3a8:	4770      	bx	lr

000bd3aa <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
   bd3aa:	b510      	push	{r4, lr}
   bd3ac:	2110      	movs	r1, #16
   bd3ae:	4604      	mov	r4, r0
   bd3b0:	f7f6 fe75 	bl	b409e <_ZdlPvj>
   bd3b4:	4620      	mov	r0, r4
   bd3b6:	bd10      	pop	{r4, pc}

000bd3b8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
   bd3b8:	b508      	push	{r3, lr}
      { delete this; }
   bd3ba:	f7ff fff6 	bl	bd3aa <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
   bd3be:	bd08      	pop	{r3, pc}

000bd3c0 <_ZN8particle5ErrorC1EOS0_>:

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
   bd3c0:	b530      	push	{r4, r5, lr}
        type_(type) {
   bd3c2:	2200      	movs	r2, #0
   bd3c4:	f64f 749c 	movw	r4, #65436	; 0xff9c
   bd3c8:	6002      	str	r2, [r0, #0]
   bd3ca:	8084      	strh	r4, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
   bd3cc:	888d      	ldrh	r5, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
   bd3ce:	808c      	strh	r4, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
   bd3d0:	680c      	ldr	r4, [r1, #0]
   bd3d2:	8085      	strh	r5, [r0, #4]
   bd3d4:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
   bd3d6:	600a      	str	r2, [r1, #0]
        Error() {
    swap(*this, error);
}
   bd3d8:	bd30      	pop	{r4, r5, pc}

000bd3da <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
   bd3da:	b510      	push	{r4, lr}
   bd3dc:	4604      	mov	r4, r0
    free((void*)msg_);
   bd3de:	6800      	ldr	r0, [r0, #0]
   bd3e0:	f7fd f80c 	bl	ba3fc <free>
}
   bd3e4:	4620      	mov	r0, r4
   bd3e6:	bd10      	pop	{r4, pc}

000bd3e8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
   bd3e8:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
   bd3ea:	68c4      	ldr	r4, [r0, #12]
   bd3ec:	b1f4      	cbz	r4, bd42c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>
      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
	_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
	__atomic_load(std::__addressof(_M_i), __ptr, int(__m));
   bd3ee:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
   bd3f0:	2b02      	cmp	r3, #2
   bd3f2:	d103      	bne.n	bd3fc <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
   bd3f4:	f104 000c 	add.w	r0, r4, #12
   bd3f8:	f7ff ffef 	bl	bd3da <_ZN8particle5ErrorD1Ev>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, int(__m));
   bd3fc:	6865      	ldr	r5, [r4, #4]
        delete onSuccess_.load(std::memory_order_relaxed);
   bd3fe:	b135      	cbz	r5, bd40e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
    class function<_Res(_ArgTypes...)>
   bd400:	4628      	mov	r0, r5
   bd402:	f7f7 f82d 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bd406:	2110      	movs	r1, #16
   bd408:	4628      	mov	r0, r5
   bd40a:	f7f6 fe48 	bl	b409e <_ZdlPvj>
   bd40e:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
   bd410:	b135      	cbz	r5, bd420 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
   bd412:	4628      	mov	r0, r5
   bd414:	f7f7 f824 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
   bd418:	2110      	movs	r1, #16
   bd41a:	4628      	mov	r0, r5
   bd41c:	f7f6 fe3f 	bl	b409e <_ZdlPvj>
   bd420:	4620      	mov	r0, r4
   bd422:	2114      	movs	r1, #20
   bd424:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   bd428:	f7f6 be39 	b.w	b409e <_ZdlPvj>
   bd42c:	bd38      	pop	{r3, r4, r5, pc}

000bd42e <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
    }
    return CloudDisconnectOptions(options->flags, options->timeout, options->graceful, clearSession);
}

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
   bd42e:	b510      	push	{r4, lr}
   bd430:	b088      	sub	sp, #32
   bd432:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
   bd434:	4668      	mov	r0, sp
   bd436:	f7fd f9a2 	bl	ba77e <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
   bd43a:	4669      	mov	r1, sp
   bd43c:	a804      	add	r0, sp, #16
   bd43e:	f7fd f9e9 	bl	ba814 <_ZN6StringC1ERKS_>
   bd442:	a804      	add	r0, sp, #16
   bd444:	47a0      	blx	r4
   bd446:	4604      	mov	r4, r0
   bd448:	a804      	add	r0, sp, #16
   bd44a:	f7fd f94d 	bl	ba6e8 <_ZN6StringD1Ev>
    String p(param);
   bd44e:	4668      	mov	r0, sp
   bd450:	f7fd f94a 	bl	ba6e8 <_ZN6StringD1Ev>
}
   bd454:	4620      	mov	r0, r4
   bd456:	b008      	add	sp, #32
   bd458:	bd10      	pop	{r4, pc}

000bd45a <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
   bd45a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
   bd45c:	2300      	movs	r3, #0
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
   bd45e:	e9cd 0102 	strd	r0, r1, [sp, #8]
    desc.funcKey = funcKey;
   bd462:	9201      	str	r2, [sp, #4]
         size = sizeof(*this);
   bd464:	2410      	movs	r4, #16
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
   bd466:	461a      	mov	r2, r3
   bd468:	4669      	mov	r1, sp
   bd46a:	4618      	mov	r0, r3
         memset(this, 0, sizeof(*this));
   bd46c:	f8ad 3002 	strh.w	r3, [sp, #2]
         size = sizeof(*this);
   bd470:	f8ad 4000 	strh.w	r4, [sp]
   bd474:	f7fc ff7a 	bl	ba36c <spark_function>
}
   bd478:	b004      	add	sp, #16
   bd47a:	bd10      	pop	{r4, pc}

000bd47c <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>:
      __shared_ptr(const __shared_ptr&) noexcept = default;
   bd47c:	680b      	ldr	r3, [r1, #0]
   bd47e:	6003      	str	r3, [r0, #0]
      : _M_pi(__r._M_pi)
   bd480:	684b      	ldr	r3, [r1, #4]
   bd482:	6043      	str	r3, [r0, #4]
	if (_M_pi != 0)
   bd484:	b113      	cbz	r3, bd48c <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_+0x10>
    { ++_M_use_count; }
   bd486:	685a      	ldr	r2, [r3, #4]
   bd488:	3201      	adds	r2, #1
   bd48a:	605a      	str	r2, [r3, #4]
      __shared_ptr(const __shared_ptr&) noexcept = default;
   bd48c:	4770      	bx	lr

000bd48e <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
   bd48e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   bd490:	4604      	mov	r4, r0
   bd492:	4668      	mov	r0, sp
   bd494:	460d      	mov	r5, r1
   bd496:	f7ff fff1 	bl	bd47c <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
      : _M_ptr(__r._M_ptr), _M_refcount()
   bd49a:	9b00      	ldr	r3, [sp, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   bd49c:	9a01      	ldr	r2, [sp, #4]
      : _M_ptr(__r._M_ptr), _M_refcount()
   bd49e:	6023      	str	r3, [r4, #0]
	_M_pi = __tmp;
   bd4a0:	6062      	str	r2, [r4, #4]
	__r._M_pi = _M_pi;
   bd4a2:	2300      	movs	r3, #0
      ~__shared_ptr() = default;
   bd4a4:	a801      	add	r0, sp, #4
	__r._M_pi = _M_pi;
   bd4a6:	9301      	str	r3, [sp, #4]
	__r._M_ptr = 0;
   bd4a8:	9300      	str	r3, [sp, #0]
      ~__shared_ptr() = default;
   bd4aa:	f7fe f8a2 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
        delete d;
   bd4ae:	b135      	cbz	r5, bd4be <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv+0x30>
   bd4b0:	1d28      	adds	r0, r5, #4
   bd4b2:	f7fe f89e 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bd4b6:	2108      	movs	r1, #8
   bd4b8:	4628      	mov	r0, r5
   bd4ba:	f7f6 fdf0 	bl	b409e <_ZdlPvj>
        return p;
    }
   bd4be:	4620      	mov	r0, r4
   bd4c0:	b003      	add	sp, #12
   bd4c2:	bd30      	pop	{r4, r5, pc}

000bd4c4 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
      if (_M_empty())
   bd4c4:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
   bd4c6:	b510      	push	{r4, lr}
      if (_M_empty())
   bd4c8:	b90a      	cbnz	r2, bd4ce <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
   bd4ca:	f000 fe46 	bl	be15a <_ZSt25__throw_bad_function_callv>
    }
   bd4ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bd4d2:	68c3      	ldr	r3, [r0, #12]
   bd4d4:	4718      	bx	r3

000bd4d6 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   bd4d6:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
   bd4d8:	6800      	ldr	r0, [r0, #0]
   bd4da:	f100 0110 	add.w	r1, r0, #16
   bd4de:	f7ff fff1 	bl	bd4c4 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
      }
   bd4e2:	bd08      	pop	{r3, pc}

000bd4e4 <_ZNKSt8functionIFvRKbEEclES1_>:
      if (_M_empty())
   bd4e4:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
   bd4e6:	b510      	push	{r4, lr}
      if (_M_empty())
   bd4e8:	b90a      	cbnz	r2, bd4ee <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
   bd4ea:	f000 fe36 	bl	be15a <_ZSt25__throw_bad_function_callv>
    }
   bd4ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bd4f2:	68c3      	ldr	r3, [r0, #12]
   bd4f4:	4718      	bx	r3

000bd4f6 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
   bd4f6:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
   bd4f8:	6800      	ldr	r0, [r0, #0]
   bd4fa:	f100 0110 	add.w	r1, r0, #16
   bd4fe:	f7ff fff1 	bl	bd4e4 <_ZNKSt8functionIFvRKbEEclES1_>
      }
   bd502:	bd08      	pop	{r3, pc}

000bd504 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
	__shared_count(_Ptr __p) : _M_pi(0)
   bd504:	b538      	push	{r3, r4, r5, lr}
   bd506:	2300      	movs	r3, #0
   bd508:	4604      	mov	r4, r0
   bd50a:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   bd50c:	2010      	movs	r0, #16
	__shared_count(_Ptr __p) : _M_pi(0)
   bd50e:	460d      	mov	r5, r1
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   bd510:	f7f6 fdc1 	bl	b4096 <_Znwj>
   bd514:	b128      	cbz	r0, bd522 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
      : _M_use_count(1), _M_weak_count(1) { }
   bd516:	2301      	movs	r3, #1
   bd518:	e9c0 3301 	strd	r3, r3, [r0, #4]
      : _M_ptr(__p) { }
   bd51c:	4b02      	ldr	r3, [pc, #8]	; (bd528 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
   bd51e:	6003      	str	r3, [r0, #0]
   bd520:	60c5      	str	r5, [r0, #12]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
   bd522:	6020      	str	r0, [r4, #0]
	}
   bd524:	4620      	mov	r0, r4
   bd526:	bd38      	pop	{r3, r4, r5, pc}
   bd528:	000c2098 	.word	0x000c2098

000bd52c <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
    function<_Res(_ArgTypes...)>::
   bd52c:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
   bd52e:	2300      	movs	r3, #0
   bd530:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
   bd532:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
   bd534:	4604      	mov	r4, r0
   bd536:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
   bd538:	b12b      	cbz	r3, bd546 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   bd53a:	2202      	movs	r2, #2
   bd53c:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   bd53e:	68eb      	ldr	r3, [r5, #12]
   bd540:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   bd542:	68ab      	ldr	r3, [r5, #8]
   bd544:	60a3      	str	r3, [r4, #8]
    }
   bd546:	4620      	mov	r0, r4
   bd548:	bd38      	pop	{r3, r4, r5, pc}
	...

000bd54c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:
    void setError(Error error) {
   bd54c:	b5f0      	push	{r4, r5, r6, r7, lr}
   bd54e:	b089      	sub	sp, #36	; 0x24
      { return _M_ptr; }
   bd550:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
   bd552:	4668      	mov	r0, sp
   bd554:	f7ff ff34 	bl	bd3c0 <_ZN8particle5ErrorC1EOS0_>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(std::__addressof(_M_i),
   bd558:	f04f 0302 	mov.w	r3, #2
   bd55c:	e8d4 2f4f 	ldrexb	r2, [r4]
   bd560:	2a00      	cmp	r2, #0
   bd562:	d103      	bne.n	bd56c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
   bd564:	e8c4 3f41 	strexb	r1, r3, [r4]
   bd568:	2900      	cmp	r1, #0
   bd56a:	d1f7      	bne.n	bd55c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x10>
        if (this->changeState(State::FAILED)) {
   bd56c:	d125      	bne.n	bd5ba <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
            new(&error_) Error(std::move(error));
   bd56e:	f104 050c 	add.w	r5, r4, #12
   bd572:	4669      	mov	r1, sp
   bd574:	4628      	mov	r0, r5
   bd576:	f7ff ff23 	bl	bd3c0 <_ZN8particle5ErrorC1EOS0_>
	__atomic_store_n(&_M_i, __i, int(__m));
   bd57a:	f3bf 8f5b 	dmb	ish
   bd57e:	2301      	movs	r3, #1
   bd580:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, int(__m));
   bd582:	2000      	movs	r0, #0
   bd584:	f104 0308 	add.w	r3, r4, #8
   bd588:	f3bf 8f5b 	dmb	ish
   bd58c:	e853 6f00 	ldrex	r6, [r3]
   bd590:	e843 0200 	strex	r2, r0, [r3]
   bd594:	2a00      	cmp	r2, #0
   bd596:	d1f9      	bne.n	bd58c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x40>
   bd598:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
   bd59c:	b16e      	cbz	r6, bd5ba <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
        return (application_thread_current(nullptr) != 0);
   bd59e:	f7fc fe59 	bl	ba254 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
   bd5a2:	b178      	cbz	r0, bd5c4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x78>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   bd5a4:	4629      	mov	r1, r5
   bd5a6:	4630      	mov	r0, r6
   bd5a8:	f7ff ff8c 	bl	bd4c4 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
    class function<_Res(_ArgTypes...)>
   bd5ac:	4630      	mov	r0, r6
   bd5ae:	f7f6 ff57 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
   bd5b2:	2110      	movs	r1, #16
   bd5b4:	4630      	mov	r0, r6
   bd5b6:	f7f6 fd72 	bl	b409e <_ZdlPvj>
        p_->setError(std::move(error));
   bd5ba:	4668      	mov	r0, sp
   bd5bc:	f7ff ff0d 	bl	bd3da <_ZN8particle5ErrorD1Ev>
    }
   bd5c0:	b009      	add	sp, #36	; 0x24
   bd5c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   bd5c4:	4631      	mov	r1, r6
   bd5c6:	a802      	add	r0, sp, #8
   bd5c8:	f7ff ffb0 	bl	bd52c <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
   bd5cc:	68e0      	ldr	r0, [r4, #12]
   bd5ce:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   bd5d2:	b108      	cbz	r0, bd5d8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x8c>
   bd5d4:	f001 fcea 	bl	befac <strdup>
        type_(type) {
   bd5d8:	9006      	str	r0, [sp, #24]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   bd5da:	2010      	movs	r0, #16
   bd5dc:	f8ad 501c 	strh.w	r5, [sp, #28]
   bd5e0:	f7f6 fd59 	bl	b4096 <_Znwj>
   bd5e4:	4605      	mov	r5, r0
   bd5e6:	b1e8      	cbz	r0, bd624 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd8>
    _Function_base() : _M_manager(nullptr) { }
   bd5e8:	2700      	movs	r7, #0
   bd5ea:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bd5ec:	2018      	movs	r0, #24
   bd5ee:	f7f6 fd52 	bl	b4096 <_Znwj>
   bd5f2:	4604      	mov	r4, r0
   bd5f4:	b188      	cbz	r0, bd61a <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xce>
	std::swap(_M_functor, __x._M_functor);
   bd5f6:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
   bd5f8:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
   bd5fa:	a802      	add	r0, sp, #8
   bd5fc:	f7fe feae 	bl	bc35c <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bd600:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
   bd602:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   bd604:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bd606:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
   bd608:	9204      	str	r2, [sp, #16]
   bd60a:	a906      	add	r1, sp, #24
   bd60c:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   bd60e:	60e3      	str	r3, [r4, #12]
   bd610:	f104 0010 	add.w	r0, r4, #16
      __a = _GLIBCXX_MOVE(__b);
   bd614:	9205      	str	r2, [sp, #20]
   bd616:	f7ff fed3 	bl	bd3c0 <_ZN8particle5ErrorC1EOS0_>
	    _M_invoker = &_My_handler::_M_invoke;
   bd61a:	4b08      	ldr	r3, [pc, #32]	; (bd63c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf0>)
   bd61c:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   bd61e:	4b08      	ldr	r3, [pc, #32]	; (bd640 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf4>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bd620:	602c      	str	r4, [r5, #0]
	    _M_manager = &_My_handler::_M_manager;
   bd622:	60ab      	str	r3, [r5, #8]
    struct _Head_base<_Idx, _Head, false>
   bd624:	a806      	add	r0, sp, #24
   bd626:	f7ff fed8 	bl	bd3da <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
   bd62a:	a802      	add	r0, sp, #8
   bd62c:	f7f6 ff18 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
   bd630:	2200      	movs	r2, #0
   bd632:	4629      	mov	r1, r5
   bd634:	4803      	ldr	r0, [pc, #12]	; (bd644 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf8>)
   bd636:	f7fc fe15 	bl	ba264 <application_thread_invoke>
   bd63a:	e7b7      	b.n	bd5ac <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x60>
   bd63c:	000bd4d7 	.word	0x000bd4d7
   bd640:	000bd759 	.word	0x000bd759
   bd644:	000bdcbb 	.word	0x000bdcbb

000bd648 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
   bd648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   bd64c:	b08b      	sub	sp, #44	; 0x2c
   bd64e:	4605      	mov	r5, r0
   bd650:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
   bd654:	460f      	mov	r7, r1
   bd656:	4690      	mov	r8, r2
   bd658:	4699      	mov	r9, r3
    static bool connected(void) { return spark_cloud_flag_connected(); }
   bd65a:	f7fc fe9f 	bl	ba39c <spark_cloud_flag_connected>
   bd65e:	ae07      	add	r6, sp, #28
    if (!connected()) {
   bd660:	4683      	mov	fp, r0
   bd662:	bb38      	cbnz	r0, bd6b4 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6c>
        type_(type) {
   bd664:	f64f 732e 	movw	r3, #65326	; 0xff2e
   bd668:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   bd66a:	a905      	add	r1, sp, #20
   bd66c:	4630      	mov	r0, r6
   bd66e:	f8ad 3018 	strh.w	r3, [sp, #24]
   bd672:	f7ff fea5 	bl	bd3c0 <_ZN8particle5ErrorC1EOS0_>
   bd676:	2014      	movs	r0, #20
   bd678:	f7f6 fd0d 	bl	b4096 <_Znwj>
   bd67c:	4604      	mov	r4, r0
   bd67e:	b148      	cbz	r0, bd694 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x4c>
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
   bd680:	2302      	movs	r3, #2
   bd682:	7003      	strb	r3, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   bd684:	2301      	movs	r3, #1
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   bd686:	e9c0 bb01 	strd	fp, fp, [r0, #4]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   bd68a:	7043      	strb	r3, [r0, #1]
            error_(std::move(error)) {
   bd68c:	4631      	mov	r1, r6
   bd68e:	300c      	adds	r0, #12
   bd690:	f7ff fe96 	bl	bd3c0 <_ZN8particle5ErrorC1EOS0_>
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   bd694:	4628      	mov	r0, r5
	: __shared_count(__p)
   bd696:	4621      	mov	r1, r4
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   bd698:	f840 4b04 	str.w	r4, [r0], #4
	: __shared_count(__p)
   bd69c:	f7ff ff32 	bl	bd504 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
   bd6a0:	4630      	mov	r0, r6
   bd6a2:	f7ff fe9a 	bl	bd3da <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
   bd6a6:	a805      	add	r0, sp, #20
   bd6a8:	f7ff fe97 	bl	bd3da <_ZN8particle5ErrorD1Ev>
        p.setError(Error::UNKNOWN);
        p.fromDataPtr(d.handler_data); // Free wrapper object
    }

    return p.future();
}
   bd6ac:	4628      	mov	r0, r5
   bd6ae:	b00b      	add	sp, #44	; 0x2c
   bd6b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d.size = sizeof(spark_send_event_data);
   bd6b4:	230c      	movs	r3, #12
    spark_send_event_data d = {};
   bd6b6:	2400      	movs	r4, #0
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
   bd6b8:	2014      	movs	r0, #20
   bd6ba:	e9cd 4408 	strd	r4, r4, [sp, #32]
    d.size = sizeof(spark_send_event_data);
   bd6be:	9307      	str	r3, [sp, #28]
   bd6c0:	f7f6 fce9 	bl	b4096 <_Znwj>
   bd6c4:	4601      	mov	r1, r0
   bd6c6:	b118      	cbz	r0, bd6d0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x88>
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
   bd6c8:	e9c0 4401 	strd	r4, r4, [r0, #4]
   bd6cc:	7004      	strb	r4, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
   bd6ce:	7044      	strb	r4, [r0, #1]
   bd6d0:	a804      	add	r0, sp, #16
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
   bd6d2:	9103      	str	r1, [sp, #12]
	: __shared_count(__p)
   bd6d4:	f7ff ff16 	bl	bd504 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    d.handler_callback = publishCompletionCallback;
   bd6d8:	4b1e      	ldr	r3, [pc, #120]	; (bd754 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x10c>)
   bd6da:	9308      	str	r3, [sp, #32]
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
   bd6dc:	2008      	movs	r0, #8
   bd6de:	f7f6 fcda 	bl	b4096 <_Znwj>
   bd6e2:	4604      	mov	r4, r0
   bd6e4:	b110      	cbz	r0, bd6ec <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xa4>
   bd6e6:	a903      	add	r1, sp, #12
   bd6e8:	f7ff fec8 	bl	bd47c <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   bd6ec:	9600      	str	r6, [sp, #0]
   bd6ee:	fa5f f38a 	uxtb.w	r3, sl
   bd6f2:	464a      	mov	r2, r9
   bd6f4:	4641      	mov	r1, r8
   bd6f6:	4638      	mov	r0, r7
    d.handler_data = p.dataPtr();
   bd6f8:	9409      	str	r4, [sp, #36]	; 0x24
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
   bd6fa:	f7fc fe57 	bl	ba3ac <spark_send_event>
   bd6fe:	b9b8      	cbnz	r0, bd730 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe8>
	return __atomic_load_n(&_M_i, int(__m));
   bd700:	9b03      	ldr	r3, [sp, #12]
   bd702:	785b      	ldrb	r3, [r3, #1]
   bd704:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   bd708:	b993      	cbnz	r3, bd730 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe8>
   bd70a:	f64f 739c 	movw	r3, #65436	; 0xff9c
        p.setError(Error::UNKNOWN);
   bd70e:	a905      	add	r1, sp, #20
   bd710:	a803      	add	r0, sp, #12
   bd712:	9205      	str	r2, [sp, #20]
   bd714:	f8ad 3018 	strh.w	r3, [sp, #24]
   bd718:	f7ff ff18 	bl	bd54c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   bd71c:	a805      	add	r0, sp, #20
   bd71e:	f7ff fe5c 	bl	bd3da <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
   bd722:	a805      	add	r0, sp, #20
   bd724:	9909      	ldr	r1, [sp, #36]	; 0x24
   bd726:	f7ff feb2 	bl	bd48e <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      ~__shared_ptr() = default;
   bd72a:	a806      	add	r0, sp, #24
   bd72c:	f7fd ff61 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bd730:	a903      	add	r1, sp, #12
   bd732:	a805      	add	r0, sp, #20
   bd734:	f7ff fea2 	bl	bd47c <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
      : _M_ptr(__r._M_ptr), _M_refcount()
   bd738:	9b05      	ldr	r3, [sp, #20]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
   bd73a:	9a06      	ldr	r2, [sp, #24]
      : _M_ptr(__r._M_ptr), _M_refcount()
   bd73c:	602b      	str	r3, [r5, #0]
	_M_pi = __tmp;
   bd73e:	606a      	str	r2, [r5, #4]
	__r._M_pi = _M_pi;
   bd740:	2300      	movs	r3, #0
      ~__shared_ptr() = default;
   bd742:	a806      	add	r0, sp, #24
	__r._M_pi = _M_pi;
   bd744:	9306      	str	r3, [sp, #24]
	__r._M_ptr = 0;
   bd746:	9305      	str	r3, [sp, #20]
      ~__shared_ptr() = default;
   bd748:	f7fd ff53 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
   bd74c:	a804      	add	r0, sp, #16
   bd74e:	f7fd ff50 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
class Promise: public PromiseBase<ResultT, ContextT> {
   bd752:	e7ab      	b.n	bd6ac <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x64>
   bd754:	000bd7d5 	.word	0x000bd7d5

000bd758 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
	switch (__op)
   bd758:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   bd75a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bd75c:	4605      	mov	r5, r0
	switch (__op)
   bd75e:	d103      	bne.n	bd768 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
   bd760:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
   bd762:	6003      	str	r3, [r0, #0]
      }
   bd764:	2000      	movs	r0, #0
   bd766:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  switch (__op)
   bd768:	2a02      	cmp	r2, #2
   bd76a:	d010      	beq.n	bd78e <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x36>
   bd76c:	2a03      	cmp	r2, #3
   bd76e:	d1f9      	bne.n	bd764 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
   bd770:	6804      	ldr	r4, [r0, #0]
   bd772:	2c00      	cmp	r4, #0
   bd774:	d0f6      	beq.n	bd764 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
   bd776:	f104 0010 	add.w	r0, r4, #16
   bd77a:	f7ff fe2e 	bl	bd3da <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
   bd77e:	4620      	mov	r0, r4
   bd780:	f7f6 fe6e 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
   bd784:	2118      	movs	r1, #24
   bd786:	4620      	mov	r0, r4
   bd788:	f7f6 fc89 	bl	b409e <_ZdlPvj>
   bd78c:	e7ea      	b.n	bd764 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
   bd78e:	2018      	movs	r0, #24
	  __dest._M_access<_Functor*>() =
   bd790:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
   bd792:	f7f6 fc80 	bl	b4096 <_Znwj>
   bd796:	4604      	mov	r4, r0
   bd798:	b150      	cbz	r0, bd7b0 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x58>
      _Bind(const _Bind&) = default;
   bd79a:	4631      	mov	r1, r6
   bd79c:	f7ff fec6 	bl	bd52c <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
   bd7a0:	6930      	ldr	r0, [r6, #16]
   bd7a2:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   bd7a6:	b108      	cbz	r0, bd7ac <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x54>
   bd7a8:	f001 fc00 	bl	befac <strdup>
        type_(type) {
   bd7ac:	6120      	str	r0, [r4, #16]
   bd7ae:	82a7      	strh	r7, [r4, #20]
	  __dest._M_access<_Functor*>() =
   bd7b0:	602c      	str	r4, [r5, #0]
	}
   bd7b2:	e7d7      	b.n	bd764 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>

000bd7b4 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
    function<_Res(_ArgTypes...)>::
   bd7b4:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
   bd7b6:	2300      	movs	r3, #0
   bd7b8:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
   bd7ba:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
   bd7bc:	4604      	mov	r4, r0
   bd7be:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
   bd7c0:	b12b      	cbz	r3, bd7ce <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   bd7c2:	2202      	movs	r2, #2
   bd7c4:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
   bd7c6:	68eb      	ldr	r3, [r5, #12]
   bd7c8:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
   bd7ca:	68ab      	ldr	r3, [r5, #8]
   bd7cc:	60a3      	str	r3, [r4, #8]
    }
   bd7ce:	4620      	mov	r0, r4
   bd7d0:	bd38      	pop	{r3, r4, r5, pc}
	...

000bd7d4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
   bd7d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   bd7d6:	b089      	sub	sp, #36	; 0x24
   bd7d8:	4604      	mov	r4, r0
   bd7da:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
   bd7dc:	a801      	add	r0, sp, #4
   bd7de:	4611      	mov	r1, r2
   bd7e0:	f7ff fe55 	bl	bd48e <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
   bd7e4:	b1a4      	cbz	r4, bd810 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
        p.setError(Error((Error::Type)error, (const char*)data));
   bd7e6:	b224      	sxth	r4, r4
        msg_(msg ? (const char*)strdup(msg) : nullptr),
   bd7e8:	b11d      	cbz	r5, bd7f2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1e>
   bd7ea:	4628      	mov	r0, r5
   bd7ec:	f001 fbde 	bl	befac <strdup>
   bd7f0:	4605      	mov	r5, r0
   bd7f2:	a801      	add	r0, sp, #4
   bd7f4:	a903      	add	r1, sp, #12
        type_(type) {
   bd7f6:	9503      	str	r5, [sp, #12]
   bd7f8:	f8ad 4010 	strh.w	r4, [sp, #16]
   bd7fc:	f7ff fea6 	bl	bd54c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
   bd800:	a803      	add	r0, sp, #12
   bd802:	f7ff fdea 	bl	bd3da <_ZN8particle5ErrorD1Ev>
   bd806:	a802      	add	r0, sp, #8
   bd808:	f7fd fef3 	bl	bb5f2 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
   bd80c:	b009      	add	sp, #36	; 0x24
   bd80e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      { return _M_ptr; }
   bd810:	9d01      	ldr	r5, [sp, #4]
	return __atomic_compare_exchange(std::__addressof(_M_i),
   bd812:	2301      	movs	r3, #1
   bd814:	e8d5 2f4f 	ldrexb	r2, [r5]
   bd818:	2a00      	cmp	r2, #0
   bd81a:	d103      	bne.n	bd824 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x50>
   bd81c:	e8c5 3f41 	strexb	r1, r3, [r5]
   bd820:	2900      	cmp	r1, #0
   bd822:	d1f7      	bne.n	bd814 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x40>
        if (this->changeState(State::SUCCEEDED)) {
   bd824:	d1ef      	bne.n	bd806 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
            new(&result_) ResultT(std::move(result));
   bd826:	732b      	strb	r3, [r5, #12]
	__atomic_store_n(&_M_i, __i, int(__m));
   bd828:	f3bf 8f5b 	dmb	ish
   bd82c:	706b      	strb	r3, [r5, #1]
	return __atomic_exchange_n(&_M_p, __p, int(__m));
   bd82e:	1d2b      	adds	r3, r5, #4
   bd830:	f3bf 8f5b 	dmb	ish
   bd834:	e853 6f00 	ldrex	r6, [r3]
   bd838:	e843 4200 	strex	r2, r4, [r3]
   bd83c:	2a00      	cmp	r2, #0
   bd83e:	d1f9      	bne.n	bd834 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x60>
   bd840:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
   bd844:	2e00      	cmp	r6, #0
   bd846:	d0de      	beq.n	bd806 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        return (application_thread_current(nullptr) != 0);
   bd848:	4620      	mov	r0, r4
   bd84a:	f7fc fd03 	bl	ba254 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
   bd84e:	4607      	mov	r7, r0
   bd850:	b160      	cbz	r0, bd86c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x98>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
   bd852:	f105 010c 	add.w	r1, r5, #12
   bd856:	4630      	mov	r0, r6
   bd858:	f7ff fe44 	bl	bd4e4 <_ZNKSt8functionIFvRKbEEclES1_>
    class function<_Res(_ArgTypes...)>
   bd85c:	4630      	mov	r0, r6
   bd85e:	f7f6 fdff 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
   bd862:	2110      	movs	r1, #16
   bd864:	4630      	mov	r0, r6
   bd866:	f7f6 fc1a 	bl	b409e <_ZdlPvj>
   bd86a:	e7cc      	b.n	bd806 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
   bd86c:	4631      	mov	r1, r6
   bd86e:	a803      	add	r0, sp, #12
   bd870:	f7ff ffa0 	bl	bd7b4 <_ZNSt8functionIFvRKbEEC1ERKS3_>
	: _M_head_impl(std::forward<_UHead>(__h)) { }
   bd874:	7b2b      	ldrb	r3, [r5, #12]
   bd876:	f88d 301c 	strb.w	r3, [sp, #28]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
   bd87a:	2010      	movs	r0, #16
   bd87c:	f7f6 fc0b 	bl	b4096 <_Znwj>
   bd880:	4605      	mov	r5, r0
   bd882:	b1d0      	cbz	r0, bd8ba <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xe6>
    _Function_base() : _M_manager(nullptr) { }
   bd884:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bd886:	2014      	movs	r0, #20
   bd888:	f7f6 fc05 	bl	b4096 <_Znwj>
   bd88c:	4604      	mov	r4, r0
   bd88e:	b178      	cbz	r0, bd8b0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xdc>
    _Function_base() : _M_manager(nullptr) { }
   bd890:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
   bd892:	4601      	mov	r1, r0
   bd894:	a803      	add	r0, sp, #12
   bd896:	f7fe fd61 	bl	bc35c <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bd89a:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
   bd89c:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
   bd89e:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
   bd8a0:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
   bd8a2:	9205      	str	r2, [sp, #20]
   bd8a4:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
   bd8a6:	60e3      	str	r3, [r4, #12]
   bd8a8:	f89d 301c 	ldrb.w	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
   bd8ac:	9206      	str	r2, [sp, #24]
   bd8ae:	7423      	strb	r3, [r4, #16]
	    _M_invoker = &_My_handler::_M_invoke;
   bd8b0:	4b06      	ldr	r3, [pc, #24]	; (bd8cc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xf8>)
   bd8b2:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
   bd8b4:	4b06      	ldr	r3, [pc, #24]	; (bd8d0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xfc>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
   bd8b6:	602c      	str	r4, [r5, #0]
	    _M_manager = &_My_handler::_M_manager;
   bd8b8:	60ab      	str	r3, [r5, #8]
    class function<_Res(_ArgTypes...)>
   bd8ba:	a803      	add	r0, sp, #12
   bd8bc:	f7f6 fdd0 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
   bd8c0:	2200      	movs	r2, #0
   bd8c2:	4629      	mov	r1, r5
   bd8c4:	4803      	ldr	r0, [pc, #12]	; (bd8d4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x100>)
   bd8c6:	f7fc fccd 	bl	ba264 <application_thread_invoke>
   bd8ca:	e7c7      	b.n	bd85c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x88>
   bd8cc:	000bd4f7 	.word	0x000bd4f7
   bd8d0:	000bd8d9 	.word	0x000bd8d9
   bd8d4:	000bdcbb 	.word	0x000bdcbb

000bd8d8 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
	switch (__op)
   bd8d8:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   bd8da:	b570      	push	{r4, r5, r6, lr}
   bd8dc:	4604      	mov	r4, r0
	switch (__op)
   bd8de:	d103      	bne.n	bd8e8 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
   bd8e0:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
   bd8e2:	6003      	str	r3, [r0, #0]
      }
   bd8e4:	2000      	movs	r0, #0
   bd8e6:	bd70      	pop	{r4, r5, r6, pc}
	  switch (__op)
   bd8e8:	2a02      	cmp	r2, #2
   bd8ea:	d00c      	beq.n	bd906 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2e>
   bd8ec:	2a03      	cmp	r2, #3
   bd8ee:	d1f9      	bne.n	bd8e4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
   bd8f0:	6804      	ldr	r4, [r0, #0]
   bd8f2:	2c00      	cmp	r4, #0
   bd8f4:	d0f6      	beq.n	bd8e4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
    class function<_Res(_ArgTypes...)>
   bd8f6:	4620      	mov	r0, r4
   bd8f8:	f7f6 fdb2 	bl	b4460 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
   bd8fc:	2114      	movs	r1, #20
   bd8fe:	4620      	mov	r0, r4
   bd900:	f7f6 fbcd 	bl	b409e <_ZdlPvj>
   bd904:	e7ee      	b.n	bd8e4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
   bd906:	2014      	movs	r0, #20
	  __dest._M_access<_Functor*>() =
   bd908:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
   bd90a:	f7f6 fbc4 	bl	b4096 <_Znwj>
   bd90e:	4605      	mov	r5, r0
   bd910:	b120      	cbz	r0, bd91c <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x44>
      _Bind(const _Bind&) = default;
   bd912:	4631      	mov	r1, r6
   bd914:	f7ff ff4e 	bl	bd7b4 <_ZNSt8functionIFvRKbEEC1ERKS3_>
   bd918:	7c33      	ldrb	r3, [r6, #16]
   bd91a:	742b      	strb	r3, [r5, #16]
	  __dest._M_access<_Functor*>() =
   bd91c:	6025      	str	r5, [r4, #0]
	}
   bd91e:	e7e1      	b.n	bd8e4 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>

000bd920 <_ZN9IPAddressD1Ev>:
    IPAddress(uint32_t address);
    // 4 bytes defining the IP address in network order
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
   bd920:	4770      	bx	lr

000bd922 <_ZN9IPAddressD0Ev>:
   bd922:	b510      	push	{r4, lr}
   bd924:	2118      	movs	r1, #24
   bd926:	4604      	mov	r4, r0
   bd928:	f7f6 fbb9 	bl	b409e <_ZdlPvj>
   bd92c:	4620      	mov	r0, r4
   bd92e:	bd10      	pop	{r4, pc}

000bd930 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
   bd930:	b5f0      	push	{r4, r5, r6, r7, lr}
#if Wiring_IPv6
#if HAL_USE_INET_HAL_POSIX
	if (address.v==6) {
   bd932:	7d03      	ldrb	r3, [r0, #20]
   bd934:	2b06      	cmp	r3, #6
{
   bd936:	b08d      	sub	sp, #52	; 0x34
   bd938:	460e      	mov	r6, r1
		char buf[INET6_ADDRSTRLEN+1];
		buf[0] = 0;
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   bd93a:	f100 0704 	add.w	r7, r0, #4
   bd93e:	f04f 0400 	mov.w	r4, #0
	if (address.v==6) {
   bd942:	d012      	beq.n	bd96a <_ZNK9IPAddress7printToER5Print+0x3a>
   bd944:	f100 0508 	add.w	r5, r0, #8
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
   bd948:	f815 1d01 	ldrb.w	r1, [r5, #-1]!
   bd94c:	220a      	movs	r2, #10
   bd94e:	4630      	mov	r0, r6
   bd950:	f7ff fb33 	bl	bcfba <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
   bd954:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
   bd956:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
   bd958:	d019      	beq.n	bd98e <_ZNK9IPAddress7printToER5Print+0x5e>
        if (n)
   bd95a:	2c00      	cmp	r4, #0
   bd95c:	d0f4      	beq.n	bd948 <_ZNK9IPAddress7printToER5Print+0x18>
            n += p.print('.');
   bd95e:	212e      	movs	r1, #46	; 0x2e
   bd960:	4630      	mov	r0, r6
   bd962:	f7ff fb11 	bl	bcf88 <_ZN5Print5printEc>
   bd966:	4404      	add	r4, r0
   bd968:	e7ee      	b.n	bd948 <_ZNK9IPAddress7printToER5Print+0x18>
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   bd96a:	232f      	movs	r3, #47	; 0x2f
   bd96c:	466a      	mov	r2, sp
   bd96e:	4639      	mov	r1, r7
   bd970:	200a      	movs	r0, #10
		buf[0] = 0;
   bd972:	f88d 4000 	strb.w	r4, [sp]
		inet_inet_ntop(AF_INET6, address.ipv6, buf, sizeof(buf));
   bd976:	f7fc fb15 	bl	b9fa4 <inet_inet_ntop>
      return write((const uint8_t *)str, strlen(str));
   bd97a:	4668      	mov	r0, sp
   bd97c:	f001 fb33 	bl	befe6 <strlen>
   bd980:	6833      	ldr	r3, [r6, #0]
   bd982:	4602      	mov	r2, r0
   bd984:	68db      	ldr	r3, [r3, #12]
   bd986:	4669      	mov	r1, sp
   bd988:	4630      	mov	r0, r6
   bd98a:	4798      	blx	r3
   bd98c:	4604      	mov	r4, r0
    }
    return n;
}
   bd98e:	4620      	mov	r0, r4
   bd990:	b00d      	add	sp, #52	; 0x34
   bd992:	bdf0      	pop	{r4, r5, r6, r7, pc}

000bd994 <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
   bd994:	b510      	push	{r4, lr}
   bd996:	4b05      	ldr	r3, [pc, #20]	; (bd9ac <_ZN9IPAddressC1Ev+0x18>)
   bd998:	4604      	mov	r4, r0
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
   bd99a:	2211      	movs	r2, #17
   bd99c:	f840 3b04 	str.w	r3, [r0], #4
   bd9a0:	2100      	movs	r1, #0
   bd9a2:	f001 faaa 	bl	beefa <memset>
}
   bd9a6:	4620      	mov	r0, r4
   bd9a8:	bd10      	pop	{r4, pc}
   bd9aa:	bf00      	nop
   bd9ac:	000c20b4 	.word	0x000c20b4

000bd9b0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
   bd9b0:	4603      	mov	r3, r0
   bd9b2:	4a07      	ldr	r2, [pc, #28]	; (bd9d0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
   bd9b4:	b510      	push	{r4, lr}
   bd9b6:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
   bd9ba:	f101 0210 	add.w	r2, r1, #16
   bd9be:	f851 4b04 	ldr.w	r4, [r1], #4
   bd9c2:	f843 4b04 	str.w	r4, [r3], #4
   bd9c6:	4291      	cmp	r1, r2
   bd9c8:	d1f9      	bne.n	bd9be <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
   bd9ca:	780a      	ldrb	r2, [r1, #0]
   bd9cc:	701a      	strb	r2, [r3, #0]
}
   bd9ce:	bd10      	pop	{r4, pc}
   bd9d0:	000c20b4 	.word	0x000c20b4

000bd9d4 <_ZN9IPAddress8set_ipv4Ehhhh>:
{
   bd9d4:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
   bd9d6:	f89d 4008 	ldrb.w	r4, [sp, #8]
   bd9da:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
   bd9de:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
   bd9e2:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        address.v = version;
   bd9e6:	2304      	movs	r3, #4
   bd9e8:	6041      	str	r1, [r0, #4]
   bd9ea:	7503      	strb	r3, [r0, #20]
}
   bd9ec:	bd10      	pop	{r4, pc}
	...

000bd9f0 <_ZN9IPAddressC1EPKh>:
IPAddress::IPAddress(const uint8_t* addr)
   bd9f0:	b507      	push	{r0, r1, r2, lr}
   bd9f2:	4b06      	ldr	r3, [pc, #24]	; (bda0c <_ZN9IPAddressC1EPKh+0x1c>)
   bd9f4:	6003      	str	r3, [r0, #0]
    set_ipv4(addr[0], addr[1], addr[2], addr[3]);
   bd9f6:	78cb      	ldrb	r3, [r1, #3]
   bd9f8:	9300      	str	r3, [sp, #0]
   bd9fa:	788b      	ldrb	r3, [r1, #2]
   bd9fc:	784a      	ldrb	r2, [r1, #1]
   bd9fe:	7809      	ldrb	r1, [r1, #0]
   bda00:	f7ff ffe8 	bl	bd9d4 <_ZN9IPAddress8set_ipv4Ehhhh>
}
   bda04:	b003      	add	sp, #12
   bda06:	f85d fb04 	ldr.w	pc, [sp], #4
   bda0a:	bf00      	nop
   bda0c:	000c20b4 	.word	0x000c20b4

000bda10 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   bda10:	7441      	strb	r1, [r0, #17]
}
   bda12:	4770      	bx	lr

000bda14 <__tcf_0>:
}

USBSerial& _fetch_usbserial()
{
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   bda14:	4770      	bx	lr

000bda16 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
   bda16:	4770      	bx	lr

000bda18 <_ZN9USBSerial4readEv>:
{
   bda18:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
   bda1a:	2100      	movs	r1, #0
   bda1c:	7c00      	ldrb	r0, [r0, #16]
   bda1e:	f7fc fbd9 	bl	ba1d4 <HAL_USB_USART_Receive_Data>
}
   bda22:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   bda26:	bd08      	pop	{r3, pc}

000bda28 <_ZN9USBSerial4peekEv>:
{
   bda28:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
   bda2a:	2101      	movs	r1, #1
   bda2c:	7c00      	ldrb	r0, [r0, #16]
   bda2e:	f7fc fbd1 	bl	ba1d4 <HAL_USB_USART_Receive_Data>
}
   bda32:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   bda36:	bd08      	pop	{r3, pc}

000bda38 <_ZN9USBSerial17availableForWriteEv>:
{
   bda38:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
   bda3a:	7c00      	ldrb	r0, [r0, #16]
   bda3c:	f7fc fbc2 	bl	ba1c4 <HAL_USB_USART_Available_Data_For_Write>
}
   bda40:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   bda44:	bd08      	pop	{r3, pc}

000bda46 <_ZN9USBSerial9availableEv>:
{
   bda46:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
   bda48:	7c00      	ldrb	r0, [r0, #16]
   bda4a:	f7fc fbb3 	bl	ba1b4 <HAL_USB_USART_Available_Data>
}
   bda4e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   bda52:	bd08      	pop	{r3, pc}

000bda54 <_ZN9USBSerial5writeEh>:
{
   bda54:	b513      	push	{r0, r1, r4, lr}
   bda56:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   bda58:	7c00      	ldrb	r0, [r0, #16]
{
   bda5a:	9101      	str	r1, [sp, #4]
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
   bda5c:	f7fc fbb2 	bl	ba1c4 <HAL_USB_USART_Available_Data_For_Write>
   bda60:	2800      	cmp	r0, #0
   bda62:	9901      	ldr	r1, [sp, #4]
   bda64:	dc01      	bgt.n	bda6a <_ZN9USBSerial5writeEh+0x16>
   bda66:	7c60      	ldrb	r0, [r4, #17]
   bda68:	b120      	cbz	r0, bda74 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
   bda6a:	7c20      	ldrb	r0, [r4, #16]
   bda6c:	f7fc fbba 	bl	ba1e4 <HAL_USB_USART_Send_Data>
   bda70:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
   bda74:	b002      	add	sp, #8
   bda76:	bd10      	pop	{r4, pc}

000bda78 <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
   bda78:	7c00      	ldrb	r0, [r0, #16]
   bda7a:	f7fc bbbb 	b.w	ba1f4 <HAL_USB_USART_Flush_Data>

000bda7e <_ZN9USBSerialD0Ev>:
   bda7e:	b510      	push	{r4, lr}
   bda80:	2114      	movs	r1, #20
   bda82:	4604      	mov	r4, r0
   bda84:	f7f6 fb0b 	bl	b409e <_ZdlPvj>
   bda88:	4620      	mov	r0, r4
   bda8a:	bd10      	pop	{r4, pc}

000bda8c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
   bda8c:	b510      	push	{r4, lr}
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   bda8e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   bda92:	4604      	mov	r4, r0
   bda94:	4608      	mov	r0, r1
   bda96:	2100      	movs	r1, #0
   bda98:	e9c4 1301 	strd	r1, r3, [r4, #4]
   bda9c:	4b04      	ldr	r3, [pc, #16]	; (bdab0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
   bda9e:	6023      	str	r3, [r4, #0]
  _blocking = true;
   bdaa0:	2301      	movs	r3, #1
  _serial = serial;
   bdaa2:	7420      	strb	r0, [r4, #16]
  _blocking = true;
   bdaa4:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
   bdaa6:	4611      	mov	r1, r2
   bdaa8:	f7fc fb74 	bl	ba194 <HAL_USB_USART_Init>
}
   bdaac:	4620      	mov	r0, r4
   bdaae:	bd10      	pop	{r4, pc}
   bdab0:	000c20c8 	.word	0x000c20c8

000bdab4 <_ZN9USBSerial5beginEl>:
    HAL_USB_USART_Begin(_serial, speed, NULL);
   bdab4:	7c00      	ldrb	r0, [r0, #16]
   bdab6:	2200      	movs	r2, #0
   bdab8:	f7fc bb74 	b.w	ba1a4 <HAL_USB_USART_Begin>

000bdabc <_Z19acquireSerialBufferv>:
{
   bdabc:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = {};
   bdabe:	2214      	movs	r2, #20
{
   bdac0:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {};
   bdac2:	2100      	movs	r1, #0
   bdac4:	f001 fa19 	bl	beefa <memset>
}
   bdac8:	4620      	mov	r0, r4
   bdaca:	bd10      	pop	{r4, pc}

000bdacc <_Z16_fetch_usbserialv>:
{
   bdacc:	b510      	push	{r4, lr}
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   bdace:	4c0f      	ldr	r4, [pc, #60]	; (bdb0c <_Z16_fetch_usbserialv+0x40>)
{
   bdad0:	b088      	sub	sp, #32
  HAL_USB_USART_Config conf = acquireSerialBuffer();
   bdad2:	a803      	add	r0, sp, #12
   bdad4:	f7ff fff2 	bl	bdabc <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
   bdad8:	7821      	ldrb	r1, [r4, #0]
   bdada:	f3bf 8f5b 	dmb	ish
   bdade:	f011 0101 	ands.w	r1, r1, #1
   bdae2:	d10f      	bne.n	bdb04 <_Z16_fetch_usbserialv+0x38>
   bdae4:	4620      	mov	r0, r4
   bdae6:	9101      	str	r1, [sp, #4]
   bdae8:	f7f6 fae8 	bl	b40bc <__cxa_guard_acquire>
   bdaec:	9901      	ldr	r1, [sp, #4]
   bdaee:	b148      	cbz	r0, bdb04 <_Z16_fetch_usbserialv+0x38>
   bdaf0:	aa03      	add	r2, sp, #12
   bdaf2:	4807      	ldr	r0, [pc, #28]	; (bdb10 <_Z16_fetch_usbserialv+0x44>)
   bdaf4:	f7ff ffca 	bl	bda8c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
   bdaf8:	4620      	mov	r0, r4
   bdafa:	f7f6 fae4 	bl	b40c6 <__cxa_guard_release>
   bdafe:	4805      	ldr	r0, [pc, #20]	; (bdb14 <_Z16_fetch_usbserialv+0x48>)
   bdb00:	f001 f9b6 	bl	bee70 <atexit>
	return _usbserial;
}
   bdb04:	4802      	ldr	r0, [pc, #8]	; (bdb10 <_Z16_fetch_usbserialv+0x44>)
   bdb06:	b008      	add	sp, #32
   bdb08:	bd10      	pop	{r4, pc}
   bdb0a:	bf00      	nop
   bdb0c:	2003e6d8 	.word	0x2003e6d8
   bdb10:	2003e6dc 	.word	0x2003e6dc
   bdb14:	000bda15 	.word	0x000bda15

000bdb18 <_Z26call_raw_interrupt_handlerPv>:
}

void call_raw_interrupt_handler(void* data)
{
    raw_interrupt_handler_t handler = raw_interrupt_handler_t(data);
    handler();
   bdb18:	4700      	bx	r0
	...

000bdb1c <_Z15attachInterrupttPFvvE13InterruptModeah>:
    }
    return handler!=NULL;
}

bool attachInterrupt(uint16_t pin, raw_interrupt_handler_t handler, InterruptMode mode, int8_t priority, uint8_t subpriority)
{
   bdb1c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    HAL_Interrupts_Detach(pin);
    HAL_InterruptExtraConfiguration extra = {};
   bdb20:	2400      	movs	r4, #0
{
   bdb22:	461d      	mov	r5, r3
   bdb24:	460f      	mov	r7, r1
   bdb26:	4690      	mov	r8, r2
   bdb28:	4606      	mov	r6, r0
    HAL_Interrupts_Detach(pin);
   bdb2a:	f7fc f901 	bl	b9d30 <HAL_Interrupts_Detach>
  if (priority >= 0) {
   bdb2e:	42a5      	cmp	r5, r4
  extra.version = HAL_INTERRUPT_EXTRA_CONFIGURATION_VERSION_1;
   bdb30:	f04f 0304 	mov.w	r3, #4
    HAL_InterruptExtraConfiguration extra = {};
   bdb34:	f8ad 400d 	strh.w	r4, [sp, #13]
  extra.version = HAL_INTERRUPT_EXTRA_CONFIGURATION_VERSION_1;
   bdb38:	f88d 300c 	strb.w	r3, [sp, #12]
    HAL_InterruptExtraConfiguration extra = {};
   bdb3c:	f88d 400f 	strb.w	r4, [sp, #15]
    extra.IRQChannelSubPriority = subpriority;
   bdb40:	bfa2      	ittt	ge
   bdb42:	f89d 3028 	ldrbge.w	r3, [sp, #40]	; 0x28
   bdb46:	f88d 300e 	strbge.w	r3, [sp, #14]
    return &extra;
   bdb4a:	ac03      	addge	r4, sp, #12
    if (SYSTEM_ERROR_NONE != HAL_Interrupts_Attach(pin, call_raw_interrupt_handler, (void*)handler, mode, configure_interrupt(extra, priority, subpriority))) {
   bdb4c:	4907      	ldr	r1, [pc, #28]	; (bdb6c <_Z15attachInterrupttPFvvE13InterruptModeah+0x50>)
   bdb4e:	9400      	str	r4, [sp, #0]
   bdb50:	4643      	mov	r3, r8
   bdb52:	463a      	mov	r2, r7
   bdb54:	4630      	mov	r0, r6
    extra.IRQChannelPreemptionPriority = (uint8_t)priority;
   bdb56:	bfa8      	it	ge
   bdb58:	f88d 500d 	strbge.w	r5, [sp, #13]
    if (SYSTEM_ERROR_NONE != HAL_Interrupts_Attach(pin, call_raw_interrupt_handler, (void*)handler, mode, configure_interrupt(extra, priority, subpriority))) {
   bdb5c:	f7fc f8e0 	bl	b9d20 <HAL_Interrupts_Attach>
        return false;
    }
    return true;
}
   bdb60:	fab0 f080 	clz	r0, r0
   bdb64:	0940      	lsrs	r0, r0, #5
   bdb66:	b004      	add	sp, #16
   bdb68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   bdb6c:	000bdb19 	.word	0x000bdb19

000bdb70 <_ZN5spark13CellularClass5readyEv>:
        return network_listening(*this, 0, NULL);
    }

    bool ready()
    {
        return network_ready(*this, 0,  NULL);
   bdb70:	2200      	movs	r2, #0
   bdb72:	6840      	ldr	r0, [r0, #4]
   bdb74:	4611      	mov	r1, r2
   bdb76:	f7fc bbb1 	b.w	ba2dc <network_ready>

000bdb7a <_ZN5spark13CellularClass9listeningEv>:
        return network_listening(*this, 0, NULL);
   bdb7a:	2200      	movs	r2, #0
   bdb7c:	6840      	ldr	r0, [r0, #4]
   bdb7e:	4611      	mov	r1, r2
   bdb80:	f7fc bbcc 	b.w	ba31c <network_listening>

000bdb84 <_ZN5spark13CellularClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
   bdb84:	2200      	movs	r2, #0
   bdb86:	6840      	ldr	r0, [r0, #4]
   bdb88:	4611      	mov	r1, r2
   bdb8a:	f7fc bbd7 	b.w	ba33c <network_get_listen_timeout>

000bdb8e <_ZN5spark13CellularClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
   bdb8e:	6840      	ldr	r0, [r0, #4]
   bdb90:	2200      	movs	r2, #0
   bdb92:	f7fc bbcb 	b.w	ba32c <network_set_listen_timeout>

000bdb96 <_ZN5spark13CellularClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
   bdb96:	6840      	ldr	r0, [r0, #4]
   bdb98:	2200      	movs	r2, #0
   bdb9a:	f081 0101 	eor.w	r1, r1, #1
   bdb9e:	f7fc bbb5 	b.w	ba30c <network_listen>

000bdba2 <_ZN5spark13CellularClass3offEv>:
        network_off(*this, 0, 0, NULL);
   bdba2:	2300      	movs	r3, #0
   bdba4:	6840      	ldr	r0, [r0, #4]
   bdba6:	461a      	mov	r2, r3
   bdba8:	4619      	mov	r1, r3
   bdbaa:	f7fc bba7 	b.w	ba2fc <network_off>

000bdbae <_ZN5spark13CellularClass2onEv>:
        network_on(*this, 0, 0, NULL);
   bdbae:	2300      	movs	r3, #0
   bdbb0:	6840      	ldr	r0, [r0, #4]
   bdbb2:	461a      	mov	r2, r3
   bdbb4:	4619      	mov	r1, r3
   bdbb6:	f7fc bb99 	b.w	ba2ec <network_on>

000bdbba <_ZN5spark13CellularClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
   bdbba:	2200      	movs	r2, #0
   bdbbc:	6840      	ldr	r0, [r0, #4]
   bdbbe:	4611      	mov	r1, r2
   bdbc0:	f7fc bb7c 	b.w	ba2bc <network_connecting>

000bdbc4 <_ZN5spark13CellularClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
   bdbc4:	6840      	ldr	r0, [r0, #4]
   bdbc6:	2200      	movs	r2, #0
   bdbc8:	2102      	movs	r1, #2
   bdbca:	f7fc bb7f 	b.w	ba2cc <network_disconnect>

000bdbce <_ZN5spark13CellularClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
   bdbce:	2300      	movs	r3, #0
   bdbd0:	6840      	ldr	r0, [r0, #4]
   bdbd2:	461a      	mov	r2, r3
   bdbd4:	f7fc bb6a 	b.w	ba2ac <network_connect>

000bdbd8 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv>:
    int tx_total;
    int rx_total;

    CellularDataHal()
    {
        memset(this, 0, sizeof(*this));
   bdbd8:	4b08      	ldr	r3, [pc, #32]	; (bdbfc <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x24>)
        return (band_get.ok = true);
    }

    CellularClass Cellular;
    // NetworkClass& Network = Cellular;
}
   bdbda:	b510      	push	{r4, lr}
   bdbdc:	2428      	movs	r4, #40	; 0x28
   bdbde:	4622      	mov	r2, r4
   bdbe0:	4618      	mov	r0, r3
   bdbe2:	2100      	movs	r1, #0
   bdbe4:	f001 f989 	bl	beefa <memset>
   bdbe8:	4b05      	ldr	r3, [pc, #20]	; (bdc00 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x28>)
        cid = -1;
        size = sizeof(*this);
   bdbea:	8004      	strh	r4, [r0, #0]
        cid = -1;
   bdbec:	f04f 32ff 	mov.w	r2, #4294967295
   bdbf0:	6042      	str	r2, [r0, #4]
   bdbf2:	2204      	movs	r2, #4
   bdbf4:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_CELLULAR) {
   bdbf6:	4a03      	ldr	r2, [pc, #12]	; (bdc04 <_GLOBAL__sub_I__ZN5spark13CellularClass4RSSIEv+0x2c>)
   bdbf8:	601a      	str	r2, [r3, #0]
   bdbfa:	bd10      	pop	{r4, pc}
   bdbfc:	2003e6f8 	.word	0x2003e6f8
   bdc00:	2003e6f0 	.word	0x2003e6f0
   bdc04:	000c20f8 	.word	0x000c20f8

000bdc08 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, const hal_usart_buffer_config_t& config);
  virtual ~USARTSerial() {};
   bdc08:	4770      	bx	lr

000bdc0a <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
   bdc0a:	7441      	strb	r1, [r0, #17]
}
   bdc0c:	4770      	bx	lr

000bdc0e <_ZN11USARTSerial17availableForWriteEv>:


int USARTSerial::availableForWrite(void)
{
   bdc0e:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
   bdc10:	7c00      	ldrb	r0, [r0, #16]
   bdc12:	f7fc f9ff 	bl	ba014 <hal_usart_available_data_for_write>
}
   bdc16:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   bdc1a:	bd08      	pop	{r3, pc}

000bdc1c <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
   bdc1c:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
   bdc1e:	7c00      	ldrb	r0, [r0, #16]
   bdc20:	f7fc f9d0 	bl	b9fc4 <hal_usart_available>
}
   bdc24:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   bdc28:	bd08      	pop	{r3, pc}

000bdc2a <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
   bdc2a:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
   bdc2c:	7c00      	ldrb	r0, [r0, #16]
   bdc2e:	f7fc f9d9 	bl	b9fe4 <hal_usart_peek>
}
   bdc32:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   bdc36:	bd08      	pop	{r3, pc}

000bdc38 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
   bdc38:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
   bdc3a:	7c00      	ldrb	r0, [r0, #16]
   bdc3c:	f7fc f9ca 	bl	b9fd4 <hal_usart_read>
}
   bdc40:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
   bdc44:	bd08      	pop	{r3, pc}

000bdc46 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  hal_usart_flush(_serial);
   bdc46:	7c00      	ldrb	r0, [r0, #16]
   bdc48:	f7fc b9d4 	b.w	b9ff4 <hal_usart_flush>

000bdc4c <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
   bdc4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   bdc4e:	7c45      	ldrb	r5, [r0, #17]
{
   bdc50:	4604      	mov	r4, r0
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   bdc52:	b12d      	cbz	r5, bdc60 <_ZN11USARTSerial5writeEh+0x14>
    // the HAL always blocks.
	  return hal_usart_write(_serial, c);
   bdc54:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
   bdc56:	b003      	add	sp, #12
   bdc58:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	  return hal_usart_write(_serial, c);
   bdc5c:	f7fc b9aa 	b.w	b9fb4 <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
   bdc60:	7c00      	ldrb	r0, [r0, #16]
   bdc62:	9101      	str	r1, [sp, #4]
   bdc64:	f7fc f9d6 	bl	ba014 <hal_usart_available_data_for_write>
   bdc68:	2800      	cmp	r0, #0
   bdc6a:	9901      	ldr	r1, [sp, #4]
   bdc6c:	dcf2      	bgt.n	bdc54 <_ZN11USARTSerial5writeEh+0x8>
}
   bdc6e:	4628      	mov	r0, r5
   bdc70:	b003      	add	sp, #12
   bdc72:	bd30      	pop	{r4, r5, pc}

000bdc74 <_ZN11USARTSerialD0Ev>:
   bdc74:	b510      	push	{r4, lr}
   bdc76:	2114      	movs	r1, #20
   bdc78:	4604      	mov	r4, r0
   bdc7a:	f7f6 fa10 	bl	b409e <_ZdlPvj>
   bdc7e:	4620      	mov	r0, r4
   bdc80:	bd10      	pop	{r4, pc}
	...

000bdc84 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t>:
USARTSerial::USARTSerial(hal_usart_interface_t serial, const hal_usart_buffer_config_t& config)
   bdc84:	b510      	push	{r4, lr}
   bdc86:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   bdc8a:	4604      	mov	r4, r0
   bdc8c:	4608      	mov	r0, r1
   bdc8e:	4611      	mov	r1, r2
   bdc90:	2200      	movs	r2, #0
   bdc92:	e9c4 2301 	strd	r2, r3, [r4, #4]
   bdc96:	4b04      	ldr	r3, [pc, #16]	; (bdca8 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t+0x24>)
   bdc98:	6023      	str	r3, [r4, #0]
  _blocking = true;
   bdc9a:	2301      	movs	r3, #1
  _serial = serial;
   bdc9c:	7420      	strb	r0, [r4, #16]
  _blocking = true;
   bdc9e:	7463      	strb	r3, [r4, #17]
  hal_usart_init_ex(serial, &config, nullptr);
   bdca0:	f7fc f9c8 	bl	ba034 <hal_usart_init_ex>
}
   bdca4:	4620      	mov	r0, r4
   bdca6:	bd10      	pop	{r4, pc}
   bdca8:	000c2134 	.word	0x000c2134

000bdcac <_ZN11USARTSerial5beginEmm>:
  hal_usart_begin_config(_serial, baud, config, nullptr);
   bdcac:	7c00      	ldrb	r0, [r0, #16]
   bdcae:	2300      	movs	r3, #0
   bdcb0:	f7fc b9b8 	b.w	ba024 <hal_usart_begin_config>

000bdcb4 <_ZN11USARTSerial5beginEm>:
  begin(baud, SERIAL_8N1);
   bdcb4:	2200      	movs	r2, #0
   bdcb6:	f7ff bff9 	b.w	bdcac <_ZN11USARTSerial5beginEmm>

000bdcba <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
   bdcba:	b510      	push	{r4, lr}
      if (_M_empty())
   bdcbc:	6883      	ldr	r3, [r0, #8]
   bdcbe:	4604      	mov	r4, r0
   bdcc0:	b90b      	cbnz	r3, bdcc6 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
   bdcc2:	f000 fa4a 	bl	be15a <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
   bdcc6:	68c3      	ldr	r3, [r0, #12]
   bdcc8:	4798      	blx	r3
      if (_M_manager)
   bdcca:	68a3      	ldr	r3, [r4, #8]
   bdccc:	b11b      	cbz	r3, bdcd6 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
   bdcce:	2203      	movs	r2, #3
   bdcd0:	4621      	mov	r1, r4
   bdcd2:	4620      	mov	r0, r4
   bdcd4:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
   bdcd6:	4620      	mov	r0, r4
   bdcd8:	2110      	movs	r1, #16
}
   bdcda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delete callbackPtr;
   bdcde:	f7f6 b9de 	b.w	b409e <_ZdlPvj>

000bdce2 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
   bdce2:	4770      	bx	lr

000bdce4 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
   bdce4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   bdce6:	4606      	mov	r6, r0
   bdce8:	4615      	mov	r5, r2
   bdcea:	460c      	mov	r4, r1
   bdcec:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
   bdcee:	42bc      	cmp	r4, r7
   bdcf0:	d006      	beq.n	bdd00 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
   bdcf2:	6833      	ldr	r3, [r6, #0]
   bdcf4:	f814 1b01 	ldrb.w	r1, [r4], #1
   bdcf8:	689b      	ldr	r3, [r3, #8]
   bdcfa:	4630      	mov	r0, r6
   bdcfc:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
   bdcfe:	e7f6      	b.n	bdcee <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
   bdd00:	4628      	mov	r0, r5
   bdd02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000bdd04 <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
   bdd04:	7c00      	ldrb	r0, [r0, #16]
   bdd06:	2200      	movs	r2, #0
   bdd08:	f7fc b9bc 	b.w	ba084 <hal_i2c_write>

000bdd0c <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
   bdd0c:	7c00      	ldrb	r0, [r0, #16]
   bdd0e:	2100      	movs	r1, #0
   bdd10:	f7fc b9c0 	b.w	ba094 <hal_i2c_available>

000bdd14 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
   bdd14:	7c00      	ldrb	r0, [r0, #16]
   bdd16:	2100      	movs	r1, #0
   bdd18:	f7fc b9c4 	b.w	ba0a4 <hal_i2c_read>

000bdd1c <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
   bdd1c:	7c00      	ldrb	r0, [r0, #16]
   bdd1e:	2100      	movs	r1, #0
   bdd20:	f7fc b9c8 	b.w	ba0b4 <hal_i2c_peek>

000bdd24 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
   bdd24:	7c00      	ldrb	r0, [r0, #16]
   bdd26:	2100      	movs	r1, #0
   bdd28:	f7fc b9cc 	b.w	ba0c4 <hal_i2c_flush>

000bdd2c <_ZN7TwoWireD0Ev>:
   bdd2c:	b510      	push	{r4, lr}
   bdd2e:	2114      	movs	r1, #20
   bdd30:	4604      	mov	r4, r0
   bdd32:	f7f6 f9b4 	bl	b409e <_ZdlPvj>
   bdd36:	4620      	mov	r0, r4
   bdd38:	bd10      	pop	{r4, pc}
	...

000bdd3c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
   bdd3c:	b510      	push	{r4, lr}
   bdd3e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   bdd42:	4604      	mov	r4, r0
   bdd44:	4608      	mov	r0, r1
   bdd46:	2100      	movs	r1, #0
   bdd48:	e9c4 1301 	strd	r1, r3, [r4, #4]
   bdd4c:	4b03      	ldr	r3, [pc, #12]	; (bdd5c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x20>)
   bdd4e:	6023      	str	r3, [r4, #0]
  _i2c = i2c;
   bdd50:	7420      	strb	r0, [r4, #16]
  hal_i2c_init(_i2c, &conf);
   bdd52:	4611      	mov	r1, r2
   bdd54:	f7fc f9c6 	bl	ba0e4 <hal_i2c_init>
}
   bdd58:	4620      	mov	r0, r4
   bdd5a:	bd10      	pop	{r4, pc}
   bdd5c:	000c2164 	.word	0x000c2164

000bdd60 <_ZN7TwoWire8setSpeedEm>:
  hal_i2c_set_speed(_i2c, clockSpeed, NULL);
   bdd60:	7c00      	ldrb	r0, [r0, #16]
   bdd62:	2200      	movs	r2, #0
   bdd64:	f7fc b96e 	b.w	ba044 <hal_i2c_set_speed>

000bdd68 <_ZN7TwoWire5beginEv>:
	hal_i2c_begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
   bdd68:	2300      	movs	r3, #0
   bdd6a:	7c00      	ldrb	r0, [r0, #16]
   bdd6c:	461a      	mov	r2, r3
   bdd6e:	4619      	mov	r1, r3
   bdd70:	f7fc b970 	b.w	ba054 <hal_i2c_begin>

000bdd74 <_ZN7TwoWire17beginTransmissionEh>:
	hal_i2c_begin_transmission(_i2c, address, NULL);
   bdd74:	7c00      	ldrb	r0, [r0, #16]
   bdd76:	2200      	movs	r2, #0
   bdd78:	f7fc b974 	b.w	ba064 <hal_i2c_begin_transmission>

000bdd7c <_ZN7TwoWire15endTransmissionEh>:
	return hal_i2c_end_transmission(_i2c, sendStop, NULL);
   bdd7c:	7c00      	ldrb	r0, [r0, #16]
   bdd7e:	2200      	movs	r2, #0
   bdd80:	f7fc b978 	b.w	ba074 <hal_i2c_end_transmission>

000bdd84 <_ZN7TwoWire15endTransmissionEv>:
  return endTransmission(true);
   bdd84:	2101      	movs	r1, #1
   bdd86:	f7ff bff9 	b.w	bdd7c <_ZN7TwoWire15endTransmissionEh>

000bdd8a <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
   bdd8a:	2300      	movs	r3, #0
   bdd8c:	6840      	ldr	r0, [r0, #4]
   bdd8e:	461a      	mov	r2, r3
   bdd90:	f7fc ba8c 	b.w	ba2ac <network_connect>

000bdd94 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
   bdd94:	6840      	ldr	r0, [r0, #4]
   bdd96:	2200      	movs	r2, #0
   bdd98:	2102      	movs	r1, #2
   bdd9a:	f7fc ba97 	b.w	ba2cc <network_disconnect>

000bdd9e <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
   bdd9e:	2200      	movs	r2, #0
   bdda0:	6840      	ldr	r0, [r0, #4]
   bdda2:	4611      	mov	r1, r2
   bdda4:	f7fc ba8a 	b.w	ba2bc <network_connecting>

000bdda8 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
   bdda8:	2200      	movs	r2, #0
   bddaa:	6840      	ldr	r0, [r0, #4]
   bddac:	4611      	mov	r1, r2
   bddae:	f7fc ba95 	b.w	ba2dc <network_ready>

000bddb2 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
   bddb2:	2300      	movs	r3, #0
   bddb4:	6840      	ldr	r0, [r0, #4]
   bddb6:	461a      	mov	r2, r3
   bddb8:	4619      	mov	r1, r3
   bddba:	f7fc ba97 	b.w	ba2ec <network_on>

000bddbe <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
   bddbe:	2300      	movs	r3, #0
   bddc0:	6840      	ldr	r0, [r0, #4]
   bddc2:	461a      	mov	r2, r3
   bddc4:	4619      	mov	r1, r3
   bddc6:	f7fc ba99 	b.w	ba2fc <network_off>

000bddca <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
   bddca:	6840      	ldr	r0, [r0, #4]
   bddcc:	2100      	movs	r1, #0
   bddce:	f7fc babd 	b.w	ba34c <network_is_on>

000bddd2 <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
   bddd2:	6840      	ldr	r0, [r0, #4]
   bddd4:	2100      	movs	r1, #0
   bddd6:	f7fc bac1 	b.w	ba35c <network_is_off>

000bddda <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
   bddda:	6840      	ldr	r0, [r0, #4]
   bdddc:	2200      	movs	r2, #0
   bddde:	f081 0101 	eor.w	r1, r1, #1
   bdde2:	f7fc ba93 	b.w	ba30c <network_listen>

000bdde6 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
   bdde6:	6840      	ldr	r0, [r0, #4]
   bdde8:	2200      	movs	r2, #0
   bddea:	f7fc ba9f 	b.w	ba32c <network_set_listen_timeout>

000bddee <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
   bddee:	2200      	movs	r2, #0
   bddf0:	6840      	ldr	r0, [r0, #4]
   bddf2:	4611      	mov	r1, r2
   bddf4:	f7fc baa2 	b.w	ba33c <network_get_listen_timeout>

000bddf8 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
   bddf8:	2200      	movs	r2, #0
   bddfa:	6840      	ldr	r0, [r0, #4]
   bddfc:	4611      	mov	r1, r2
   bddfe:	f7fc ba8d 	b.w	ba31c <network_listening>

000bde02 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
   bde02:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bde06:	b095      	sub	sp, #84	; 0x54
   bde08:	4614      	mov	r4, r2
   bde0a:	460d      	mov	r5, r1
   bde0c:	4607      	mov	r7, r0
    IPAddress addr;
   bde0e:	f7ff fdc1 	bl	bd994 <_ZN9IPAddressC1Ev>
#if HAL_USE_INET_HAL_POSIX
    struct addrinfo *ai = nullptr;
   bde12:	2100      	movs	r1, #0
    struct addrinfo hints = {};
   bde14:	221c      	movs	r2, #28
   bde16:	a80d      	add	r0, sp, #52	; 0x34
    struct addrinfo *ai = nullptr;
   bde18:	9100      	str	r1, [sp, #0]
    struct addrinfo hints = {};
   bde1a:	f001 f86e 	bl	beefa <memset>
    hints.ai_flags = AI_ADDRCONFIG;
   bde1e:	2340      	movs	r3, #64	; 0x40
   bde20:	930c      	str	r3, [sp, #48]	; 0x30
    hints.ai_family = AF_UNSPEC;
    const int r = getaddrinfo(name, nullptr, &hints, &ai);
   bde22:	4620      	mov	r0, r4
   bde24:	466b      	mov	r3, sp
   bde26:	aa0c      	add	r2, sp, #48	; 0x30
   bde28:	2100      	movs	r1, #0
   bde2a:	f7fb ff49 	bl	b9cc0 <netdb_getaddrinfo>
    if (!r) {
   bde2e:	4604      	mov	r4, r0
   bde30:	2800      	cmp	r0, #0
   bde32:	d14b      	bne.n	bdecc <_ZN5spark12NetworkClass7resolveEPKc+0xca>
        bool ok = false;
        // This is not really needed if AI_ADDRCONFIG is properly supported
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   bde34:	4602      	mov	r2, r0
   bde36:	2101      	movs	r1, #1
   bde38:	6868      	ldr	r0, [r5, #4]
   bde3a:	f7fc fa4f 	bl	ba2dc <network_ready>
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   bde3e:	2102      	movs	r1, #2
        bool ipv4 = network_ready(*this, NETWORK_READY_TYPE_IPV4, nullptr);
   bde40:	4680      	mov	r8, r0
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   bde42:	4622      	mov	r2, r4
   bde44:	6868      	ldr	r0, [r5, #4]
   bde46:	f7fc fa49 	bl	ba2dc <network_ready>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   bde4a:	9e00      	ldr	r6, [sp, #0]
        bool ipv6 = network_ready(*this, NETWORK_READY_TYPE_IPV6, nullptr);
   bde4c:	4681      	mov	r9, r0
        bool ok = false;
   bde4e:	4621      	mov	r1, r4
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   bde50:	2e00      	cmp	r6, #0
   bde52:	d03b      	beq.n	bdecc <_ZN5spark12NetworkClass7resolveEPKc+0xca>
   bde54:	2900      	cmp	r1, #0
   bde56:	d139      	bne.n	bdecc <_ZN5spark12NetworkClass7resolveEPKc+0xca>
            // NOTE: using only the first entry that matches the current state of IPv4/IPv6 connectivity
            switch (cur->ai_family) {
   bde58:	6873      	ldr	r3, [r6, #4]
   bde5a:	2b02      	cmp	r3, #2
   bde5c:	d003      	beq.n	bde66 <_ZN5spark12NetworkClass7resolveEPKc+0x64>
   bde5e:	2b0a      	cmp	r3, #10
   bde60:	d011      	beq.n	bde86 <_ZN5spark12NetworkClass7resolveEPKc+0x84>
        for (auto cur = ai; cur != nullptr && !ok; cur = cur->ai_next) {
   bde62:	69f6      	ldr	r6, [r6, #28]
   bde64:	e7f4      	b.n	bde50 <_ZN5spark12NetworkClass7resolveEPKc+0x4e>
                case AF_INET: {
                    if (!ipv4) {
   bde66:	f1b8 0f00 	cmp.w	r8, #0
   bde6a:	d0fa      	beq.n	bde62 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                        continue;
                    }
                    // NOTE: HAL_IPAddress is little-endian
                    auto in = (struct sockaddr_in*)cur->ai_addr;
                    addr = (const uint8_t*)(&in->sin_addr.s_addr);
   bde6c:	6971      	ldr	r1, [r6, #20]
        return *this = IPAddress(address);
   bde6e:	a806      	add	r0, sp, #24
   bde70:	3104      	adds	r1, #4
class IPAddress : public Printable {
   bde72:	ad07      	add	r5, sp, #28
        return *this = IPAddress(address);
   bde74:	f7ff fdbc 	bl	bd9f0 <_ZN9IPAddressC1EPKh>
class IPAddress : public Printable {
   bde78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   bde7a:	1d3c      	adds	r4, r7, #4
   bde7c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bde7e:	682b      	ldr	r3, [r5, #0]
   bde80:	7023      	strb	r3, [r4, #0]
                    ok = true;
   bde82:	4641      	mov	r1, r8
        return *this = IPAddress(address);
   bde84:	e7ed      	b.n	bde62 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                    break;
                }
                case AF_INET6: {
                    if (!ipv6) {
   bde86:	f1b9 0f00 	cmp.w	r9, #0
   bde8a:	d0ea      	beq.n	bde62 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                        continue;
                    }
                    auto in6 = (struct sockaddr_in6*)cur->ai_addr;
   bde8c:	6974      	ldr	r4, [r6, #20]
                    HAL_IPAddress a = {};
   bde8e:	2210      	movs	r2, #16
   bde90:	a801      	add	r0, sp, #4
   bde92:	f001 f832 	bl	beefa <memset>
                    a.v = 6;
   bde96:	2306      	movs	r3, #6
   bde98:	f88d 3014 	strb.w	r3, [sp, #20]
                    memcpy(a.ipv6, in6->sin6_addr.s6_addr, sizeof(a.ipv6));
   bde9c:	ad01      	add	r5, sp, #4
   bde9e:	f104 0308 	add.w	r3, r4, #8
   bdea2:	3418      	adds	r4, #24
   bdea4:	6818      	ldr	r0, [r3, #0]
   bdea6:	6859      	ldr	r1, [r3, #4]
   bdea8:	462a      	mov	r2, r5
   bdeaa:	c203      	stmia	r2!, {r0, r1}
   bdeac:	3308      	adds	r3, #8
   bdeae:	42a3      	cmp	r3, r4
   bdeb0:	4615      	mov	r5, r2
   bdeb2:	d1f7      	bne.n	bdea4 <_ZN5spark12NetworkClass7resolveEPKc+0xa2>
                    addr = IPAddress(a);
   bdeb4:	a901      	add	r1, sp, #4
   bdeb6:	a806      	add	r0, sp, #24
class IPAddress : public Printable {
   bdeb8:	ad07      	add	r5, sp, #28
   bdeba:	f7ff fd79 	bl	bd9b0 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
   bdebe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   bdec0:	1d3c      	adds	r4, r7, #4
   bdec2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   bdec4:	682b      	ldr	r3, [r5, #0]
   bdec6:	7023      	strb	r3, [r4, #0]
                    ok = true;
   bdec8:	4649      	mov	r1, r9
   bdeca:	e7ca      	b.n	bde62 <_ZN5spark12NetworkClass7resolveEPKc+0x60>
                    break;
                }
            }
        }
    }
    freeaddrinfo(ai);
   bdecc:	9800      	ldr	r0, [sp, #0]
   bdece:	f7fb feef 	bl	b9cb0 <netdb_freeaddrinfo>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
   bded2:	4638      	mov	r0, r7
   bded4:	b015      	add	sp, #84	; 0x54
   bded6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

000bdedc <_GLOBAL__sub_I__ZN5spark7NetworkE>:
   bdedc:	4b02      	ldr	r3, [pc, #8]	; (bdee8 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
   bdede:	4a03      	ldr	r2, [pc, #12]	; (bdeec <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
   bdee0:	601a      	str	r2, [r3, #0]
   bdee2:	2200      	movs	r2, #0
   bdee4:	605a      	str	r2, [r3, #4]

} // spark
   bdee6:	4770      	bx	lr
   bdee8:	2003e720 	.word	0x2003e720
   bdeec:	000c218c 	.word	0x000c218c

000bdef0 <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
   bdef0:	2825      	cmp	r0, #37	; 0x25
bool pinAvailable(uint16_t pin) {
   bdef2:	b513      	push	{r0, r1, r4, lr}
  if (pin >= TOTAL_PINS) {
   bdef4:	d902      	bls.n	bdefc <pinAvailable+0xc>
    return false;
   bdef6:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
   bdef8:	b002      	add	sp, #8
   bdefa:	bd10      	pop	{r4, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
   bdefc:	f1a0 030b 	sub.w	r3, r0, #11
   bdf00:	2b02      	cmp	r3, #2
   bdf02:	d81a      	bhi.n	bdf3a <pinAvailable+0x4a>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
   bdf04:	4c17      	ldr	r4, [pc, #92]	; (bdf64 <pinAvailable+0x74>)
   bdf06:	7821      	ldrb	r1, [r4, #0]
   bdf08:	f3bf 8f5b 	dmb	ish
   bdf0c:	f011 0101 	ands.w	r1, r1, #1
   bdf10:	d10b      	bne.n	bdf2a <pinAvailable+0x3a>
   bdf12:	4620      	mov	r0, r4
   bdf14:	9101      	str	r1, [sp, #4]
   bdf16:	f7f6 f8d1 	bl	b40bc <__cxa_guard_acquire>
   bdf1a:	9901      	ldr	r1, [sp, #4]
   bdf1c:	b128      	cbz	r0, bdf2a <pinAvailable+0x3a>
   bdf1e:	4812      	ldr	r0, [pc, #72]	; (bdf68 <pinAvailable+0x78>)
   bdf20:	f7fc fb10 	bl	ba544 <_ZN8SPIClassC1E19hal_spi_interface_t>
   bdf24:	4620      	mov	r0, r4
   bdf26:	f7f6 f8ce 	bl	b40c6 <__cxa_guard_release>
   bdf2a:	4b0f      	ldr	r3, [pc, #60]	; (bdf68 <pinAvailable+0x78>)
   bdf2c:	7818      	ldrb	r0, [r3, #0]
   bdf2e:	f7fc f8f9 	bl	ba124 <hal_spi_is_enabled>
   bdf32:	2800      	cmp	r0, #0
   bdf34:	d1df      	bne.n	bdef6 <pinAvailable+0x6>
  return true; // 'pin' is available
   bdf36:	2001      	movs	r0, #1
   bdf38:	e7de      	b.n	bdef8 <pinAvailable+0x8>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
   bdf3a:	2801      	cmp	r0, #1
   bdf3c:	d809      	bhi.n	bdf52 <pinAvailable+0x62>
   bdf3e:	f000 f8c1 	bl	be0c4 <_Z19__fetch_global_Wirev>
   bdf42:	2100      	movs	r1, #0
   bdf44:	7c00      	ldrb	r0, [r0, #16]
   bdf46:	f7fc f8c5 	bl	ba0d4 <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
   bdf4a:	f080 0001 	eor.w	r0, r0, #1
   bdf4e:	b2c0      	uxtb	r0, r0
   bdf50:	e7d2      	b.n	bdef8 <pinAvailable+0x8>
   bdf52:	3809      	subs	r0, #9
   bdf54:	2801      	cmp	r0, #1
   bdf56:	d8ee      	bhi.n	bdf36 <pinAvailable+0x46>
   bdf58:	f000 f878 	bl	be04c <_Z22__fetch_global_Serial1v>
   bdf5c:	7c00      	ldrb	r0, [r0, #16]
   bdf5e:	f7fc f851 	bl	ba004 <hal_usart_is_enabled>
   bdf62:	e7f2      	b.n	bdf4a <pinAvailable+0x5a>
   bdf64:	2003e63c 	.word	0x2003e63c
   bdf68:	2003e640 	.word	0x2003e640

000bdf6c <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   bdf6c:	2825      	cmp	r0, #37	; 0x25
{
   bdf6e:	b538      	push	{r3, r4, r5, lr}
   bdf70:	4604      	mov	r4, r0
   bdf72:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
   bdf74:	d80a      	bhi.n	bdf8c <pinMode+0x20>
   bdf76:	29ff      	cmp	r1, #255	; 0xff
   bdf78:	d008      	beq.n	bdf8c <pinMode+0x20>
  if( !pinAvailable(pin) ) {
   bdf7a:	f7ff ffb9 	bl	bdef0 <pinAvailable>
   bdf7e:	b128      	cbz	r0, bdf8c <pinMode+0x20>
  HAL_Pin_Mode(pin, setMode);
   bdf80:	4629      	mov	r1, r5
   bdf82:	4620      	mov	r0, r4
}
   bdf84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_Pin_Mode(pin, setMode);
   bdf88:	f7fb beaa 	b.w	b9ce0 <HAL_Pin_Mode>
}
   bdf8c:	bd38      	pop	{r3, r4, r5, pc}

000bdf8e <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
   bdf8e:	b538      	push	{r3, r4, r5, lr}
   bdf90:	4604      	mov	r4, r0
   bdf92:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
   bdf94:	f7fb feac 	bl	b9cf0 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
   bdf98:	28ff      	cmp	r0, #255	; 0xff
   bdf9a:	d010      	beq.n	bdfbe <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
   bdf9c:	2806      	cmp	r0, #6
   bdf9e:	d804      	bhi.n	bdfaa <digitalWrite+0x1c>
   bdfa0:	234d      	movs	r3, #77	; 0x4d
   bdfa2:	fa23 f000 	lsr.w	r0, r3, r0
   bdfa6:	07c3      	lsls	r3, r0, #31
   bdfa8:	d409      	bmi.n	bdfbe <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
   bdfaa:	4620      	mov	r0, r4
   bdfac:	f7ff ffa0 	bl	bdef0 <pinAvailable>
   bdfb0:	b128      	cbz	r0, bdfbe <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
   bdfb2:	4629      	mov	r1, r5
   bdfb4:	4620      	mov	r0, r4
}
   bdfb6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_GPIO_Write(pin, value);
   bdfba:	f7fb bea1 	b.w	b9d00 <HAL_GPIO_Write>
}
   bdfbe:	bd38      	pop	{r3, r4, r5, pc}

000bdfc0 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
   bdfc0:	b510      	push	{r4, lr}
   bdfc2:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
   bdfc4:	f7fb fe94 	bl	b9cf0 <HAL_Get_Pin_Mode>
    return mode == AF_OUTPUT_PUSHPULL ||
   bdfc8:	1f03      	subs	r3, r0, #4
    if (is_af_output_mode(mode))
   bdfca:	b2db      	uxtb	r3, r3
   bdfcc:	2b01      	cmp	r3, #1
   bdfce:	d908      	bls.n	bdfe2 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
   bdfd0:	4620      	mov	r0, r4
   bdfd2:	f7ff ff8d 	bl	bdef0 <pinAvailable>
   bdfd6:	b120      	cbz	r0, bdfe2 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
   bdfd8:	4620      	mov	r0, r4
}
   bdfda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return HAL_GPIO_Read(pin);
   bdfde:	f7fb be97 	b.w	b9d10 <HAL_GPIO_Read>
}
   bdfe2:	2000      	movs	r0, #0
   bdfe4:	bd10      	pop	{r4, pc}

000bdfe6 <analogRead>:
 */
int32_t analogRead(pin_t pin)
{
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
#if defined(FIRST_ANALOG_PIN) && FIRST_ANALOG_PIN > 0
  if(pin < FIRST_ANALOG_PIN)
   bdfe6:	280d      	cmp	r0, #13
{
   bdfe8:	b510      	push	{r4, lr}
   bdfea:	4604      	mov	r4, r0
  {
    pin = pin + FIRST_ANALOG_PIN;
   bdfec:	bf9c      	itt	ls
   bdfee:	340e      	addls	r4, #14
   bdff0:	b2a4      	uxthls	r4, r4
  }
#endif // defined(FIRST_ANALOG_PIN) && FIRST_ANALOG_PIN > 0

  // Safety check
  if( !pinAvailable(pin) ) {
   bdff2:	4620      	mov	r0, r4
   bdff4:	f7ff ff7c 	bl	bdef0 <pinAvailable>
   bdff8:	b150      	cbz	r0, be010 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
   bdffa:	2103      	movs	r1, #3
   bdffc:	4620      	mov	r0, r4
   bdffe:	f7fb fe67 	bl	b9cd0 <HAL_Validate_Pin_Function>
   be002:	2803      	cmp	r0, #3
   be004:	d104      	bne.n	be010 <analogRead+0x2a>
  {
    return LOW;
  }

  return hal_adc_read(pin);
   be006:	4620      	mov	r0, r4
}
   be008:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return hal_adc_read(pin);
   be00c:	f7fb be98 	b.w	b9d40 <hal_adc_read>
}
   be010:	2000      	movs	r0, #0
   be012:	bd10      	pop	{r4, pc}

000be014 <__tcf_0>:
}
#endif

USARTSerial& __fetch_global_Serial1()
{
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   be014:	4770      	bx	lr
	...

000be018 <_Z20acquireSerial1Bufferv>:
{
   be018:	b538      	push	{r3, r4, r5, lr}
   be01a:	4604      	mov	r4, r0
    hal_usart_buffer_config_t config = {
   be01c:	2514      	movs	r5, #20
   be01e:	462a      	mov	r2, r5
   be020:	2100      	movs	r1, #0
   be022:	f000 ff6a 	bl	beefa <memset>
   be026:	8025      	strh	r5, [r4, #0]
   be028:	2540      	movs	r5, #64	; 0x40
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   be02a:	4907      	ldr	r1, [pc, #28]	; (be048 <_Z20acquireSerial1Bufferv+0x30>)
    hal_usart_buffer_config_t config = {
   be02c:	8125      	strh	r5, [r4, #8]
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   be02e:	4628      	mov	r0, r5
    hal_usart_buffer_config_t config = {
   be030:	8225      	strh	r5, [r4, #16]
        .rx_buffer = new (std::nothrow) uint8_t[bufferSize],
   be032:	f000 f86b 	bl	be10c <_ZnajRKSt9nothrow_t>
        .tx_buffer = new (std::nothrow) uint8_t[bufferSize],
   be036:	4904      	ldr	r1, [pc, #16]	; (be048 <_Z20acquireSerial1Bufferv+0x30>)
    };
   be038:	6060      	str	r0, [r4, #4]
        .tx_buffer = new (std::nothrow) uint8_t[bufferSize],
   be03a:	4628      	mov	r0, r5
   be03c:	f000 f866 	bl	be10c <_ZnajRKSt9nothrow_t>
    };
   be040:	60e0      	str	r0, [r4, #12]
}
   be042:	4620      	mov	r0, r4
   be044:	bd38      	pop	{r3, r4, r5, pc}
   be046:	bf00      	nop
   be048:	000c21c0 	.word	0x000c21c0

000be04c <_Z22__fetch_global_Serial1v>:
{
   be04c:	b530      	push	{r4, r5, lr}
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   be04e:	4d0e      	ldr	r5, [pc, #56]	; (be088 <_Z22__fetch_global_Serial1v+0x3c>)
   be050:	7829      	ldrb	r1, [r5, #0]
   be052:	f3bf 8f5b 	dmb	ish
   be056:	f011 0401 	ands.w	r4, r1, #1
{
   be05a:	b087      	sub	sp, #28
    static USARTSerial serial1(HAL_USART_SERIAL1, acquireSerial1Buffer());
   be05c:	d111      	bne.n	be082 <_Z22__fetch_global_Serial1v+0x36>
   be05e:	4628      	mov	r0, r5
   be060:	f7f6 f82c 	bl	b40bc <__cxa_guard_acquire>
   be064:	b168      	cbz	r0, be082 <_Z22__fetch_global_Serial1v+0x36>
   be066:	a801      	add	r0, sp, #4
   be068:	f7ff ffd6 	bl	be018 <_Z20acquireSerial1Bufferv>
   be06c:	aa01      	add	r2, sp, #4
   be06e:	4621      	mov	r1, r4
   be070:	4806      	ldr	r0, [pc, #24]	; (be08c <_Z22__fetch_global_Serial1v+0x40>)
   be072:	f7ff fe07 	bl	bdc84 <_ZN11USARTSerialC1E21hal_usart_interface_tRK25hal_usart_buffer_config_t>
   be076:	4628      	mov	r0, r5
   be078:	f7f6 f825 	bl	b40c6 <__cxa_guard_release>
   be07c:	4804      	ldr	r0, [pc, #16]	; (be090 <_Z22__fetch_global_Serial1v+0x44>)
   be07e:	f000 fef7 	bl	bee70 <atexit>
    return serial1;
}
   be082:	4802      	ldr	r0, [pc, #8]	; (be08c <_Z22__fetch_global_Serial1v+0x40>)
   be084:	b007      	add	sp, #28
   be086:	bd30      	pop	{r4, r5, pc}
   be088:	2003e728 	.word	0x2003e728
   be08c:	2003e72c 	.word	0x2003e72c
   be090:	000be015 	.word	0x000be015

000be094 <__tcf_0>:
}
#endif

TwoWire& __fetch_global_Wire()
{
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   be094:	4770      	bx	lr
	...

000be098 <_Z17acquireWireBufferv>:
{
   be098:	b538      	push	{r3, r4, r5, lr}
	hal_i2c_config_t config = {
   be09a:	2520      	movs	r5, #32
   be09c:	2314      	movs	r3, #20
{
   be09e:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
   be0a0:	6003      	str	r3, [r0, #0]
   be0a2:	6085      	str	r5, [r0, #8]
   be0a4:	6105      	str	r5, [r0, #16]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   be0a6:	4906      	ldr	r1, [pc, #24]	; (be0c0 <_Z17acquireWireBufferv+0x28>)
   be0a8:	4628      	mov	r0, r5
   be0aa:	f000 f82f 	bl	be10c <_ZnajRKSt9nothrow_t>
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   be0ae:	4904      	ldr	r1, [pc, #16]	; (be0c0 <_Z17acquireWireBufferv+0x28>)
	};
   be0b0:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
   be0b2:	4628      	mov	r0, r5
   be0b4:	f000 f82a 	bl	be10c <_ZnajRKSt9nothrow_t>
	};
   be0b8:	60e0      	str	r0, [r4, #12]
}
   be0ba:	4620      	mov	r0, r4
   be0bc:	bd38      	pop	{r3, r4, r5, pc}
   be0be:	bf00      	nop
   be0c0:	000c21c0 	.word	0x000c21c0

000be0c4 <_Z19__fetch_global_Wirev>:
{
   be0c4:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   be0c6:	4d0e      	ldr	r5, [pc, #56]	; (be100 <_Z19__fetch_global_Wirev+0x3c>)
   be0c8:	7829      	ldrb	r1, [r5, #0]
   be0ca:	f3bf 8f5b 	dmb	ish
   be0ce:	f011 0401 	ands.w	r4, r1, #1
{
   be0d2:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
   be0d4:	d111      	bne.n	be0fa <_Z19__fetch_global_Wirev+0x36>
   be0d6:	4628      	mov	r0, r5
   be0d8:	f7f5 fff0 	bl	b40bc <__cxa_guard_acquire>
   be0dc:	b168      	cbz	r0, be0fa <_Z19__fetch_global_Wirev+0x36>
   be0de:	a801      	add	r0, sp, #4
   be0e0:	f7ff ffda 	bl	be098 <_Z17acquireWireBufferv>
   be0e4:	aa01      	add	r2, sp, #4
   be0e6:	4621      	mov	r1, r4
   be0e8:	4806      	ldr	r0, [pc, #24]	; (be104 <_Z19__fetch_global_Wirev+0x40>)
   be0ea:	f7ff fe27 	bl	bdd3c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
   be0ee:	4628      	mov	r0, r5
   be0f0:	f7f5 ffe9 	bl	b40c6 <__cxa_guard_release>
   be0f4:	4804      	ldr	r0, [pc, #16]	; (be108 <_Z19__fetch_global_Wirev+0x44>)
   be0f6:	f000 febb 	bl	bee70 <atexit>
	return wire;
}
   be0fa:	4802      	ldr	r0, [pc, #8]	; (be104 <_Z19__fetch_global_Wirev+0x40>)
   be0fc:	b007      	add	sp, #28
   be0fe:	bd30      	pop	{r4, r5, pc}
   be100:	2003e744 	.word	0x2003e744
   be104:	2003e748 	.word	0x2003e748
   be108:	000be095 	.word	0x000be095

000be10c <_ZnajRKSt9nothrow_t>:
   be10c:	f7f5 bfc5 	b.w	b409a <_Znaj>

000be110 <_ZSt17__throw_bad_allocv>:
   be110:	b508      	push	{r3, lr}
   be112:	f7fc f9a3 	bl	ba45c <abort>

000be116 <_ZSt19__throw_logic_errorPKc>:
   be116:	b508      	push	{r3, lr}
   be118:	f7fc f9a0 	bl	ba45c <abort>

000be11c <_ZSt20__throw_length_errorPKc>:
   be11c:	b508      	push	{r3, lr}
   be11e:	f7fc f99d 	bl	ba45c <abort>

000be122 <_ZSt24__throw_out_of_range_fmtPKcz>:
   be122:	b40f      	push	{r0, r1, r2, r3}
   be124:	b580      	push	{r7, lr}
   be126:	b084      	sub	sp, #16
   be128:	af00      	add	r7, sp, #0
   be12a:	f107 0418 	add.w	r4, r7, #24
   be12e:	f854 2b04 	ldr.w	r2, [r4], #4
   be132:	607a      	str	r2, [r7, #4]
   be134:	4610      	mov	r0, r2
   be136:	f000 ff56 	bl	befe6 <strlen>
   be13a:	f200 2307 	addw	r3, r0, #519	; 0x207
   be13e:	f023 0307 	bic.w	r3, r3, #7
   be142:	ebad 0d03 	sub.w	sp, sp, r3
   be146:	f500 7100 	add.w	r1, r0, #512	; 0x200
   be14a:	687a      	ldr	r2, [r7, #4]
   be14c:	60fc      	str	r4, [r7, #12]
   be14e:	4623      	mov	r3, r4
   be150:	4668      	mov	r0, sp
   be152:	f000 f85d 	bl	be210 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list>
   be156:	f7fc f981 	bl	ba45c <abort>

000be15a <_ZSt25__throw_bad_function_callv>:
   be15a:	b508      	push	{r3, lr}
   be15c:	f7fc f97e 	bl	ba45c <abort>

000be160 <_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info>:
   be160:	4901      	ldr	r1, [pc, #4]	; (be168 <_ZNSt19_Sp_make_shared_tag5_S_eqERKSt9type_info+0x8>)
   be162:	f000 b98b 	b.w	be47c <_ZNKSt9type_infoeqERKS_>
   be166:	bf00      	nop
   be168:	000c21dc 	.word	0x000c21dc

000be16c <_ZN9__gnu_cxx26__throw_insufficient_spaceEPKcS1_>:
   be16c:	b580      	push	{r7, lr}
   be16e:	b09c      	sub	sp, #112	; 0x70
   be170:	4606      	mov	r6, r0
   be172:	af00      	add	r7, sp, #0
   be174:	460c      	mov	r4, r1
   be176:	1ba4      	subs	r4, r4, r6
   be178:	490e      	ldr	r1, [pc, #56]	; (be1b4 <_ZN9__gnu_cxx26__throw_insufficient_spaceEPKcS1_+0x48>)
   be17a:	2269      	movs	r2, #105	; 0x69
   be17c:	1d38      	adds	r0, r7, #4
   be17e:	f000 fe94 	bl	beeaa <memcpy>
   be182:	f104 0370 	add.w	r3, r4, #112	; 0x70
   be186:	f023 0307 	bic.w	r3, r3, #7
   be18a:	ebad 0d03 	sub.w	sp, sp, r3
   be18e:	466d      	mov	r5, sp
   be190:	2268      	movs	r2, #104	; 0x68
   be192:	1d39      	adds	r1, r7, #4
   be194:	4628      	mov	r0, r5
   be196:	f000 fe88 	bl	beeaa <memcpy>
   be19a:	4622      	mov	r2, r4
   be19c:	4631      	mov	r1, r6
   be19e:	f105 0068 	add.w	r0, r5, #104	; 0x68
   be1a2:	442c      	add	r4, r5
   be1a4:	f000 fe81 	bl	beeaa <memcpy>
   be1a8:	2300      	movs	r3, #0
   be1aa:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
   be1ae:	4628      	mov	r0, r5
   be1b0:	f7ff ffb1 	bl	be116 <_ZSt19__throw_logic_errorPKc>
   be1b4:	000c21e4 	.word	0x000c21e4

000be1b8 <_ZN9__gnu_cxx15__concat_size_tEPcjj>:
   be1b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   be1bc:	af00      	add	r7, sp, #0
   be1be:	b084      	sub	sp, #16
   be1c0:	466d      	mov	r5, sp
   be1c2:	f105 040c 	add.w	r4, r5, #12
   be1c6:	f8df 8044 	ldr.w	r8, [pc, #68]	; be20c <_ZN9__gnu_cxx15__concat_size_tEPcjj+0x54>
   be1ca:	4623      	mov	r3, r4
   be1cc:	f04f 0c0a 	mov.w	ip, #10
   be1d0:	fbb2 f6fc 	udiv	r6, r2, ip
   be1d4:	fb0c 2e16 	mls	lr, ip, r6, r2
   be1d8:	f818 e00e 	ldrb.w	lr, [r8, lr]
   be1dc:	f803 ed01 	strb.w	lr, [r3, #-1]!
   be1e0:	4696      	mov	lr, r2
   be1e2:	f1be 0f09 	cmp.w	lr, #9
   be1e6:	4632      	mov	r2, r6
   be1e8:	d8f2      	bhi.n	be1d0 <_ZN9__gnu_cxx15__concat_size_tEPcjj+0x18>
   be1ea:	1ae4      	subs	r4, r4, r3
   be1ec:	428c      	cmp	r4, r1
   be1ee:	d809      	bhi.n	be204 <_ZN9__gnu_cxx15__concat_size_tEPcjj+0x4c>
   be1f0:	f1c4 030c 	rsb	r3, r4, #12
   be1f4:	4622      	mov	r2, r4
   be1f6:	18e9      	adds	r1, r5, r3
   be1f8:	f000 fe57 	bl	beeaa <memcpy>
   be1fc:	4620      	mov	r0, r4
   be1fe:	46bd      	mov	sp, r7
   be200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   be204:	f04f 34ff 	mov.w	r4, #4294967295
   be208:	e7f8      	b.n	be1fc <_ZN9__gnu_cxx15__concat_size_tEPcjj+0x44>
   be20a:	bf00      	nop
   be20c:	000c224d 	.word	0x000c224d

000be210 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list>:
   be210:	3901      	subs	r1, #1
   be212:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   be216:	4607      	mov	r7, r0
   be218:	4615      	mov	r5, r2
   be21a:	eb00 0801 	add.w	r8, r0, r1
   be21e:	4604      	mov	r4, r0
   be220:	782a      	ldrb	r2, [r5, #0]
   be222:	b392      	cbz	r2, be28a <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x7a>
   be224:	4544      	cmp	r4, r8
   be226:	d22a      	bcs.n	be27e <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x6e>
   be228:	2a25      	cmp	r2, #37	; 0x25
   be22a:	d107      	bne.n	be23c <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x2c>
   be22c:	786a      	ldrb	r2, [r5, #1]
   be22e:	2a73      	cmp	r2, #115	; 0x73
   be230:	d009      	beq.n	be246 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x36>
   be232:	2a7a      	cmp	r2, #122	; 0x7a
   be234:	d012      	beq.n	be25c <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x4c>
   be236:	2a25      	cmp	r2, #37	; 0x25
   be238:	d100      	bne.n	be23c <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x2c>
   be23a:	3501      	adds	r5, #1
   be23c:	f815 2b01 	ldrb.w	r2, [r5], #1
   be240:	f804 2b01 	strb.w	r2, [r4], #1
   be244:	e7ec      	b.n	be220 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x10>
   be246:	f853 2b04 	ldr.w	r2, [r3], #4
   be24a:	3a01      	subs	r2, #1
   be24c:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   be250:	b1c9      	cbz	r1, be286 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x76>
   be252:	4544      	cmp	r4, r8
   be254:	d013      	beq.n	be27e <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x6e>
   be256:	f804 1b01 	strb.w	r1, [r4], #1
   be25a:	e7f7      	b.n	be24c <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x3c>
   be25c:	78aa      	ldrb	r2, [r5, #2]
   be25e:	2a75      	cmp	r2, #117	; 0x75
   be260:	d1ec      	bne.n	be23c <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x2c>
   be262:	461e      	mov	r6, r3
   be264:	eba8 0104 	sub.w	r1, r8, r4
   be268:	f856 2b04 	ldr.w	r2, [r6], #4
   be26c:	4620      	mov	r0, r4
   be26e:	f7ff ffa3 	bl	be1b8 <_ZN9__gnu_cxx15__concat_size_tEPcjj>
   be272:	2800      	cmp	r0, #0
   be274:	dd03      	ble.n	be27e <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x6e>
   be276:	4404      	add	r4, r0
   be278:	3503      	adds	r5, #3
   be27a:	4633      	mov	r3, r6
   be27c:	e7d0      	b.n	be220 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x10>
   be27e:	4621      	mov	r1, r4
   be280:	4638      	mov	r0, r7
   be282:	f7ff ff73 	bl	be16c <_ZN9__gnu_cxx26__throw_insufficient_spaceEPKcS1_>
   be286:	3502      	adds	r5, #2
   be288:	e7ca      	b.n	be220 <_ZN9__gnu_cxx15__snprintf_liteEPcjPKcSt9__va_list+0x10>
   be28a:	7022      	strb	r2, [r4, #0]
   be28c:	1be0      	subs	r0, r4, r7
   be28e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000be292 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PPv>:
   be292:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   be294:	2400      	movs	r4, #0
   be296:	2310      	movs	r3, #16
   be298:	e9cd 3402 	strd	r3, r4, [sp, #8]
   be29c:	6803      	ldr	r3, [r0, #0]
   be29e:	4615      	mov	r5, r2
   be2a0:	699e      	ldr	r6, [r3, #24]
   be2a2:	6812      	ldr	r2, [r2, #0]
   be2a4:	466b      	mov	r3, sp
   be2a6:	e9cd 4400 	strd	r4, r4, [sp]
   be2aa:	47b0      	blx	r6
   be2ac:	f89d 3004 	ldrb.w	r3, [sp, #4]
   be2b0:	f003 0306 	and.w	r3, r3, #6
   be2b4:	2b06      	cmp	r3, #6
   be2b6:	bf03      	ittte	eq
   be2b8:	9b00      	ldreq	r3, [sp, #0]
   be2ba:	602b      	streq	r3, [r5, #0]
   be2bc:	2001      	moveq	r0, #1
   be2be:	4620      	movne	r0, r4
   be2c0:	b004      	add	sp, #16
   be2c2:	bd70      	pop	{r4, r5, r6, pc}

000be2c4 <_ZNK10__cxxabiv117__class_type_info20__do_find_public_srcEiPKvPKS0_S2_>:
   be2c4:	9800      	ldr	r0, [sp, #0]
   be2c6:	4290      	cmp	r0, r2
   be2c8:	bf14      	ite	ne
   be2ca:	2001      	movne	r0, #1
   be2cc:	2006      	moveq	r0, #6
   be2ce:	4770      	bx	lr

000be2d0 <_ZN10__cxxabiv117__class_type_infoD1Ev>:
   be2d0:	b510      	push	{r4, lr}
   be2d2:	4b03      	ldr	r3, [pc, #12]	; (be2e0 <_ZN10__cxxabiv117__class_type_infoD1Ev+0x10>)
   be2d4:	6003      	str	r3, [r0, #0]
   be2d6:	4604      	mov	r4, r0
   be2d8:	f000 f8cd 	bl	be476 <_ZNSt9type_infoD1Ev>
   be2dc:	4620      	mov	r0, r4
   be2de:	bd10      	pop	{r4, pc}
   be2e0:	000c2290 	.word	0x000c2290

000be2e4 <_ZN10__cxxabiv117__class_type_infoD0Ev>:
   be2e4:	b510      	push	{r4, lr}
   be2e6:	4604      	mov	r4, r0
   be2e8:	f7ff fff2 	bl	be2d0 <_ZN10__cxxabiv117__class_type_infoD1Ev>
   be2ec:	4620      	mov	r0, r4
   be2ee:	2108      	movs	r1, #8
   be2f0:	f7f5 fed5 	bl	b409e <_ZdlPvj>
   be2f4:	4620      	mov	r0, r4
   be2f6:	bd10      	pop	{r4, pc}

000be2f8 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE>:
   be2f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   be2fc:	461f      	mov	r7, r3
   be2fe:	e9dd 3408 	ldrd	r3, r4, [sp, #32]
   be302:	f8dd 8018 	ldr.w	r8, [sp, #24]
   be306:	4598      	cmp	r8, r3
   be308:	4606      	mov	r6, r0
   be30a:	4615      	mov	r5, r2
   be30c:	d107      	bne.n	be31e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x26>
   be30e:	9907      	ldr	r1, [sp, #28]
   be310:	f000 f8b4 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be314:	b118      	cbz	r0, be31e <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x26>
   be316:	7165      	strb	r5, [r4, #5]
   be318:	2000      	movs	r0, #0
   be31a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   be31e:	4639      	mov	r1, r7
   be320:	4630      	mov	r0, r6
   be322:	f000 f8ab 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be326:	2800      	cmp	r0, #0
   be328:	d0f6      	beq.n	be318 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x20>
   be32a:	2301      	movs	r3, #1
   be32c:	f8c4 8000 	str.w	r8, [r4]
   be330:	7125      	strb	r5, [r4, #4]
   be332:	71a3      	strb	r3, [r4, #6]
   be334:	e7f0      	b.n	be318 <_ZNK10__cxxabiv117__class_type_info12__do_dyncastEiNS0_10__sub_kindEPKS0_PKvS3_S5_RNS0_16__dyncast_resultE+0x20>

000be336 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>:
   be336:	b538      	push	{r3, r4, r5, lr}
   be338:	4615      	mov	r5, r2
   be33a:	461c      	mov	r4, r3
   be33c:	f000 f89e 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be340:	b120      	cbz	r0, be34c <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE+0x16>
   be342:	2308      	movs	r3, #8
   be344:	60e3      	str	r3, [r4, #12]
   be346:	2306      	movs	r3, #6
   be348:	6025      	str	r5, [r4, #0]
   be34a:	7123      	strb	r3, [r4, #4]
   be34c:	bd38      	pop	{r3, r4, r5, pc}

000be34e <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj>:
   be34e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   be350:	4605      	mov	r5, r0
   be352:	460c      	mov	r4, r1
   be354:	9201      	str	r2, [sp, #4]
   be356:	461e      	mov	r6, r3
   be358:	f000 f890 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be35c:	b950      	cbnz	r0, be374 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
   be35e:	2e03      	cmp	r6, #3
   be360:	d808      	bhi.n	be374 <_ZNK10__cxxabiv117__class_type_info10__do_catchEPKSt9type_infoPPvj+0x26>
   be362:	6823      	ldr	r3, [r4, #0]
   be364:	9a01      	ldr	r2, [sp, #4]
   be366:	695b      	ldr	r3, [r3, #20]
   be368:	4629      	mov	r1, r5
   be36a:	4620      	mov	r0, r4
   be36c:	b002      	add	sp, #8
   be36e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   be372:	4718      	bx	r3
   be374:	b002      	add	sp, #8
   be376:	bd70      	pop	{r4, r5, r6, pc}

000be378 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>:
   be378:	b510      	push	{r4, lr}
   be37a:	4b03      	ldr	r3, [pc, #12]	; (be388 <_ZN10__cxxabiv120__si_class_type_infoD1Ev+0x10>)
   be37c:	6003      	str	r3, [r0, #0]
   be37e:	4604      	mov	r4, r0
   be380:	f7ff ffa6 	bl	be2d0 <_ZN10__cxxabiv117__class_type_infoD1Ev>
   be384:	4620      	mov	r0, r4
   be386:	bd10      	pop	{r4, pc}
   be388:	000c22f0 	.word	0x000c22f0

000be38c <_ZN10__cxxabiv120__si_class_type_infoD0Ev>:
   be38c:	b510      	push	{r4, lr}
   be38e:	4604      	mov	r4, r0
   be390:	f7ff fff2 	bl	be378 <_ZN10__cxxabiv120__si_class_type_infoD1Ev>
   be394:	4620      	mov	r0, r4
   be396:	210c      	movs	r1, #12
   be398:	f7f5 fe81 	bl	b409e <_ZdlPvj>
   be39c:	4620      	mov	r0, r4
   be39e:	bd10      	pop	{r4, pc}

000be3a0 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_>:
   be3a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   be3a2:	9f08      	ldr	r7, [sp, #32]
   be3a4:	4297      	cmp	r7, r2
   be3a6:	4605      	mov	r5, r0
   be3a8:	460e      	mov	r6, r1
   be3aa:	4614      	mov	r4, r2
   be3ac:	d00a      	beq.n	be3c4 <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0x24>
   be3ae:	68a8      	ldr	r0, [r5, #8]
   be3b0:	6802      	ldr	r2, [r0, #0]
   be3b2:	9708      	str	r7, [sp, #32]
   be3b4:	6a15      	ldr	r5, [r2, #32]
   be3b6:	4631      	mov	r1, r6
   be3b8:	4622      	mov	r2, r4
   be3ba:	46ac      	mov	ip, r5
   be3bc:	b003      	add	sp, #12
   be3be:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   be3c2:	4760      	bx	ip
   be3c4:	4619      	mov	r1, r3
   be3c6:	9301      	str	r3, [sp, #4]
   be3c8:	f000 f858 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be3cc:	9b01      	ldr	r3, [sp, #4]
   be3ce:	2800      	cmp	r0, #0
   be3d0:	d0ed      	beq.n	be3ae <_ZNK10__cxxabiv120__si_class_type_info20__do_find_public_srcEiPKvPKNS_17__class_type_infoES2_+0xe>
   be3d2:	2006      	movs	r0, #6
   be3d4:	b003      	add	sp, #12
   be3d6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000be3d8 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE>:
   be3d8:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   be3dc:	460d      	mov	r5, r1
   be3de:	4619      	mov	r1, r3
   be3e0:	e9dd 4b0a 	ldrd	r4, fp, [sp, #40]	; 0x28
   be3e4:	e9dd a60c 	ldrd	sl, r6, [sp, #48]	; 0x30
   be3e8:	4681      	mov	r9, r0
   be3ea:	4617      	mov	r7, r2
   be3ec:	4698      	mov	r8, r3
   be3ee:	f000 f845 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be3f2:	b190      	cbz	r0, be41a <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x42>
   be3f4:	2d00      	cmp	r5, #0
   be3f6:	6034      	str	r4, [r6, #0]
   be3f8:	7137      	strb	r7, [r6, #4]
   be3fa:	db09      	blt.n	be410 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x38>
   be3fc:	1961      	adds	r1, r4, r5
   be3fe:	458a      	cmp	sl, r1
   be400:	bf0c      	ite	eq
   be402:	2106      	moveq	r1, #6
   be404:	2101      	movne	r1, #1
   be406:	71b1      	strb	r1, [r6, #6]
   be408:	2000      	movs	r0, #0
   be40a:	b001      	add	sp, #4
   be40c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   be410:	3502      	adds	r5, #2
   be412:	d1f9      	bne.n	be408 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
   be414:	2301      	movs	r3, #1
   be416:	71b3      	strb	r3, [r6, #6]
   be418:	e7f6      	b.n	be408 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
   be41a:	4554      	cmp	r4, sl
   be41c:	d106      	bne.n	be42c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
   be41e:	4659      	mov	r1, fp
   be420:	4648      	mov	r0, r9
   be422:	f000 f82b 	bl	be47c <_ZNKSt9type_infoeqERKS_>
   be426:	b108      	cbz	r0, be42c <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x54>
   be428:	7177      	strb	r7, [r6, #5]
   be42a:	e7ed      	b.n	be408 <_ZNK10__cxxabiv120__si_class_type_info12__do_dyncastEiNS_17__class_type_info10__sub_kindEPKS1_PKvS4_S6_RNS1_16__dyncast_resultE+0x30>
   be42c:	f8d9 0008 	ldr.w	r0, [r9, #8]
   be430:	6803      	ldr	r3, [r0, #0]
   be432:	e9cd a60c 	strd	sl, r6, [sp, #48]	; 0x30
   be436:	e9cd 4b0a 	strd	r4, fp, [sp, #40]	; 0x28
   be43a:	69dc      	ldr	r4, [r3, #28]
   be43c:	463a      	mov	r2, r7
   be43e:	4643      	mov	r3, r8
   be440:	4629      	mov	r1, r5
   be442:	46a4      	mov	ip, r4
   be444:	b001      	add	sp, #4
   be446:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   be44a:	4760      	bx	ip

000be44c <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE>:
   be44c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   be450:	4607      	mov	r7, r0
   be452:	460c      	mov	r4, r1
   be454:	4615      	mov	r5, r2
   be456:	461e      	mov	r6, r3
   be458:	f7ff ff6d 	bl	be336 <_ZNK10__cxxabiv117__class_type_info11__do_upcastEPKS0_PKvRNS0_15__upcast_resultE>
   be45c:	b948      	cbnz	r0, be472 <_ZNK10__cxxabiv120__si_class_type_info11__do_upcastEPKNS_17__class_type_infoEPKvRNS1_15__upcast_resultE+0x26>
   be45e:	68b8      	ldr	r0, [r7, #8]
   be460:	6803      	ldr	r3, [r0, #0]
   be462:	699f      	ldr	r7, [r3, #24]
   be464:	462a      	mov	r2, r5
   be466:	4633      	mov	r3, r6
   be468:	4621      	mov	r1, r4
   be46a:	46bc      	mov	ip, r7
   be46c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   be470:	4760      	bx	ip
   be472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000be476 <_ZNSt9type_infoD1Ev>:
   be476:	4770      	bx	lr

000be478 <_ZNKSt9type_info14__is_pointer_pEv>:
   be478:	2000      	movs	r0, #0
   be47a:	4770      	bx	lr

000be47c <_ZNKSt9type_infoeqERKS_>:
   be47c:	4281      	cmp	r1, r0
   be47e:	b508      	push	{r3, lr}
   be480:	d00e      	beq.n	be4a0 <_ZNKSt9type_infoeqERKS_+0x24>
   be482:	6840      	ldr	r0, [r0, #4]
   be484:	7803      	ldrb	r3, [r0, #0]
   be486:	2b2a      	cmp	r3, #42	; 0x2a
   be488:	d00c      	beq.n	be4a4 <_ZNKSt9type_infoeqERKS_+0x28>
   be48a:	6849      	ldr	r1, [r1, #4]
   be48c:	780b      	ldrb	r3, [r1, #0]
   be48e:	2b2a      	cmp	r3, #42	; 0x2a
   be490:	bf08      	it	eq
   be492:	3101      	addeq	r1, #1
   be494:	f000 fd77 	bl	bef86 <strcmp>
   be498:	fab0 f080 	clz	r0, r0
   be49c:	0940      	lsrs	r0, r0, #5
   be49e:	bd08      	pop	{r3, pc}
   be4a0:	2001      	movs	r0, #1
   be4a2:	e7fc      	b.n	be49e <_ZNKSt9type_infoeqERKS_+0x22>
   be4a4:	2000      	movs	r0, #0
   be4a6:	e7fa      	b.n	be49e <_ZNKSt9type_infoeqERKS_+0x22>

000be4a8 <__aeabi_drsub>:
   be4a8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   be4ac:	e002      	b.n	be4b4 <__adddf3>
   be4ae:	bf00      	nop

000be4b0 <__aeabi_dsub>:
   be4b0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

000be4b4 <__adddf3>:
   be4b4:	b530      	push	{r4, r5, lr}
   be4b6:	ea4f 0441 	mov.w	r4, r1, lsl #1
   be4ba:	ea4f 0543 	mov.w	r5, r3, lsl #1
   be4be:	ea94 0f05 	teq	r4, r5
   be4c2:	bf08      	it	eq
   be4c4:	ea90 0f02 	teqeq	r0, r2
   be4c8:	bf1f      	itttt	ne
   be4ca:	ea54 0c00 	orrsne.w	ip, r4, r0
   be4ce:	ea55 0c02 	orrsne.w	ip, r5, r2
   be4d2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   be4d6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   be4da:	f000 80e2 	beq.w	be6a2 <__adddf3+0x1ee>
   be4de:	ea4f 5454 	mov.w	r4, r4, lsr #21
   be4e2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   be4e6:	bfb8      	it	lt
   be4e8:	426d      	neglt	r5, r5
   be4ea:	dd0c      	ble.n	be506 <__adddf3+0x52>
   be4ec:	442c      	add	r4, r5
   be4ee:	ea80 0202 	eor.w	r2, r0, r2
   be4f2:	ea81 0303 	eor.w	r3, r1, r3
   be4f6:	ea82 0000 	eor.w	r0, r2, r0
   be4fa:	ea83 0101 	eor.w	r1, r3, r1
   be4fe:	ea80 0202 	eor.w	r2, r0, r2
   be502:	ea81 0303 	eor.w	r3, r1, r3
   be506:	2d36      	cmp	r5, #54	; 0x36
   be508:	bf88      	it	hi
   be50a:	bd30      	pophi	{r4, r5, pc}
   be50c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   be510:	ea4f 3101 	mov.w	r1, r1, lsl #12
   be514:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   be518:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   be51c:	d002      	beq.n	be524 <__adddf3+0x70>
   be51e:	4240      	negs	r0, r0
   be520:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   be524:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   be528:	ea4f 3303 	mov.w	r3, r3, lsl #12
   be52c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   be530:	d002      	beq.n	be538 <__adddf3+0x84>
   be532:	4252      	negs	r2, r2
   be534:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   be538:	ea94 0f05 	teq	r4, r5
   be53c:	f000 80a7 	beq.w	be68e <__adddf3+0x1da>
   be540:	f1a4 0401 	sub.w	r4, r4, #1
   be544:	f1d5 0e20 	rsbs	lr, r5, #32
   be548:	db0d      	blt.n	be566 <__adddf3+0xb2>
   be54a:	fa02 fc0e 	lsl.w	ip, r2, lr
   be54e:	fa22 f205 	lsr.w	r2, r2, r5
   be552:	1880      	adds	r0, r0, r2
   be554:	f141 0100 	adc.w	r1, r1, #0
   be558:	fa03 f20e 	lsl.w	r2, r3, lr
   be55c:	1880      	adds	r0, r0, r2
   be55e:	fa43 f305 	asr.w	r3, r3, r5
   be562:	4159      	adcs	r1, r3
   be564:	e00e      	b.n	be584 <__adddf3+0xd0>
   be566:	f1a5 0520 	sub.w	r5, r5, #32
   be56a:	f10e 0e20 	add.w	lr, lr, #32
   be56e:	2a01      	cmp	r2, #1
   be570:	fa03 fc0e 	lsl.w	ip, r3, lr
   be574:	bf28      	it	cs
   be576:	f04c 0c02 	orrcs.w	ip, ip, #2
   be57a:	fa43 f305 	asr.w	r3, r3, r5
   be57e:	18c0      	adds	r0, r0, r3
   be580:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   be584:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   be588:	d507      	bpl.n	be59a <__adddf3+0xe6>
   be58a:	f04f 0e00 	mov.w	lr, #0
   be58e:	f1dc 0c00 	rsbs	ip, ip, #0
   be592:	eb7e 0000 	sbcs.w	r0, lr, r0
   be596:	eb6e 0101 	sbc.w	r1, lr, r1
   be59a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   be59e:	d31b      	bcc.n	be5d8 <__adddf3+0x124>
   be5a0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   be5a4:	d30c      	bcc.n	be5c0 <__adddf3+0x10c>
   be5a6:	0849      	lsrs	r1, r1, #1
   be5a8:	ea5f 0030 	movs.w	r0, r0, rrx
   be5ac:	ea4f 0c3c 	mov.w	ip, ip, rrx
   be5b0:	f104 0401 	add.w	r4, r4, #1
   be5b4:	ea4f 5244 	mov.w	r2, r4, lsl #21
   be5b8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   be5bc:	f080 809a 	bcs.w	be6f4 <__adddf3+0x240>
   be5c0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   be5c4:	bf08      	it	eq
   be5c6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   be5ca:	f150 0000 	adcs.w	r0, r0, #0
   be5ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   be5d2:	ea41 0105 	orr.w	r1, r1, r5
   be5d6:	bd30      	pop	{r4, r5, pc}
   be5d8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   be5dc:	4140      	adcs	r0, r0
   be5de:	eb41 0101 	adc.w	r1, r1, r1
   be5e2:	3c01      	subs	r4, #1
   be5e4:	bf28      	it	cs
   be5e6:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   be5ea:	d2e9      	bcs.n	be5c0 <__adddf3+0x10c>
   be5ec:	f091 0f00 	teq	r1, #0
   be5f0:	bf04      	itt	eq
   be5f2:	4601      	moveq	r1, r0
   be5f4:	2000      	moveq	r0, #0
   be5f6:	fab1 f381 	clz	r3, r1
   be5fa:	bf08      	it	eq
   be5fc:	3320      	addeq	r3, #32
   be5fe:	f1a3 030b 	sub.w	r3, r3, #11
   be602:	f1b3 0220 	subs.w	r2, r3, #32
   be606:	da0c      	bge.n	be622 <__adddf3+0x16e>
   be608:	320c      	adds	r2, #12
   be60a:	dd08      	ble.n	be61e <__adddf3+0x16a>
   be60c:	f102 0c14 	add.w	ip, r2, #20
   be610:	f1c2 020c 	rsb	r2, r2, #12
   be614:	fa01 f00c 	lsl.w	r0, r1, ip
   be618:	fa21 f102 	lsr.w	r1, r1, r2
   be61c:	e00c      	b.n	be638 <__adddf3+0x184>
   be61e:	f102 0214 	add.w	r2, r2, #20
   be622:	bfd8      	it	le
   be624:	f1c2 0c20 	rsble	ip, r2, #32
   be628:	fa01 f102 	lsl.w	r1, r1, r2
   be62c:	fa20 fc0c 	lsr.w	ip, r0, ip
   be630:	bfdc      	itt	le
   be632:	ea41 010c 	orrle.w	r1, r1, ip
   be636:	4090      	lslle	r0, r2
   be638:	1ae4      	subs	r4, r4, r3
   be63a:	bfa2      	ittt	ge
   be63c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   be640:	4329      	orrge	r1, r5
   be642:	bd30      	popge	{r4, r5, pc}
   be644:	ea6f 0404 	mvn.w	r4, r4
   be648:	3c1f      	subs	r4, #31
   be64a:	da1c      	bge.n	be686 <__adddf3+0x1d2>
   be64c:	340c      	adds	r4, #12
   be64e:	dc0e      	bgt.n	be66e <__adddf3+0x1ba>
   be650:	f104 0414 	add.w	r4, r4, #20
   be654:	f1c4 0220 	rsb	r2, r4, #32
   be658:	fa20 f004 	lsr.w	r0, r0, r4
   be65c:	fa01 f302 	lsl.w	r3, r1, r2
   be660:	ea40 0003 	orr.w	r0, r0, r3
   be664:	fa21 f304 	lsr.w	r3, r1, r4
   be668:	ea45 0103 	orr.w	r1, r5, r3
   be66c:	bd30      	pop	{r4, r5, pc}
   be66e:	f1c4 040c 	rsb	r4, r4, #12
   be672:	f1c4 0220 	rsb	r2, r4, #32
   be676:	fa20 f002 	lsr.w	r0, r0, r2
   be67a:	fa01 f304 	lsl.w	r3, r1, r4
   be67e:	ea40 0003 	orr.w	r0, r0, r3
   be682:	4629      	mov	r1, r5
   be684:	bd30      	pop	{r4, r5, pc}
   be686:	fa21 f004 	lsr.w	r0, r1, r4
   be68a:	4629      	mov	r1, r5
   be68c:	bd30      	pop	{r4, r5, pc}
   be68e:	f094 0f00 	teq	r4, #0
   be692:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   be696:	bf06      	itte	eq
   be698:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   be69c:	3401      	addeq	r4, #1
   be69e:	3d01      	subne	r5, #1
   be6a0:	e74e      	b.n	be540 <__adddf3+0x8c>
   be6a2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   be6a6:	bf18      	it	ne
   be6a8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   be6ac:	d029      	beq.n	be702 <__adddf3+0x24e>
   be6ae:	ea94 0f05 	teq	r4, r5
   be6b2:	bf08      	it	eq
   be6b4:	ea90 0f02 	teqeq	r0, r2
   be6b8:	d005      	beq.n	be6c6 <__adddf3+0x212>
   be6ba:	ea54 0c00 	orrs.w	ip, r4, r0
   be6be:	bf04      	itt	eq
   be6c0:	4619      	moveq	r1, r3
   be6c2:	4610      	moveq	r0, r2
   be6c4:	bd30      	pop	{r4, r5, pc}
   be6c6:	ea91 0f03 	teq	r1, r3
   be6ca:	bf1e      	ittt	ne
   be6cc:	2100      	movne	r1, #0
   be6ce:	2000      	movne	r0, #0
   be6d0:	bd30      	popne	{r4, r5, pc}
   be6d2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   be6d6:	d105      	bne.n	be6e4 <__adddf3+0x230>
   be6d8:	0040      	lsls	r0, r0, #1
   be6da:	4149      	adcs	r1, r1
   be6dc:	bf28      	it	cs
   be6de:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   be6e2:	bd30      	pop	{r4, r5, pc}
   be6e4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   be6e8:	bf3c      	itt	cc
   be6ea:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   be6ee:	bd30      	popcc	{r4, r5, pc}
   be6f0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   be6f4:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   be6f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   be6fc:	f04f 0000 	mov.w	r0, #0
   be700:	bd30      	pop	{r4, r5, pc}
   be702:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   be706:	bf1a      	itte	ne
   be708:	4619      	movne	r1, r3
   be70a:	4610      	movne	r0, r2
   be70c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   be710:	bf1c      	itt	ne
   be712:	460b      	movne	r3, r1
   be714:	4602      	movne	r2, r0
   be716:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   be71a:	bf06      	itte	eq
   be71c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   be720:	ea91 0f03 	teqeq	r1, r3
   be724:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   be728:	bd30      	pop	{r4, r5, pc}
   be72a:	bf00      	nop

000be72c <__aeabi_ui2d>:
   be72c:	f090 0f00 	teq	r0, #0
   be730:	bf04      	itt	eq
   be732:	2100      	moveq	r1, #0
   be734:	4770      	bxeq	lr
   be736:	b530      	push	{r4, r5, lr}
   be738:	f44f 6480 	mov.w	r4, #1024	; 0x400
   be73c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   be740:	f04f 0500 	mov.w	r5, #0
   be744:	f04f 0100 	mov.w	r1, #0
   be748:	e750      	b.n	be5ec <__adddf3+0x138>
   be74a:	bf00      	nop

000be74c <__aeabi_i2d>:
   be74c:	f090 0f00 	teq	r0, #0
   be750:	bf04      	itt	eq
   be752:	2100      	moveq	r1, #0
   be754:	4770      	bxeq	lr
   be756:	b530      	push	{r4, r5, lr}
   be758:	f44f 6480 	mov.w	r4, #1024	; 0x400
   be75c:	f104 0432 	add.w	r4, r4, #50	; 0x32
   be760:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   be764:	bf48      	it	mi
   be766:	4240      	negmi	r0, r0
   be768:	f04f 0100 	mov.w	r1, #0
   be76c:	e73e      	b.n	be5ec <__adddf3+0x138>
   be76e:	bf00      	nop

000be770 <__aeabi_f2d>:
   be770:	0042      	lsls	r2, r0, #1
   be772:	ea4f 01e2 	mov.w	r1, r2, asr #3
   be776:	ea4f 0131 	mov.w	r1, r1, rrx
   be77a:	ea4f 7002 	mov.w	r0, r2, lsl #28
   be77e:	bf1f      	itttt	ne
   be780:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   be784:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   be788:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   be78c:	4770      	bxne	lr
   be78e:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   be792:	bf08      	it	eq
   be794:	4770      	bxeq	lr
   be796:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   be79a:	bf04      	itt	eq
   be79c:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   be7a0:	4770      	bxeq	lr
   be7a2:	b530      	push	{r4, r5, lr}
   be7a4:	f44f 7460 	mov.w	r4, #896	; 0x380
   be7a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   be7ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   be7b0:	e71c      	b.n	be5ec <__adddf3+0x138>
   be7b2:	bf00      	nop

000be7b4 <__aeabi_ul2d>:
   be7b4:	ea50 0201 	orrs.w	r2, r0, r1
   be7b8:	bf08      	it	eq
   be7ba:	4770      	bxeq	lr
   be7bc:	b530      	push	{r4, r5, lr}
   be7be:	f04f 0500 	mov.w	r5, #0
   be7c2:	e00a      	b.n	be7da <__aeabi_l2d+0x16>

000be7c4 <__aeabi_l2d>:
   be7c4:	ea50 0201 	orrs.w	r2, r0, r1
   be7c8:	bf08      	it	eq
   be7ca:	4770      	bxeq	lr
   be7cc:	b530      	push	{r4, r5, lr}
   be7ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   be7d2:	d502      	bpl.n	be7da <__aeabi_l2d+0x16>
   be7d4:	4240      	negs	r0, r0
   be7d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   be7da:	f44f 6480 	mov.w	r4, #1024	; 0x400
   be7de:	f104 0432 	add.w	r4, r4, #50	; 0x32
   be7e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   be7e6:	f43f aed8 	beq.w	be59a <__adddf3+0xe6>
   be7ea:	f04f 0203 	mov.w	r2, #3
   be7ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   be7f2:	bf18      	it	ne
   be7f4:	3203      	addne	r2, #3
   be7f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   be7fa:	bf18      	it	ne
   be7fc:	3203      	addne	r2, #3
   be7fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   be802:	f1c2 0320 	rsb	r3, r2, #32
   be806:	fa00 fc03 	lsl.w	ip, r0, r3
   be80a:	fa20 f002 	lsr.w	r0, r0, r2
   be80e:	fa01 fe03 	lsl.w	lr, r1, r3
   be812:	ea40 000e 	orr.w	r0, r0, lr
   be816:	fa21 f102 	lsr.w	r1, r1, r2
   be81a:	4414      	add	r4, r2
   be81c:	e6bd      	b.n	be59a <__adddf3+0xe6>
   be81e:	bf00      	nop

000be820 <__aeabi_dmul>:
   be820:	b570      	push	{r4, r5, r6, lr}
   be822:	f04f 0cff 	mov.w	ip, #255	; 0xff
   be826:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   be82a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   be82e:	bf1d      	ittte	ne
   be830:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   be834:	ea94 0f0c 	teqne	r4, ip
   be838:	ea95 0f0c 	teqne	r5, ip
   be83c:	f000 f8de 	bleq	be9fc <__aeabi_dmul+0x1dc>
   be840:	442c      	add	r4, r5
   be842:	ea81 0603 	eor.w	r6, r1, r3
   be846:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   be84a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   be84e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   be852:	bf18      	it	ne
   be854:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   be858:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   be85c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   be860:	d038      	beq.n	be8d4 <__aeabi_dmul+0xb4>
   be862:	fba0 ce02 	umull	ip, lr, r0, r2
   be866:	f04f 0500 	mov.w	r5, #0
   be86a:	fbe1 e502 	umlal	lr, r5, r1, r2
   be86e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   be872:	fbe0 e503 	umlal	lr, r5, r0, r3
   be876:	f04f 0600 	mov.w	r6, #0
   be87a:	fbe1 5603 	umlal	r5, r6, r1, r3
   be87e:	f09c 0f00 	teq	ip, #0
   be882:	bf18      	it	ne
   be884:	f04e 0e01 	orrne.w	lr, lr, #1
   be888:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   be88c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   be890:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   be894:	d204      	bcs.n	be8a0 <__aeabi_dmul+0x80>
   be896:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   be89a:	416d      	adcs	r5, r5
   be89c:	eb46 0606 	adc.w	r6, r6, r6
   be8a0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   be8a4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   be8a8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   be8ac:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   be8b0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   be8b4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   be8b8:	bf88      	it	hi
   be8ba:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   be8be:	d81e      	bhi.n	be8fe <__aeabi_dmul+0xde>
   be8c0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   be8c4:	bf08      	it	eq
   be8c6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   be8ca:	f150 0000 	adcs.w	r0, r0, #0
   be8ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   be8d2:	bd70      	pop	{r4, r5, r6, pc}
   be8d4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   be8d8:	ea46 0101 	orr.w	r1, r6, r1
   be8dc:	ea40 0002 	orr.w	r0, r0, r2
   be8e0:	ea81 0103 	eor.w	r1, r1, r3
   be8e4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   be8e8:	bfc2      	ittt	gt
   be8ea:	ebd4 050c 	rsbsgt	r5, r4, ip
   be8ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   be8f2:	bd70      	popgt	{r4, r5, r6, pc}
   be8f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   be8f8:	f04f 0e00 	mov.w	lr, #0
   be8fc:	3c01      	subs	r4, #1
   be8fe:	f300 80ab 	bgt.w	bea58 <__aeabi_dmul+0x238>
   be902:	f114 0f36 	cmn.w	r4, #54	; 0x36
   be906:	bfde      	ittt	le
   be908:	2000      	movle	r0, #0
   be90a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   be90e:	bd70      	pople	{r4, r5, r6, pc}
   be910:	f1c4 0400 	rsb	r4, r4, #0
   be914:	3c20      	subs	r4, #32
   be916:	da35      	bge.n	be984 <__aeabi_dmul+0x164>
   be918:	340c      	adds	r4, #12
   be91a:	dc1b      	bgt.n	be954 <__aeabi_dmul+0x134>
   be91c:	f104 0414 	add.w	r4, r4, #20
   be920:	f1c4 0520 	rsb	r5, r4, #32
   be924:	fa00 f305 	lsl.w	r3, r0, r5
   be928:	fa20 f004 	lsr.w	r0, r0, r4
   be92c:	fa01 f205 	lsl.w	r2, r1, r5
   be930:	ea40 0002 	orr.w	r0, r0, r2
   be934:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   be938:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   be93c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   be940:	fa21 f604 	lsr.w	r6, r1, r4
   be944:	eb42 0106 	adc.w	r1, r2, r6
   be948:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   be94c:	bf08      	it	eq
   be94e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   be952:	bd70      	pop	{r4, r5, r6, pc}
   be954:	f1c4 040c 	rsb	r4, r4, #12
   be958:	f1c4 0520 	rsb	r5, r4, #32
   be95c:	fa00 f304 	lsl.w	r3, r0, r4
   be960:	fa20 f005 	lsr.w	r0, r0, r5
   be964:	fa01 f204 	lsl.w	r2, r1, r4
   be968:	ea40 0002 	orr.w	r0, r0, r2
   be96c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   be970:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   be974:	f141 0100 	adc.w	r1, r1, #0
   be978:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   be97c:	bf08      	it	eq
   be97e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   be982:	bd70      	pop	{r4, r5, r6, pc}
   be984:	f1c4 0520 	rsb	r5, r4, #32
   be988:	fa00 f205 	lsl.w	r2, r0, r5
   be98c:	ea4e 0e02 	orr.w	lr, lr, r2
   be990:	fa20 f304 	lsr.w	r3, r0, r4
   be994:	fa01 f205 	lsl.w	r2, r1, r5
   be998:	ea43 0302 	orr.w	r3, r3, r2
   be99c:	fa21 f004 	lsr.w	r0, r1, r4
   be9a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   be9a4:	fa21 f204 	lsr.w	r2, r1, r4
   be9a8:	ea20 0002 	bic.w	r0, r0, r2
   be9ac:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   be9b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   be9b4:	bf08      	it	eq
   be9b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   be9ba:	bd70      	pop	{r4, r5, r6, pc}
   be9bc:	f094 0f00 	teq	r4, #0
   be9c0:	d10f      	bne.n	be9e2 <__aeabi_dmul+0x1c2>
   be9c2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   be9c6:	0040      	lsls	r0, r0, #1
   be9c8:	eb41 0101 	adc.w	r1, r1, r1
   be9cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   be9d0:	bf08      	it	eq
   be9d2:	3c01      	subeq	r4, #1
   be9d4:	d0f7      	beq.n	be9c6 <__aeabi_dmul+0x1a6>
   be9d6:	ea41 0106 	orr.w	r1, r1, r6
   be9da:	f095 0f00 	teq	r5, #0
   be9de:	bf18      	it	ne
   be9e0:	4770      	bxne	lr
   be9e2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   be9e6:	0052      	lsls	r2, r2, #1
   be9e8:	eb43 0303 	adc.w	r3, r3, r3
   be9ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   be9f0:	bf08      	it	eq
   be9f2:	3d01      	subeq	r5, #1
   be9f4:	d0f7      	beq.n	be9e6 <__aeabi_dmul+0x1c6>
   be9f6:	ea43 0306 	orr.w	r3, r3, r6
   be9fa:	4770      	bx	lr
   be9fc:	ea94 0f0c 	teq	r4, ip
   bea00:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   bea04:	bf18      	it	ne
   bea06:	ea95 0f0c 	teqne	r5, ip
   bea0a:	d00c      	beq.n	bea26 <__aeabi_dmul+0x206>
   bea0c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   bea10:	bf18      	it	ne
   bea12:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   bea16:	d1d1      	bne.n	be9bc <__aeabi_dmul+0x19c>
   bea18:	ea81 0103 	eor.w	r1, r1, r3
   bea1c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   bea20:	f04f 0000 	mov.w	r0, #0
   bea24:	bd70      	pop	{r4, r5, r6, pc}
   bea26:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   bea2a:	bf06      	itte	eq
   bea2c:	4610      	moveq	r0, r2
   bea2e:	4619      	moveq	r1, r3
   bea30:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   bea34:	d019      	beq.n	bea6a <__aeabi_dmul+0x24a>
   bea36:	ea94 0f0c 	teq	r4, ip
   bea3a:	d102      	bne.n	bea42 <__aeabi_dmul+0x222>
   bea3c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   bea40:	d113      	bne.n	bea6a <__aeabi_dmul+0x24a>
   bea42:	ea95 0f0c 	teq	r5, ip
   bea46:	d105      	bne.n	bea54 <__aeabi_dmul+0x234>
   bea48:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   bea4c:	bf1c      	itt	ne
   bea4e:	4610      	movne	r0, r2
   bea50:	4619      	movne	r1, r3
   bea52:	d10a      	bne.n	bea6a <__aeabi_dmul+0x24a>
   bea54:	ea81 0103 	eor.w	r1, r1, r3
   bea58:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   bea5c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   bea60:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   bea64:	f04f 0000 	mov.w	r0, #0
   bea68:	bd70      	pop	{r4, r5, r6, pc}
   bea6a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   bea6e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   bea72:	bd70      	pop	{r4, r5, r6, pc}

000bea74 <__aeabi_ddiv>:
   bea74:	b570      	push	{r4, r5, r6, lr}
   bea76:	f04f 0cff 	mov.w	ip, #255	; 0xff
   bea7a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   bea7e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   bea82:	bf1d      	ittte	ne
   bea84:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   bea88:	ea94 0f0c 	teqne	r4, ip
   bea8c:	ea95 0f0c 	teqne	r5, ip
   bea90:	f000 f8a7 	bleq	bebe2 <__aeabi_ddiv+0x16e>
   bea94:	eba4 0405 	sub.w	r4, r4, r5
   bea98:	ea81 0e03 	eor.w	lr, r1, r3
   bea9c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   beaa0:	ea4f 3101 	mov.w	r1, r1, lsl #12
   beaa4:	f000 8088 	beq.w	bebb8 <__aeabi_ddiv+0x144>
   beaa8:	ea4f 3303 	mov.w	r3, r3, lsl #12
   beaac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   beab0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   beab4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   beab8:	ea4f 2202 	mov.w	r2, r2, lsl #8
   beabc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   beac0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   beac4:	ea4f 2600 	mov.w	r6, r0, lsl #8
   beac8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   beacc:	429d      	cmp	r5, r3
   beace:	bf08      	it	eq
   bead0:	4296      	cmpeq	r6, r2
   bead2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   bead6:	f504 7440 	add.w	r4, r4, #768	; 0x300
   beada:	d202      	bcs.n	beae2 <__aeabi_ddiv+0x6e>
   beadc:	085b      	lsrs	r3, r3, #1
   beade:	ea4f 0232 	mov.w	r2, r2, rrx
   beae2:	1ab6      	subs	r6, r6, r2
   beae4:	eb65 0503 	sbc.w	r5, r5, r3
   beae8:	085b      	lsrs	r3, r3, #1
   beaea:	ea4f 0232 	mov.w	r2, r2, rrx
   beaee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   beaf2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   beaf6:	ebb6 0e02 	subs.w	lr, r6, r2
   beafa:	eb75 0e03 	sbcs.w	lr, r5, r3
   beafe:	bf22      	ittt	cs
   beb00:	1ab6      	subcs	r6, r6, r2
   beb02:	4675      	movcs	r5, lr
   beb04:	ea40 000c 	orrcs.w	r0, r0, ip
   beb08:	085b      	lsrs	r3, r3, #1
   beb0a:	ea4f 0232 	mov.w	r2, r2, rrx
   beb0e:	ebb6 0e02 	subs.w	lr, r6, r2
   beb12:	eb75 0e03 	sbcs.w	lr, r5, r3
   beb16:	bf22      	ittt	cs
   beb18:	1ab6      	subcs	r6, r6, r2
   beb1a:	4675      	movcs	r5, lr
   beb1c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   beb20:	085b      	lsrs	r3, r3, #1
   beb22:	ea4f 0232 	mov.w	r2, r2, rrx
   beb26:	ebb6 0e02 	subs.w	lr, r6, r2
   beb2a:	eb75 0e03 	sbcs.w	lr, r5, r3
   beb2e:	bf22      	ittt	cs
   beb30:	1ab6      	subcs	r6, r6, r2
   beb32:	4675      	movcs	r5, lr
   beb34:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   beb38:	085b      	lsrs	r3, r3, #1
   beb3a:	ea4f 0232 	mov.w	r2, r2, rrx
   beb3e:	ebb6 0e02 	subs.w	lr, r6, r2
   beb42:	eb75 0e03 	sbcs.w	lr, r5, r3
   beb46:	bf22      	ittt	cs
   beb48:	1ab6      	subcs	r6, r6, r2
   beb4a:	4675      	movcs	r5, lr
   beb4c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   beb50:	ea55 0e06 	orrs.w	lr, r5, r6
   beb54:	d018      	beq.n	beb88 <__aeabi_ddiv+0x114>
   beb56:	ea4f 1505 	mov.w	r5, r5, lsl #4
   beb5a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   beb5e:	ea4f 1606 	mov.w	r6, r6, lsl #4
   beb62:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   beb66:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   beb6a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   beb6e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   beb72:	d1c0      	bne.n	beaf6 <__aeabi_ddiv+0x82>
   beb74:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   beb78:	d10b      	bne.n	beb92 <__aeabi_ddiv+0x11e>
   beb7a:	ea41 0100 	orr.w	r1, r1, r0
   beb7e:	f04f 0000 	mov.w	r0, #0
   beb82:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   beb86:	e7b6      	b.n	beaf6 <__aeabi_ddiv+0x82>
   beb88:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   beb8c:	bf04      	itt	eq
   beb8e:	4301      	orreq	r1, r0
   beb90:	2000      	moveq	r0, #0
   beb92:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   beb96:	bf88      	it	hi
   beb98:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   beb9c:	f63f aeaf 	bhi.w	be8fe <__aeabi_dmul+0xde>
   beba0:	ebb5 0c03 	subs.w	ip, r5, r3
   beba4:	bf04      	itt	eq
   beba6:	ebb6 0c02 	subseq.w	ip, r6, r2
   bebaa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   bebae:	f150 0000 	adcs.w	r0, r0, #0
   bebb2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   bebb6:	bd70      	pop	{r4, r5, r6, pc}
   bebb8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   bebbc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   bebc0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   bebc4:	bfc2      	ittt	gt
   bebc6:	ebd4 050c 	rsbsgt	r5, r4, ip
   bebca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   bebce:	bd70      	popgt	{r4, r5, r6, pc}
   bebd0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   bebd4:	f04f 0e00 	mov.w	lr, #0
   bebd8:	3c01      	subs	r4, #1
   bebda:	e690      	b.n	be8fe <__aeabi_dmul+0xde>
   bebdc:	ea45 0e06 	orr.w	lr, r5, r6
   bebe0:	e68d      	b.n	be8fe <__aeabi_dmul+0xde>
   bebe2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   bebe6:	ea94 0f0c 	teq	r4, ip
   bebea:	bf08      	it	eq
   bebec:	ea95 0f0c 	teqeq	r5, ip
   bebf0:	f43f af3b 	beq.w	bea6a <__aeabi_dmul+0x24a>
   bebf4:	ea94 0f0c 	teq	r4, ip
   bebf8:	d10a      	bne.n	bec10 <__aeabi_ddiv+0x19c>
   bebfa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   bebfe:	f47f af34 	bne.w	bea6a <__aeabi_dmul+0x24a>
   bec02:	ea95 0f0c 	teq	r5, ip
   bec06:	f47f af25 	bne.w	bea54 <__aeabi_dmul+0x234>
   bec0a:	4610      	mov	r0, r2
   bec0c:	4619      	mov	r1, r3
   bec0e:	e72c      	b.n	bea6a <__aeabi_dmul+0x24a>
   bec10:	ea95 0f0c 	teq	r5, ip
   bec14:	d106      	bne.n	bec24 <__aeabi_ddiv+0x1b0>
   bec16:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   bec1a:	f43f aefd 	beq.w	bea18 <__aeabi_dmul+0x1f8>
   bec1e:	4610      	mov	r0, r2
   bec20:	4619      	mov	r1, r3
   bec22:	e722      	b.n	bea6a <__aeabi_dmul+0x24a>
   bec24:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   bec28:	bf18      	it	ne
   bec2a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   bec2e:	f47f aec5 	bne.w	be9bc <__aeabi_dmul+0x19c>
   bec32:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   bec36:	f47f af0d 	bne.w	bea54 <__aeabi_dmul+0x234>
   bec3a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   bec3e:	f47f aeeb 	bne.w	bea18 <__aeabi_dmul+0x1f8>
   bec42:	e712      	b.n	bea6a <__aeabi_dmul+0x24a>

000bec44 <__gedf2>:
   bec44:	f04f 3cff 	mov.w	ip, #4294967295
   bec48:	e006      	b.n	bec58 <__cmpdf2+0x4>
   bec4a:	bf00      	nop

000bec4c <__ledf2>:
   bec4c:	f04f 0c01 	mov.w	ip, #1
   bec50:	e002      	b.n	bec58 <__cmpdf2+0x4>
   bec52:	bf00      	nop

000bec54 <__cmpdf2>:
   bec54:	f04f 0c01 	mov.w	ip, #1
   bec58:	f84d cd04 	str.w	ip, [sp, #-4]!
   bec5c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   bec60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   bec64:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   bec68:	bf18      	it	ne
   bec6a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   bec6e:	d01b      	beq.n	beca8 <__cmpdf2+0x54>
   bec70:	b001      	add	sp, #4
   bec72:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   bec76:	bf0c      	ite	eq
   bec78:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   bec7c:	ea91 0f03 	teqne	r1, r3
   bec80:	bf02      	ittt	eq
   bec82:	ea90 0f02 	teqeq	r0, r2
   bec86:	2000      	moveq	r0, #0
   bec88:	4770      	bxeq	lr
   bec8a:	f110 0f00 	cmn.w	r0, #0
   bec8e:	ea91 0f03 	teq	r1, r3
   bec92:	bf58      	it	pl
   bec94:	4299      	cmppl	r1, r3
   bec96:	bf08      	it	eq
   bec98:	4290      	cmpeq	r0, r2
   bec9a:	bf2c      	ite	cs
   bec9c:	17d8      	asrcs	r0, r3, #31
   bec9e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   beca2:	f040 0001 	orr.w	r0, r0, #1
   beca6:	4770      	bx	lr
   beca8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   becac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   becb0:	d102      	bne.n	becb8 <__cmpdf2+0x64>
   becb2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   becb6:	d107      	bne.n	becc8 <__cmpdf2+0x74>
   becb8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   becbc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   becc0:	d1d6      	bne.n	bec70 <__cmpdf2+0x1c>
   becc2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   becc6:	d0d3      	beq.n	bec70 <__cmpdf2+0x1c>
   becc8:	f85d 0b04 	ldr.w	r0, [sp], #4
   beccc:	4770      	bx	lr
   becce:	bf00      	nop

000becd0 <__aeabi_cdrcmple>:
   becd0:	4684      	mov	ip, r0
   becd2:	4610      	mov	r0, r2
   becd4:	4662      	mov	r2, ip
   becd6:	468c      	mov	ip, r1
   becd8:	4619      	mov	r1, r3
   becda:	4663      	mov	r3, ip
   becdc:	e000      	b.n	bece0 <__aeabi_cdcmpeq>
   becde:	bf00      	nop

000bece0 <__aeabi_cdcmpeq>:
   bece0:	b501      	push	{r0, lr}
   bece2:	f7ff ffb7 	bl	bec54 <__cmpdf2>
   bece6:	2800      	cmp	r0, #0
   bece8:	bf48      	it	mi
   becea:	f110 0f00 	cmnmi.w	r0, #0
   becee:	bd01      	pop	{r0, pc}

000becf0 <__aeabi_dcmpeq>:
   becf0:	f84d ed08 	str.w	lr, [sp, #-8]!
   becf4:	f7ff fff4 	bl	bece0 <__aeabi_cdcmpeq>
   becf8:	bf0c      	ite	eq
   becfa:	2001      	moveq	r0, #1
   becfc:	2000      	movne	r0, #0
   becfe:	f85d fb08 	ldr.w	pc, [sp], #8
   bed02:	bf00      	nop

000bed04 <__aeabi_dcmplt>:
   bed04:	f84d ed08 	str.w	lr, [sp, #-8]!
   bed08:	f7ff ffea 	bl	bece0 <__aeabi_cdcmpeq>
   bed0c:	bf34      	ite	cc
   bed0e:	2001      	movcc	r0, #1
   bed10:	2000      	movcs	r0, #0
   bed12:	f85d fb08 	ldr.w	pc, [sp], #8
   bed16:	bf00      	nop

000bed18 <__aeabi_dcmple>:
   bed18:	f84d ed08 	str.w	lr, [sp, #-8]!
   bed1c:	f7ff ffe0 	bl	bece0 <__aeabi_cdcmpeq>
   bed20:	bf94      	ite	ls
   bed22:	2001      	movls	r0, #1
   bed24:	2000      	movhi	r0, #0
   bed26:	f85d fb08 	ldr.w	pc, [sp], #8
   bed2a:	bf00      	nop

000bed2c <__aeabi_dcmpge>:
   bed2c:	f84d ed08 	str.w	lr, [sp, #-8]!
   bed30:	f7ff ffce 	bl	becd0 <__aeabi_cdrcmple>
   bed34:	bf94      	ite	ls
   bed36:	2001      	movls	r0, #1
   bed38:	2000      	movhi	r0, #0
   bed3a:	f85d fb08 	ldr.w	pc, [sp], #8
   bed3e:	bf00      	nop

000bed40 <__aeabi_dcmpgt>:
   bed40:	f84d ed08 	str.w	lr, [sp, #-8]!
   bed44:	f7ff ffc4 	bl	becd0 <__aeabi_cdrcmple>
   bed48:	bf34      	ite	cc
   bed4a:	2001      	movcc	r0, #1
   bed4c:	2000      	movcs	r0, #0
   bed4e:	f85d fb08 	ldr.w	pc, [sp], #8
   bed52:	bf00      	nop

000bed54 <__aeabi_d2uiz>:
   bed54:	004a      	lsls	r2, r1, #1
   bed56:	d211      	bcs.n	bed7c <__aeabi_d2uiz+0x28>
   bed58:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   bed5c:	d211      	bcs.n	bed82 <__aeabi_d2uiz+0x2e>
   bed5e:	d50d      	bpl.n	bed7c <__aeabi_d2uiz+0x28>
   bed60:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   bed64:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   bed68:	d40e      	bmi.n	bed88 <__aeabi_d2uiz+0x34>
   bed6a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   bed6e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   bed72:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   bed76:	fa23 f002 	lsr.w	r0, r3, r2
   bed7a:	4770      	bx	lr
   bed7c:	f04f 0000 	mov.w	r0, #0
   bed80:	4770      	bx	lr
   bed82:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   bed86:	d102      	bne.n	bed8e <__aeabi_d2uiz+0x3a>
   bed88:	f04f 30ff 	mov.w	r0, #4294967295
   bed8c:	4770      	bx	lr
   bed8e:	f04f 0000 	mov.w	r0, #0
   bed92:	4770      	bx	lr

000bed94 <__aeabi_d2f>:
   bed94:	ea4f 0241 	mov.w	r2, r1, lsl #1
   bed98:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   bed9c:	bf24      	itt	cs
   bed9e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   beda2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   beda6:	d90d      	bls.n	bedc4 <__aeabi_d2f+0x30>
   beda8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   bedac:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   bedb0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   bedb4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   bedb8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   bedbc:	bf08      	it	eq
   bedbe:	f020 0001 	biceq.w	r0, r0, #1
   bedc2:	4770      	bx	lr
   bedc4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   bedc8:	d121      	bne.n	bee0e <__aeabi_d2f+0x7a>
   bedca:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   bedce:	bfbc      	itt	lt
   bedd0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   bedd4:	4770      	bxlt	lr
   bedd6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   bedda:	ea4f 5252 	mov.w	r2, r2, lsr #21
   bedde:	f1c2 0218 	rsb	r2, r2, #24
   bede2:	f1c2 0c20 	rsb	ip, r2, #32
   bede6:	fa10 f30c 	lsls.w	r3, r0, ip
   bedea:	fa20 f002 	lsr.w	r0, r0, r2
   bedee:	bf18      	it	ne
   bedf0:	f040 0001 	orrne.w	r0, r0, #1
   bedf4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   bedf8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   bedfc:	fa03 fc0c 	lsl.w	ip, r3, ip
   bee00:	ea40 000c 	orr.w	r0, r0, ip
   bee04:	fa23 f302 	lsr.w	r3, r3, r2
   bee08:	ea4f 0343 	mov.w	r3, r3, lsl #1
   bee0c:	e7cc      	b.n	beda8 <__aeabi_d2f+0x14>
   bee0e:	ea7f 5362 	mvns.w	r3, r2, asr #21
   bee12:	d107      	bne.n	bee24 <__aeabi_d2f+0x90>
   bee14:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   bee18:	bf1e      	ittt	ne
   bee1a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   bee1e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   bee22:	4770      	bxne	lr
   bee24:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   bee28:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   bee2c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   bee30:	4770      	bx	lr
   bee32:	bf00      	nop

000bee34 <__aeabi_d2ulz>:
   bee34:	b5d0      	push	{r4, r6, r7, lr}
   bee36:	4b0c      	ldr	r3, [pc, #48]	; (bee68 <__aeabi_d2ulz+0x34>)
   bee38:	2200      	movs	r2, #0
   bee3a:	4606      	mov	r6, r0
   bee3c:	460f      	mov	r7, r1
   bee3e:	f7ff fcef 	bl	be820 <__aeabi_dmul>
   bee42:	f7ff ff87 	bl	bed54 <__aeabi_d2uiz>
   bee46:	4604      	mov	r4, r0
   bee48:	f7ff fc70 	bl	be72c <__aeabi_ui2d>
   bee4c:	4b07      	ldr	r3, [pc, #28]	; (bee6c <__aeabi_d2ulz+0x38>)
   bee4e:	2200      	movs	r2, #0
   bee50:	f7ff fce6 	bl	be820 <__aeabi_dmul>
   bee54:	4602      	mov	r2, r0
   bee56:	460b      	mov	r3, r1
   bee58:	4630      	mov	r0, r6
   bee5a:	4639      	mov	r1, r7
   bee5c:	f7ff fb28 	bl	be4b0 <__aeabi_dsub>
   bee60:	f7ff ff78 	bl	bed54 <__aeabi_d2uiz>
   bee64:	4621      	mov	r1, r4
   bee66:	bdd0      	pop	{r4, r6, r7, pc}
   bee68:	3df00000 	.word	0x3df00000
   bee6c:	41f00000 	.word	0x41f00000

000bee70 <atexit>:
   bee70:	2300      	movs	r3, #0
   bee72:	4601      	mov	r1, r0
   bee74:	461a      	mov	r2, r3
   bee76:	4618      	mov	r0, r3
   bee78:	f000 bfac 	b.w	bfdd4 <__register_exitproc>

000bee7c <atof>:
   bee7c:	2100      	movs	r1, #0
   bee7e:	f000 bf11 	b.w	bfca4 <strtod>

000bee82 <atoi>:
   bee82:	220a      	movs	r2, #10
   bee84:	2100      	movs	r1, #0
   bee86:	f000 bf9b 	b.w	bfdc0 <strtol>

000bee8a <memcmp>:
   bee8a:	b510      	push	{r4, lr}
   bee8c:	3901      	subs	r1, #1
   bee8e:	4402      	add	r2, r0
   bee90:	4290      	cmp	r0, r2
   bee92:	d101      	bne.n	bee98 <memcmp+0xe>
   bee94:	2000      	movs	r0, #0
   bee96:	e005      	b.n	beea4 <memcmp+0x1a>
   bee98:	7803      	ldrb	r3, [r0, #0]
   bee9a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   bee9e:	42a3      	cmp	r3, r4
   beea0:	d001      	beq.n	beea6 <memcmp+0x1c>
   beea2:	1b18      	subs	r0, r3, r4
   beea4:	bd10      	pop	{r4, pc}
   beea6:	3001      	adds	r0, #1
   beea8:	e7f2      	b.n	bee90 <memcmp+0x6>

000beeaa <memcpy>:
   beeaa:	440a      	add	r2, r1
   beeac:	4291      	cmp	r1, r2
   beeae:	f100 33ff 	add.w	r3, r0, #4294967295
   beeb2:	d100      	bne.n	beeb6 <memcpy+0xc>
   beeb4:	4770      	bx	lr
   beeb6:	b510      	push	{r4, lr}
   beeb8:	f811 4b01 	ldrb.w	r4, [r1], #1
   beebc:	f803 4f01 	strb.w	r4, [r3, #1]!
   beec0:	4291      	cmp	r1, r2
   beec2:	d1f9      	bne.n	beeb8 <memcpy+0xe>
   beec4:	bd10      	pop	{r4, pc}

000beec6 <memmove>:
   beec6:	4288      	cmp	r0, r1
   beec8:	b510      	push	{r4, lr}
   beeca:	eb01 0402 	add.w	r4, r1, r2
   beece:	d902      	bls.n	beed6 <memmove+0x10>
   beed0:	4284      	cmp	r4, r0
   beed2:	4623      	mov	r3, r4
   beed4:	d807      	bhi.n	beee6 <memmove+0x20>
   beed6:	1e43      	subs	r3, r0, #1
   beed8:	42a1      	cmp	r1, r4
   beeda:	d008      	beq.n	beeee <memmove+0x28>
   beedc:	f811 2b01 	ldrb.w	r2, [r1], #1
   beee0:	f803 2f01 	strb.w	r2, [r3, #1]!
   beee4:	e7f8      	b.n	beed8 <memmove+0x12>
   beee6:	4402      	add	r2, r0
   beee8:	4601      	mov	r1, r0
   beeea:	428a      	cmp	r2, r1
   beeec:	d100      	bne.n	beef0 <memmove+0x2a>
   beeee:	bd10      	pop	{r4, pc}
   beef0:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   beef4:	f802 4d01 	strb.w	r4, [r2, #-1]!
   beef8:	e7f7      	b.n	beeea <memmove+0x24>

000beefa <memset>:
   beefa:	4402      	add	r2, r0
   beefc:	4603      	mov	r3, r0
   beefe:	4293      	cmp	r3, r2
   bef00:	d100      	bne.n	bef04 <memset+0xa>
   bef02:	4770      	bx	lr
   bef04:	f803 1b01 	strb.w	r1, [r3], #1
   bef08:	e7f9      	b.n	beefe <memset+0x4>
	...

000bef0c <srand>:
   bef0c:	b538      	push	{r3, r4, r5, lr}
   bef0e:	4b10      	ldr	r3, [pc, #64]	; (bef50 <srand+0x44>)
   bef10:	681d      	ldr	r5, [r3, #0]
   bef12:	6bab      	ldr	r3, [r5, #56]	; 0x38
   bef14:	4604      	mov	r4, r0
   bef16:	b9b3      	cbnz	r3, bef46 <srand+0x3a>
   bef18:	2018      	movs	r0, #24
   bef1a:	f7fb fa67 	bl	ba3ec <malloc>
   bef1e:	4602      	mov	r2, r0
   bef20:	63a8      	str	r0, [r5, #56]	; 0x38
   bef22:	b920      	cbnz	r0, bef2e <srand+0x22>
   bef24:	4b0b      	ldr	r3, [pc, #44]	; (bef54 <srand+0x48>)
   bef26:	480c      	ldr	r0, [pc, #48]	; (bef58 <srand+0x4c>)
   bef28:	2142      	movs	r1, #66	; 0x42
   bef2a:	f7fb faaf 	bl	ba48c <__assert_func>
   bef2e:	490b      	ldr	r1, [pc, #44]	; (bef5c <srand+0x50>)
   bef30:	4b0b      	ldr	r3, [pc, #44]	; (bef60 <srand+0x54>)
   bef32:	e9c0 1300 	strd	r1, r3, [r0]
   bef36:	4b0b      	ldr	r3, [pc, #44]	; (bef64 <srand+0x58>)
   bef38:	6083      	str	r3, [r0, #8]
   bef3a:	230b      	movs	r3, #11
   bef3c:	8183      	strh	r3, [r0, #12]
   bef3e:	2100      	movs	r1, #0
   bef40:	2001      	movs	r0, #1
   bef42:	e9c2 0104 	strd	r0, r1, [r2, #16]
   bef46:	6bab      	ldr	r3, [r5, #56]	; 0x38
   bef48:	2200      	movs	r2, #0
   bef4a:	611c      	str	r4, [r3, #16]
   bef4c:	615a      	str	r2, [r3, #20]
   bef4e:	bd38      	pop	{r3, r4, r5, pc}
   bef50:	2003dab0 	.word	0x2003dab0
   bef54:	000c2329 	.word	0x000c2329
   bef58:	000c2340 	.word	0x000c2340
   bef5c:	abcd330e 	.word	0xabcd330e
   bef60:	e66d1234 	.word	0xe66d1234
   bef64:	0005deec 	.word	0x0005deec

000bef68 <strcat>:
   bef68:	b510      	push	{r4, lr}
   bef6a:	4602      	mov	r2, r0
   bef6c:	7814      	ldrb	r4, [r2, #0]
   bef6e:	4613      	mov	r3, r2
   bef70:	3201      	adds	r2, #1
   bef72:	2c00      	cmp	r4, #0
   bef74:	d1fa      	bne.n	bef6c <strcat+0x4>
   bef76:	3b01      	subs	r3, #1
   bef78:	f811 2b01 	ldrb.w	r2, [r1], #1
   bef7c:	f803 2f01 	strb.w	r2, [r3, #1]!
   bef80:	2a00      	cmp	r2, #0
   bef82:	d1f9      	bne.n	bef78 <strcat+0x10>
   bef84:	bd10      	pop	{r4, pc}

000bef86 <strcmp>:
   bef86:	f810 2b01 	ldrb.w	r2, [r0], #1
   bef8a:	f811 3b01 	ldrb.w	r3, [r1], #1
   bef8e:	2a01      	cmp	r2, #1
   bef90:	bf28      	it	cs
   bef92:	429a      	cmpcs	r2, r3
   bef94:	d0f7      	beq.n	bef86 <strcmp>
   bef96:	1ad0      	subs	r0, r2, r3
   bef98:	4770      	bx	lr

000bef9a <strcpy>:
   bef9a:	4603      	mov	r3, r0
   bef9c:	f811 2b01 	ldrb.w	r2, [r1], #1
   befa0:	f803 2b01 	strb.w	r2, [r3], #1
   befa4:	2a00      	cmp	r2, #0
   befa6:	d1f9      	bne.n	bef9c <strcpy+0x2>
   befa8:	4770      	bx	lr
	...

000befac <strdup>:
   befac:	4b02      	ldr	r3, [pc, #8]	; (befb8 <strdup+0xc>)
   befae:	4601      	mov	r1, r0
   befb0:	6818      	ldr	r0, [r3, #0]
   befb2:	f000 b803 	b.w	befbc <_strdup_r>
   befb6:	bf00      	nop
   befb8:	2003dab0 	.word	0x2003dab0

000befbc <_strdup_r>:
   befbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   befbe:	4604      	mov	r4, r0
   befc0:	4608      	mov	r0, r1
   befc2:	460d      	mov	r5, r1
   befc4:	f000 f80f 	bl	befe6 <strlen>
   befc8:	1c42      	adds	r2, r0, #1
   befca:	4611      	mov	r1, r2
   befcc:	4620      	mov	r0, r4
   befce:	9201      	str	r2, [sp, #4]
   befd0:	f7fb fa4c 	bl	ba46c <_malloc_r>
   befd4:	4604      	mov	r4, r0
   befd6:	b118      	cbz	r0, befe0 <_strdup_r+0x24>
   befd8:	9a01      	ldr	r2, [sp, #4]
   befda:	4629      	mov	r1, r5
   befdc:	f7ff ff65 	bl	beeaa <memcpy>
   befe0:	4620      	mov	r0, r4
   befe2:	b003      	add	sp, #12
   befe4:	bd30      	pop	{r4, r5, pc}

000befe6 <strlen>:
   befe6:	4603      	mov	r3, r0
   befe8:	f813 2b01 	ldrb.w	r2, [r3], #1
   befec:	2a00      	cmp	r2, #0
   befee:	d1fb      	bne.n	befe8 <strlen+0x2>
   beff0:	1a18      	subs	r0, r3, r0
   beff2:	3801      	subs	r0, #1
   beff4:	4770      	bx	lr

000beff6 <strncmp>:
   beff6:	b510      	push	{r4, lr}
   beff8:	b17a      	cbz	r2, bf01a <strncmp+0x24>
   beffa:	4603      	mov	r3, r0
   beffc:	3901      	subs	r1, #1
   beffe:	1884      	adds	r4, r0, r2
   bf000:	f813 0b01 	ldrb.w	r0, [r3], #1
   bf004:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   bf008:	4290      	cmp	r0, r2
   bf00a:	d101      	bne.n	bf010 <strncmp+0x1a>
   bf00c:	42a3      	cmp	r3, r4
   bf00e:	d101      	bne.n	bf014 <strncmp+0x1e>
   bf010:	1a80      	subs	r0, r0, r2
   bf012:	bd10      	pop	{r4, pc}
   bf014:	2800      	cmp	r0, #0
   bf016:	d1f3      	bne.n	bf000 <strncmp+0xa>
   bf018:	e7fa      	b.n	bf010 <strncmp+0x1a>
   bf01a:	4610      	mov	r0, r2
   bf01c:	e7f9      	b.n	bf012 <strncmp+0x1c>

000bf01e <strncpy>:
   bf01e:	b510      	push	{r4, lr}
   bf020:	3901      	subs	r1, #1
   bf022:	4603      	mov	r3, r0
   bf024:	b132      	cbz	r2, bf034 <strncpy+0x16>
   bf026:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   bf02a:	f803 4b01 	strb.w	r4, [r3], #1
   bf02e:	3a01      	subs	r2, #1
   bf030:	2c00      	cmp	r4, #0
   bf032:	d1f7      	bne.n	bf024 <strncpy+0x6>
   bf034:	441a      	add	r2, r3
   bf036:	2100      	movs	r1, #0
   bf038:	4293      	cmp	r3, r2
   bf03a:	d100      	bne.n	bf03e <strncpy+0x20>
   bf03c:	bd10      	pop	{r4, pc}
   bf03e:	f803 1b01 	strb.w	r1, [r3], #1
   bf042:	e7f9      	b.n	bf038 <strncpy+0x1a>

000bf044 <strnlen>:
   bf044:	b510      	push	{r4, lr}
   bf046:	4602      	mov	r2, r0
   bf048:	4401      	add	r1, r0
   bf04a:	428a      	cmp	r2, r1
   bf04c:	4613      	mov	r3, r2
   bf04e:	d003      	beq.n	bf058 <strnlen+0x14>
   bf050:	781c      	ldrb	r4, [r3, #0]
   bf052:	3201      	adds	r2, #1
   bf054:	2c00      	cmp	r4, #0
   bf056:	d1f8      	bne.n	bf04a <strnlen+0x6>
   bf058:	1a18      	subs	r0, r3, r0
   bf05a:	bd10      	pop	{r4, pc}

000bf05c <sulp>:
   bf05c:	b570      	push	{r4, r5, r6, lr}
   bf05e:	4604      	mov	r4, r0
   bf060:	460d      	mov	r5, r1
   bf062:	ec45 4b10 	vmov	d0, r4, r5
   bf066:	4616      	mov	r6, r2
   bf068:	f001 fe0e 	bl	c0c88 <__ulp>
   bf06c:	ec51 0b10 	vmov	r0, r1, d0
   bf070:	b17e      	cbz	r6, bf092 <sulp+0x36>
   bf072:	f3c5 530a 	ubfx	r3, r5, #20, #11
   bf076:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
   bf07a:	2b00      	cmp	r3, #0
   bf07c:	dd09      	ble.n	bf092 <sulp+0x36>
   bf07e:	051b      	lsls	r3, r3, #20
   bf080:	f103 557f 	add.w	r5, r3, #1069547520	; 0x3fc00000
   bf084:	2400      	movs	r4, #0
   bf086:	f505 1540 	add.w	r5, r5, #3145728	; 0x300000
   bf08a:	4622      	mov	r2, r4
   bf08c:	462b      	mov	r3, r5
   bf08e:	f7ff fbc7 	bl	be820 <__aeabi_dmul>
   bf092:	bd70      	pop	{r4, r5, r6, pc}
   bf094:	0000      	movs	r0, r0
	...

000bf098 <_strtod_l>:
   bf098:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   bf09c:	ed2d 8b02 	vpush	{d8}
   bf0a0:	b09d      	sub	sp, #116	; 0x74
   bf0a2:	461f      	mov	r7, r3
   bf0a4:	2300      	movs	r3, #0
   bf0a6:	9318      	str	r3, [sp, #96]	; 0x60
   bf0a8:	4ba2      	ldr	r3, [pc, #648]	; (bf334 <_strtod_l+0x29c>)
   bf0aa:	9213      	str	r2, [sp, #76]	; 0x4c
   bf0ac:	681b      	ldr	r3, [r3, #0]
   bf0ae:	9305      	str	r3, [sp, #20]
   bf0b0:	4604      	mov	r4, r0
   bf0b2:	4618      	mov	r0, r3
   bf0b4:	4688      	mov	r8, r1
   bf0b6:	f7ff ff96 	bl	befe6 <strlen>
   bf0ba:	f04f 0a00 	mov.w	sl, #0
   bf0be:	4605      	mov	r5, r0
   bf0c0:	f04f 0b00 	mov.w	fp, #0
   bf0c4:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
   bf0c8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf0ca:	781a      	ldrb	r2, [r3, #0]
   bf0cc:	2a2b      	cmp	r2, #43	; 0x2b
   bf0ce:	d04e      	beq.n	bf16e <_strtod_l+0xd6>
   bf0d0:	d83b      	bhi.n	bf14a <_strtod_l+0xb2>
   bf0d2:	2a0d      	cmp	r2, #13
   bf0d4:	d834      	bhi.n	bf140 <_strtod_l+0xa8>
   bf0d6:	2a08      	cmp	r2, #8
   bf0d8:	d834      	bhi.n	bf144 <_strtod_l+0xac>
   bf0da:	2a00      	cmp	r2, #0
   bf0dc:	d03e      	beq.n	bf15c <_strtod_l+0xc4>
   bf0de:	2300      	movs	r3, #0
   bf0e0:	930a      	str	r3, [sp, #40]	; 0x28
   bf0e2:	9e17      	ldr	r6, [sp, #92]	; 0x5c
   bf0e4:	7833      	ldrb	r3, [r6, #0]
   bf0e6:	2b30      	cmp	r3, #48	; 0x30
   bf0e8:	f040 80b0 	bne.w	bf24c <_strtod_l+0x1b4>
   bf0ec:	7873      	ldrb	r3, [r6, #1]
   bf0ee:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   bf0f2:	2b58      	cmp	r3, #88	; 0x58
   bf0f4:	d168      	bne.n	bf1c8 <_strtod_l+0x130>
   bf0f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   bf0f8:	9301      	str	r3, [sp, #4]
   bf0fa:	ab18      	add	r3, sp, #96	; 0x60
   bf0fc:	9702      	str	r7, [sp, #8]
   bf0fe:	9300      	str	r3, [sp, #0]
   bf100:	4a8d      	ldr	r2, [pc, #564]	; (bf338 <_strtod_l+0x2a0>)
   bf102:	ab19      	add	r3, sp, #100	; 0x64
   bf104:	a917      	add	r1, sp, #92	; 0x5c
   bf106:	4620      	mov	r0, r4
   bf108:	f000 ff2e 	bl	bff68 <__gethex>
   bf10c:	f010 0707 	ands.w	r7, r0, #7
   bf110:	4605      	mov	r5, r0
   bf112:	d005      	beq.n	bf120 <_strtod_l+0x88>
   bf114:	2f06      	cmp	r7, #6
   bf116:	d12c      	bne.n	bf172 <_strtod_l+0xda>
   bf118:	3601      	adds	r6, #1
   bf11a:	2300      	movs	r3, #0
   bf11c:	9617      	str	r6, [sp, #92]	; 0x5c
   bf11e:	930a      	str	r3, [sp, #40]	; 0x28
   bf120:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   bf122:	2b00      	cmp	r3, #0
   bf124:	f040 8590 	bne.w	bfc48 <_strtod_l+0xbb0>
   bf128:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   bf12a:	b1eb      	cbz	r3, bf168 <_strtod_l+0xd0>
   bf12c:	4652      	mov	r2, sl
   bf12e:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
   bf132:	ec43 2b10 	vmov	d0, r2, r3
   bf136:	b01d      	add	sp, #116	; 0x74
   bf138:	ecbd 8b02 	vpop	{d8}
   bf13c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   bf140:	2a20      	cmp	r2, #32
   bf142:	d1cc      	bne.n	bf0de <_strtod_l+0x46>
   bf144:	3301      	adds	r3, #1
   bf146:	9317      	str	r3, [sp, #92]	; 0x5c
   bf148:	e7be      	b.n	bf0c8 <_strtod_l+0x30>
   bf14a:	2a2d      	cmp	r2, #45	; 0x2d
   bf14c:	d1c7      	bne.n	bf0de <_strtod_l+0x46>
   bf14e:	2201      	movs	r2, #1
   bf150:	920a      	str	r2, [sp, #40]	; 0x28
   bf152:	1c5a      	adds	r2, r3, #1
   bf154:	9217      	str	r2, [sp, #92]	; 0x5c
   bf156:	785b      	ldrb	r3, [r3, #1]
   bf158:	2b00      	cmp	r3, #0
   bf15a:	d1c2      	bne.n	bf0e2 <_strtod_l+0x4a>
   bf15c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   bf15e:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
   bf162:	2b00      	cmp	r3, #0
   bf164:	f040 856e 	bne.w	bfc44 <_strtod_l+0xbac>
   bf168:	4652      	mov	r2, sl
   bf16a:	465b      	mov	r3, fp
   bf16c:	e7e1      	b.n	bf132 <_strtod_l+0x9a>
   bf16e:	2200      	movs	r2, #0
   bf170:	e7ee      	b.n	bf150 <_strtod_l+0xb8>
   bf172:	9a18      	ldr	r2, [sp, #96]	; 0x60
   bf174:	b13a      	cbz	r2, bf186 <_strtod_l+0xee>
   bf176:	2135      	movs	r1, #53	; 0x35
   bf178:	a81a      	add	r0, sp, #104	; 0x68
   bf17a:	f001 fe90 	bl	c0e9e <__copybits>
   bf17e:	9918      	ldr	r1, [sp, #96]	; 0x60
   bf180:	4620      	mov	r0, r4
   bf182:	f001 fa4f 	bl	c0624 <_Bfree>
   bf186:	3f01      	subs	r7, #1
   bf188:	2f04      	cmp	r7, #4
   bf18a:	d806      	bhi.n	bf19a <_strtod_l+0x102>
   bf18c:	e8df f007 	tbb	[pc, r7]
   bf190:	1714030a 	.word	0x1714030a
   bf194:	0a          	.byte	0x0a
   bf195:	00          	.byte	0x00
   bf196:	e9dd ab1a 	ldrd	sl, fp, [sp, #104]	; 0x68
   bf19a:	0728      	lsls	r0, r5, #28
   bf19c:	d5c0      	bpl.n	bf120 <_strtod_l+0x88>
   bf19e:	f04b 4b00 	orr.w	fp, fp, #2147483648	; 0x80000000
   bf1a2:	e7bd      	b.n	bf120 <_strtod_l+0x88>
   bf1a4:	e9dd a31a 	ldrd	sl, r3, [sp, #104]	; 0x68
   bf1a8:	9a19      	ldr	r2, [sp, #100]	; 0x64
   bf1aa:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   bf1ae:	f202 4233 	addw	r2, r2, #1075	; 0x433
   bf1b2:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
   bf1b6:	e7f0      	b.n	bf19a <_strtod_l+0x102>
   bf1b8:	f8df b180 	ldr.w	fp, [pc, #384]	; bf33c <_strtod_l+0x2a4>
   bf1bc:	e7ed      	b.n	bf19a <_strtod_l+0x102>
   bf1be:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
   bf1c2:	f04f 3aff 	mov.w	sl, #4294967295
   bf1c6:	e7e8      	b.n	bf19a <_strtod_l+0x102>
   bf1c8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf1ca:	1c5a      	adds	r2, r3, #1
   bf1cc:	9217      	str	r2, [sp, #92]	; 0x5c
   bf1ce:	785b      	ldrb	r3, [r3, #1]
   bf1d0:	2b30      	cmp	r3, #48	; 0x30
   bf1d2:	d0f9      	beq.n	bf1c8 <_strtod_l+0x130>
   bf1d4:	2b00      	cmp	r3, #0
   bf1d6:	d0a3      	beq.n	bf120 <_strtod_l+0x88>
   bf1d8:	2301      	movs	r3, #1
   bf1da:	f04f 0900 	mov.w	r9, #0
   bf1de:	9304      	str	r3, [sp, #16]
   bf1e0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf1e2:	9308      	str	r3, [sp, #32]
   bf1e4:	f8cd 901c 	str.w	r9, [sp, #28]
   bf1e8:	464f      	mov	r7, r9
   bf1ea:	220a      	movs	r2, #10
   bf1ec:	9817      	ldr	r0, [sp, #92]	; 0x5c
   bf1ee:	7806      	ldrb	r6, [r0, #0]
   bf1f0:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
   bf1f4:	b2d9      	uxtb	r1, r3
   bf1f6:	2909      	cmp	r1, #9
   bf1f8:	d92a      	bls.n	bf250 <_strtod_l+0x1b8>
   bf1fa:	9905      	ldr	r1, [sp, #20]
   bf1fc:	462a      	mov	r2, r5
   bf1fe:	f7ff fefa 	bl	beff6 <strncmp>
   bf202:	b398      	cbz	r0, bf26c <_strtod_l+0x1d4>
   bf204:	2000      	movs	r0, #0
   bf206:	4632      	mov	r2, r6
   bf208:	463d      	mov	r5, r7
   bf20a:	9005      	str	r0, [sp, #20]
   bf20c:	4603      	mov	r3, r0
   bf20e:	2a65      	cmp	r2, #101	; 0x65
   bf210:	d001      	beq.n	bf216 <_strtod_l+0x17e>
   bf212:	2a45      	cmp	r2, #69	; 0x45
   bf214:	d118      	bne.n	bf248 <_strtod_l+0x1b0>
   bf216:	b91d      	cbnz	r5, bf220 <_strtod_l+0x188>
   bf218:	9a04      	ldr	r2, [sp, #16]
   bf21a:	4302      	orrs	r2, r0
   bf21c:	d09e      	beq.n	bf15c <_strtod_l+0xc4>
   bf21e:	2500      	movs	r5, #0
   bf220:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
   bf224:	f108 0201 	add.w	r2, r8, #1
   bf228:	9217      	str	r2, [sp, #92]	; 0x5c
   bf22a:	f898 2001 	ldrb.w	r2, [r8, #1]
   bf22e:	2a2b      	cmp	r2, #43	; 0x2b
   bf230:	d075      	beq.n	bf31e <_strtod_l+0x286>
   bf232:	2a2d      	cmp	r2, #45	; 0x2d
   bf234:	d07b      	beq.n	bf32e <_strtod_l+0x296>
   bf236:	f04f 0c00 	mov.w	ip, #0
   bf23a:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   bf23e:	2909      	cmp	r1, #9
   bf240:	f240 8082 	bls.w	bf348 <_strtod_l+0x2b0>
   bf244:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
   bf248:	2600      	movs	r6, #0
   bf24a:	e09d      	b.n	bf388 <_strtod_l+0x2f0>
   bf24c:	2300      	movs	r3, #0
   bf24e:	e7c4      	b.n	bf1da <_strtod_l+0x142>
   bf250:	2f08      	cmp	r7, #8
   bf252:	bfd8      	it	le
   bf254:	9907      	ldrle	r1, [sp, #28]
   bf256:	f100 0001 	add.w	r0, r0, #1
   bf25a:	bfda      	itte	le
   bf25c:	fb02 3301 	mlale	r3, r2, r1, r3
   bf260:	9307      	strle	r3, [sp, #28]
   bf262:	fb02 3909 	mlagt	r9, r2, r9, r3
   bf266:	3701      	adds	r7, #1
   bf268:	9017      	str	r0, [sp, #92]	; 0x5c
   bf26a:	e7bf      	b.n	bf1ec <_strtod_l+0x154>
   bf26c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf26e:	195a      	adds	r2, r3, r5
   bf270:	9217      	str	r2, [sp, #92]	; 0x5c
   bf272:	5d5a      	ldrb	r2, [r3, r5]
   bf274:	2f00      	cmp	r7, #0
   bf276:	d037      	beq.n	bf2e8 <_strtod_l+0x250>
   bf278:	9005      	str	r0, [sp, #20]
   bf27a:	463d      	mov	r5, r7
   bf27c:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   bf280:	2b09      	cmp	r3, #9
   bf282:	d912      	bls.n	bf2aa <_strtod_l+0x212>
   bf284:	2301      	movs	r3, #1
   bf286:	e7c2      	b.n	bf20e <_strtod_l+0x176>
   bf288:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf28a:	1c5a      	adds	r2, r3, #1
   bf28c:	9217      	str	r2, [sp, #92]	; 0x5c
   bf28e:	785a      	ldrb	r2, [r3, #1]
   bf290:	3001      	adds	r0, #1
   bf292:	2a30      	cmp	r2, #48	; 0x30
   bf294:	d0f8      	beq.n	bf288 <_strtod_l+0x1f0>
   bf296:	f1a2 0331 	sub.w	r3, r2, #49	; 0x31
   bf29a:	2b08      	cmp	r3, #8
   bf29c:	f200 84d9 	bhi.w	bfc52 <_strtod_l+0xbba>
   bf2a0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf2a2:	9005      	str	r0, [sp, #20]
   bf2a4:	2000      	movs	r0, #0
   bf2a6:	9308      	str	r3, [sp, #32]
   bf2a8:	4605      	mov	r5, r0
   bf2aa:	3a30      	subs	r2, #48	; 0x30
   bf2ac:	f100 0301 	add.w	r3, r0, #1
   bf2b0:	d014      	beq.n	bf2dc <_strtod_l+0x244>
   bf2b2:	9905      	ldr	r1, [sp, #20]
   bf2b4:	4419      	add	r1, r3
   bf2b6:	9105      	str	r1, [sp, #20]
   bf2b8:	462b      	mov	r3, r5
   bf2ba:	eb00 0e05 	add.w	lr, r0, r5
   bf2be:	210a      	movs	r1, #10
   bf2c0:	4573      	cmp	r3, lr
   bf2c2:	d113      	bne.n	bf2ec <_strtod_l+0x254>
   bf2c4:	182b      	adds	r3, r5, r0
   bf2c6:	2b08      	cmp	r3, #8
   bf2c8:	f105 0501 	add.w	r5, r5, #1
   bf2cc:	4405      	add	r5, r0
   bf2ce:	dc1c      	bgt.n	bf30a <_strtod_l+0x272>
   bf2d0:	9907      	ldr	r1, [sp, #28]
   bf2d2:	230a      	movs	r3, #10
   bf2d4:	fb03 2301 	mla	r3, r3, r1, r2
   bf2d8:	9307      	str	r3, [sp, #28]
   bf2da:	2300      	movs	r3, #0
   bf2dc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   bf2de:	1c51      	adds	r1, r2, #1
   bf2e0:	9117      	str	r1, [sp, #92]	; 0x5c
   bf2e2:	7852      	ldrb	r2, [r2, #1]
   bf2e4:	4618      	mov	r0, r3
   bf2e6:	e7c9      	b.n	bf27c <_strtod_l+0x1e4>
   bf2e8:	4638      	mov	r0, r7
   bf2ea:	e7d2      	b.n	bf292 <_strtod_l+0x1fa>
   bf2ec:	2b08      	cmp	r3, #8
   bf2ee:	dc04      	bgt.n	bf2fa <_strtod_l+0x262>
   bf2f0:	9e07      	ldr	r6, [sp, #28]
   bf2f2:	434e      	muls	r6, r1
   bf2f4:	9607      	str	r6, [sp, #28]
   bf2f6:	3301      	adds	r3, #1
   bf2f8:	e7e2      	b.n	bf2c0 <_strtod_l+0x228>
   bf2fa:	f103 0c01 	add.w	ip, r3, #1
   bf2fe:	f1bc 0f10 	cmp.w	ip, #16
   bf302:	bfd8      	it	le
   bf304:	fb01 f909 	mulle.w	r9, r1, r9
   bf308:	e7f5      	b.n	bf2f6 <_strtod_l+0x25e>
   bf30a:	2d10      	cmp	r5, #16
   bf30c:	bfdc      	itt	le
   bf30e:	230a      	movle	r3, #10
   bf310:	fb03 2909 	mlale	r9, r3, r9, r2
   bf314:	e7e1      	b.n	bf2da <_strtod_l+0x242>
   bf316:	2300      	movs	r3, #0
   bf318:	9305      	str	r3, [sp, #20]
   bf31a:	2301      	movs	r3, #1
   bf31c:	e77c      	b.n	bf218 <_strtod_l+0x180>
   bf31e:	f04f 0c00 	mov.w	ip, #0
   bf322:	f108 0202 	add.w	r2, r8, #2
   bf326:	9217      	str	r2, [sp, #92]	; 0x5c
   bf328:	f898 2002 	ldrb.w	r2, [r8, #2]
   bf32c:	e785      	b.n	bf23a <_strtod_l+0x1a2>
   bf32e:	f04f 0c01 	mov.w	ip, #1
   bf332:	e7f6      	b.n	bf322 <_strtod_l+0x28a>
   bf334:	000c25b8 	.word	0x000c25b8
   bf338:	000c23cc 	.word	0x000c23cc
   bf33c:	7ff00000 	.word	0x7ff00000
   bf340:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   bf342:	1c51      	adds	r1, r2, #1
   bf344:	9117      	str	r1, [sp, #92]	; 0x5c
   bf346:	7852      	ldrb	r2, [r2, #1]
   bf348:	2a30      	cmp	r2, #48	; 0x30
   bf34a:	d0f9      	beq.n	bf340 <_strtod_l+0x2a8>
   bf34c:	f1a2 0131 	sub.w	r1, r2, #49	; 0x31
   bf350:	2908      	cmp	r1, #8
   bf352:	f63f af79 	bhi.w	bf248 <_strtod_l+0x1b0>
   bf356:	f1a2 0e30 	sub.w	lr, r2, #48	; 0x30
   bf35a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   bf35c:	9206      	str	r2, [sp, #24]
   bf35e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   bf360:	1c51      	adds	r1, r2, #1
   bf362:	9117      	str	r1, [sp, #92]	; 0x5c
   bf364:	7852      	ldrb	r2, [r2, #1]
   bf366:	f1a2 0630 	sub.w	r6, r2, #48	; 0x30
   bf36a:	2e09      	cmp	r6, #9
   bf36c:	d937      	bls.n	bf3de <_strtod_l+0x346>
   bf36e:	9e06      	ldr	r6, [sp, #24]
   bf370:	1b89      	subs	r1, r1, r6
   bf372:	2908      	cmp	r1, #8
   bf374:	f644 661f 	movw	r6, #19999	; 0x4e1f
   bf378:	dc02      	bgt.n	bf380 <_strtod_l+0x2e8>
   bf37a:	4576      	cmp	r6, lr
   bf37c:	bfa8      	it	ge
   bf37e:	4676      	movge	r6, lr
   bf380:	f1bc 0f00 	cmp.w	ip, #0
   bf384:	d000      	beq.n	bf388 <_strtod_l+0x2f0>
   bf386:	4276      	negs	r6, r6
   bf388:	2d00      	cmp	r5, #0
   bf38a:	d14d      	bne.n	bf428 <_strtod_l+0x390>
   bf38c:	9904      	ldr	r1, [sp, #16]
   bf38e:	4301      	orrs	r1, r0
   bf390:	f47f aec6 	bne.w	bf120 <_strtod_l+0x88>
   bf394:	2b00      	cmp	r3, #0
   bf396:	f47f aee1 	bne.w	bf15c <_strtod_l+0xc4>
   bf39a:	2a69      	cmp	r2, #105	; 0x69
   bf39c:	d027      	beq.n	bf3ee <_strtod_l+0x356>
   bf39e:	dc24      	bgt.n	bf3ea <_strtod_l+0x352>
   bf3a0:	2a49      	cmp	r2, #73	; 0x49
   bf3a2:	d024      	beq.n	bf3ee <_strtod_l+0x356>
   bf3a4:	2a4e      	cmp	r2, #78	; 0x4e
   bf3a6:	f47f aed9 	bne.w	bf15c <_strtod_l+0xc4>
   bf3aa:	499f      	ldr	r1, [pc, #636]	; (bf628 <_strtod_l+0x590>)
   bf3ac:	a817      	add	r0, sp, #92	; 0x5c
   bf3ae:	f001 f833 	bl	c0418 <__match>
   bf3b2:	2800      	cmp	r0, #0
   bf3b4:	f43f aed2 	beq.w	bf15c <_strtod_l+0xc4>
   bf3b8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf3ba:	781b      	ldrb	r3, [r3, #0]
   bf3bc:	2b28      	cmp	r3, #40	; 0x28
   bf3be:	d12d      	bne.n	bf41c <_strtod_l+0x384>
   bf3c0:	499a      	ldr	r1, [pc, #616]	; (bf62c <_strtod_l+0x594>)
   bf3c2:	aa1a      	add	r2, sp, #104	; 0x68
   bf3c4:	a817      	add	r0, sp, #92	; 0x5c
   bf3c6:	f001 f83b 	bl	c0440 <__hexnan>
   bf3ca:	2805      	cmp	r0, #5
   bf3cc:	d126      	bne.n	bf41c <_strtod_l+0x384>
   bf3ce:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   bf3d0:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
   bf3d4:	f043 4bff 	orr.w	fp, r3, #2139095040	; 0x7f800000
   bf3d8:	f44b 0be0 	orr.w	fp, fp, #7340032	; 0x700000
   bf3dc:	e6a0      	b.n	bf120 <_strtod_l+0x88>
   bf3de:	210a      	movs	r1, #10
   bf3e0:	fb01 2e0e 	mla	lr, r1, lr, r2
   bf3e4:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
   bf3e8:	e7b9      	b.n	bf35e <_strtod_l+0x2c6>
   bf3ea:	2a6e      	cmp	r2, #110	; 0x6e
   bf3ec:	e7db      	b.n	bf3a6 <_strtod_l+0x30e>
   bf3ee:	4990      	ldr	r1, [pc, #576]	; (bf630 <_strtod_l+0x598>)
   bf3f0:	a817      	add	r0, sp, #92	; 0x5c
   bf3f2:	f001 f811 	bl	c0418 <__match>
   bf3f6:	2800      	cmp	r0, #0
   bf3f8:	f43f aeb0 	beq.w	bf15c <_strtod_l+0xc4>
   bf3fc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf3fe:	498d      	ldr	r1, [pc, #564]	; (bf634 <_strtod_l+0x59c>)
   bf400:	3b01      	subs	r3, #1
   bf402:	a817      	add	r0, sp, #92	; 0x5c
   bf404:	9317      	str	r3, [sp, #92]	; 0x5c
   bf406:	f001 f807 	bl	c0418 <__match>
   bf40a:	b910      	cbnz	r0, bf412 <_strtod_l+0x37a>
   bf40c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bf40e:	3301      	adds	r3, #1
   bf410:	9317      	str	r3, [sp, #92]	; 0x5c
   bf412:	f8df b230 	ldr.w	fp, [pc, #560]	; bf644 <_strtod_l+0x5ac>
   bf416:	f04f 0a00 	mov.w	sl, #0
   bf41a:	e681      	b.n	bf120 <_strtod_l+0x88>
   bf41c:	4886      	ldr	r0, [pc, #536]	; (bf638 <_strtod_l+0x5a0>)
   bf41e:	f001 fd93 	bl	c0f48 <nan>
   bf422:	ec5b ab10 	vmov	sl, fp, d0
   bf426:	e67b      	b.n	bf120 <_strtod_l+0x88>
   bf428:	9b05      	ldr	r3, [sp, #20]
   bf42a:	9807      	ldr	r0, [sp, #28]
   bf42c:	1af3      	subs	r3, r6, r3
   bf42e:	2f00      	cmp	r7, #0
   bf430:	bf08      	it	eq
   bf432:	462f      	moveq	r7, r5
   bf434:	2d10      	cmp	r5, #16
   bf436:	9306      	str	r3, [sp, #24]
   bf438:	46a8      	mov	r8, r5
   bf43a:	bfa8      	it	ge
   bf43c:	f04f 0810 	movge.w	r8, #16
   bf440:	f7ff f974 	bl	be72c <__aeabi_ui2d>
   bf444:	2d09      	cmp	r5, #9
   bf446:	4682      	mov	sl, r0
   bf448:	468b      	mov	fp, r1
   bf44a:	dd13      	ble.n	bf474 <_strtod_l+0x3dc>
   bf44c:	4b7b      	ldr	r3, [pc, #492]	; (bf63c <_strtod_l+0x5a4>)
   bf44e:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
   bf452:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
   bf456:	f7ff f9e3 	bl	be820 <__aeabi_dmul>
   bf45a:	4682      	mov	sl, r0
   bf45c:	4648      	mov	r0, r9
   bf45e:	468b      	mov	fp, r1
   bf460:	f7ff f964 	bl	be72c <__aeabi_ui2d>
   bf464:	4602      	mov	r2, r0
   bf466:	460b      	mov	r3, r1
   bf468:	4650      	mov	r0, sl
   bf46a:	4659      	mov	r1, fp
   bf46c:	f7ff f822 	bl	be4b4 <__adddf3>
   bf470:	4682      	mov	sl, r0
   bf472:	468b      	mov	fp, r1
   bf474:	2d0f      	cmp	r5, #15
   bf476:	dc38      	bgt.n	bf4ea <_strtod_l+0x452>
   bf478:	9b06      	ldr	r3, [sp, #24]
   bf47a:	2b00      	cmp	r3, #0
   bf47c:	f43f ae50 	beq.w	bf120 <_strtod_l+0x88>
   bf480:	dd24      	ble.n	bf4cc <_strtod_l+0x434>
   bf482:	2b16      	cmp	r3, #22
   bf484:	dc0b      	bgt.n	bf49e <_strtod_l+0x406>
   bf486:	496d      	ldr	r1, [pc, #436]	; (bf63c <_strtod_l+0x5a4>)
   bf488:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   bf48c:	e9d1 0100 	ldrd	r0, r1, [r1]
   bf490:	4652      	mov	r2, sl
   bf492:	465b      	mov	r3, fp
   bf494:	f7ff f9c4 	bl	be820 <__aeabi_dmul>
   bf498:	4682      	mov	sl, r0
   bf49a:	468b      	mov	fp, r1
   bf49c:	e640      	b.n	bf120 <_strtod_l+0x88>
   bf49e:	9a06      	ldr	r2, [sp, #24]
   bf4a0:	f1c5 0325 	rsb	r3, r5, #37	; 0x25
   bf4a4:	4293      	cmp	r3, r2
   bf4a6:	db20      	blt.n	bf4ea <_strtod_l+0x452>
   bf4a8:	4c64      	ldr	r4, [pc, #400]	; (bf63c <_strtod_l+0x5a4>)
   bf4aa:	f1c5 050f 	rsb	r5, r5, #15
   bf4ae:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
   bf4b2:	4652      	mov	r2, sl
   bf4b4:	465b      	mov	r3, fp
   bf4b6:	e9d1 0100 	ldrd	r0, r1, [r1]
   bf4ba:	f7ff f9b1 	bl	be820 <__aeabi_dmul>
   bf4be:	9b06      	ldr	r3, [sp, #24]
   bf4c0:	1b5d      	subs	r5, r3, r5
   bf4c2:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   bf4c6:	e9d4 2300 	ldrd	r2, r3, [r4]
   bf4ca:	e7e3      	b.n	bf494 <_strtod_l+0x3fc>
   bf4cc:	9b06      	ldr	r3, [sp, #24]
   bf4ce:	3316      	adds	r3, #22
   bf4d0:	db0b      	blt.n	bf4ea <_strtod_l+0x452>
   bf4d2:	9b05      	ldr	r3, [sp, #20]
   bf4d4:	1b9e      	subs	r6, r3, r6
   bf4d6:	4b59      	ldr	r3, [pc, #356]	; (bf63c <_strtod_l+0x5a4>)
   bf4d8:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
   bf4dc:	e9d6 2300 	ldrd	r2, r3, [r6]
   bf4e0:	4650      	mov	r0, sl
   bf4e2:	4659      	mov	r1, fp
   bf4e4:	f7ff fac6 	bl	bea74 <__aeabi_ddiv>
   bf4e8:	e7d6      	b.n	bf498 <_strtod_l+0x400>
   bf4ea:	9b06      	ldr	r3, [sp, #24]
   bf4ec:	eba5 0808 	sub.w	r8, r5, r8
   bf4f0:	4498      	add	r8, r3
   bf4f2:	f1b8 0f00 	cmp.w	r8, #0
   bf4f6:	dd74      	ble.n	bf5e2 <_strtod_l+0x54a>
   bf4f8:	f018 030f 	ands.w	r3, r8, #15
   bf4fc:	d00a      	beq.n	bf514 <_strtod_l+0x47c>
   bf4fe:	494f      	ldr	r1, [pc, #316]	; (bf63c <_strtod_l+0x5a4>)
   bf500:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   bf504:	4652      	mov	r2, sl
   bf506:	465b      	mov	r3, fp
   bf508:	e9d1 0100 	ldrd	r0, r1, [r1]
   bf50c:	f7ff f988 	bl	be820 <__aeabi_dmul>
   bf510:	4682      	mov	sl, r0
   bf512:	468b      	mov	fp, r1
   bf514:	f038 080f 	bics.w	r8, r8, #15
   bf518:	d04f      	beq.n	bf5ba <_strtod_l+0x522>
   bf51a:	f5b8 7f9a 	cmp.w	r8, #308	; 0x134
   bf51e:	dd22      	ble.n	bf566 <_strtod_l+0x4ce>
   bf520:	2500      	movs	r5, #0
   bf522:	462e      	mov	r6, r5
   bf524:	9507      	str	r5, [sp, #28]
   bf526:	9505      	str	r5, [sp, #20]
   bf528:	2322      	movs	r3, #34	; 0x22
   bf52a:	f8df b118 	ldr.w	fp, [pc, #280]	; bf644 <_strtod_l+0x5ac>
   bf52e:	6023      	str	r3, [r4, #0]
   bf530:	f04f 0a00 	mov.w	sl, #0
   bf534:	9b07      	ldr	r3, [sp, #28]
   bf536:	2b00      	cmp	r3, #0
   bf538:	f43f adf2 	beq.w	bf120 <_strtod_l+0x88>
   bf53c:	9918      	ldr	r1, [sp, #96]	; 0x60
   bf53e:	4620      	mov	r0, r4
   bf540:	f001 f870 	bl	c0624 <_Bfree>
   bf544:	9905      	ldr	r1, [sp, #20]
   bf546:	4620      	mov	r0, r4
   bf548:	f001 f86c 	bl	c0624 <_Bfree>
   bf54c:	4631      	mov	r1, r6
   bf54e:	4620      	mov	r0, r4
   bf550:	f001 f868 	bl	c0624 <_Bfree>
   bf554:	9907      	ldr	r1, [sp, #28]
   bf556:	4620      	mov	r0, r4
   bf558:	f001 f864 	bl	c0624 <_Bfree>
   bf55c:	4629      	mov	r1, r5
   bf55e:	4620      	mov	r0, r4
   bf560:	f001 f860 	bl	c0624 <_Bfree>
   bf564:	e5dc      	b.n	bf120 <_strtod_l+0x88>
   bf566:	4b36      	ldr	r3, [pc, #216]	; (bf640 <_strtod_l+0x5a8>)
   bf568:	9304      	str	r3, [sp, #16]
   bf56a:	2300      	movs	r3, #0
   bf56c:	ea4f 1828 	mov.w	r8, r8, asr #4
   bf570:	4650      	mov	r0, sl
   bf572:	4659      	mov	r1, fp
   bf574:	4699      	mov	r9, r3
   bf576:	f1b8 0f01 	cmp.w	r8, #1
   bf57a:	dc21      	bgt.n	bf5c0 <_strtod_l+0x528>
   bf57c:	b10b      	cbz	r3, bf582 <_strtod_l+0x4ea>
   bf57e:	4682      	mov	sl, r0
   bf580:	468b      	mov	fp, r1
   bf582:	4b2f      	ldr	r3, [pc, #188]	; (bf640 <_strtod_l+0x5a8>)
   bf584:	f1ab 7b54 	sub.w	fp, fp, #55574528	; 0x3500000
   bf588:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
   bf58c:	4652      	mov	r2, sl
   bf58e:	465b      	mov	r3, fp
   bf590:	e9d9 0100 	ldrd	r0, r1, [r9]
   bf594:	f7ff f944 	bl	be820 <__aeabi_dmul>
   bf598:	4b2a      	ldr	r3, [pc, #168]	; (bf644 <_strtod_l+0x5ac>)
   bf59a:	460a      	mov	r2, r1
   bf59c:	400b      	ands	r3, r1
   bf59e:	492a      	ldr	r1, [pc, #168]	; (bf648 <_strtod_l+0x5b0>)
   bf5a0:	428b      	cmp	r3, r1
   bf5a2:	4682      	mov	sl, r0
   bf5a4:	d8bc      	bhi.n	bf520 <_strtod_l+0x488>
   bf5a6:	f5a1 1180 	sub.w	r1, r1, #1048576	; 0x100000
   bf5aa:	428b      	cmp	r3, r1
   bf5ac:	bf86      	itte	hi
   bf5ae:	f8df b09c 	ldrhi.w	fp, [pc, #156]	; bf64c <_strtod_l+0x5b4>
   bf5b2:	f04f 3aff 	movhi.w	sl, #4294967295
   bf5b6:	f102 7b54 	addls.w	fp, r2, #55574528	; 0x3500000
   bf5ba:	2300      	movs	r3, #0
   bf5bc:	9304      	str	r3, [sp, #16]
   bf5be:	e084      	b.n	bf6ca <_strtod_l+0x632>
   bf5c0:	f018 0f01 	tst.w	r8, #1
   bf5c4:	d005      	beq.n	bf5d2 <_strtod_l+0x53a>
   bf5c6:	9b04      	ldr	r3, [sp, #16]
   bf5c8:	e9d3 2300 	ldrd	r2, r3, [r3]
   bf5cc:	f7ff f928 	bl	be820 <__aeabi_dmul>
   bf5d0:	2301      	movs	r3, #1
   bf5d2:	9a04      	ldr	r2, [sp, #16]
   bf5d4:	3208      	adds	r2, #8
   bf5d6:	f109 0901 	add.w	r9, r9, #1
   bf5da:	ea4f 0868 	mov.w	r8, r8, asr #1
   bf5de:	9204      	str	r2, [sp, #16]
   bf5e0:	e7c9      	b.n	bf576 <_strtod_l+0x4de>
   bf5e2:	d0ea      	beq.n	bf5ba <_strtod_l+0x522>
   bf5e4:	f1c8 0800 	rsb	r8, r8, #0
   bf5e8:	f018 020f 	ands.w	r2, r8, #15
   bf5ec:	d00a      	beq.n	bf604 <_strtod_l+0x56c>
   bf5ee:	4b13      	ldr	r3, [pc, #76]	; (bf63c <_strtod_l+0x5a4>)
   bf5f0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   bf5f4:	4650      	mov	r0, sl
   bf5f6:	4659      	mov	r1, fp
   bf5f8:	e9d3 2300 	ldrd	r2, r3, [r3]
   bf5fc:	f7ff fa3a 	bl	bea74 <__aeabi_ddiv>
   bf600:	4682      	mov	sl, r0
   bf602:	468b      	mov	fp, r1
   bf604:	ea5f 1828 	movs.w	r8, r8, asr #4
   bf608:	d0d7      	beq.n	bf5ba <_strtod_l+0x522>
   bf60a:	f1b8 0f1f 	cmp.w	r8, #31
   bf60e:	dd1f      	ble.n	bf650 <_strtod_l+0x5b8>
   bf610:	2500      	movs	r5, #0
   bf612:	462e      	mov	r6, r5
   bf614:	9507      	str	r5, [sp, #28]
   bf616:	9505      	str	r5, [sp, #20]
   bf618:	2322      	movs	r3, #34	; 0x22
   bf61a:	f04f 0a00 	mov.w	sl, #0
   bf61e:	f04f 0b00 	mov.w	fp, #0
   bf622:	6023      	str	r3, [r4, #0]
   bf624:	e786      	b.n	bf534 <_strtod_l+0x49c>
   bf626:	bf00      	nop
   bf628:	000c23c6 	.word	0x000c23c6
   bf62c:	000c23e0 	.word	0x000c23e0
   bf630:	000c23bd 	.word	0x000c23bd
   bf634:	000c23c0 	.word	0x000c23c0
   bf638:	000c1076 	.word	0x000c1076
   bf63c:	000c2678 	.word	0x000c2678
   bf640:	000c2650 	.word	0x000c2650
   bf644:	7ff00000 	.word	0x7ff00000
   bf648:	7ca00000 	.word	0x7ca00000
   bf64c:	7fefffff 	.word	0x7fefffff
   bf650:	f018 0310 	ands.w	r3, r8, #16
   bf654:	bf18      	it	ne
   bf656:	236a      	movne	r3, #106	; 0x6a
   bf658:	f8df 93ac 	ldr.w	r9, [pc, #940]	; bfa08 <_strtod_l+0x970>
   bf65c:	9304      	str	r3, [sp, #16]
   bf65e:	4650      	mov	r0, sl
   bf660:	4659      	mov	r1, fp
   bf662:	2300      	movs	r3, #0
   bf664:	f018 0f01 	tst.w	r8, #1
   bf668:	d004      	beq.n	bf674 <_strtod_l+0x5dc>
   bf66a:	e9d9 2300 	ldrd	r2, r3, [r9]
   bf66e:	f7ff f8d7 	bl	be820 <__aeabi_dmul>
   bf672:	2301      	movs	r3, #1
   bf674:	ea5f 0868 	movs.w	r8, r8, asr #1
   bf678:	f109 0908 	add.w	r9, r9, #8
   bf67c:	d1f2      	bne.n	bf664 <_strtod_l+0x5cc>
   bf67e:	b10b      	cbz	r3, bf684 <_strtod_l+0x5ec>
   bf680:	4682      	mov	sl, r0
   bf682:	468b      	mov	fp, r1
   bf684:	9b04      	ldr	r3, [sp, #16]
   bf686:	b1c3      	cbz	r3, bf6ba <_strtod_l+0x622>
   bf688:	f3cb 520a 	ubfx	r2, fp, #20, #11
   bf68c:	f1c2 036b 	rsb	r3, r2, #107	; 0x6b
   bf690:	2b00      	cmp	r3, #0
   bf692:	4659      	mov	r1, fp
   bf694:	dd11      	ble.n	bf6ba <_strtod_l+0x622>
   bf696:	2b1f      	cmp	r3, #31
   bf698:	f340 8124 	ble.w	bf8e4 <_strtod_l+0x84c>
   bf69c:	2b34      	cmp	r3, #52	; 0x34
   bf69e:	bfde      	ittt	le
   bf6a0:	f1c2 024b 	rsble	r2, r2, #75	; 0x4b
   bf6a4:	f04f 33ff 	movle.w	r3, #4294967295
   bf6a8:	fa03 f202 	lslle.w	r2, r3, r2
   bf6ac:	f04f 0a00 	mov.w	sl, #0
   bf6b0:	bfcc      	ite	gt
   bf6b2:	f04f 7b5c 	movgt.w	fp, #57671680	; 0x3700000
   bf6b6:	ea02 0b01 	andle.w	fp, r2, r1
   bf6ba:	2200      	movs	r2, #0
   bf6bc:	2300      	movs	r3, #0
   bf6be:	4650      	mov	r0, sl
   bf6c0:	4659      	mov	r1, fp
   bf6c2:	f7ff fb15 	bl	becf0 <__aeabi_dcmpeq>
   bf6c6:	2800      	cmp	r0, #0
   bf6c8:	d1a2      	bne.n	bf610 <_strtod_l+0x578>
   bf6ca:	9b07      	ldr	r3, [sp, #28]
   bf6cc:	9300      	str	r3, [sp, #0]
   bf6ce:	9908      	ldr	r1, [sp, #32]
   bf6d0:	462b      	mov	r3, r5
   bf6d2:	463a      	mov	r2, r7
   bf6d4:	4620      	mov	r0, r4
   bf6d6:	f001 f80d 	bl	c06f4 <__s2b>
   bf6da:	9007      	str	r0, [sp, #28]
   bf6dc:	2800      	cmp	r0, #0
   bf6de:	f43f af1f 	beq.w	bf520 <_strtod_l+0x488>
   bf6e2:	9b05      	ldr	r3, [sp, #20]
   bf6e4:	1b9e      	subs	r6, r3, r6
   bf6e6:	9b06      	ldr	r3, [sp, #24]
   bf6e8:	2b00      	cmp	r3, #0
   bf6ea:	bfb4      	ite	lt
   bf6ec:	4633      	movlt	r3, r6
   bf6ee:	2300      	movge	r3, #0
   bf6f0:	930c      	str	r3, [sp, #48]	; 0x30
   bf6f2:	9b06      	ldr	r3, [sp, #24]
   bf6f4:	2500      	movs	r5, #0
   bf6f6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   bf6fa:	9312      	str	r3, [sp, #72]	; 0x48
   bf6fc:	462e      	mov	r6, r5
   bf6fe:	9b07      	ldr	r3, [sp, #28]
   bf700:	4620      	mov	r0, r4
   bf702:	6859      	ldr	r1, [r3, #4]
   bf704:	f000 ff4e 	bl	c05a4 <_Balloc>
   bf708:	9005      	str	r0, [sp, #20]
   bf70a:	2800      	cmp	r0, #0
   bf70c:	f43f af0c 	beq.w	bf528 <_strtod_l+0x490>
   bf710:	9b07      	ldr	r3, [sp, #28]
   bf712:	691a      	ldr	r2, [r3, #16]
   bf714:	3202      	adds	r2, #2
   bf716:	f103 010c 	add.w	r1, r3, #12
   bf71a:	0092      	lsls	r2, r2, #2
   bf71c:	300c      	adds	r0, #12
   bf71e:	f7ff fbc4 	bl	beeaa <memcpy>
   bf722:	ec4b ab10 	vmov	d0, sl, fp
   bf726:	aa1a      	add	r2, sp, #104	; 0x68
   bf728:	a919      	add	r1, sp, #100	; 0x64
   bf72a:	4620      	mov	r0, r4
   bf72c:	f001 fb28 	bl	c0d80 <__d2b>
   bf730:	ec4b ab18 	vmov	d8, sl, fp
   bf734:	9018      	str	r0, [sp, #96]	; 0x60
   bf736:	2800      	cmp	r0, #0
   bf738:	f43f aef6 	beq.w	bf528 <_strtod_l+0x490>
   bf73c:	2101      	movs	r1, #1
   bf73e:	4620      	mov	r0, r4
   bf740:	f001 f872 	bl	c0828 <__i2b>
   bf744:	4606      	mov	r6, r0
   bf746:	2800      	cmp	r0, #0
   bf748:	f43f aeee 	beq.w	bf528 <_strtod_l+0x490>
   bf74c:	9b19      	ldr	r3, [sp, #100]	; 0x64
   bf74e:	9904      	ldr	r1, [sp, #16]
   bf750:	2b00      	cmp	r3, #0
   bf752:	bfab      	itete	ge
   bf754:	9a0c      	ldrge	r2, [sp, #48]	; 0x30
   bf756:	9a12      	ldrlt	r2, [sp, #72]	; 0x48
   bf758:	9f12      	ldrge	r7, [sp, #72]	; 0x48
   bf75a:	f8dd 9030 	ldrlt.w	r9, [sp, #48]	; 0x30
   bf75e:	bfac      	ite	ge
   bf760:	eb03 0902 	addge.w	r9, r3, r2
   bf764:	1ad7      	sublt	r7, r2, r3
   bf766:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   bf768:	eba3 0801 	sub.w	r8, r3, r1
   bf76c:	4490      	add	r8, r2
   bf76e:	4ba1      	ldr	r3, [pc, #644]	; (bf9f4 <_strtod_l+0x95c>)
   bf770:	f108 38ff 	add.w	r8, r8, #4294967295
   bf774:	4598      	cmp	r8, r3
   bf776:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
   bf77a:	f280 80c7 	bge.w	bf90c <_strtod_l+0x874>
   bf77e:	eba3 0308 	sub.w	r3, r3, r8
   bf782:	2b1f      	cmp	r3, #31
   bf784:	eba2 0203 	sub.w	r2, r2, r3
   bf788:	f04f 0101 	mov.w	r1, #1
   bf78c:	f300 80b1 	bgt.w	bf8f2 <_strtod_l+0x85a>
   bf790:	fa01 f303 	lsl.w	r3, r1, r3
   bf794:	930d      	str	r3, [sp, #52]	; 0x34
   bf796:	2300      	movs	r3, #0
   bf798:	9308      	str	r3, [sp, #32]
   bf79a:	eb09 0802 	add.w	r8, r9, r2
   bf79e:	9b04      	ldr	r3, [sp, #16]
   bf7a0:	45c1      	cmp	r9, r8
   bf7a2:	4417      	add	r7, r2
   bf7a4:	441f      	add	r7, r3
   bf7a6:	464b      	mov	r3, r9
   bf7a8:	bfa8      	it	ge
   bf7aa:	4643      	movge	r3, r8
   bf7ac:	42bb      	cmp	r3, r7
   bf7ae:	bfa8      	it	ge
   bf7b0:	463b      	movge	r3, r7
   bf7b2:	2b00      	cmp	r3, #0
   bf7b4:	bfc2      	ittt	gt
   bf7b6:	eba8 0803 	subgt.w	r8, r8, r3
   bf7ba:	1aff      	subgt	r7, r7, r3
   bf7bc:	eba9 0903 	subgt.w	r9, r9, r3
   bf7c0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   bf7c2:	2b00      	cmp	r3, #0
   bf7c4:	dd17      	ble.n	bf7f6 <_strtod_l+0x75e>
   bf7c6:	4631      	mov	r1, r6
   bf7c8:	461a      	mov	r2, r3
   bf7ca:	4620      	mov	r0, r4
   bf7cc:	f001 f8ec 	bl	c09a8 <__pow5mult>
   bf7d0:	4606      	mov	r6, r0
   bf7d2:	2800      	cmp	r0, #0
   bf7d4:	f43f aea8 	beq.w	bf528 <_strtod_l+0x490>
   bf7d8:	4601      	mov	r1, r0
   bf7da:	9a18      	ldr	r2, [sp, #96]	; 0x60
   bf7dc:	4620      	mov	r0, r4
   bf7de:	f001 f839 	bl	c0854 <__multiply>
   bf7e2:	900b      	str	r0, [sp, #44]	; 0x2c
   bf7e4:	2800      	cmp	r0, #0
   bf7e6:	f43f ae9f 	beq.w	bf528 <_strtod_l+0x490>
   bf7ea:	9918      	ldr	r1, [sp, #96]	; 0x60
   bf7ec:	4620      	mov	r0, r4
   bf7ee:	f000 ff19 	bl	c0624 <_Bfree>
   bf7f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bf7f4:	9318      	str	r3, [sp, #96]	; 0x60
   bf7f6:	f1b8 0f00 	cmp.w	r8, #0
   bf7fa:	f300 808c 	bgt.w	bf916 <_strtod_l+0x87e>
   bf7fe:	9b06      	ldr	r3, [sp, #24]
   bf800:	2b00      	cmp	r3, #0
   bf802:	dd08      	ble.n	bf816 <_strtod_l+0x77e>
   bf804:	9a12      	ldr	r2, [sp, #72]	; 0x48
   bf806:	9905      	ldr	r1, [sp, #20]
   bf808:	4620      	mov	r0, r4
   bf80a:	f001 f8cd 	bl	c09a8 <__pow5mult>
   bf80e:	9005      	str	r0, [sp, #20]
   bf810:	2800      	cmp	r0, #0
   bf812:	f43f ae89 	beq.w	bf528 <_strtod_l+0x490>
   bf816:	2f00      	cmp	r7, #0
   bf818:	dd08      	ble.n	bf82c <_strtod_l+0x794>
   bf81a:	9905      	ldr	r1, [sp, #20]
   bf81c:	463a      	mov	r2, r7
   bf81e:	4620      	mov	r0, r4
   bf820:	f001 f91c 	bl	c0a5c <__lshift>
   bf824:	9005      	str	r0, [sp, #20]
   bf826:	2800      	cmp	r0, #0
   bf828:	f43f ae7e 	beq.w	bf528 <_strtod_l+0x490>
   bf82c:	f1b9 0f00 	cmp.w	r9, #0
   bf830:	dd08      	ble.n	bf844 <_strtod_l+0x7ac>
   bf832:	4631      	mov	r1, r6
   bf834:	464a      	mov	r2, r9
   bf836:	4620      	mov	r0, r4
   bf838:	f001 f910 	bl	c0a5c <__lshift>
   bf83c:	4606      	mov	r6, r0
   bf83e:	2800      	cmp	r0, #0
   bf840:	f43f ae72 	beq.w	bf528 <_strtod_l+0x490>
   bf844:	9a05      	ldr	r2, [sp, #20]
   bf846:	9918      	ldr	r1, [sp, #96]	; 0x60
   bf848:	4620      	mov	r0, r4
   bf84a:	f001 f993 	bl	c0b74 <__mdiff>
   bf84e:	4605      	mov	r5, r0
   bf850:	2800      	cmp	r0, #0
   bf852:	f43f ae69 	beq.w	bf528 <_strtod_l+0x490>
   bf856:	68c3      	ldr	r3, [r0, #12]
   bf858:	930b      	str	r3, [sp, #44]	; 0x2c
   bf85a:	2300      	movs	r3, #0
   bf85c:	60c3      	str	r3, [r0, #12]
   bf85e:	4631      	mov	r1, r6
   bf860:	f001 f96c 	bl	c0b3c <__mcmp>
   bf864:	2800      	cmp	r0, #0
   bf866:	da60      	bge.n	bf92a <_strtod_l+0x892>
   bf868:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bf86a:	ea53 030a 	orrs.w	r3, r3, sl
   bf86e:	f040 8082 	bne.w	bf976 <_strtod_l+0x8de>
   bf872:	f3cb 0313 	ubfx	r3, fp, #0, #20
   bf876:	2b00      	cmp	r3, #0
   bf878:	d17d      	bne.n	bf976 <_strtod_l+0x8de>
   bf87a:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
   bf87e:	0d1b      	lsrs	r3, r3, #20
   bf880:	051b      	lsls	r3, r3, #20
   bf882:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
   bf886:	d976      	bls.n	bf976 <_strtod_l+0x8de>
   bf888:	696b      	ldr	r3, [r5, #20]
   bf88a:	b913      	cbnz	r3, bf892 <_strtod_l+0x7fa>
   bf88c:	692b      	ldr	r3, [r5, #16]
   bf88e:	2b01      	cmp	r3, #1
   bf890:	dd71      	ble.n	bf976 <_strtod_l+0x8de>
   bf892:	4629      	mov	r1, r5
   bf894:	2201      	movs	r2, #1
   bf896:	4620      	mov	r0, r4
   bf898:	f001 f8e0 	bl	c0a5c <__lshift>
   bf89c:	4631      	mov	r1, r6
   bf89e:	4605      	mov	r5, r0
   bf8a0:	f001 f94c 	bl	c0b3c <__mcmp>
   bf8a4:	2800      	cmp	r0, #0
   bf8a6:	dd66      	ble.n	bf976 <_strtod_l+0x8de>
   bf8a8:	9904      	ldr	r1, [sp, #16]
   bf8aa:	4a53      	ldr	r2, [pc, #332]	; (bf9f8 <_strtod_l+0x960>)
   bf8ac:	465b      	mov	r3, fp
   bf8ae:	2900      	cmp	r1, #0
   bf8b0:	f000 8081 	beq.w	bf9b6 <_strtod_l+0x91e>
   bf8b4:	ea02 010b 	and.w	r1, r2, fp
   bf8b8:	f1b1 6fd6 	cmp.w	r1, #112197632	; 0x6b00000
   bf8bc:	dc7b      	bgt.n	bf9b6 <_strtod_l+0x91e>
   bf8be:	f1b1 7f5c 	cmp.w	r1, #57671680	; 0x3700000
   bf8c2:	f77f aea9 	ble.w	bf618 <_strtod_l+0x580>
   bf8c6:	4b4d      	ldr	r3, [pc, #308]	; (bf9fc <_strtod_l+0x964>)
   bf8c8:	4650      	mov	r0, sl
   bf8ca:	4659      	mov	r1, fp
   bf8cc:	2200      	movs	r2, #0
   bf8ce:	f7fe ffa7 	bl	be820 <__aeabi_dmul>
   bf8d2:	460b      	mov	r3, r1
   bf8d4:	4303      	orrs	r3, r0
   bf8d6:	bf08      	it	eq
   bf8d8:	2322      	moveq	r3, #34	; 0x22
   bf8da:	4682      	mov	sl, r0
   bf8dc:	468b      	mov	fp, r1
   bf8de:	bf08      	it	eq
   bf8e0:	6023      	streq	r3, [r4, #0]
   bf8e2:	e62b      	b.n	bf53c <_strtod_l+0x4a4>
   bf8e4:	f04f 32ff 	mov.w	r2, #4294967295
   bf8e8:	fa02 f303 	lsl.w	r3, r2, r3
   bf8ec:	ea03 0a0a 	and.w	sl, r3, sl
   bf8f0:	e6e3      	b.n	bf6ba <_strtod_l+0x622>
   bf8f2:	f1c8 487f 	rsb	r8, r8, #4278190080	; 0xff000000
   bf8f6:	f508 087f 	add.w	r8, r8, #16711680	; 0xff0000
   bf8fa:	f508 487b 	add.w	r8, r8, #64256	; 0xfb00
   bf8fe:	f108 08e2 	add.w	r8, r8, #226	; 0xe2
   bf902:	fa01 f308 	lsl.w	r3, r1, r8
   bf906:	9308      	str	r3, [sp, #32]
   bf908:	910d      	str	r1, [sp, #52]	; 0x34
   bf90a:	e746      	b.n	bf79a <_strtod_l+0x702>
   bf90c:	2300      	movs	r3, #0
   bf90e:	9308      	str	r3, [sp, #32]
   bf910:	2301      	movs	r3, #1
   bf912:	930d      	str	r3, [sp, #52]	; 0x34
   bf914:	e741      	b.n	bf79a <_strtod_l+0x702>
   bf916:	9918      	ldr	r1, [sp, #96]	; 0x60
   bf918:	4642      	mov	r2, r8
   bf91a:	4620      	mov	r0, r4
   bf91c:	f001 f89e 	bl	c0a5c <__lshift>
   bf920:	9018      	str	r0, [sp, #96]	; 0x60
   bf922:	2800      	cmp	r0, #0
   bf924:	f47f af6b 	bne.w	bf7fe <_strtod_l+0x766>
   bf928:	e5fe      	b.n	bf528 <_strtod_l+0x490>
   bf92a:	465f      	mov	r7, fp
   bf92c:	d16e      	bne.n	bfa0c <_strtod_l+0x974>
   bf92e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   bf930:	f3cb 0313 	ubfx	r3, fp, #0, #20
   bf934:	b342      	cbz	r2, bf988 <_strtod_l+0x8f0>
   bf936:	4a32      	ldr	r2, [pc, #200]	; (bfa00 <_strtod_l+0x968>)
   bf938:	4293      	cmp	r3, r2
   bf93a:	d128      	bne.n	bf98e <_strtod_l+0x8f6>
   bf93c:	9b04      	ldr	r3, [sp, #16]
   bf93e:	4651      	mov	r1, sl
   bf940:	b1eb      	cbz	r3, bf97e <_strtod_l+0x8e6>
   bf942:	4b2d      	ldr	r3, [pc, #180]	; (bf9f8 <_strtod_l+0x960>)
   bf944:	403b      	ands	r3, r7
   bf946:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
   bf94a:	f04f 32ff 	mov.w	r2, #4294967295
   bf94e:	d819      	bhi.n	bf984 <_strtod_l+0x8ec>
   bf950:	0d1b      	lsrs	r3, r3, #20
   bf952:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
   bf956:	fa02 f303 	lsl.w	r3, r2, r3
   bf95a:	4299      	cmp	r1, r3
   bf95c:	d117      	bne.n	bf98e <_strtod_l+0x8f6>
   bf95e:	4b29      	ldr	r3, [pc, #164]	; (bfa04 <_strtod_l+0x96c>)
   bf960:	429f      	cmp	r7, r3
   bf962:	d102      	bne.n	bf96a <_strtod_l+0x8d2>
   bf964:	3101      	adds	r1, #1
   bf966:	f43f addf 	beq.w	bf528 <_strtod_l+0x490>
   bf96a:	4b23      	ldr	r3, [pc, #140]	; (bf9f8 <_strtod_l+0x960>)
   bf96c:	403b      	ands	r3, r7
   bf96e:	f503 1b80 	add.w	fp, r3, #1048576	; 0x100000
   bf972:	f04f 0a00 	mov.w	sl, #0
   bf976:	9b04      	ldr	r3, [sp, #16]
   bf978:	2b00      	cmp	r3, #0
   bf97a:	d1a4      	bne.n	bf8c6 <_strtod_l+0x82e>
   bf97c:	e5de      	b.n	bf53c <_strtod_l+0x4a4>
   bf97e:	f04f 33ff 	mov.w	r3, #4294967295
   bf982:	e7ea      	b.n	bf95a <_strtod_l+0x8c2>
   bf984:	4613      	mov	r3, r2
   bf986:	e7e8      	b.n	bf95a <_strtod_l+0x8c2>
   bf988:	ea53 030a 	orrs.w	r3, r3, sl
   bf98c:	d08c      	beq.n	bf8a8 <_strtod_l+0x810>
   bf98e:	9b08      	ldr	r3, [sp, #32]
   bf990:	b1db      	cbz	r3, bf9ca <_strtod_l+0x932>
   bf992:	423b      	tst	r3, r7
   bf994:	d0ef      	beq.n	bf976 <_strtod_l+0x8de>
   bf996:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bf998:	9a04      	ldr	r2, [sp, #16]
   bf99a:	4650      	mov	r0, sl
   bf99c:	4659      	mov	r1, fp
   bf99e:	b1c3      	cbz	r3, bf9d2 <_strtod_l+0x93a>
   bf9a0:	f7ff fb5c 	bl	bf05c <sulp>
   bf9a4:	4602      	mov	r2, r0
   bf9a6:	460b      	mov	r3, r1
   bf9a8:	ec51 0b18 	vmov	r0, r1, d8
   bf9ac:	f7fe fd82 	bl	be4b4 <__adddf3>
   bf9b0:	4682      	mov	sl, r0
   bf9b2:	468b      	mov	fp, r1
   bf9b4:	e7df      	b.n	bf976 <_strtod_l+0x8de>
   bf9b6:	4013      	ands	r3, r2
   bf9b8:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
   bf9bc:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
   bf9c0:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
   bf9c4:	f04f 3aff 	mov.w	sl, #4294967295
   bf9c8:	e7d5      	b.n	bf976 <_strtod_l+0x8de>
   bf9ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   bf9cc:	ea13 0f0a 	tst.w	r3, sl
   bf9d0:	e7e0      	b.n	bf994 <_strtod_l+0x8fc>
   bf9d2:	f7ff fb43 	bl	bf05c <sulp>
   bf9d6:	4602      	mov	r2, r0
   bf9d8:	460b      	mov	r3, r1
   bf9da:	ec51 0b18 	vmov	r0, r1, d8
   bf9de:	f7fe fd67 	bl	be4b0 <__aeabi_dsub>
   bf9e2:	2200      	movs	r2, #0
   bf9e4:	2300      	movs	r3, #0
   bf9e6:	4682      	mov	sl, r0
   bf9e8:	468b      	mov	fp, r1
   bf9ea:	f7ff f981 	bl	becf0 <__aeabi_dcmpeq>
   bf9ee:	2800      	cmp	r0, #0
   bf9f0:	d0c1      	beq.n	bf976 <_strtod_l+0x8de>
   bf9f2:	e611      	b.n	bf618 <_strtod_l+0x580>
   bf9f4:	fffffc02 	.word	0xfffffc02
   bf9f8:	7ff00000 	.word	0x7ff00000
   bf9fc:	39500000 	.word	0x39500000
   bfa00:	000fffff 	.word	0x000fffff
   bfa04:	7fefffff 	.word	0x7fefffff
   bfa08:	000c23f8 	.word	0x000c23f8
   bfa0c:	4631      	mov	r1, r6
   bfa0e:	4628      	mov	r0, r5
   bfa10:	f001 fa12 	bl	c0e38 <__ratio>
   bfa14:	ec59 8b10 	vmov	r8, r9, d0
   bfa18:	ee10 0a10 	vmov	r0, s0
   bfa1c:	2200      	movs	r2, #0
   bfa1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   bfa22:	4649      	mov	r1, r9
   bfa24:	f7ff f978 	bl	bed18 <__aeabi_dcmple>
   bfa28:	2800      	cmp	r0, #0
   bfa2a:	d07a      	beq.n	bfb22 <_strtod_l+0xa8a>
   bfa2c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bfa2e:	2b00      	cmp	r3, #0
   bfa30:	d04a      	beq.n	bfac8 <_strtod_l+0xa30>
   bfa32:	4b95      	ldr	r3, [pc, #596]	; (bfc88 <_strtod_l+0xbf0>)
   bfa34:	2200      	movs	r2, #0
   bfa36:	e9cd 2308 	strd	r2, r3, [sp, #32]
   bfa3a:	f8df 924c 	ldr.w	r9, [pc, #588]	; bfc88 <_strtod_l+0xbf0>
   bfa3e:	f04f 0800 	mov.w	r8, #0
   bfa42:	4b92      	ldr	r3, [pc, #584]	; (bfc8c <_strtod_l+0xbf4>)
   bfa44:	403b      	ands	r3, r7
   bfa46:	930d      	str	r3, [sp, #52]	; 0x34
   bfa48:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   bfa4a:	4b91      	ldr	r3, [pc, #580]	; (bfc90 <_strtod_l+0xbf8>)
   bfa4c:	429a      	cmp	r2, r3
   bfa4e:	f040 80b0 	bne.w	bfbb2 <_strtod_l+0xb1a>
   bfa52:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   bfa56:	f1a7 7b54 	sub.w	fp, r7, #55574528	; 0x3500000
   bfa5a:	ec4b ab10 	vmov	d0, sl, fp
   bfa5e:	e9cd 0108 	strd	r0, r1, [sp, #32]
   bfa62:	f001 f911 	bl	c0c88 <__ulp>
   bfa66:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   bfa6a:	ec53 2b10 	vmov	r2, r3, d0
   bfa6e:	f7fe fed7 	bl	be820 <__aeabi_dmul>
   bfa72:	4652      	mov	r2, sl
   bfa74:	465b      	mov	r3, fp
   bfa76:	f7fe fd1d 	bl	be4b4 <__adddf3>
   bfa7a:	460b      	mov	r3, r1
   bfa7c:	4983      	ldr	r1, [pc, #524]	; (bfc8c <_strtod_l+0xbf4>)
   bfa7e:	4a85      	ldr	r2, [pc, #532]	; (bfc94 <_strtod_l+0xbfc>)
   bfa80:	4019      	ands	r1, r3
   bfa82:	4291      	cmp	r1, r2
   bfa84:	4682      	mov	sl, r0
   bfa86:	d960      	bls.n	bfb4a <_strtod_l+0xab2>
   bfa88:	ee18 3a90 	vmov	r3, s17
   bfa8c:	f102 7254 	add.w	r2, r2, #55574528	; 0x3500000
   bfa90:	4293      	cmp	r3, r2
   bfa92:	d104      	bne.n	bfa9e <_strtod_l+0xa06>
   bfa94:	ee18 3a10 	vmov	r3, s16
   bfa98:	3301      	adds	r3, #1
   bfa9a:	f43f ad45 	beq.w	bf528 <_strtod_l+0x490>
   bfa9e:	f8df b200 	ldr.w	fp, [pc, #512]	; bfca0 <_strtod_l+0xc08>
   bfaa2:	f04f 3aff 	mov.w	sl, #4294967295
   bfaa6:	9918      	ldr	r1, [sp, #96]	; 0x60
   bfaa8:	4620      	mov	r0, r4
   bfaaa:	f000 fdbb 	bl	c0624 <_Bfree>
   bfaae:	9905      	ldr	r1, [sp, #20]
   bfab0:	4620      	mov	r0, r4
   bfab2:	f000 fdb7 	bl	c0624 <_Bfree>
   bfab6:	4631      	mov	r1, r6
   bfab8:	4620      	mov	r0, r4
   bfaba:	f000 fdb3 	bl	c0624 <_Bfree>
   bfabe:	4629      	mov	r1, r5
   bfac0:	4620      	mov	r0, r4
   bfac2:	f000 fdaf 	bl	c0624 <_Bfree>
   bfac6:	e61a      	b.n	bf6fe <_strtod_l+0x666>
   bfac8:	f1ba 0f00 	cmp.w	sl, #0
   bfacc:	d11b      	bne.n	bfb06 <_strtod_l+0xa6e>
   bface:	f3cb 0313 	ubfx	r3, fp, #0, #20
   bfad2:	b9f3      	cbnz	r3, bfb12 <_strtod_l+0xa7a>
   bfad4:	4b6c      	ldr	r3, [pc, #432]	; (bfc88 <_strtod_l+0xbf0>)
   bfad6:	2200      	movs	r2, #0
   bfad8:	4640      	mov	r0, r8
   bfada:	4649      	mov	r1, r9
   bfadc:	f7ff f912 	bl	bed04 <__aeabi_dcmplt>
   bfae0:	b9d0      	cbnz	r0, bfb18 <_strtod_l+0xa80>
   bfae2:	4640      	mov	r0, r8
   bfae4:	4649      	mov	r1, r9
   bfae6:	4b6c      	ldr	r3, [pc, #432]	; (bfc98 <_strtod_l+0xc00>)
   bfae8:	2200      	movs	r2, #0
   bfaea:	f7fe fe99 	bl	be820 <__aeabi_dmul>
   bfaee:	4680      	mov	r8, r0
   bfaf0:	4689      	mov	r9, r1
   bfaf2:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
   bfaf6:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
   bfafa:	9315      	str	r3, [sp, #84]	; 0x54
   bfafc:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   bfb00:	e9cd 2308 	strd	r2, r3, [sp, #32]
   bfb04:	e79d      	b.n	bfa42 <_strtod_l+0x9aa>
   bfb06:	f1ba 0f01 	cmp.w	sl, #1
   bfb0a:	d102      	bne.n	bfb12 <_strtod_l+0xa7a>
   bfb0c:	2f00      	cmp	r7, #0
   bfb0e:	f43f ad83 	beq.w	bf618 <_strtod_l+0x580>
   bfb12:	4b62      	ldr	r3, [pc, #392]	; (bfc9c <_strtod_l+0xc04>)
   bfb14:	2200      	movs	r2, #0
   bfb16:	e78e      	b.n	bfa36 <_strtod_l+0x99e>
   bfb18:	f8df 917c 	ldr.w	r9, [pc, #380]	; bfc98 <_strtod_l+0xc00>
   bfb1c:	f04f 0800 	mov.w	r8, #0
   bfb20:	e7e7      	b.n	bfaf2 <_strtod_l+0xa5a>
   bfb22:	4b5d      	ldr	r3, [pc, #372]	; (bfc98 <_strtod_l+0xc00>)
   bfb24:	4640      	mov	r0, r8
   bfb26:	4649      	mov	r1, r9
   bfb28:	2200      	movs	r2, #0
   bfb2a:	f7fe fe79 	bl	be820 <__aeabi_dmul>
   bfb2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bfb30:	4680      	mov	r8, r0
   bfb32:	4689      	mov	r9, r1
   bfb34:	b933      	cbnz	r3, bfb44 <_strtod_l+0xaac>
   bfb36:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
   bfb3a:	900e      	str	r0, [sp, #56]	; 0x38
   bfb3c:	930f      	str	r3, [sp, #60]	; 0x3c
   bfb3e:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   bfb42:	e7dd      	b.n	bfb00 <_strtod_l+0xa68>
   bfb44:	e9cd 890e 	strd	r8, r9, [sp, #56]	; 0x38
   bfb48:	e7f9      	b.n	bfb3e <_strtod_l+0xaa6>
   bfb4a:	f103 7b54 	add.w	fp, r3, #55574528	; 0x3500000
   bfb4e:	9b04      	ldr	r3, [sp, #16]
   bfb50:	2b00      	cmp	r3, #0
   bfb52:	d1a8      	bne.n	bfaa6 <_strtod_l+0xa0e>
   bfb54:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
   bfb58:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   bfb5a:	0d1b      	lsrs	r3, r3, #20
   bfb5c:	051b      	lsls	r3, r3, #20
   bfb5e:	429a      	cmp	r2, r3
   bfb60:	d1a1      	bne.n	bfaa6 <_strtod_l+0xa0e>
   bfb62:	4640      	mov	r0, r8
   bfb64:	4649      	mov	r1, r9
   bfb66:	f001 fa05 	bl	c0f74 <__aeabi_d2lz>
   bfb6a:	f7fe fe2b 	bl	be7c4 <__aeabi_l2d>
   bfb6e:	4602      	mov	r2, r0
   bfb70:	460b      	mov	r3, r1
   bfb72:	4640      	mov	r0, r8
   bfb74:	4649      	mov	r1, r9
   bfb76:	f7fe fc9b 	bl	be4b0 <__aeabi_dsub>
   bfb7a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   bfb7c:	f3cb 0313 	ubfx	r3, fp, #0, #20
   bfb80:	ea43 030a 	orr.w	r3, r3, sl
   bfb84:	4313      	orrs	r3, r2
   bfb86:	4680      	mov	r8, r0
   bfb88:	4689      	mov	r9, r1
   bfb8a:	d055      	beq.n	bfc38 <_strtod_l+0xba0>
   bfb8c:	a336      	add	r3, pc, #216	; (adr r3, bfc68 <_strtod_l+0xbd0>)
   bfb8e:	e9d3 2300 	ldrd	r2, r3, [r3]
   bfb92:	f7ff f8b7 	bl	bed04 <__aeabi_dcmplt>
   bfb96:	2800      	cmp	r0, #0
   bfb98:	f47f acd0 	bne.w	bf53c <_strtod_l+0x4a4>
   bfb9c:	a334      	add	r3, pc, #208	; (adr r3, bfc70 <_strtod_l+0xbd8>)
   bfb9e:	e9d3 2300 	ldrd	r2, r3, [r3]
   bfba2:	4640      	mov	r0, r8
   bfba4:	4649      	mov	r1, r9
   bfba6:	f7ff f8cb 	bl	bed40 <__aeabi_dcmpgt>
   bfbaa:	2800      	cmp	r0, #0
   bfbac:	f43f af7b 	beq.w	bfaa6 <_strtod_l+0xa0e>
   bfbb0:	e4c4      	b.n	bf53c <_strtod_l+0x4a4>
   bfbb2:	9b04      	ldr	r3, [sp, #16]
   bfbb4:	b333      	cbz	r3, bfc04 <_strtod_l+0xb6c>
   bfbb6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   bfbb8:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
   bfbbc:	d822      	bhi.n	bfc04 <_strtod_l+0xb6c>
   bfbbe:	a32e      	add	r3, pc, #184	; (adr r3, bfc78 <_strtod_l+0xbe0>)
   bfbc0:	e9d3 2300 	ldrd	r2, r3, [r3]
   bfbc4:	4640      	mov	r0, r8
   bfbc6:	4649      	mov	r1, r9
   bfbc8:	f7ff f8a6 	bl	bed18 <__aeabi_dcmple>
   bfbcc:	b1a0      	cbz	r0, bfbf8 <_strtod_l+0xb60>
   bfbce:	4649      	mov	r1, r9
   bfbd0:	4640      	mov	r0, r8
   bfbd2:	f7ff f8bf 	bl	bed54 <__aeabi_d2uiz>
   bfbd6:	2801      	cmp	r0, #1
   bfbd8:	bf38      	it	cc
   bfbda:	2001      	movcc	r0, #1
   bfbdc:	f7fe fda6 	bl	be72c <__aeabi_ui2d>
   bfbe0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   bfbe2:	4680      	mov	r8, r0
   bfbe4:	4689      	mov	r9, r1
   bfbe6:	bb23      	cbnz	r3, bfc32 <_strtod_l+0xb9a>
   bfbe8:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
   bfbec:	9010      	str	r0, [sp, #64]	; 0x40
   bfbee:	9311      	str	r3, [sp, #68]	; 0x44
   bfbf0:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   bfbf4:	e9cd 2308 	strd	r2, r3, [sp, #32]
   bfbf8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   bfbfa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   bfbfc:	f103 63d6 	add.w	r3, r3, #112197632	; 0x6b00000
   bfc00:	1a9b      	subs	r3, r3, r2
   bfc02:	9309      	str	r3, [sp, #36]	; 0x24
   bfc04:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   bfc08:	eeb0 0a48 	vmov.f32	s0, s16
   bfc0c:	eef0 0a68 	vmov.f32	s1, s17
   bfc10:	e9cd 0108 	strd	r0, r1, [sp, #32]
   bfc14:	f001 f838 	bl	c0c88 <__ulp>
   bfc18:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   bfc1c:	ec53 2b10 	vmov	r2, r3, d0
   bfc20:	f7fe fdfe 	bl	be820 <__aeabi_dmul>
   bfc24:	ec53 2b18 	vmov	r2, r3, d8
   bfc28:	f7fe fc44 	bl	be4b4 <__adddf3>
   bfc2c:	4682      	mov	sl, r0
   bfc2e:	468b      	mov	fp, r1
   bfc30:	e78d      	b.n	bfb4e <_strtod_l+0xab6>
   bfc32:	e9cd 8910 	strd	r8, r9, [sp, #64]	; 0x40
   bfc36:	e7db      	b.n	bfbf0 <_strtod_l+0xb58>
   bfc38:	a311      	add	r3, pc, #68	; (adr r3, bfc80 <_strtod_l+0xbe8>)
   bfc3a:	e9d3 2300 	ldrd	r2, r3, [r3]
   bfc3e:	f7ff f861 	bl	bed04 <__aeabi_dcmplt>
   bfc42:	e7b2      	b.n	bfbaa <_strtod_l+0xb12>
   bfc44:	2300      	movs	r3, #0
   bfc46:	930a      	str	r3, [sp, #40]	; 0x28
   bfc48:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   bfc4a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   bfc4c:	6013      	str	r3, [r2, #0]
   bfc4e:	f7ff ba6b 	b.w	bf128 <_strtod_l+0x90>
   bfc52:	2a65      	cmp	r2, #101	; 0x65
   bfc54:	f43f ab5f 	beq.w	bf316 <_strtod_l+0x27e>
   bfc58:	2a45      	cmp	r2, #69	; 0x45
   bfc5a:	f43f ab5c 	beq.w	bf316 <_strtod_l+0x27e>
   bfc5e:	2301      	movs	r3, #1
   bfc60:	f7ff bb94 	b.w	bf38c <_strtod_l+0x2f4>
   bfc64:	f3af 8000 	nop.w
   bfc68:	94a03595 	.word	0x94a03595
   bfc6c:	3fdfffff 	.word	0x3fdfffff
   bfc70:	35afe535 	.word	0x35afe535
   bfc74:	3fe00000 	.word	0x3fe00000
   bfc78:	ffc00000 	.word	0xffc00000
   bfc7c:	41dfffff 	.word	0x41dfffff
   bfc80:	94a03595 	.word	0x94a03595
   bfc84:	3fcfffff 	.word	0x3fcfffff
   bfc88:	3ff00000 	.word	0x3ff00000
   bfc8c:	7ff00000 	.word	0x7ff00000
   bfc90:	7fe00000 	.word	0x7fe00000
   bfc94:	7c9fffff 	.word	0x7c9fffff
   bfc98:	3fe00000 	.word	0x3fe00000
   bfc9c:	bff00000 	.word	0xbff00000
   bfca0:	7fefffff 	.word	0x7fefffff

000bfca4 <strtod>:
   bfca4:	460a      	mov	r2, r1
   bfca6:	4601      	mov	r1, r0
   bfca8:	4802      	ldr	r0, [pc, #8]	; (bfcb4 <strtod+0x10>)
   bfcaa:	4b03      	ldr	r3, [pc, #12]	; (bfcb8 <strtod+0x14>)
   bfcac:	6800      	ldr	r0, [r0, #0]
   bfcae:	f7ff b9f3 	b.w	bf098 <_strtod_l>
   bfcb2:	bf00      	nop
   bfcb4:	2003dab0 	.word	0x2003dab0
   bfcb8:	2003db1c 	.word	0x2003db1c

000bfcbc <_strtol_l.constprop.0>:
   bfcbc:	2b01      	cmp	r3, #1
   bfcbe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   bfcc2:	d001      	beq.n	bfcc8 <_strtol_l.constprop.0+0xc>
   bfcc4:	2b24      	cmp	r3, #36	; 0x24
   bfcc6:	d906      	bls.n	bfcd6 <_strtol_l.constprop.0+0x1a>
   bfcc8:	f7fa fbd8 	bl	ba47c <__errno>
   bfccc:	2316      	movs	r3, #22
   bfcce:	6003      	str	r3, [r0, #0]
   bfcd0:	2000      	movs	r0, #0
   bfcd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   bfcd6:	f8df c0e4 	ldr.w	ip, [pc, #228]	; bfdbc <_strtol_l.constprop.0+0x100>
   bfcda:	460d      	mov	r5, r1
   bfcdc:	462e      	mov	r6, r5
   bfcde:	f815 4b01 	ldrb.w	r4, [r5], #1
   bfce2:	f814 700c 	ldrb.w	r7, [r4, ip]
   bfce6:	f017 0708 	ands.w	r7, r7, #8
   bfcea:	d1f7      	bne.n	bfcdc <_strtol_l.constprop.0+0x20>
   bfcec:	2c2d      	cmp	r4, #45	; 0x2d
   bfcee:	d132      	bne.n	bfd56 <_strtol_l.constprop.0+0x9a>
   bfcf0:	782c      	ldrb	r4, [r5, #0]
   bfcf2:	2701      	movs	r7, #1
   bfcf4:	1cb5      	adds	r5, r6, #2
   bfcf6:	2b00      	cmp	r3, #0
   bfcf8:	d05b      	beq.n	bfdb2 <_strtol_l.constprop.0+0xf6>
   bfcfa:	2b10      	cmp	r3, #16
   bfcfc:	d109      	bne.n	bfd12 <_strtol_l.constprop.0+0x56>
   bfcfe:	2c30      	cmp	r4, #48	; 0x30
   bfd00:	d107      	bne.n	bfd12 <_strtol_l.constprop.0+0x56>
   bfd02:	782c      	ldrb	r4, [r5, #0]
   bfd04:	f004 04df 	and.w	r4, r4, #223	; 0xdf
   bfd08:	2c58      	cmp	r4, #88	; 0x58
   bfd0a:	d14d      	bne.n	bfda8 <_strtol_l.constprop.0+0xec>
   bfd0c:	786c      	ldrb	r4, [r5, #1]
   bfd0e:	2310      	movs	r3, #16
   bfd10:	3502      	adds	r5, #2
   bfd12:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
   bfd16:	f108 38ff 	add.w	r8, r8, #4294967295
   bfd1a:	f04f 0c00 	mov.w	ip, #0
   bfd1e:	fbb8 f9f3 	udiv	r9, r8, r3
   bfd22:	4666      	mov	r6, ip
   bfd24:	fb03 8a19 	mls	sl, r3, r9, r8
   bfd28:	f1a4 0e30 	sub.w	lr, r4, #48	; 0x30
   bfd2c:	f1be 0f09 	cmp.w	lr, #9
   bfd30:	d816      	bhi.n	bfd60 <_strtol_l.constprop.0+0xa4>
   bfd32:	4674      	mov	r4, lr
   bfd34:	42a3      	cmp	r3, r4
   bfd36:	dd24      	ble.n	bfd82 <_strtol_l.constprop.0+0xc6>
   bfd38:	f1bc 0f00 	cmp.w	ip, #0
   bfd3c:	db1e      	blt.n	bfd7c <_strtol_l.constprop.0+0xc0>
   bfd3e:	45b1      	cmp	r9, r6
   bfd40:	d31c      	bcc.n	bfd7c <_strtol_l.constprop.0+0xc0>
   bfd42:	d101      	bne.n	bfd48 <_strtol_l.constprop.0+0x8c>
   bfd44:	45a2      	cmp	sl, r4
   bfd46:	db19      	blt.n	bfd7c <_strtol_l.constprop.0+0xc0>
   bfd48:	fb06 4603 	mla	r6, r6, r3, r4
   bfd4c:	f04f 0c01 	mov.w	ip, #1
   bfd50:	f815 4b01 	ldrb.w	r4, [r5], #1
   bfd54:	e7e8      	b.n	bfd28 <_strtol_l.constprop.0+0x6c>
   bfd56:	2c2b      	cmp	r4, #43	; 0x2b
   bfd58:	bf04      	itt	eq
   bfd5a:	782c      	ldrbeq	r4, [r5, #0]
   bfd5c:	1cb5      	addeq	r5, r6, #2
   bfd5e:	e7ca      	b.n	bfcf6 <_strtol_l.constprop.0+0x3a>
   bfd60:	f1a4 0e41 	sub.w	lr, r4, #65	; 0x41
   bfd64:	f1be 0f19 	cmp.w	lr, #25
   bfd68:	d801      	bhi.n	bfd6e <_strtol_l.constprop.0+0xb2>
   bfd6a:	3c37      	subs	r4, #55	; 0x37
   bfd6c:	e7e2      	b.n	bfd34 <_strtol_l.constprop.0+0x78>
   bfd6e:	f1a4 0e61 	sub.w	lr, r4, #97	; 0x61
   bfd72:	f1be 0f19 	cmp.w	lr, #25
   bfd76:	d804      	bhi.n	bfd82 <_strtol_l.constprop.0+0xc6>
   bfd78:	3c57      	subs	r4, #87	; 0x57
   bfd7a:	e7db      	b.n	bfd34 <_strtol_l.constprop.0+0x78>
   bfd7c:	f04f 3cff 	mov.w	ip, #4294967295
   bfd80:	e7e6      	b.n	bfd50 <_strtol_l.constprop.0+0x94>
   bfd82:	f1bc 0f00 	cmp.w	ip, #0
   bfd86:	da05      	bge.n	bfd94 <_strtol_l.constprop.0+0xd8>
   bfd88:	2322      	movs	r3, #34	; 0x22
   bfd8a:	6003      	str	r3, [r0, #0]
   bfd8c:	4646      	mov	r6, r8
   bfd8e:	b942      	cbnz	r2, bfda2 <_strtol_l.constprop.0+0xe6>
   bfd90:	4630      	mov	r0, r6
   bfd92:	e79e      	b.n	bfcd2 <_strtol_l.constprop.0+0x16>
   bfd94:	b107      	cbz	r7, bfd98 <_strtol_l.constprop.0+0xdc>
   bfd96:	4276      	negs	r6, r6
   bfd98:	2a00      	cmp	r2, #0
   bfd9a:	d0f9      	beq.n	bfd90 <_strtol_l.constprop.0+0xd4>
   bfd9c:	f1bc 0f00 	cmp.w	ip, #0
   bfda0:	d000      	beq.n	bfda4 <_strtol_l.constprop.0+0xe8>
   bfda2:	1e69      	subs	r1, r5, #1
   bfda4:	6011      	str	r1, [r2, #0]
   bfda6:	e7f3      	b.n	bfd90 <_strtol_l.constprop.0+0xd4>
   bfda8:	2430      	movs	r4, #48	; 0x30
   bfdaa:	2b00      	cmp	r3, #0
   bfdac:	d1b1      	bne.n	bfd12 <_strtol_l.constprop.0+0x56>
   bfdae:	2308      	movs	r3, #8
   bfdb0:	e7af      	b.n	bfd12 <_strtol_l.constprop.0+0x56>
   bfdb2:	2c30      	cmp	r4, #48	; 0x30
   bfdb4:	d0a5      	beq.n	bfd02 <_strtol_l.constprop.0+0x46>
   bfdb6:	230a      	movs	r3, #10
   bfdb8:	e7ab      	b.n	bfd12 <_strtol_l.constprop.0+0x56>
   bfdba:	bf00      	nop
   bfdbc:	000c2421 	.word	0x000c2421

000bfdc0 <strtol>:
   bfdc0:	4613      	mov	r3, r2
   bfdc2:	460a      	mov	r2, r1
   bfdc4:	4601      	mov	r1, r0
   bfdc6:	4802      	ldr	r0, [pc, #8]	; (bfdd0 <strtol+0x10>)
   bfdc8:	6800      	ldr	r0, [r0, #0]
   bfdca:	f7ff bf77 	b.w	bfcbc <_strtol_l.constprop.0>
   bfdce:	bf00      	nop
   bfdd0:	2003dab0 	.word	0x2003dab0

000bfdd4 <__register_exitproc>:
   bfdd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   bfdd8:	f8df 80b8 	ldr.w	r8, [pc, #184]	; bfe94 <__register_exitproc+0xc0>
   bfddc:	4606      	mov	r6, r0
   bfdde:	f8d8 0000 	ldr.w	r0, [r8]
   bfde2:	461f      	mov	r7, r3
   bfde4:	460d      	mov	r5, r1
   bfde6:	4691      	mov	r9, r2
   bfde8:	f000 fbc6 	bl	c0578 <__retarget_lock_acquire_recursive>
   bfdec:	4b25      	ldr	r3, [pc, #148]	; (bfe84 <__register_exitproc+0xb0>)
   bfdee:	681c      	ldr	r4, [r3, #0]
   bfdf0:	b934      	cbnz	r4, bfe00 <__register_exitproc+0x2c>
   bfdf2:	4c25      	ldr	r4, [pc, #148]	; (bfe88 <__register_exitproc+0xb4>)
   bfdf4:	601c      	str	r4, [r3, #0]
   bfdf6:	4b25      	ldr	r3, [pc, #148]	; (bfe8c <__register_exitproc+0xb8>)
   bfdf8:	b113      	cbz	r3, bfe00 <__register_exitproc+0x2c>
   bfdfa:	681b      	ldr	r3, [r3, #0]
   bfdfc:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
   bfe00:	6863      	ldr	r3, [r4, #4]
   bfe02:	2b1f      	cmp	r3, #31
   bfe04:	dd07      	ble.n	bfe16 <__register_exitproc+0x42>
   bfe06:	f8d8 0000 	ldr.w	r0, [r8]
   bfe0a:	f000 fbb7 	bl	c057c <__retarget_lock_release_recursive>
   bfe0e:	f04f 30ff 	mov.w	r0, #4294967295
   bfe12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   bfe16:	b34e      	cbz	r6, bfe6c <__register_exitproc+0x98>
   bfe18:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
   bfe1c:	b988      	cbnz	r0, bfe42 <__register_exitproc+0x6e>
   bfe1e:	4b1c      	ldr	r3, [pc, #112]	; (bfe90 <__register_exitproc+0xbc>)
   bfe20:	b923      	cbnz	r3, bfe2c <__register_exitproc+0x58>
   bfe22:	f8d8 0000 	ldr.w	r0, [r8]
   bfe26:	f000 fba8 	bl	c057a <__retarget_lock_release>
   bfe2a:	e7f0      	b.n	bfe0e <__register_exitproc+0x3a>
   bfe2c:	f44f 7084 	mov.w	r0, #264	; 0x108
   bfe30:	f7fa fadc 	bl	ba3ec <malloc>
   bfe34:	2800      	cmp	r0, #0
   bfe36:	d0f4      	beq.n	bfe22 <__register_exitproc+0x4e>
   bfe38:	2300      	movs	r3, #0
   bfe3a:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
   bfe3e:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
   bfe42:	6863      	ldr	r3, [r4, #4]
   bfe44:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
   bfe48:	2201      	movs	r2, #1
   bfe4a:	409a      	lsls	r2, r3
   bfe4c:	eb00 0183 	add.w	r1, r0, r3, lsl #2
   bfe50:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
   bfe54:	4313      	orrs	r3, r2
   bfe56:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
   bfe5a:	2e02      	cmp	r6, #2
   bfe5c:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
   bfe60:	bf02      	ittt	eq
   bfe62:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
   bfe66:	4313      	orreq	r3, r2
   bfe68:	f8c0 3104 	streq.w	r3, [r0, #260]	; 0x104
   bfe6c:	6863      	ldr	r3, [r4, #4]
   bfe6e:	f8d8 0000 	ldr.w	r0, [r8]
   bfe72:	1c5a      	adds	r2, r3, #1
   bfe74:	3302      	adds	r3, #2
   bfe76:	6062      	str	r2, [r4, #4]
   bfe78:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
   bfe7c:	f000 fb7e 	bl	c057c <__retarget_lock_release_recursive>
   bfe80:	2000      	movs	r0, #0
   bfe82:	e7c6      	b.n	bfe12 <__register_exitproc+0x3e>
   bfe84:	2003e7e8 	.word	0x2003e7e8
   bfe88:	2003e75c 	.word	0x2003e75c
   bfe8c:	00000000 	.word	0x00000000
   bfe90:	000ba3ed 	.word	0x000ba3ed
   bfe94:	2003db14 	.word	0x2003db14

000bfe98 <rshift>:
   bfe98:	6903      	ldr	r3, [r0, #16]
   bfe9a:	ebb3 1f61 	cmp.w	r3, r1, asr #5
   bfe9e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   bfea2:	ea4f 1261 	mov.w	r2, r1, asr #5
   bfea6:	f100 0414 	add.w	r4, r0, #20
   bfeaa:	dd45      	ble.n	bff38 <rshift+0xa0>
   bfeac:	f011 011f 	ands.w	r1, r1, #31
   bfeb0:	eb04 0683 	add.w	r6, r4, r3, lsl #2
   bfeb4:	eb04 0582 	add.w	r5, r4, r2, lsl #2
   bfeb8:	d10c      	bne.n	bfed4 <rshift+0x3c>
   bfeba:	f100 0710 	add.w	r7, r0, #16
   bfebe:	4629      	mov	r1, r5
   bfec0:	42b1      	cmp	r1, r6
   bfec2:	d334      	bcc.n	bff2e <rshift+0x96>
   bfec4:	1a9b      	subs	r3, r3, r2
   bfec6:	009b      	lsls	r3, r3, #2
   bfec8:	1eea      	subs	r2, r5, #3
   bfeca:	4296      	cmp	r6, r2
   bfecc:	bf38      	it	cc
   bfece:	2300      	movcc	r3, #0
   bfed0:	4423      	add	r3, r4
   bfed2:	e015      	b.n	bff00 <rshift+0x68>
   bfed4:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
   bfed8:	f1c1 0820 	rsb	r8, r1, #32
   bfedc:	40cf      	lsrs	r7, r1
   bfede:	f105 0e04 	add.w	lr, r5, #4
   bfee2:	46a1      	mov	r9, r4
   bfee4:	4576      	cmp	r6, lr
   bfee6:	46f4      	mov	ip, lr
   bfee8:	d815      	bhi.n	bff16 <rshift+0x7e>
   bfeea:	1a9a      	subs	r2, r3, r2
   bfeec:	0092      	lsls	r2, r2, #2
   bfeee:	3a04      	subs	r2, #4
   bfef0:	3501      	adds	r5, #1
   bfef2:	42ae      	cmp	r6, r5
   bfef4:	bf38      	it	cc
   bfef6:	2200      	movcc	r2, #0
   bfef8:	18a3      	adds	r3, r4, r2
   bfefa:	50a7      	str	r7, [r4, r2]
   bfefc:	b107      	cbz	r7, bff00 <rshift+0x68>
   bfefe:	3304      	adds	r3, #4
   bff00:	1b1a      	subs	r2, r3, r4
   bff02:	42a3      	cmp	r3, r4
   bff04:	ea4f 02a2 	mov.w	r2, r2, asr #2
   bff08:	bf08      	it	eq
   bff0a:	2300      	moveq	r3, #0
   bff0c:	6102      	str	r2, [r0, #16]
   bff0e:	bf08      	it	eq
   bff10:	6143      	streq	r3, [r0, #20]
   bff12:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   bff16:	f8dc c000 	ldr.w	ip, [ip]
   bff1a:	fa0c fc08 	lsl.w	ip, ip, r8
   bff1e:	ea4c 0707 	orr.w	r7, ip, r7
   bff22:	f849 7b04 	str.w	r7, [r9], #4
   bff26:	f85e 7b04 	ldr.w	r7, [lr], #4
   bff2a:	40cf      	lsrs	r7, r1
   bff2c:	e7da      	b.n	bfee4 <rshift+0x4c>
   bff2e:	f851 cb04 	ldr.w	ip, [r1], #4
   bff32:	f847 cf04 	str.w	ip, [r7, #4]!
   bff36:	e7c3      	b.n	bfec0 <rshift+0x28>
   bff38:	4623      	mov	r3, r4
   bff3a:	e7e1      	b.n	bff00 <rshift+0x68>

000bff3c <__hexdig_fun>:
   bff3c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   bff40:	2b09      	cmp	r3, #9
   bff42:	d802      	bhi.n	bff4a <__hexdig_fun+0xe>
   bff44:	3820      	subs	r0, #32
   bff46:	b2c0      	uxtb	r0, r0
   bff48:	4770      	bx	lr
   bff4a:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   bff4e:	2b05      	cmp	r3, #5
   bff50:	d801      	bhi.n	bff56 <__hexdig_fun+0x1a>
   bff52:	3847      	subs	r0, #71	; 0x47
   bff54:	e7f7      	b.n	bff46 <__hexdig_fun+0xa>
   bff56:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   bff5a:	2b05      	cmp	r3, #5
   bff5c:	d801      	bhi.n	bff62 <__hexdig_fun+0x26>
   bff5e:	3827      	subs	r0, #39	; 0x27
   bff60:	e7f1      	b.n	bff46 <__hexdig_fun+0xa>
   bff62:	2000      	movs	r0, #0
   bff64:	4770      	bx	lr
	...

000bff68 <__gethex>:
   bff68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   bff6c:	ed2d 8b02 	vpush	{d8}
   bff70:	b089      	sub	sp, #36	; 0x24
   bff72:	ee08 0a10 	vmov	s16, r0
   bff76:	9304      	str	r3, [sp, #16]
   bff78:	4bb4      	ldr	r3, [pc, #720]	; (c024c <__gethex+0x2e4>)
   bff7a:	681b      	ldr	r3, [r3, #0]
   bff7c:	9301      	str	r3, [sp, #4]
   bff7e:	4618      	mov	r0, r3
   bff80:	468b      	mov	fp, r1
   bff82:	4690      	mov	r8, r2
   bff84:	f7ff f82f 	bl	befe6 <strlen>
   bff88:	9b01      	ldr	r3, [sp, #4]
   bff8a:	f8db 2000 	ldr.w	r2, [fp]
   bff8e:	4403      	add	r3, r0
   bff90:	4682      	mov	sl, r0
   bff92:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   bff96:	9305      	str	r3, [sp, #20]
   bff98:	1c93      	adds	r3, r2, #2
   bff9a:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
   bff9e:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
   bffa2:	32fe      	adds	r2, #254	; 0xfe
   bffa4:	18d1      	adds	r1, r2, r3
   bffa6:	461f      	mov	r7, r3
   bffa8:	f813 0b01 	ldrb.w	r0, [r3], #1
   bffac:	9100      	str	r1, [sp, #0]
   bffae:	2830      	cmp	r0, #48	; 0x30
   bffb0:	d0f8      	beq.n	bffa4 <__gethex+0x3c>
   bffb2:	f7ff ffc3 	bl	bff3c <__hexdig_fun>
   bffb6:	4604      	mov	r4, r0
   bffb8:	2800      	cmp	r0, #0
   bffba:	d13a      	bne.n	c0032 <__gethex+0xca>
   bffbc:	9901      	ldr	r1, [sp, #4]
   bffbe:	4652      	mov	r2, sl
   bffc0:	4638      	mov	r0, r7
   bffc2:	f7ff f818 	bl	beff6 <strncmp>
   bffc6:	4605      	mov	r5, r0
   bffc8:	2800      	cmp	r0, #0
   bffca:	d168      	bne.n	c009e <__gethex+0x136>
   bffcc:	f817 000a 	ldrb.w	r0, [r7, sl]
   bffd0:	eb07 060a 	add.w	r6, r7, sl
   bffd4:	f7ff ffb2 	bl	bff3c <__hexdig_fun>
   bffd8:	2800      	cmp	r0, #0
   bffda:	d062      	beq.n	c00a2 <__gethex+0x13a>
   bffdc:	4633      	mov	r3, r6
   bffde:	7818      	ldrb	r0, [r3, #0]
   bffe0:	2830      	cmp	r0, #48	; 0x30
   bffe2:	461f      	mov	r7, r3
   bffe4:	f103 0301 	add.w	r3, r3, #1
   bffe8:	d0f9      	beq.n	bffde <__gethex+0x76>
   bffea:	f7ff ffa7 	bl	bff3c <__hexdig_fun>
   bffee:	2301      	movs	r3, #1
   bfff0:	fab0 f480 	clz	r4, r0
   bfff4:	0964      	lsrs	r4, r4, #5
   bfff6:	4635      	mov	r5, r6
   bfff8:	9300      	str	r3, [sp, #0]
   bfffa:	463a      	mov	r2, r7
   bfffc:	4616      	mov	r6, r2
   bfffe:	3201      	adds	r2, #1
   c0000:	7830      	ldrb	r0, [r6, #0]
   c0002:	f7ff ff9b 	bl	bff3c <__hexdig_fun>
   c0006:	2800      	cmp	r0, #0
   c0008:	d1f8      	bne.n	bfffc <__gethex+0x94>
   c000a:	9901      	ldr	r1, [sp, #4]
   c000c:	4652      	mov	r2, sl
   c000e:	4630      	mov	r0, r6
   c0010:	f7fe fff1 	bl	beff6 <strncmp>
   c0014:	b980      	cbnz	r0, c0038 <__gethex+0xd0>
   c0016:	b94d      	cbnz	r5, c002c <__gethex+0xc4>
   c0018:	eb06 050a 	add.w	r5, r6, sl
   c001c:	462a      	mov	r2, r5
   c001e:	4616      	mov	r6, r2
   c0020:	3201      	adds	r2, #1
   c0022:	7830      	ldrb	r0, [r6, #0]
   c0024:	f7ff ff8a 	bl	bff3c <__hexdig_fun>
   c0028:	2800      	cmp	r0, #0
   c002a:	d1f8      	bne.n	c001e <__gethex+0xb6>
   c002c:	1bad      	subs	r5, r5, r6
   c002e:	00ad      	lsls	r5, r5, #2
   c0030:	e004      	b.n	c003c <__gethex+0xd4>
   c0032:	2400      	movs	r4, #0
   c0034:	4625      	mov	r5, r4
   c0036:	e7e0      	b.n	bfffa <__gethex+0x92>
   c0038:	2d00      	cmp	r5, #0
   c003a:	d1f7      	bne.n	c002c <__gethex+0xc4>
   c003c:	7833      	ldrb	r3, [r6, #0]
   c003e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   c0042:	2b50      	cmp	r3, #80	; 0x50
   c0044:	d13b      	bne.n	c00be <__gethex+0x156>
   c0046:	7873      	ldrb	r3, [r6, #1]
   c0048:	2b2b      	cmp	r3, #43	; 0x2b
   c004a:	d02c      	beq.n	c00a6 <__gethex+0x13e>
   c004c:	2b2d      	cmp	r3, #45	; 0x2d
   c004e:	d02e      	beq.n	c00ae <__gethex+0x146>
   c0050:	1c71      	adds	r1, r6, #1
   c0052:	f04f 0900 	mov.w	r9, #0
   c0056:	7808      	ldrb	r0, [r1, #0]
   c0058:	f7ff ff70 	bl	bff3c <__hexdig_fun>
   c005c:	1e43      	subs	r3, r0, #1
   c005e:	b2db      	uxtb	r3, r3
   c0060:	2b18      	cmp	r3, #24
   c0062:	d82c      	bhi.n	c00be <__gethex+0x156>
   c0064:	f1a0 0210 	sub.w	r2, r0, #16
   c0068:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   c006c:	f7ff ff66 	bl	bff3c <__hexdig_fun>
   c0070:	1e43      	subs	r3, r0, #1
   c0072:	b2db      	uxtb	r3, r3
   c0074:	2b18      	cmp	r3, #24
   c0076:	d91d      	bls.n	c00b4 <__gethex+0x14c>
   c0078:	f1b9 0f00 	cmp.w	r9, #0
   c007c:	d000      	beq.n	c0080 <__gethex+0x118>
   c007e:	4252      	negs	r2, r2
   c0080:	4415      	add	r5, r2
   c0082:	f8cb 1000 	str.w	r1, [fp]
   c0086:	b1e4      	cbz	r4, c00c2 <__gethex+0x15a>
   c0088:	9b00      	ldr	r3, [sp, #0]
   c008a:	2b00      	cmp	r3, #0
   c008c:	bf14      	ite	ne
   c008e:	2700      	movne	r7, #0
   c0090:	2706      	moveq	r7, #6
   c0092:	4638      	mov	r0, r7
   c0094:	b009      	add	sp, #36	; 0x24
   c0096:	ecbd 8b02 	vpop	{d8}
   c009a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   c009e:	463e      	mov	r6, r7
   c00a0:	4625      	mov	r5, r4
   c00a2:	2401      	movs	r4, #1
   c00a4:	e7ca      	b.n	c003c <__gethex+0xd4>
   c00a6:	f04f 0900 	mov.w	r9, #0
   c00aa:	1cb1      	adds	r1, r6, #2
   c00ac:	e7d3      	b.n	c0056 <__gethex+0xee>
   c00ae:	f04f 0901 	mov.w	r9, #1
   c00b2:	e7fa      	b.n	c00aa <__gethex+0x142>
   c00b4:	230a      	movs	r3, #10
   c00b6:	fb03 0202 	mla	r2, r3, r2, r0
   c00ba:	3a10      	subs	r2, #16
   c00bc:	e7d4      	b.n	c0068 <__gethex+0x100>
   c00be:	4631      	mov	r1, r6
   c00c0:	e7df      	b.n	c0082 <__gethex+0x11a>
   c00c2:	1bf3      	subs	r3, r6, r7
   c00c4:	3b01      	subs	r3, #1
   c00c6:	4621      	mov	r1, r4
   c00c8:	2b07      	cmp	r3, #7
   c00ca:	dc0b      	bgt.n	c00e4 <__gethex+0x17c>
   c00cc:	ee18 0a10 	vmov	r0, s16
   c00d0:	f000 fa68 	bl	c05a4 <_Balloc>
   c00d4:	4604      	mov	r4, r0
   c00d6:	b940      	cbnz	r0, c00ea <__gethex+0x182>
   c00d8:	4b5d      	ldr	r3, [pc, #372]	; (c0250 <__gethex+0x2e8>)
   c00da:	4602      	mov	r2, r0
   c00dc:	21de      	movs	r1, #222	; 0xde
   c00de:	485d      	ldr	r0, [pc, #372]	; (c0254 <__gethex+0x2ec>)
   c00e0:	f7fa f9d4 	bl	ba48c <__assert_func>
   c00e4:	3101      	adds	r1, #1
   c00e6:	105b      	asrs	r3, r3, #1
   c00e8:	e7ee      	b.n	c00c8 <__gethex+0x160>
   c00ea:	f100 0914 	add.w	r9, r0, #20
   c00ee:	f04f 0b00 	mov.w	fp, #0
   c00f2:	f1ca 0301 	rsb	r3, sl, #1
   c00f6:	f8cd 9008 	str.w	r9, [sp, #8]
   c00fa:	f8cd b000 	str.w	fp, [sp]
   c00fe:	9306      	str	r3, [sp, #24]
   c0100:	42b7      	cmp	r7, r6
   c0102:	d340      	bcc.n	c0186 <__gethex+0x21e>
   c0104:	9802      	ldr	r0, [sp, #8]
   c0106:	9b00      	ldr	r3, [sp, #0]
   c0108:	f840 3b04 	str.w	r3, [r0], #4
   c010c:	eba0 0009 	sub.w	r0, r0, r9
   c0110:	1080      	asrs	r0, r0, #2
   c0112:	0146      	lsls	r6, r0, #5
   c0114:	6120      	str	r0, [r4, #16]
   c0116:	4618      	mov	r0, r3
   c0118:	f000 fb36 	bl	c0788 <__hi0bits>
   c011c:	1a30      	subs	r0, r6, r0
   c011e:	f8d8 6000 	ldr.w	r6, [r8]
   c0122:	42b0      	cmp	r0, r6
   c0124:	dd63      	ble.n	c01ee <__gethex+0x286>
   c0126:	1b87      	subs	r7, r0, r6
   c0128:	4639      	mov	r1, r7
   c012a:	4620      	mov	r0, r4
   c012c:	f000 feda 	bl	c0ee4 <__any_on>
   c0130:	4682      	mov	sl, r0
   c0132:	b1a8      	cbz	r0, c0160 <__gethex+0x1f8>
   c0134:	1e7b      	subs	r3, r7, #1
   c0136:	1159      	asrs	r1, r3, #5
   c0138:	f003 021f 	and.w	r2, r3, #31
   c013c:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
   c0140:	f04f 0a01 	mov.w	sl, #1
   c0144:	fa0a f202 	lsl.w	r2, sl, r2
   c0148:	420a      	tst	r2, r1
   c014a:	d009      	beq.n	c0160 <__gethex+0x1f8>
   c014c:	4553      	cmp	r3, sl
   c014e:	dd05      	ble.n	c015c <__gethex+0x1f4>
   c0150:	1eb9      	subs	r1, r7, #2
   c0152:	4620      	mov	r0, r4
   c0154:	f000 fec6 	bl	c0ee4 <__any_on>
   c0158:	2800      	cmp	r0, #0
   c015a:	d145      	bne.n	c01e8 <__gethex+0x280>
   c015c:	f04f 0a02 	mov.w	sl, #2
   c0160:	4639      	mov	r1, r7
   c0162:	4620      	mov	r0, r4
   c0164:	f7ff fe98 	bl	bfe98 <rshift>
   c0168:	443d      	add	r5, r7
   c016a:	f8d8 3008 	ldr.w	r3, [r8, #8]
   c016e:	42ab      	cmp	r3, r5
   c0170:	da4c      	bge.n	c020c <__gethex+0x2a4>
   c0172:	ee18 0a10 	vmov	r0, s16
   c0176:	4621      	mov	r1, r4
   c0178:	f000 fa54 	bl	c0624 <_Bfree>
   c017c:	9a14      	ldr	r2, [sp, #80]	; 0x50
   c017e:	2300      	movs	r3, #0
   c0180:	6013      	str	r3, [r2, #0]
   c0182:	27a3      	movs	r7, #163	; 0xa3
   c0184:	e785      	b.n	c0092 <__gethex+0x12a>
   c0186:	1e73      	subs	r3, r6, #1
   c0188:	9a05      	ldr	r2, [sp, #20]
   c018a:	9303      	str	r3, [sp, #12]
   c018c:	f816 3c01 	ldrb.w	r3, [r6, #-1]
   c0190:	4293      	cmp	r3, r2
   c0192:	d019      	beq.n	c01c8 <__gethex+0x260>
   c0194:	f1bb 0f20 	cmp.w	fp, #32
   c0198:	d107      	bne.n	c01aa <__gethex+0x242>
   c019a:	9b02      	ldr	r3, [sp, #8]
   c019c:	9a00      	ldr	r2, [sp, #0]
   c019e:	f843 2b04 	str.w	r2, [r3], #4
   c01a2:	9302      	str	r3, [sp, #8]
   c01a4:	2300      	movs	r3, #0
   c01a6:	9300      	str	r3, [sp, #0]
   c01a8:	469b      	mov	fp, r3
   c01aa:	f816 0c01 	ldrb.w	r0, [r6, #-1]
   c01ae:	f7ff fec5 	bl	bff3c <__hexdig_fun>
   c01b2:	9b00      	ldr	r3, [sp, #0]
   c01b4:	f000 000f 	and.w	r0, r0, #15
   c01b8:	fa00 f00b 	lsl.w	r0, r0, fp
   c01bc:	4303      	orrs	r3, r0
   c01be:	9300      	str	r3, [sp, #0]
   c01c0:	f10b 0b04 	add.w	fp, fp, #4
   c01c4:	9b03      	ldr	r3, [sp, #12]
   c01c6:	e00d      	b.n	c01e4 <__gethex+0x27c>
   c01c8:	9b03      	ldr	r3, [sp, #12]
   c01ca:	9a06      	ldr	r2, [sp, #24]
   c01cc:	4413      	add	r3, r2
   c01ce:	42bb      	cmp	r3, r7
   c01d0:	d3e0      	bcc.n	c0194 <__gethex+0x22c>
   c01d2:	4618      	mov	r0, r3
   c01d4:	9901      	ldr	r1, [sp, #4]
   c01d6:	9307      	str	r3, [sp, #28]
   c01d8:	4652      	mov	r2, sl
   c01da:	f7fe ff0c 	bl	beff6 <strncmp>
   c01de:	9b07      	ldr	r3, [sp, #28]
   c01e0:	2800      	cmp	r0, #0
   c01e2:	d1d7      	bne.n	c0194 <__gethex+0x22c>
   c01e4:	461e      	mov	r6, r3
   c01e6:	e78b      	b.n	c0100 <__gethex+0x198>
   c01e8:	f04f 0a03 	mov.w	sl, #3
   c01ec:	e7b8      	b.n	c0160 <__gethex+0x1f8>
   c01ee:	da0a      	bge.n	c0206 <__gethex+0x29e>
   c01f0:	1a37      	subs	r7, r6, r0
   c01f2:	4621      	mov	r1, r4
   c01f4:	ee18 0a10 	vmov	r0, s16
   c01f8:	463a      	mov	r2, r7
   c01fa:	f000 fc2f 	bl	c0a5c <__lshift>
   c01fe:	1bed      	subs	r5, r5, r7
   c0200:	4604      	mov	r4, r0
   c0202:	f100 0914 	add.w	r9, r0, #20
   c0206:	f04f 0a00 	mov.w	sl, #0
   c020a:	e7ae      	b.n	c016a <__gethex+0x202>
   c020c:	f8d8 0004 	ldr.w	r0, [r8, #4]
   c0210:	42a8      	cmp	r0, r5
   c0212:	dd72      	ble.n	c02fa <__gethex+0x392>
   c0214:	1b45      	subs	r5, r0, r5
   c0216:	42ae      	cmp	r6, r5
   c0218:	dc36      	bgt.n	c0288 <__gethex+0x320>
   c021a:	f8d8 300c 	ldr.w	r3, [r8, #12]
   c021e:	2b02      	cmp	r3, #2
   c0220:	d02a      	beq.n	c0278 <__gethex+0x310>
   c0222:	2b03      	cmp	r3, #3
   c0224:	d02c      	beq.n	c0280 <__gethex+0x318>
   c0226:	2b01      	cmp	r3, #1
   c0228:	d11c      	bne.n	c0264 <__gethex+0x2fc>
   c022a:	42ae      	cmp	r6, r5
   c022c:	d11a      	bne.n	c0264 <__gethex+0x2fc>
   c022e:	2e01      	cmp	r6, #1
   c0230:	d112      	bne.n	c0258 <__gethex+0x2f0>
   c0232:	9a04      	ldr	r2, [sp, #16]
   c0234:	f8d8 3004 	ldr.w	r3, [r8, #4]
   c0238:	6013      	str	r3, [r2, #0]
   c023a:	2301      	movs	r3, #1
   c023c:	6123      	str	r3, [r4, #16]
   c023e:	f8c9 3000 	str.w	r3, [r9]
   c0242:	9b14      	ldr	r3, [sp, #80]	; 0x50
   c0244:	2762      	movs	r7, #98	; 0x62
   c0246:	601c      	str	r4, [r3, #0]
   c0248:	e723      	b.n	c0092 <__gethex+0x12a>
   c024a:	bf00      	nop
   c024c:	000c25b8 	.word	0x000c25b8
   c0250:	000c2521 	.word	0x000c2521
   c0254:	000c2532 	.word	0x000c2532
   c0258:	1e71      	subs	r1, r6, #1
   c025a:	4620      	mov	r0, r4
   c025c:	f000 fe42 	bl	c0ee4 <__any_on>
   c0260:	2800      	cmp	r0, #0
   c0262:	d1e6      	bne.n	c0232 <__gethex+0x2ca>
   c0264:	ee18 0a10 	vmov	r0, s16
   c0268:	4621      	mov	r1, r4
   c026a:	f000 f9db 	bl	c0624 <_Bfree>
   c026e:	9a14      	ldr	r2, [sp, #80]	; 0x50
   c0270:	2300      	movs	r3, #0
   c0272:	6013      	str	r3, [r2, #0]
   c0274:	2750      	movs	r7, #80	; 0x50
   c0276:	e70c      	b.n	c0092 <__gethex+0x12a>
   c0278:	9b15      	ldr	r3, [sp, #84]	; 0x54
   c027a:	2b00      	cmp	r3, #0
   c027c:	d1f2      	bne.n	c0264 <__gethex+0x2fc>
   c027e:	e7d8      	b.n	c0232 <__gethex+0x2ca>
   c0280:	9b15      	ldr	r3, [sp, #84]	; 0x54
   c0282:	2b00      	cmp	r3, #0
   c0284:	d1d5      	bne.n	c0232 <__gethex+0x2ca>
   c0286:	e7ed      	b.n	c0264 <__gethex+0x2fc>
   c0288:	1e6f      	subs	r7, r5, #1
   c028a:	f1ba 0f00 	cmp.w	sl, #0
   c028e:	d131      	bne.n	c02f4 <__gethex+0x38c>
   c0290:	b127      	cbz	r7, c029c <__gethex+0x334>
   c0292:	4639      	mov	r1, r7
   c0294:	4620      	mov	r0, r4
   c0296:	f000 fe25 	bl	c0ee4 <__any_on>
   c029a:	4682      	mov	sl, r0
   c029c:	117b      	asrs	r3, r7, #5
   c029e:	2101      	movs	r1, #1
   c02a0:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
   c02a4:	f007 071f 	and.w	r7, r7, #31
   c02a8:	fa01 f707 	lsl.w	r7, r1, r7
   c02ac:	421f      	tst	r7, r3
   c02ae:	4629      	mov	r1, r5
   c02b0:	4620      	mov	r0, r4
   c02b2:	bf18      	it	ne
   c02b4:	f04a 0a02 	orrne.w	sl, sl, #2
   c02b8:	1b76      	subs	r6, r6, r5
   c02ba:	f7ff fded 	bl	bfe98 <rshift>
   c02be:	f8d8 5004 	ldr.w	r5, [r8, #4]
   c02c2:	2702      	movs	r7, #2
   c02c4:	f1ba 0f00 	cmp.w	sl, #0
   c02c8:	d048      	beq.n	c035c <__gethex+0x3f4>
   c02ca:	f8d8 300c 	ldr.w	r3, [r8, #12]
   c02ce:	2b02      	cmp	r3, #2
   c02d0:	d015      	beq.n	c02fe <__gethex+0x396>
   c02d2:	2b03      	cmp	r3, #3
   c02d4:	d017      	beq.n	c0306 <__gethex+0x39e>
   c02d6:	2b01      	cmp	r3, #1
   c02d8:	d109      	bne.n	c02ee <__gethex+0x386>
   c02da:	f01a 0f02 	tst.w	sl, #2
   c02de:	d006      	beq.n	c02ee <__gethex+0x386>
   c02e0:	f8d9 0000 	ldr.w	r0, [r9]
   c02e4:	ea4a 0a00 	orr.w	sl, sl, r0
   c02e8:	f01a 0f01 	tst.w	sl, #1
   c02ec:	d10e      	bne.n	c030c <__gethex+0x3a4>
   c02ee:	f047 0710 	orr.w	r7, r7, #16
   c02f2:	e033      	b.n	c035c <__gethex+0x3f4>
   c02f4:	f04f 0a01 	mov.w	sl, #1
   c02f8:	e7d0      	b.n	c029c <__gethex+0x334>
   c02fa:	2701      	movs	r7, #1
   c02fc:	e7e2      	b.n	c02c4 <__gethex+0x35c>
   c02fe:	9b15      	ldr	r3, [sp, #84]	; 0x54
   c0300:	f1c3 0301 	rsb	r3, r3, #1
   c0304:	9315      	str	r3, [sp, #84]	; 0x54
   c0306:	9b15      	ldr	r3, [sp, #84]	; 0x54
   c0308:	2b00      	cmp	r3, #0
   c030a:	d0f0      	beq.n	c02ee <__gethex+0x386>
   c030c:	f8d4 b010 	ldr.w	fp, [r4, #16]
   c0310:	f104 0314 	add.w	r3, r4, #20
   c0314:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
   c0318:	eb03 018b 	add.w	r1, r3, fp, lsl #2
   c031c:	f04f 0c00 	mov.w	ip, #0
   c0320:	4618      	mov	r0, r3
   c0322:	f853 2b04 	ldr.w	r2, [r3], #4
   c0326:	f1b2 3fff 	cmp.w	r2, #4294967295
   c032a:	d01c      	beq.n	c0366 <__gethex+0x3fe>
   c032c:	3201      	adds	r2, #1
   c032e:	6002      	str	r2, [r0, #0]
   c0330:	2f02      	cmp	r7, #2
   c0332:	f104 0314 	add.w	r3, r4, #20
   c0336:	d13f      	bne.n	c03b8 <__gethex+0x450>
   c0338:	f8d8 2000 	ldr.w	r2, [r8]
   c033c:	3a01      	subs	r2, #1
   c033e:	42b2      	cmp	r2, r6
   c0340:	d10a      	bne.n	c0358 <__gethex+0x3f0>
   c0342:	1171      	asrs	r1, r6, #5
   c0344:	2201      	movs	r2, #1
   c0346:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
   c034a:	f006 061f 	and.w	r6, r6, #31
   c034e:	fa02 f606 	lsl.w	r6, r2, r6
   c0352:	421e      	tst	r6, r3
   c0354:	bf18      	it	ne
   c0356:	4617      	movne	r7, r2
   c0358:	f047 0720 	orr.w	r7, r7, #32
   c035c:	9b14      	ldr	r3, [sp, #80]	; 0x50
   c035e:	601c      	str	r4, [r3, #0]
   c0360:	9b04      	ldr	r3, [sp, #16]
   c0362:	601d      	str	r5, [r3, #0]
   c0364:	e695      	b.n	c0092 <__gethex+0x12a>
   c0366:	4299      	cmp	r1, r3
   c0368:	f843 cc04 	str.w	ip, [r3, #-4]
   c036c:	d8d8      	bhi.n	c0320 <__gethex+0x3b8>
   c036e:	68a3      	ldr	r3, [r4, #8]
   c0370:	459b      	cmp	fp, r3
   c0372:	db19      	blt.n	c03a8 <__gethex+0x440>
   c0374:	6861      	ldr	r1, [r4, #4]
   c0376:	ee18 0a10 	vmov	r0, s16
   c037a:	3101      	adds	r1, #1
   c037c:	f000 f912 	bl	c05a4 <_Balloc>
   c0380:	4681      	mov	r9, r0
   c0382:	b918      	cbnz	r0, c038c <__gethex+0x424>
   c0384:	4b1a      	ldr	r3, [pc, #104]	; (c03f0 <__gethex+0x488>)
   c0386:	4602      	mov	r2, r0
   c0388:	2184      	movs	r1, #132	; 0x84
   c038a:	e6a8      	b.n	c00de <__gethex+0x176>
   c038c:	6922      	ldr	r2, [r4, #16]
   c038e:	3202      	adds	r2, #2
   c0390:	f104 010c 	add.w	r1, r4, #12
   c0394:	0092      	lsls	r2, r2, #2
   c0396:	300c      	adds	r0, #12
   c0398:	f7fe fd87 	bl	beeaa <memcpy>
   c039c:	4621      	mov	r1, r4
   c039e:	ee18 0a10 	vmov	r0, s16
   c03a2:	f000 f93f 	bl	c0624 <_Bfree>
   c03a6:	464c      	mov	r4, r9
   c03a8:	6923      	ldr	r3, [r4, #16]
   c03aa:	1c5a      	adds	r2, r3, #1
   c03ac:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   c03b0:	6122      	str	r2, [r4, #16]
   c03b2:	2201      	movs	r2, #1
   c03b4:	615a      	str	r2, [r3, #20]
   c03b6:	e7bb      	b.n	c0330 <__gethex+0x3c8>
   c03b8:	6922      	ldr	r2, [r4, #16]
   c03ba:	455a      	cmp	r2, fp
   c03bc:	dd0b      	ble.n	c03d6 <__gethex+0x46e>
   c03be:	2101      	movs	r1, #1
   c03c0:	4620      	mov	r0, r4
   c03c2:	f7ff fd69 	bl	bfe98 <rshift>
   c03c6:	f8d8 3008 	ldr.w	r3, [r8, #8]
   c03ca:	3501      	adds	r5, #1
   c03cc:	42ab      	cmp	r3, r5
   c03ce:	f6ff aed0 	blt.w	c0172 <__gethex+0x20a>
   c03d2:	2701      	movs	r7, #1
   c03d4:	e7c0      	b.n	c0358 <__gethex+0x3f0>
   c03d6:	f016 061f 	ands.w	r6, r6, #31
   c03da:	d0fa      	beq.n	c03d2 <__gethex+0x46a>
   c03dc:	4453      	add	r3, sl
   c03de:	f1c6 0620 	rsb	r6, r6, #32
   c03e2:	f853 0c04 	ldr.w	r0, [r3, #-4]
   c03e6:	f000 f9cf 	bl	c0788 <__hi0bits>
   c03ea:	42b0      	cmp	r0, r6
   c03ec:	dbe7      	blt.n	c03be <__gethex+0x456>
   c03ee:	e7f0      	b.n	c03d2 <__gethex+0x46a>
   c03f0:	000c2521 	.word	0x000c2521

000c03f4 <L_shift>:
   c03f4:	f1c2 0208 	rsb	r2, r2, #8
   c03f8:	0092      	lsls	r2, r2, #2
   c03fa:	b570      	push	{r4, r5, r6, lr}
   c03fc:	f1c2 0620 	rsb	r6, r2, #32
   c0400:	6843      	ldr	r3, [r0, #4]
   c0402:	6804      	ldr	r4, [r0, #0]
   c0404:	fa03 f506 	lsl.w	r5, r3, r6
   c0408:	432c      	orrs	r4, r5
   c040a:	40d3      	lsrs	r3, r2
   c040c:	6004      	str	r4, [r0, #0]
   c040e:	f840 3f04 	str.w	r3, [r0, #4]!
   c0412:	4288      	cmp	r0, r1
   c0414:	d3f4      	bcc.n	c0400 <L_shift+0xc>
   c0416:	bd70      	pop	{r4, r5, r6, pc}

000c0418 <__match>:
   c0418:	b530      	push	{r4, r5, lr}
   c041a:	6803      	ldr	r3, [r0, #0]
   c041c:	3301      	adds	r3, #1
   c041e:	f811 4b01 	ldrb.w	r4, [r1], #1
   c0422:	b914      	cbnz	r4, c042a <__match+0x12>
   c0424:	6003      	str	r3, [r0, #0]
   c0426:	2001      	movs	r0, #1
   c0428:	bd30      	pop	{r4, r5, pc}
   c042a:	f813 2b01 	ldrb.w	r2, [r3], #1
   c042e:	f1a2 0541 	sub.w	r5, r2, #65	; 0x41
   c0432:	2d19      	cmp	r5, #25
   c0434:	bf98      	it	ls
   c0436:	3220      	addls	r2, #32
   c0438:	42a2      	cmp	r2, r4
   c043a:	d0f0      	beq.n	c041e <__match+0x6>
   c043c:	2000      	movs	r0, #0
   c043e:	e7f3      	b.n	c0428 <__match+0x10>

000c0440 <__hexnan>:
   c0440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   c0444:	680b      	ldr	r3, [r1, #0]
   c0446:	115e      	asrs	r6, r3, #5
   c0448:	eb02 0686 	add.w	r6, r2, r6, lsl #2
   c044c:	f013 031f 	ands.w	r3, r3, #31
   c0450:	b087      	sub	sp, #28
   c0452:	bf18      	it	ne
   c0454:	3604      	addne	r6, #4
   c0456:	2500      	movs	r5, #0
   c0458:	1f37      	subs	r7, r6, #4
   c045a:	4690      	mov	r8, r2
   c045c:	6802      	ldr	r2, [r0, #0]
   c045e:	9301      	str	r3, [sp, #4]
   c0460:	4682      	mov	sl, r0
   c0462:	f846 5c04 	str.w	r5, [r6, #-4]
   c0466:	46b9      	mov	r9, r7
   c0468:	463c      	mov	r4, r7
   c046a:	9502      	str	r5, [sp, #8]
   c046c:	46ab      	mov	fp, r5
   c046e:	7851      	ldrb	r1, [r2, #1]
   c0470:	1c53      	adds	r3, r2, #1
   c0472:	9303      	str	r3, [sp, #12]
   c0474:	b341      	cbz	r1, c04c8 <__hexnan+0x88>
   c0476:	4608      	mov	r0, r1
   c0478:	9205      	str	r2, [sp, #20]
   c047a:	9104      	str	r1, [sp, #16]
   c047c:	f7ff fd5e 	bl	bff3c <__hexdig_fun>
   c0480:	2800      	cmp	r0, #0
   c0482:	d14f      	bne.n	c0524 <__hexnan+0xe4>
   c0484:	9904      	ldr	r1, [sp, #16]
   c0486:	9a05      	ldr	r2, [sp, #20]
   c0488:	2920      	cmp	r1, #32
   c048a:	d818      	bhi.n	c04be <__hexnan+0x7e>
   c048c:	9b02      	ldr	r3, [sp, #8]
   c048e:	459b      	cmp	fp, r3
   c0490:	dd13      	ble.n	c04ba <__hexnan+0x7a>
   c0492:	454c      	cmp	r4, r9
   c0494:	d206      	bcs.n	c04a4 <__hexnan+0x64>
   c0496:	2d07      	cmp	r5, #7
   c0498:	dc04      	bgt.n	c04a4 <__hexnan+0x64>
   c049a:	462a      	mov	r2, r5
   c049c:	4649      	mov	r1, r9
   c049e:	4620      	mov	r0, r4
   c04a0:	f7ff ffa8 	bl	c03f4 <L_shift>
   c04a4:	4544      	cmp	r4, r8
   c04a6:	d950      	bls.n	c054a <__hexnan+0x10a>
   c04a8:	2300      	movs	r3, #0
   c04aa:	f1a4 0904 	sub.w	r9, r4, #4
   c04ae:	f844 3c04 	str.w	r3, [r4, #-4]
   c04b2:	f8cd b008 	str.w	fp, [sp, #8]
   c04b6:	464c      	mov	r4, r9
   c04b8:	461d      	mov	r5, r3
   c04ba:	9a03      	ldr	r2, [sp, #12]
   c04bc:	e7d7      	b.n	c046e <__hexnan+0x2e>
   c04be:	2929      	cmp	r1, #41	; 0x29
   c04c0:	d156      	bne.n	c0570 <__hexnan+0x130>
   c04c2:	3202      	adds	r2, #2
   c04c4:	f8ca 2000 	str.w	r2, [sl]
   c04c8:	f1bb 0f00 	cmp.w	fp, #0
   c04cc:	d050      	beq.n	c0570 <__hexnan+0x130>
   c04ce:	454c      	cmp	r4, r9
   c04d0:	d206      	bcs.n	c04e0 <__hexnan+0xa0>
   c04d2:	2d07      	cmp	r5, #7
   c04d4:	dc04      	bgt.n	c04e0 <__hexnan+0xa0>
   c04d6:	462a      	mov	r2, r5
   c04d8:	4649      	mov	r1, r9
   c04da:	4620      	mov	r0, r4
   c04dc:	f7ff ff8a 	bl	c03f4 <L_shift>
   c04e0:	4544      	cmp	r4, r8
   c04e2:	d934      	bls.n	c054e <__hexnan+0x10e>
   c04e4:	f1a8 0204 	sub.w	r2, r8, #4
   c04e8:	4623      	mov	r3, r4
   c04ea:	f853 1b04 	ldr.w	r1, [r3], #4
   c04ee:	f842 1f04 	str.w	r1, [r2, #4]!
   c04f2:	429f      	cmp	r7, r3
   c04f4:	d2f9      	bcs.n	c04ea <__hexnan+0xaa>
   c04f6:	1b3b      	subs	r3, r7, r4
   c04f8:	f023 0303 	bic.w	r3, r3, #3
   c04fc:	3304      	adds	r3, #4
   c04fe:	3401      	adds	r4, #1
   c0500:	3e03      	subs	r6, #3
   c0502:	42b4      	cmp	r4, r6
   c0504:	bf88      	it	hi
   c0506:	2304      	movhi	r3, #4
   c0508:	4443      	add	r3, r8
   c050a:	2200      	movs	r2, #0
   c050c:	f843 2b04 	str.w	r2, [r3], #4
   c0510:	429f      	cmp	r7, r3
   c0512:	d2fb      	bcs.n	c050c <__hexnan+0xcc>
   c0514:	683b      	ldr	r3, [r7, #0]
   c0516:	b91b      	cbnz	r3, c0520 <__hexnan+0xe0>
   c0518:	4547      	cmp	r7, r8
   c051a:	d127      	bne.n	c056c <__hexnan+0x12c>
   c051c:	2301      	movs	r3, #1
   c051e:	603b      	str	r3, [r7, #0]
   c0520:	2005      	movs	r0, #5
   c0522:	e026      	b.n	c0572 <__hexnan+0x132>
   c0524:	3501      	adds	r5, #1
   c0526:	2d08      	cmp	r5, #8
   c0528:	f10b 0b01 	add.w	fp, fp, #1
   c052c:	dd06      	ble.n	c053c <__hexnan+0xfc>
   c052e:	4544      	cmp	r4, r8
   c0530:	d9c3      	bls.n	c04ba <__hexnan+0x7a>
   c0532:	2300      	movs	r3, #0
   c0534:	f844 3c04 	str.w	r3, [r4, #-4]
   c0538:	2501      	movs	r5, #1
   c053a:	3c04      	subs	r4, #4
   c053c:	6822      	ldr	r2, [r4, #0]
   c053e:	f000 000f 	and.w	r0, r0, #15
   c0542:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
   c0546:	6022      	str	r2, [r4, #0]
   c0548:	e7b7      	b.n	c04ba <__hexnan+0x7a>
   c054a:	2508      	movs	r5, #8
   c054c:	e7b5      	b.n	c04ba <__hexnan+0x7a>
   c054e:	9b01      	ldr	r3, [sp, #4]
   c0550:	2b00      	cmp	r3, #0
   c0552:	d0df      	beq.n	c0514 <__hexnan+0xd4>
   c0554:	f04f 32ff 	mov.w	r2, #4294967295
   c0558:	f1c3 0320 	rsb	r3, r3, #32
   c055c:	fa22 f303 	lsr.w	r3, r2, r3
   c0560:	f856 2c04 	ldr.w	r2, [r6, #-4]
   c0564:	401a      	ands	r2, r3
   c0566:	f846 2c04 	str.w	r2, [r6, #-4]
   c056a:	e7d3      	b.n	c0514 <__hexnan+0xd4>
   c056c:	3f04      	subs	r7, #4
   c056e:	e7d1      	b.n	c0514 <__hexnan+0xd4>
   c0570:	2004      	movs	r0, #4
   c0572:	b007      	add	sp, #28
   c0574:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000c0578 <__retarget_lock_acquire_recursive>:
   c0578:	4770      	bx	lr

000c057a <__retarget_lock_release>:
   c057a:	4770      	bx	lr

000c057c <__retarget_lock_release_recursive>:
   c057c:	4770      	bx	lr

000c057e <__ascii_mbtowc>:
   c057e:	b082      	sub	sp, #8
   c0580:	b901      	cbnz	r1, c0584 <__ascii_mbtowc+0x6>
   c0582:	a901      	add	r1, sp, #4
   c0584:	b142      	cbz	r2, c0598 <__ascii_mbtowc+0x1a>
   c0586:	b14b      	cbz	r3, c059c <__ascii_mbtowc+0x1e>
   c0588:	7813      	ldrb	r3, [r2, #0]
   c058a:	600b      	str	r3, [r1, #0]
   c058c:	7812      	ldrb	r2, [r2, #0]
   c058e:	1e10      	subs	r0, r2, #0
   c0590:	bf18      	it	ne
   c0592:	2001      	movne	r0, #1
   c0594:	b002      	add	sp, #8
   c0596:	4770      	bx	lr
   c0598:	4610      	mov	r0, r2
   c059a:	e7fb      	b.n	c0594 <__ascii_mbtowc+0x16>
   c059c:	f06f 0001 	mvn.w	r0, #1
   c05a0:	e7f8      	b.n	c0594 <__ascii_mbtowc+0x16>
	...

000c05a4 <_Balloc>:
   c05a4:	b570      	push	{r4, r5, r6, lr}
   c05a6:	6a46      	ldr	r6, [r0, #36]	; 0x24
   c05a8:	4604      	mov	r4, r0
   c05aa:	460d      	mov	r5, r1
   c05ac:	b976      	cbnz	r6, c05cc <_Balloc+0x28>
   c05ae:	2010      	movs	r0, #16
   c05b0:	f7f9 ff1c 	bl	ba3ec <malloc>
   c05b4:	4602      	mov	r2, r0
   c05b6:	6260      	str	r0, [r4, #36]	; 0x24
   c05b8:	b920      	cbnz	r0, c05c4 <_Balloc+0x20>
   c05ba:	4b18      	ldr	r3, [pc, #96]	; (c061c <_Balloc+0x78>)
   c05bc:	4818      	ldr	r0, [pc, #96]	; (c0620 <_Balloc+0x7c>)
   c05be:	2166      	movs	r1, #102	; 0x66
   c05c0:	f7f9 ff64 	bl	ba48c <__assert_func>
   c05c4:	e9c0 6601 	strd	r6, r6, [r0, #4]
   c05c8:	6006      	str	r6, [r0, #0]
   c05ca:	60c6      	str	r6, [r0, #12]
   c05cc:	6a66      	ldr	r6, [r4, #36]	; 0x24
   c05ce:	68f3      	ldr	r3, [r6, #12]
   c05d0:	b183      	cbz	r3, c05f4 <_Balloc+0x50>
   c05d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   c05d4:	68db      	ldr	r3, [r3, #12]
   c05d6:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
   c05da:	b9b8      	cbnz	r0, c060c <_Balloc+0x68>
   c05dc:	2101      	movs	r1, #1
   c05de:	fa01 f605 	lsl.w	r6, r1, r5
   c05e2:	1d72      	adds	r2, r6, #5
   c05e4:	0092      	lsls	r2, r2, #2
   c05e6:	4620      	mov	r0, r4
   c05e8:	f000 fc9d 	bl	c0f26 <_calloc_r>
   c05ec:	b160      	cbz	r0, c0608 <_Balloc+0x64>
   c05ee:	e9c0 5601 	strd	r5, r6, [r0, #4]
   c05f2:	e00e      	b.n	c0612 <_Balloc+0x6e>
   c05f4:	2221      	movs	r2, #33	; 0x21
   c05f6:	2104      	movs	r1, #4
   c05f8:	4620      	mov	r0, r4
   c05fa:	f000 fc94 	bl	c0f26 <_calloc_r>
   c05fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
   c0600:	60f0      	str	r0, [r6, #12]
   c0602:	68db      	ldr	r3, [r3, #12]
   c0604:	2b00      	cmp	r3, #0
   c0606:	d1e4      	bne.n	c05d2 <_Balloc+0x2e>
   c0608:	2000      	movs	r0, #0
   c060a:	bd70      	pop	{r4, r5, r6, pc}
   c060c:	6802      	ldr	r2, [r0, #0]
   c060e:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
   c0612:	2300      	movs	r3, #0
   c0614:	e9c0 3303 	strd	r3, r3, [r0, #12]
   c0618:	e7f7      	b.n	c060a <_Balloc+0x66>
   c061a:	bf00      	nop
   c061c:	000c2329 	.word	0x000c2329
   c0620:	000c25cc 	.word	0x000c25cc

000c0624 <_Bfree>:
   c0624:	b570      	push	{r4, r5, r6, lr}
   c0626:	6a46      	ldr	r6, [r0, #36]	; 0x24
   c0628:	4605      	mov	r5, r0
   c062a:	460c      	mov	r4, r1
   c062c:	b976      	cbnz	r6, c064c <_Bfree+0x28>
   c062e:	2010      	movs	r0, #16
   c0630:	f7f9 fedc 	bl	ba3ec <malloc>
   c0634:	4602      	mov	r2, r0
   c0636:	6268      	str	r0, [r5, #36]	; 0x24
   c0638:	b920      	cbnz	r0, c0644 <_Bfree+0x20>
   c063a:	4b09      	ldr	r3, [pc, #36]	; (c0660 <_Bfree+0x3c>)
   c063c:	4809      	ldr	r0, [pc, #36]	; (c0664 <_Bfree+0x40>)
   c063e:	218a      	movs	r1, #138	; 0x8a
   c0640:	f7f9 ff24 	bl	ba48c <__assert_func>
   c0644:	e9c0 6601 	strd	r6, r6, [r0, #4]
   c0648:	6006      	str	r6, [r0, #0]
   c064a:	60c6      	str	r6, [r0, #12]
   c064c:	b13c      	cbz	r4, c065e <_Bfree+0x3a>
   c064e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   c0650:	6862      	ldr	r2, [r4, #4]
   c0652:	68db      	ldr	r3, [r3, #12]
   c0654:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   c0658:	6021      	str	r1, [r4, #0]
   c065a:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
   c065e:	bd70      	pop	{r4, r5, r6, pc}
   c0660:	000c2329 	.word	0x000c2329
   c0664:	000c25cc 	.word	0x000c25cc

000c0668 <__multadd>:
   c0668:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   c066c:	690d      	ldr	r5, [r1, #16]
   c066e:	4607      	mov	r7, r0
   c0670:	460c      	mov	r4, r1
   c0672:	461e      	mov	r6, r3
   c0674:	f101 0c14 	add.w	ip, r1, #20
   c0678:	2000      	movs	r0, #0
   c067a:	f8dc 3000 	ldr.w	r3, [ip]
   c067e:	b299      	uxth	r1, r3
   c0680:	fb02 6101 	mla	r1, r2, r1, r6
   c0684:	0c1e      	lsrs	r6, r3, #16
   c0686:	0c0b      	lsrs	r3, r1, #16
   c0688:	fb02 3306 	mla	r3, r2, r6, r3
   c068c:	b289      	uxth	r1, r1
   c068e:	3001      	adds	r0, #1
   c0690:	eb01 4103 	add.w	r1, r1, r3, lsl #16
   c0694:	4285      	cmp	r5, r0
   c0696:	f84c 1b04 	str.w	r1, [ip], #4
   c069a:	ea4f 4613 	mov.w	r6, r3, lsr #16
   c069e:	dcec      	bgt.n	c067a <__multadd+0x12>
   c06a0:	b30e      	cbz	r6, c06e6 <__multadd+0x7e>
   c06a2:	68a3      	ldr	r3, [r4, #8]
   c06a4:	42ab      	cmp	r3, r5
   c06a6:	dc19      	bgt.n	c06dc <__multadd+0x74>
   c06a8:	6861      	ldr	r1, [r4, #4]
   c06aa:	4638      	mov	r0, r7
   c06ac:	3101      	adds	r1, #1
   c06ae:	f7ff ff79 	bl	c05a4 <_Balloc>
   c06b2:	4680      	mov	r8, r0
   c06b4:	b928      	cbnz	r0, c06c2 <__multadd+0x5a>
   c06b6:	4602      	mov	r2, r0
   c06b8:	4b0c      	ldr	r3, [pc, #48]	; (c06ec <__multadd+0x84>)
   c06ba:	480d      	ldr	r0, [pc, #52]	; (c06f0 <__multadd+0x88>)
   c06bc:	21b5      	movs	r1, #181	; 0xb5
   c06be:	f7f9 fee5 	bl	ba48c <__assert_func>
   c06c2:	6922      	ldr	r2, [r4, #16]
   c06c4:	3202      	adds	r2, #2
   c06c6:	f104 010c 	add.w	r1, r4, #12
   c06ca:	0092      	lsls	r2, r2, #2
   c06cc:	300c      	adds	r0, #12
   c06ce:	f7fe fbec 	bl	beeaa <memcpy>
   c06d2:	4621      	mov	r1, r4
   c06d4:	4638      	mov	r0, r7
   c06d6:	f7ff ffa5 	bl	c0624 <_Bfree>
   c06da:	4644      	mov	r4, r8
   c06dc:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   c06e0:	3501      	adds	r5, #1
   c06e2:	615e      	str	r6, [r3, #20]
   c06e4:	6125      	str	r5, [r4, #16]
   c06e6:	4620      	mov	r0, r4
   c06e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   c06ec:	000c2521 	.word	0x000c2521
   c06f0:	000c25cc 	.word	0x000c25cc

000c06f4 <__s2b>:
   c06f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   c06f8:	460c      	mov	r4, r1
   c06fa:	4615      	mov	r5, r2
   c06fc:	461f      	mov	r7, r3
   c06fe:	2209      	movs	r2, #9
   c0700:	3308      	adds	r3, #8
   c0702:	4606      	mov	r6, r0
   c0704:	fb93 f3f2 	sdiv	r3, r3, r2
   c0708:	2100      	movs	r1, #0
   c070a:	2201      	movs	r2, #1
   c070c:	429a      	cmp	r2, r3
   c070e:	db09      	blt.n	c0724 <__s2b+0x30>
   c0710:	4630      	mov	r0, r6
   c0712:	f7ff ff47 	bl	c05a4 <_Balloc>
   c0716:	b940      	cbnz	r0, c072a <__s2b+0x36>
   c0718:	4602      	mov	r2, r0
   c071a:	4b19      	ldr	r3, [pc, #100]	; (c0780 <__s2b+0x8c>)
   c071c:	4819      	ldr	r0, [pc, #100]	; (c0784 <__s2b+0x90>)
   c071e:	21ce      	movs	r1, #206	; 0xce
   c0720:	f7f9 feb4 	bl	ba48c <__assert_func>
   c0724:	0052      	lsls	r2, r2, #1
   c0726:	3101      	adds	r1, #1
   c0728:	e7f0      	b.n	c070c <__s2b+0x18>
   c072a:	9b08      	ldr	r3, [sp, #32]
   c072c:	6143      	str	r3, [r0, #20]
   c072e:	2d09      	cmp	r5, #9
   c0730:	f04f 0301 	mov.w	r3, #1
   c0734:	6103      	str	r3, [r0, #16]
   c0736:	dd16      	ble.n	c0766 <__s2b+0x72>
   c0738:	f104 0909 	add.w	r9, r4, #9
   c073c:	46c8      	mov	r8, r9
   c073e:	442c      	add	r4, r5
   c0740:	f818 3b01 	ldrb.w	r3, [r8], #1
   c0744:	4601      	mov	r1, r0
   c0746:	3b30      	subs	r3, #48	; 0x30
   c0748:	220a      	movs	r2, #10
   c074a:	4630      	mov	r0, r6
   c074c:	f7ff ff8c 	bl	c0668 <__multadd>
   c0750:	45a0      	cmp	r8, r4
   c0752:	d1f5      	bne.n	c0740 <__s2b+0x4c>
   c0754:	f1a5 0408 	sub.w	r4, r5, #8
   c0758:	444c      	add	r4, r9
   c075a:	1b2d      	subs	r5, r5, r4
   c075c:	1963      	adds	r3, r4, r5
   c075e:	42bb      	cmp	r3, r7
   c0760:	db04      	blt.n	c076c <__s2b+0x78>
   c0762:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   c0766:	340a      	adds	r4, #10
   c0768:	2509      	movs	r5, #9
   c076a:	e7f6      	b.n	c075a <__s2b+0x66>
   c076c:	f814 3b01 	ldrb.w	r3, [r4], #1
   c0770:	4601      	mov	r1, r0
   c0772:	3b30      	subs	r3, #48	; 0x30
   c0774:	220a      	movs	r2, #10
   c0776:	4630      	mov	r0, r6
   c0778:	f7ff ff76 	bl	c0668 <__multadd>
   c077c:	e7ee      	b.n	c075c <__s2b+0x68>
   c077e:	bf00      	nop
   c0780:	000c2521 	.word	0x000c2521
   c0784:	000c25cc 	.word	0x000c25cc

000c0788 <__hi0bits>:
   c0788:	0c03      	lsrs	r3, r0, #16
   c078a:	041b      	lsls	r3, r3, #16
   c078c:	b9d3      	cbnz	r3, c07c4 <__hi0bits+0x3c>
   c078e:	0400      	lsls	r0, r0, #16
   c0790:	2310      	movs	r3, #16
   c0792:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
   c0796:	bf04      	itt	eq
   c0798:	0200      	lsleq	r0, r0, #8
   c079a:	3308      	addeq	r3, #8
   c079c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
   c07a0:	bf04      	itt	eq
   c07a2:	0100      	lsleq	r0, r0, #4
   c07a4:	3304      	addeq	r3, #4
   c07a6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
   c07aa:	bf04      	itt	eq
   c07ac:	0080      	lsleq	r0, r0, #2
   c07ae:	3302      	addeq	r3, #2
   c07b0:	2800      	cmp	r0, #0
   c07b2:	db05      	blt.n	c07c0 <__hi0bits+0x38>
   c07b4:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
   c07b8:	f103 0301 	add.w	r3, r3, #1
   c07bc:	bf08      	it	eq
   c07be:	2320      	moveq	r3, #32
   c07c0:	4618      	mov	r0, r3
   c07c2:	4770      	bx	lr
   c07c4:	2300      	movs	r3, #0
   c07c6:	e7e4      	b.n	c0792 <__hi0bits+0xa>

000c07c8 <__lo0bits>:
   c07c8:	6803      	ldr	r3, [r0, #0]
   c07ca:	f013 0207 	ands.w	r2, r3, #7
   c07ce:	4601      	mov	r1, r0
   c07d0:	d00b      	beq.n	c07ea <__lo0bits+0x22>
   c07d2:	07da      	lsls	r2, r3, #31
   c07d4:	d423      	bmi.n	c081e <__lo0bits+0x56>
   c07d6:	0798      	lsls	r0, r3, #30
   c07d8:	bf49      	itett	mi
   c07da:	085b      	lsrmi	r3, r3, #1
   c07dc:	089b      	lsrpl	r3, r3, #2
   c07de:	2001      	movmi	r0, #1
   c07e0:	600b      	strmi	r3, [r1, #0]
   c07e2:	bf5c      	itt	pl
   c07e4:	600b      	strpl	r3, [r1, #0]
   c07e6:	2002      	movpl	r0, #2
   c07e8:	4770      	bx	lr
   c07ea:	b298      	uxth	r0, r3
   c07ec:	b9a8      	cbnz	r0, c081a <__lo0bits+0x52>
   c07ee:	0c1b      	lsrs	r3, r3, #16
   c07f0:	2010      	movs	r0, #16
   c07f2:	b2da      	uxtb	r2, r3
   c07f4:	b90a      	cbnz	r2, c07fa <__lo0bits+0x32>
   c07f6:	3008      	adds	r0, #8
   c07f8:	0a1b      	lsrs	r3, r3, #8
   c07fa:	071a      	lsls	r2, r3, #28
   c07fc:	bf04      	itt	eq
   c07fe:	091b      	lsreq	r3, r3, #4
   c0800:	3004      	addeq	r0, #4
   c0802:	079a      	lsls	r2, r3, #30
   c0804:	bf04      	itt	eq
   c0806:	089b      	lsreq	r3, r3, #2
   c0808:	3002      	addeq	r0, #2
   c080a:	07da      	lsls	r2, r3, #31
   c080c:	d403      	bmi.n	c0816 <__lo0bits+0x4e>
   c080e:	085b      	lsrs	r3, r3, #1
   c0810:	f100 0001 	add.w	r0, r0, #1
   c0814:	d005      	beq.n	c0822 <__lo0bits+0x5a>
   c0816:	600b      	str	r3, [r1, #0]
   c0818:	4770      	bx	lr
   c081a:	4610      	mov	r0, r2
   c081c:	e7e9      	b.n	c07f2 <__lo0bits+0x2a>
   c081e:	2000      	movs	r0, #0
   c0820:	4770      	bx	lr
   c0822:	2020      	movs	r0, #32
   c0824:	4770      	bx	lr
	...

000c0828 <__i2b>:
   c0828:	b510      	push	{r4, lr}
   c082a:	460c      	mov	r4, r1
   c082c:	2101      	movs	r1, #1
   c082e:	f7ff feb9 	bl	c05a4 <_Balloc>
   c0832:	4602      	mov	r2, r0
   c0834:	b928      	cbnz	r0, c0842 <__i2b+0x1a>
   c0836:	4b05      	ldr	r3, [pc, #20]	; (c084c <__i2b+0x24>)
   c0838:	4805      	ldr	r0, [pc, #20]	; (c0850 <__i2b+0x28>)
   c083a:	f44f 71a0 	mov.w	r1, #320	; 0x140
   c083e:	f7f9 fe25 	bl	ba48c <__assert_func>
   c0842:	2301      	movs	r3, #1
   c0844:	6144      	str	r4, [r0, #20]
   c0846:	6103      	str	r3, [r0, #16]
   c0848:	bd10      	pop	{r4, pc}
   c084a:	bf00      	nop
   c084c:	000c2521 	.word	0x000c2521
   c0850:	000c25cc 	.word	0x000c25cc

000c0854 <__multiply>:
   c0854:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   c0858:	4691      	mov	r9, r2
   c085a:	690a      	ldr	r2, [r1, #16]
   c085c:	f8d9 3010 	ldr.w	r3, [r9, #16]
   c0860:	429a      	cmp	r2, r3
   c0862:	bfb8      	it	lt
   c0864:	460b      	movlt	r3, r1
   c0866:	460c      	mov	r4, r1
   c0868:	bfbc      	itt	lt
   c086a:	464c      	movlt	r4, r9
   c086c:	4699      	movlt	r9, r3
   c086e:	6927      	ldr	r7, [r4, #16]
   c0870:	f8d9 a010 	ldr.w	sl, [r9, #16]
   c0874:	68a3      	ldr	r3, [r4, #8]
   c0876:	6861      	ldr	r1, [r4, #4]
   c0878:	eb07 060a 	add.w	r6, r7, sl
   c087c:	42b3      	cmp	r3, r6
   c087e:	b085      	sub	sp, #20
   c0880:	bfb8      	it	lt
   c0882:	3101      	addlt	r1, #1
   c0884:	f7ff fe8e 	bl	c05a4 <_Balloc>
   c0888:	b930      	cbnz	r0, c0898 <__multiply+0x44>
   c088a:	4602      	mov	r2, r0
   c088c:	4b44      	ldr	r3, [pc, #272]	; (c09a0 <__multiply+0x14c>)
   c088e:	4845      	ldr	r0, [pc, #276]	; (c09a4 <__multiply+0x150>)
   c0890:	f240 115d 	movw	r1, #349	; 0x15d
   c0894:	f7f9 fdfa 	bl	ba48c <__assert_func>
   c0898:	f100 0514 	add.w	r5, r0, #20
   c089c:	eb05 0886 	add.w	r8, r5, r6, lsl #2
   c08a0:	462b      	mov	r3, r5
   c08a2:	2200      	movs	r2, #0
   c08a4:	4543      	cmp	r3, r8
   c08a6:	d321      	bcc.n	c08ec <__multiply+0x98>
   c08a8:	f104 0314 	add.w	r3, r4, #20
   c08ac:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   c08b0:	f109 0314 	add.w	r3, r9, #20
   c08b4:	eb03 028a 	add.w	r2, r3, sl, lsl #2
   c08b8:	9202      	str	r2, [sp, #8]
   c08ba:	1b3a      	subs	r2, r7, r4
   c08bc:	3a15      	subs	r2, #21
   c08be:	f022 0203 	bic.w	r2, r2, #3
   c08c2:	3204      	adds	r2, #4
   c08c4:	f104 0115 	add.w	r1, r4, #21
   c08c8:	428f      	cmp	r7, r1
   c08ca:	bf38      	it	cc
   c08cc:	2204      	movcc	r2, #4
   c08ce:	9201      	str	r2, [sp, #4]
   c08d0:	9a02      	ldr	r2, [sp, #8]
   c08d2:	9303      	str	r3, [sp, #12]
   c08d4:	429a      	cmp	r2, r3
   c08d6:	d80c      	bhi.n	c08f2 <__multiply+0x9e>
   c08d8:	2e00      	cmp	r6, #0
   c08da:	dd03      	ble.n	c08e4 <__multiply+0x90>
   c08dc:	f858 3d04 	ldr.w	r3, [r8, #-4]!
   c08e0:	2b00      	cmp	r3, #0
   c08e2:	d05a      	beq.n	c099a <__multiply+0x146>
   c08e4:	6106      	str	r6, [r0, #16]
   c08e6:	b005      	add	sp, #20
   c08e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   c08ec:	f843 2b04 	str.w	r2, [r3], #4
   c08f0:	e7d8      	b.n	c08a4 <__multiply+0x50>
   c08f2:	f8b3 a000 	ldrh.w	sl, [r3]
   c08f6:	f1ba 0f00 	cmp.w	sl, #0
   c08fa:	d024      	beq.n	c0946 <__multiply+0xf2>
   c08fc:	f104 0e14 	add.w	lr, r4, #20
   c0900:	46a9      	mov	r9, r5
   c0902:	f04f 0c00 	mov.w	ip, #0
   c0906:	f85e 2b04 	ldr.w	r2, [lr], #4
   c090a:	f8d9 1000 	ldr.w	r1, [r9]
   c090e:	fa1f fb82 	uxth.w	fp, r2
   c0912:	b289      	uxth	r1, r1
   c0914:	fb0a 110b 	mla	r1, sl, fp, r1
   c0918:	ea4f 4b12 	mov.w	fp, r2, lsr #16
   c091c:	f8d9 2000 	ldr.w	r2, [r9]
   c0920:	4461      	add	r1, ip
   c0922:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   c0926:	fb0a c20b 	mla	r2, sl, fp, ip
   c092a:	eb02 4211 	add.w	r2, r2, r1, lsr #16
   c092e:	b289      	uxth	r1, r1
   c0930:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   c0934:	4577      	cmp	r7, lr
   c0936:	f849 1b04 	str.w	r1, [r9], #4
   c093a:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   c093e:	d8e2      	bhi.n	c0906 <__multiply+0xb2>
   c0940:	9a01      	ldr	r2, [sp, #4]
   c0942:	f845 c002 	str.w	ip, [r5, r2]
   c0946:	9a03      	ldr	r2, [sp, #12]
   c0948:	f8b2 9002 	ldrh.w	r9, [r2, #2]
   c094c:	3304      	adds	r3, #4
   c094e:	f1b9 0f00 	cmp.w	r9, #0
   c0952:	d020      	beq.n	c0996 <__multiply+0x142>
   c0954:	6829      	ldr	r1, [r5, #0]
   c0956:	f104 0c14 	add.w	ip, r4, #20
   c095a:	46ae      	mov	lr, r5
   c095c:	f04f 0a00 	mov.w	sl, #0
   c0960:	f8bc b000 	ldrh.w	fp, [ip]
   c0964:	f8be 2002 	ldrh.w	r2, [lr, #2]
   c0968:	fb09 220b 	mla	r2, r9, fp, r2
   c096c:	4492      	add	sl, r2
   c096e:	b289      	uxth	r1, r1
   c0970:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
   c0974:	f84e 1b04 	str.w	r1, [lr], #4
   c0978:	f85c 2b04 	ldr.w	r2, [ip], #4
   c097c:	f8be 1000 	ldrh.w	r1, [lr]
   c0980:	0c12      	lsrs	r2, r2, #16
   c0982:	fb09 1102 	mla	r1, r9, r2, r1
   c0986:	eb01 411a 	add.w	r1, r1, sl, lsr #16
   c098a:	4567      	cmp	r7, ip
   c098c:	ea4f 4a11 	mov.w	sl, r1, lsr #16
   c0990:	d8e6      	bhi.n	c0960 <__multiply+0x10c>
   c0992:	9a01      	ldr	r2, [sp, #4]
   c0994:	50a9      	str	r1, [r5, r2]
   c0996:	3504      	adds	r5, #4
   c0998:	e79a      	b.n	c08d0 <__multiply+0x7c>
   c099a:	3e01      	subs	r6, #1
   c099c:	e79c      	b.n	c08d8 <__multiply+0x84>
   c099e:	bf00      	nop
   c09a0:	000c2521 	.word	0x000c2521
   c09a4:	000c25cc 	.word	0x000c25cc

000c09a8 <__pow5mult>:
   c09a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   c09ac:	4615      	mov	r5, r2
   c09ae:	f012 0203 	ands.w	r2, r2, #3
   c09b2:	4606      	mov	r6, r0
   c09b4:	460f      	mov	r7, r1
   c09b6:	d007      	beq.n	c09c8 <__pow5mult+0x20>
   c09b8:	4c25      	ldr	r4, [pc, #148]	; (c0a50 <__pow5mult+0xa8>)
   c09ba:	3a01      	subs	r2, #1
   c09bc:	2300      	movs	r3, #0
   c09be:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   c09c2:	f7ff fe51 	bl	c0668 <__multadd>
   c09c6:	4607      	mov	r7, r0
   c09c8:	10ad      	asrs	r5, r5, #2
   c09ca:	d03d      	beq.n	c0a48 <__pow5mult+0xa0>
   c09cc:	6a74      	ldr	r4, [r6, #36]	; 0x24
   c09ce:	b97c      	cbnz	r4, c09f0 <__pow5mult+0x48>
   c09d0:	2010      	movs	r0, #16
   c09d2:	f7f9 fd0b 	bl	ba3ec <malloc>
   c09d6:	4602      	mov	r2, r0
   c09d8:	6270      	str	r0, [r6, #36]	; 0x24
   c09da:	b928      	cbnz	r0, c09e8 <__pow5mult+0x40>
   c09dc:	4b1d      	ldr	r3, [pc, #116]	; (c0a54 <__pow5mult+0xac>)
   c09de:	481e      	ldr	r0, [pc, #120]	; (c0a58 <__pow5mult+0xb0>)
   c09e0:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
   c09e4:	f7f9 fd52 	bl	ba48c <__assert_func>
   c09e8:	e9c0 4401 	strd	r4, r4, [r0, #4]
   c09ec:	6004      	str	r4, [r0, #0]
   c09ee:	60c4      	str	r4, [r0, #12]
   c09f0:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   c09f4:	f8d8 4008 	ldr.w	r4, [r8, #8]
   c09f8:	b94c      	cbnz	r4, c0a0e <__pow5mult+0x66>
   c09fa:	f240 2171 	movw	r1, #625	; 0x271
   c09fe:	4630      	mov	r0, r6
   c0a00:	f7ff ff12 	bl	c0828 <__i2b>
   c0a04:	2300      	movs	r3, #0
   c0a06:	f8c8 0008 	str.w	r0, [r8, #8]
   c0a0a:	4604      	mov	r4, r0
   c0a0c:	6003      	str	r3, [r0, #0]
   c0a0e:	f04f 0900 	mov.w	r9, #0
   c0a12:	07eb      	lsls	r3, r5, #31
   c0a14:	d50a      	bpl.n	c0a2c <__pow5mult+0x84>
   c0a16:	4639      	mov	r1, r7
   c0a18:	4622      	mov	r2, r4
   c0a1a:	4630      	mov	r0, r6
   c0a1c:	f7ff ff1a 	bl	c0854 <__multiply>
   c0a20:	4639      	mov	r1, r7
   c0a22:	4680      	mov	r8, r0
   c0a24:	4630      	mov	r0, r6
   c0a26:	f7ff fdfd 	bl	c0624 <_Bfree>
   c0a2a:	4647      	mov	r7, r8
   c0a2c:	106d      	asrs	r5, r5, #1
   c0a2e:	d00b      	beq.n	c0a48 <__pow5mult+0xa0>
   c0a30:	6820      	ldr	r0, [r4, #0]
   c0a32:	b938      	cbnz	r0, c0a44 <__pow5mult+0x9c>
   c0a34:	4622      	mov	r2, r4
   c0a36:	4621      	mov	r1, r4
   c0a38:	4630      	mov	r0, r6
   c0a3a:	f7ff ff0b 	bl	c0854 <__multiply>
   c0a3e:	6020      	str	r0, [r4, #0]
   c0a40:	f8c0 9000 	str.w	r9, [r0]
   c0a44:	4604      	mov	r4, r0
   c0a46:	e7e4      	b.n	c0a12 <__pow5mult+0x6a>
   c0a48:	4638      	mov	r0, r7
   c0a4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   c0a4e:	bf00      	nop
   c0a50:	000c2740 	.word	0x000c2740
   c0a54:	000c2329 	.word	0x000c2329
   c0a58:	000c25cc 	.word	0x000c25cc

000c0a5c <__lshift>:
   c0a5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   c0a60:	460c      	mov	r4, r1
   c0a62:	6849      	ldr	r1, [r1, #4]
   c0a64:	6923      	ldr	r3, [r4, #16]
   c0a66:	eb03 1862 	add.w	r8, r3, r2, asr #5
   c0a6a:	68a3      	ldr	r3, [r4, #8]
   c0a6c:	4607      	mov	r7, r0
   c0a6e:	4691      	mov	r9, r2
   c0a70:	ea4f 1a62 	mov.w	sl, r2, asr #5
   c0a74:	f108 0601 	add.w	r6, r8, #1
   c0a78:	42b3      	cmp	r3, r6
   c0a7a:	db0b      	blt.n	c0a94 <__lshift+0x38>
   c0a7c:	4638      	mov	r0, r7
   c0a7e:	f7ff fd91 	bl	c05a4 <_Balloc>
   c0a82:	4605      	mov	r5, r0
   c0a84:	b948      	cbnz	r0, c0a9a <__lshift+0x3e>
   c0a86:	4602      	mov	r2, r0
   c0a88:	4b2a      	ldr	r3, [pc, #168]	; (c0b34 <__lshift+0xd8>)
   c0a8a:	482b      	ldr	r0, [pc, #172]	; (c0b38 <__lshift+0xdc>)
   c0a8c:	f240 11d9 	movw	r1, #473	; 0x1d9
   c0a90:	f7f9 fcfc 	bl	ba48c <__assert_func>
   c0a94:	3101      	adds	r1, #1
   c0a96:	005b      	lsls	r3, r3, #1
   c0a98:	e7ee      	b.n	c0a78 <__lshift+0x1c>
   c0a9a:	2300      	movs	r3, #0
   c0a9c:	f100 0114 	add.w	r1, r0, #20
   c0aa0:	f100 0210 	add.w	r2, r0, #16
   c0aa4:	4618      	mov	r0, r3
   c0aa6:	4553      	cmp	r3, sl
   c0aa8:	db37      	blt.n	c0b1a <__lshift+0xbe>
   c0aaa:	6920      	ldr	r0, [r4, #16]
   c0aac:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   c0ab0:	f104 0314 	add.w	r3, r4, #20
   c0ab4:	f019 091f 	ands.w	r9, r9, #31
   c0ab8:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   c0abc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   c0ac0:	d02f      	beq.n	c0b22 <__lshift+0xc6>
   c0ac2:	f1c9 0e20 	rsb	lr, r9, #32
   c0ac6:	468a      	mov	sl, r1
   c0ac8:	f04f 0c00 	mov.w	ip, #0
   c0acc:	681a      	ldr	r2, [r3, #0]
   c0ace:	fa02 f209 	lsl.w	r2, r2, r9
   c0ad2:	ea42 020c 	orr.w	r2, r2, ip
   c0ad6:	f84a 2b04 	str.w	r2, [sl], #4
   c0ada:	f853 2b04 	ldr.w	r2, [r3], #4
   c0ade:	4298      	cmp	r0, r3
   c0ae0:	fa22 fc0e 	lsr.w	ip, r2, lr
   c0ae4:	d8f2      	bhi.n	c0acc <__lshift+0x70>
   c0ae6:	1b03      	subs	r3, r0, r4
   c0ae8:	3b15      	subs	r3, #21
   c0aea:	f023 0303 	bic.w	r3, r3, #3
   c0aee:	3304      	adds	r3, #4
   c0af0:	f104 0215 	add.w	r2, r4, #21
   c0af4:	4290      	cmp	r0, r2
   c0af6:	bf38      	it	cc
   c0af8:	2304      	movcc	r3, #4
   c0afa:	f841 c003 	str.w	ip, [r1, r3]
   c0afe:	f1bc 0f00 	cmp.w	ip, #0
   c0b02:	d001      	beq.n	c0b08 <__lshift+0xac>
   c0b04:	f108 0602 	add.w	r6, r8, #2
   c0b08:	3e01      	subs	r6, #1
   c0b0a:	4638      	mov	r0, r7
   c0b0c:	612e      	str	r6, [r5, #16]
   c0b0e:	4621      	mov	r1, r4
   c0b10:	f7ff fd88 	bl	c0624 <_Bfree>
   c0b14:	4628      	mov	r0, r5
   c0b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   c0b1a:	f842 0f04 	str.w	r0, [r2, #4]!
   c0b1e:	3301      	adds	r3, #1
   c0b20:	e7c1      	b.n	c0aa6 <__lshift+0x4a>
   c0b22:	3904      	subs	r1, #4
   c0b24:	f853 2b04 	ldr.w	r2, [r3], #4
   c0b28:	f841 2f04 	str.w	r2, [r1, #4]!
   c0b2c:	4298      	cmp	r0, r3
   c0b2e:	d8f9      	bhi.n	c0b24 <__lshift+0xc8>
   c0b30:	e7ea      	b.n	c0b08 <__lshift+0xac>
   c0b32:	bf00      	nop
   c0b34:	000c2521 	.word	0x000c2521
   c0b38:	000c25cc 	.word	0x000c25cc

000c0b3c <__mcmp>:
   c0b3c:	b530      	push	{r4, r5, lr}
   c0b3e:	6902      	ldr	r2, [r0, #16]
   c0b40:	690c      	ldr	r4, [r1, #16]
   c0b42:	1b12      	subs	r2, r2, r4
   c0b44:	d10e      	bne.n	c0b64 <__mcmp+0x28>
   c0b46:	f100 0314 	add.w	r3, r0, #20
   c0b4a:	3114      	adds	r1, #20
   c0b4c:	eb03 0084 	add.w	r0, r3, r4, lsl #2
   c0b50:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   c0b54:	f850 5d04 	ldr.w	r5, [r0, #-4]!
   c0b58:	f851 4d04 	ldr.w	r4, [r1, #-4]!
   c0b5c:	42a5      	cmp	r5, r4
   c0b5e:	d003      	beq.n	c0b68 <__mcmp+0x2c>
   c0b60:	d305      	bcc.n	c0b6e <__mcmp+0x32>
   c0b62:	2201      	movs	r2, #1
   c0b64:	4610      	mov	r0, r2
   c0b66:	bd30      	pop	{r4, r5, pc}
   c0b68:	4283      	cmp	r3, r0
   c0b6a:	d3f3      	bcc.n	c0b54 <__mcmp+0x18>
   c0b6c:	e7fa      	b.n	c0b64 <__mcmp+0x28>
   c0b6e:	f04f 32ff 	mov.w	r2, #4294967295
   c0b72:	e7f7      	b.n	c0b64 <__mcmp+0x28>

000c0b74 <__mdiff>:
   c0b74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   c0b78:	460c      	mov	r4, r1
   c0b7a:	4606      	mov	r6, r0
   c0b7c:	4611      	mov	r1, r2
   c0b7e:	4620      	mov	r0, r4
   c0b80:	4690      	mov	r8, r2
   c0b82:	f7ff ffdb 	bl	c0b3c <__mcmp>
   c0b86:	1e05      	subs	r5, r0, #0
   c0b88:	d110      	bne.n	c0bac <__mdiff+0x38>
   c0b8a:	4629      	mov	r1, r5
   c0b8c:	4630      	mov	r0, r6
   c0b8e:	f7ff fd09 	bl	c05a4 <_Balloc>
   c0b92:	b930      	cbnz	r0, c0ba2 <__mdiff+0x2e>
   c0b94:	4b3a      	ldr	r3, [pc, #232]	; (c0c80 <__mdiff+0x10c>)
   c0b96:	4602      	mov	r2, r0
   c0b98:	f240 2132 	movw	r1, #562	; 0x232
   c0b9c:	4839      	ldr	r0, [pc, #228]	; (c0c84 <__mdiff+0x110>)
   c0b9e:	f7f9 fc75 	bl	ba48c <__assert_func>
   c0ba2:	2301      	movs	r3, #1
   c0ba4:	e9c0 3504 	strd	r3, r5, [r0, #16]
   c0ba8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   c0bac:	bfa4      	itt	ge
   c0bae:	4643      	movge	r3, r8
   c0bb0:	46a0      	movge	r8, r4
   c0bb2:	4630      	mov	r0, r6
   c0bb4:	f8d8 1004 	ldr.w	r1, [r8, #4]
   c0bb8:	bfa6      	itte	ge
   c0bba:	461c      	movge	r4, r3
   c0bbc:	2500      	movge	r5, #0
   c0bbe:	2501      	movlt	r5, #1
   c0bc0:	f7ff fcf0 	bl	c05a4 <_Balloc>
   c0bc4:	b920      	cbnz	r0, c0bd0 <__mdiff+0x5c>
   c0bc6:	4b2e      	ldr	r3, [pc, #184]	; (c0c80 <__mdiff+0x10c>)
   c0bc8:	4602      	mov	r2, r0
   c0bca:	f44f 7110 	mov.w	r1, #576	; 0x240
   c0bce:	e7e5      	b.n	c0b9c <__mdiff+0x28>
   c0bd0:	f8d8 7010 	ldr.w	r7, [r8, #16]
   c0bd4:	6926      	ldr	r6, [r4, #16]
   c0bd6:	60c5      	str	r5, [r0, #12]
   c0bd8:	f104 0914 	add.w	r9, r4, #20
   c0bdc:	f108 0514 	add.w	r5, r8, #20
   c0be0:	f100 0e14 	add.w	lr, r0, #20
   c0be4:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
   c0be8:	eb09 0686 	add.w	r6, r9, r6, lsl #2
   c0bec:	f108 0210 	add.w	r2, r8, #16
   c0bf0:	46f2      	mov	sl, lr
   c0bf2:	2100      	movs	r1, #0
   c0bf4:	f859 3b04 	ldr.w	r3, [r9], #4
   c0bf8:	f852 bf04 	ldr.w	fp, [r2, #4]!
   c0bfc:	fa1f f883 	uxth.w	r8, r3
   c0c00:	fa11 f18b 	uxtah	r1, r1, fp
   c0c04:	0c1b      	lsrs	r3, r3, #16
   c0c06:	eba1 0808 	sub.w	r8, r1, r8
   c0c0a:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
   c0c0e:	eb03 4328 	add.w	r3, r3, r8, asr #16
   c0c12:	fa1f f888 	uxth.w	r8, r8
   c0c16:	1419      	asrs	r1, r3, #16
   c0c18:	454e      	cmp	r6, r9
   c0c1a:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
   c0c1e:	f84a 3b04 	str.w	r3, [sl], #4
   c0c22:	d8e7      	bhi.n	c0bf4 <__mdiff+0x80>
   c0c24:	1b33      	subs	r3, r6, r4
   c0c26:	3b15      	subs	r3, #21
   c0c28:	f023 0303 	bic.w	r3, r3, #3
   c0c2c:	3304      	adds	r3, #4
   c0c2e:	3415      	adds	r4, #21
   c0c30:	42a6      	cmp	r6, r4
   c0c32:	bf38      	it	cc
   c0c34:	2304      	movcc	r3, #4
   c0c36:	441d      	add	r5, r3
   c0c38:	4473      	add	r3, lr
   c0c3a:	469e      	mov	lr, r3
   c0c3c:	462e      	mov	r6, r5
   c0c3e:	4566      	cmp	r6, ip
   c0c40:	d30e      	bcc.n	c0c60 <__mdiff+0xec>
   c0c42:	f10c 0203 	add.w	r2, ip, #3
   c0c46:	1b52      	subs	r2, r2, r5
   c0c48:	f022 0203 	bic.w	r2, r2, #3
   c0c4c:	3d03      	subs	r5, #3
   c0c4e:	45ac      	cmp	ip, r5
   c0c50:	bf38      	it	cc
   c0c52:	2200      	movcc	r2, #0
   c0c54:	441a      	add	r2, r3
   c0c56:	f852 3d04 	ldr.w	r3, [r2, #-4]!
   c0c5a:	b17b      	cbz	r3, c0c7c <__mdiff+0x108>
   c0c5c:	6107      	str	r7, [r0, #16]
   c0c5e:	e7a3      	b.n	c0ba8 <__mdiff+0x34>
   c0c60:	f856 8b04 	ldr.w	r8, [r6], #4
   c0c64:	fa11 f288 	uxtah	r2, r1, r8
   c0c68:	1414      	asrs	r4, r2, #16
   c0c6a:	eb04 4418 	add.w	r4, r4, r8, lsr #16
   c0c6e:	b292      	uxth	r2, r2
   c0c70:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
   c0c74:	f84e 2b04 	str.w	r2, [lr], #4
   c0c78:	1421      	asrs	r1, r4, #16
   c0c7a:	e7e0      	b.n	c0c3e <__mdiff+0xca>
   c0c7c:	3f01      	subs	r7, #1
   c0c7e:	e7ea      	b.n	c0c56 <__mdiff+0xe2>
   c0c80:	000c2521 	.word	0x000c2521
   c0c84:	000c25cc 	.word	0x000c25cc

000c0c88 <__ulp>:
   c0c88:	b082      	sub	sp, #8
   c0c8a:	ed8d 0b00 	vstr	d0, [sp]
   c0c8e:	9b01      	ldr	r3, [sp, #4]
   c0c90:	4912      	ldr	r1, [pc, #72]	; (c0cdc <__ulp+0x54>)
   c0c92:	4019      	ands	r1, r3
   c0c94:	f1a1 7150 	sub.w	r1, r1, #54525952	; 0x3400000
   c0c98:	2900      	cmp	r1, #0
   c0c9a:	dd05      	ble.n	c0ca8 <__ulp+0x20>
   c0c9c:	2200      	movs	r2, #0
   c0c9e:	460b      	mov	r3, r1
   c0ca0:	ec43 2b10 	vmov	d0, r2, r3
   c0ca4:	b002      	add	sp, #8
   c0ca6:	4770      	bx	lr
   c0ca8:	4249      	negs	r1, r1
   c0caa:	f1b1 7fa0 	cmp.w	r1, #20971520	; 0x1400000
   c0cae:	ea4f 5021 	mov.w	r0, r1, asr #20
   c0cb2:	f04f 0200 	mov.w	r2, #0
   c0cb6:	f04f 0300 	mov.w	r3, #0
   c0cba:	da04      	bge.n	c0cc6 <__ulp+0x3e>
   c0cbc:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   c0cc0:	fa41 f300 	asr.w	r3, r1, r0
   c0cc4:	e7ec      	b.n	c0ca0 <__ulp+0x18>
   c0cc6:	f1a0 0114 	sub.w	r1, r0, #20
   c0cca:	291e      	cmp	r1, #30
   c0ccc:	bfda      	itte	le
   c0cce:	f04f 4000 	movle.w	r0, #2147483648	; 0x80000000
   c0cd2:	fa20 f101 	lsrle.w	r1, r0, r1
   c0cd6:	2101      	movgt	r1, #1
   c0cd8:	460a      	mov	r2, r1
   c0cda:	e7e1      	b.n	c0ca0 <__ulp+0x18>
   c0cdc:	7ff00000 	.word	0x7ff00000

000c0ce0 <__b2d>:
   c0ce0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   c0ce2:	6905      	ldr	r5, [r0, #16]
   c0ce4:	f100 0714 	add.w	r7, r0, #20
   c0ce8:	eb07 0585 	add.w	r5, r7, r5, lsl #2
   c0cec:	1f2e      	subs	r6, r5, #4
   c0cee:	f855 4c04 	ldr.w	r4, [r5, #-4]
   c0cf2:	4620      	mov	r0, r4
   c0cf4:	f7ff fd48 	bl	c0788 <__hi0bits>
   c0cf8:	f1c0 0320 	rsb	r3, r0, #32
   c0cfc:	280a      	cmp	r0, #10
   c0cfe:	f8df c07c 	ldr.w	ip, [pc, #124]	; c0d7c <__b2d+0x9c>
   c0d02:	600b      	str	r3, [r1, #0]
   c0d04:	dc14      	bgt.n	c0d30 <__b2d+0x50>
   c0d06:	f1c0 0e0b 	rsb	lr, r0, #11
   c0d0a:	fa24 f10e 	lsr.w	r1, r4, lr
   c0d0e:	42b7      	cmp	r7, r6
   c0d10:	ea41 030c 	orr.w	r3, r1, ip
   c0d14:	bf34      	ite	cc
   c0d16:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
   c0d1a:	2100      	movcs	r1, #0
   c0d1c:	3015      	adds	r0, #21
   c0d1e:	fa04 f000 	lsl.w	r0, r4, r0
   c0d22:	fa21 f10e 	lsr.w	r1, r1, lr
   c0d26:	ea40 0201 	orr.w	r2, r0, r1
   c0d2a:	ec43 2b10 	vmov	d0, r2, r3
   c0d2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   c0d30:	42b7      	cmp	r7, r6
   c0d32:	bf3a      	itte	cc
   c0d34:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
   c0d38:	f1a5 0608 	subcc.w	r6, r5, #8
   c0d3c:	2100      	movcs	r1, #0
   c0d3e:	380b      	subs	r0, #11
   c0d40:	d017      	beq.n	c0d72 <__b2d+0x92>
   c0d42:	f1c0 0c20 	rsb	ip, r0, #32
   c0d46:	fa04 f500 	lsl.w	r5, r4, r0
   c0d4a:	42be      	cmp	r6, r7
   c0d4c:	fa21 f40c 	lsr.w	r4, r1, ip
   c0d50:	ea45 0504 	orr.w	r5, r5, r4
   c0d54:	bf8c      	ite	hi
   c0d56:	f856 4c04 	ldrhi.w	r4, [r6, #-4]
   c0d5a:	2400      	movls	r4, #0
   c0d5c:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
   c0d60:	fa01 f000 	lsl.w	r0, r1, r0
   c0d64:	fa24 f40c 	lsr.w	r4, r4, ip
   c0d68:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
   c0d6c:	ea40 0204 	orr.w	r2, r0, r4
   c0d70:	e7db      	b.n	c0d2a <__b2d+0x4a>
   c0d72:	ea44 030c 	orr.w	r3, r4, ip
   c0d76:	460a      	mov	r2, r1
   c0d78:	e7d7      	b.n	c0d2a <__b2d+0x4a>
   c0d7a:	bf00      	nop
   c0d7c:	3ff00000 	.word	0x3ff00000

000c0d80 <__d2b>:
   c0d80:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   c0d84:	4689      	mov	r9, r1
   c0d86:	2101      	movs	r1, #1
   c0d88:	ec57 6b10 	vmov	r6, r7, d0
   c0d8c:	4690      	mov	r8, r2
   c0d8e:	f7ff fc09 	bl	c05a4 <_Balloc>
   c0d92:	4604      	mov	r4, r0
   c0d94:	b930      	cbnz	r0, c0da4 <__d2b+0x24>
   c0d96:	4602      	mov	r2, r0
   c0d98:	4b25      	ldr	r3, [pc, #148]	; (c0e30 <__d2b+0xb0>)
   c0d9a:	4826      	ldr	r0, [pc, #152]	; (c0e34 <__d2b+0xb4>)
   c0d9c:	f240 310a 	movw	r1, #778	; 0x30a
   c0da0:	f7f9 fb74 	bl	ba48c <__assert_func>
   c0da4:	f3c7 550a 	ubfx	r5, r7, #20, #11
   c0da8:	f3c7 0313 	ubfx	r3, r7, #0, #20
   c0dac:	bb35      	cbnz	r5, c0dfc <__d2b+0x7c>
   c0dae:	2e00      	cmp	r6, #0
   c0db0:	9301      	str	r3, [sp, #4]
   c0db2:	d028      	beq.n	c0e06 <__d2b+0x86>
   c0db4:	4668      	mov	r0, sp
   c0db6:	9600      	str	r6, [sp, #0]
   c0db8:	f7ff fd06 	bl	c07c8 <__lo0bits>
   c0dbc:	9900      	ldr	r1, [sp, #0]
   c0dbe:	b300      	cbz	r0, c0e02 <__d2b+0x82>
   c0dc0:	9a01      	ldr	r2, [sp, #4]
   c0dc2:	f1c0 0320 	rsb	r3, r0, #32
   c0dc6:	fa02 f303 	lsl.w	r3, r2, r3
   c0dca:	430b      	orrs	r3, r1
   c0dcc:	40c2      	lsrs	r2, r0
   c0dce:	6163      	str	r3, [r4, #20]
   c0dd0:	9201      	str	r2, [sp, #4]
   c0dd2:	9b01      	ldr	r3, [sp, #4]
   c0dd4:	61a3      	str	r3, [r4, #24]
   c0dd6:	2b00      	cmp	r3, #0
   c0dd8:	bf14      	ite	ne
   c0dda:	2202      	movne	r2, #2
   c0ddc:	2201      	moveq	r2, #1
   c0dde:	6122      	str	r2, [r4, #16]
   c0de0:	b1d5      	cbz	r5, c0e18 <__d2b+0x98>
   c0de2:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
   c0de6:	4405      	add	r5, r0
   c0de8:	f8c9 5000 	str.w	r5, [r9]
   c0dec:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   c0df0:	f8c8 0000 	str.w	r0, [r8]
   c0df4:	4620      	mov	r0, r4
   c0df6:	b003      	add	sp, #12
   c0df8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   c0dfc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   c0e00:	e7d5      	b.n	c0dae <__d2b+0x2e>
   c0e02:	6161      	str	r1, [r4, #20]
   c0e04:	e7e5      	b.n	c0dd2 <__d2b+0x52>
   c0e06:	a801      	add	r0, sp, #4
   c0e08:	f7ff fcde 	bl	c07c8 <__lo0bits>
   c0e0c:	9b01      	ldr	r3, [sp, #4]
   c0e0e:	6163      	str	r3, [r4, #20]
   c0e10:	2201      	movs	r2, #1
   c0e12:	6122      	str	r2, [r4, #16]
   c0e14:	3020      	adds	r0, #32
   c0e16:	e7e3      	b.n	c0de0 <__d2b+0x60>
   c0e18:	eb04 0382 	add.w	r3, r4, r2, lsl #2
   c0e1c:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   c0e20:	f8c9 0000 	str.w	r0, [r9]
   c0e24:	6918      	ldr	r0, [r3, #16]
   c0e26:	f7ff fcaf 	bl	c0788 <__hi0bits>
   c0e2a:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
   c0e2e:	e7df      	b.n	c0df0 <__d2b+0x70>
   c0e30:	000c2521 	.word	0x000c2521
   c0e34:	000c25cc 	.word	0x000c25cc

000c0e38 <__ratio>:
   c0e38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   c0e3c:	4688      	mov	r8, r1
   c0e3e:	4669      	mov	r1, sp
   c0e40:	4681      	mov	r9, r0
   c0e42:	f7ff ff4d 	bl	c0ce0 <__b2d>
   c0e46:	a901      	add	r1, sp, #4
   c0e48:	4640      	mov	r0, r8
   c0e4a:	ec55 4b10 	vmov	r4, r5, d0
   c0e4e:	f7ff ff47 	bl	c0ce0 <__b2d>
   c0e52:	f8d9 3010 	ldr.w	r3, [r9, #16]
   c0e56:	f8d8 2010 	ldr.w	r2, [r8, #16]
   c0e5a:	eba3 0c02 	sub.w	ip, r3, r2
   c0e5e:	e9dd 3200 	ldrd	r3, r2, [sp]
   c0e62:	1a9b      	subs	r3, r3, r2
   c0e64:	eb03 134c 	add.w	r3, r3, ip, lsl #5
   c0e68:	ec51 0b10 	vmov	r0, r1, d0
   c0e6c:	2b00      	cmp	r3, #0
   c0e6e:	bfd6      	itet	le
   c0e70:	460a      	movle	r2, r1
   c0e72:	462a      	movgt	r2, r5
   c0e74:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
   c0e78:	468b      	mov	fp, r1
   c0e7a:	462f      	mov	r7, r5
   c0e7c:	bfd4      	ite	le
   c0e7e:	eb02 5b03 	addle.w	fp, r2, r3, lsl #20
   c0e82:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
   c0e86:	4620      	mov	r0, r4
   c0e88:	ee10 2a10 	vmov	r2, s0
   c0e8c:	465b      	mov	r3, fp
   c0e8e:	4639      	mov	r1, r7
   c0e90:	f7fd fdf0 	bl	bea74 <__aeabi_ddiv>
   c0e94:	ec41 0b10 	vmov	d0, r0, r1
   c0e98:	b003      	add	sp, #12
   c0e9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000c0e9e <__copybits>:
   c0e9e:	3901      	subs	r1, #1
   c0ea0:	b570      	push	{r4, r5, r6, lr}
   c0ea2:	1149      	asrs	r1, r1, #5
   c0ea4:	6914      	ldr	r4, [r2, #16]
   c0ea6:	3101      	adds	r1, #1
   c0ea8:	f102 0314 	add.w	r3, r2, #20
   c0eac:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   c0eb0:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   c0eb4:	1f05      	subs	r5, r0, #4
   c0eb6:	42a3      	cmp	r3, r4
   c0eb8:	d30c      	bcc.n	c0ed4 <__copybits+0x36>
   c0eba:	1aa3      	subs	r3, r4, r2
   c0ebc:	3b11      	subs	r3, #17
   c0ebe:	f023 0303 	bic.w	r3, r3, #3
   c0ec2:	3211      	adds	r2, #17
   c0ec4:	42a2      	cmp	r2, r4
   c0ec6:	bf88      	it	hi
   c0ec8:	2300      	movhi	r3, #0
   c0eca:	4418      	add	r0, r3
   c0ecc:	2300      	movs	r3, #0
   c0ece:	4288      	cmp	r0, r1
   c0ed0:	d305      	bcc.n	c0ede <__copybits+0x40>
   c0ed2:	bd70      	pop	{r4, r5, r6, pc}
   c0ed4:	f853 6b04 	ldr.w	r6, [r3], #4
   c0ed8:	f845 6f04 	str.w	r6, [r5, #4]!
   c0edc:	e7eb      	b.n	c0eb6 <__copybits+0x18>
   c0ede:	f840 3b04 	str.w	r3, [r0], #4
   c0ee2:	e7f4      	b.n	c0ece <__copybits+0x30>

000c0ee4 <__any_on>:
   c0ee4:	f100 0214 	add.w	r2, r0, #20
   c0ee8:	6900      	ldr	r0, [r0, #16]
   c0eea:	114b      	asrs	r3, r1, #5
   c0eec:	4298      	cmp	r0, r3
   c0eee:	b510      	push	{r4, lr}
   c0ef0:	db11      	blt.n	c0f16 <__any_on+0x32>
   c0ef2:	dd0a      	ble.n	c0f0a <__any_on+0x26>
   c0ef4:	f011 011f 	ands.w	r1, r1, #31
   c0ef8:	d007      	beq.n	c0f0a <__any_on+0x26>
   c0efa:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
   c0efe:	fa24 f001 	lsr.w	r0, r4, r1
   c0f02:	fa00 f101 	lsl.w	r1, r0, r1
   c0f06:	428c      	cmp	r4, r1
   c0f08:	d10b      	bne.n	c0f22 <__any_on+0x3e>
   c0f0a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   c0f0e:	4293      	cmp	r3, r2
   c0f10:	d803      	bhi.n	c0f1a <__any_on+0x36>
   c0f12:	2000      	movs	r0, #0
   c0f14:	bd10      	pop	{r4, pc}
   c0f16:	4603      	mov	r3, r0
   c0f18:	e7f7      	b.n	c0f0a <__any_on+0x26>
   c0f1a:	f853 1d04 	ldr.w	r1, [r3, #-4]!
   c0f1e:	2900      	cmp	r1, #0
   c0f20:	d0f5      	beq.n	c0f0e <__any_on+0x2a>
   c0f22:	2001      	movs	r0, #1
   c0f24:	e7f6      	b.n	c0f14 <__any_on+0x30>

000c0f26 <_calloc_r>:
   c0f26:	b513      	push	{r0, r1, r4, lr}
   c0f28:	434a      	muls	r2, r1
   c0f2a:	4611      	mov	r1, r2
   c0f2c:	9201      	str	r2, [sp, #4]
   c0f2e:	f7f9 fa9d 	bl	ba46c <_malloc_r>
   c0f32:	4604      	mov	r4, r0
   c0f34:	b118      	cbz	r0, c0f3e <_calloc_r+0x18>
   c0f36:	9a01      	ldr	r2, [sp, #4]
   c0f38:	2100      	movs	r1, #0
   c0f3a:	f7fd ffde 	bl	beefa <memset>
   c0f3e:	4620      	mov	r0, r4
   c0f40:	b002      	add	sp, #8
   c0f42:	bd10      	pop	{r4, pc}
   c0f44:	0000      	movs	r0, r0
	...

000c0f48 <nan>:
   c0f48:	ed9f 0b01 	vldr	d0, [pc, #4]	; c0f50 <nan+0x8>
   c0f4c:	4770      	bx	lr
   c0f4e:	bf00      	nop
   c0f50:	00000000 	.word	0x00000000
   c0f54:	7ff80000 	.word	0x7ff80000

000c0f58 <__ascii_wctomb>:
   c0f58:	b149      	cbz	r1, c0f6e <__ascii_wctomb+0x16>
   c0f5a:	2aff      	cmp	r2, #255	; 0xff
   c0f5c:	bf85      	ittet	hi
   c0f5e:	238a      	movhi	r3, #138	; 0x8a
   c0f60:	6003      	strhi	r3, [r0, #0]
   c0f62:	700a      	strbls	r2, [r1, #0]
   c0f64:	f04f 30ff 	movhi.w	r0, #4294967295
   c0f68:	bf98      	it	ls
   c0f6a:	2001      	movls	r0, #1
   c0f6c:	4770      	bx	lr
   c0f6e:	4608      	mov	r0, r1
   c0f70:	4770      	bx	lr
	...

000c0f74 <__aeabi_d2lz>:
   c0f74:	b538      	push	{r3, r4, r5, lr}
   c0f76:	2200      	movs	r2, #0
   c0f78:	2300      	movs	r3, #0
   c0f7a:	4604      	mov	r4, r0
   c0f7c:	460d      	mov	r5, r1
   c0f7e:	f7fd fec1 	bl	bed04 <__aeabi_dcmplt>
   c0f82:	b928      	cbnz	r0, c0f90 <__aeabi_d2lz+0x1c>
   c0f84:	4620      	mov	r0, r4
   c0f86:	4629      	mov	r1, r5
   c0f88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   c0f8c:	f7fd bf52 	b.w	bee34 <__aeabi_d2ulz>
   c0f90:	4620      	mov	r0, r4
   c0f92:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
   c0f96:	f7fd ff4d 	bl	bee34 <__aeabi_d2ulz>
   c0f9a:	4240      	negs	r0, r0
   c0f9c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   c0fa0:	bd38      	pop	{r3, r4, r5, pc}
   c0fa2:	bf00      	nop

000c0fa4 <dynalib_user>:
   c0fa4:	4021 000b 405d 000b 4085 000b 4089 000b     !@..]@...@...@..
   c0fb4:	0000 0000 6143 6c6c 6f20 206e 7570 6572     ....Call on pure
   c0fc4:	7620 7269 7574 6c61 6400 6665 7561 746c      virtual.default
   c0fd4:	0020 534d 0042 534c 0042 533c 4950 6553      .MSB.LSB.<SPISe
   c0fe4:	7474 6e69 7367 6420 6665 7561 746c 003e     ttings default>.
   c0ff4:	533c 4950 6553 7474 6e69 7367 2520 2573     <SPISettings %s%
   c1004:	2075 7325 4d20 444f 2545 3e75 6600 6c69     u %s MODE%u>.fil
   c1014:	6e65 6d61 0065 6966 656c 6f63 706d 6600     ename.filecomp.f
   c1024:	6c69 6465 6e6f 0065 575b 5241 5d4e 5220     iledone.[WARN] R
   c1034:	6950 4d20 7365 6173 6567 4320 6568 6b63     Pi Message Check
   c1044:	7573 206d 6f44 7365 4e20 746f 4d20 7461     sum Does Not Mat
   c1054:	6863 3a21 2520 0073 7463 006c 7325 2520     ch!: %s.ctl.%s %
   c1064:	2073 7325 2520 2064 6425 2520 2064 6425     s %s %d %d %d %d
   c1074:	0a00 4300 5243 7350 7075 2542 2064 6425     ...CCRPsupB%d %d
   c1084:	2520 2e30 6636 2520 2e30 6636 2520 2064      %0.6f %0.6f %d 
   c1094:	6425 2520 0064 495b 464e 5d4f 5220 6365     %d %d.[INFO] Rec
   c10a4:	6965 6576 2064 6152 7073 6562 7272 2079     eived Raspberry 
   c10b4:	6950 4d20 7365 6173 6567 203a 7325 2500     Pi Message: %s.%
   c10c4:	2573 3230 0078 4343 7548 0062 4343 2542     s%02x.CCHub.CCB%
   c10d4:	6d64 7274 3025 6433 3025 6433 4300 4243     dmtr%03d%03d.CCB
   c10e4:	6425 7768 0061 6576 7463 726f 3a3a 4d5f     %dhwa.vector::_M
   c10f4:	725f 6e61 6567 635f 6568 6b63 203a 5f5f     _range_check: __
   c1104:	206e 7728 6968 6863 6920 2073 7a25 2975     n (which is %zu)
   c1114:	3e20 203d 6874 7369 3e2d 6973 657a 2928      >= this->size()
   c1124:	2820 6877 6369 2068 7369 2520 757a 0029      (which is %zu).
   c1134:	4343 2542 6364 6c74 3025 362e 2066 3025     CCB%dctl%0.6f %0
   c1144:	362e 2066 6425 2520 2064 6425 7600 6365     .6f %d %d %d.vec
   c1154:	6f74 3a72 5f3a 5f4d 6572 6c61 6f6c 5f63     tor::_M_realloc_
   c1164:	6e69 6573 7472 4d00 746f 726f 2073 6552     insert.Motors Re
   c1174:	7573 696d 676e 5000 6572 7373 6120 6167     suming.Press aga
   c1184:	6e69 7420 206f 7473 706f 4d00 746f 726f     in to stop.Motor
   c1194:	2073 7453 706f 6570 2164 5000 6572 7373     s Stopped!.Press
   c11a4:	6120 6167 6e69 7420 206f 7473 7261 0074      again to start.
   c11b4:	575b 5241 5d4e 5720 7261 696e 676e 202c     [WARN] Warning, 
   c11c4:	6863 6365 736b 6d75 6420 656f 2073 6f6e     checksum does no
   c11d4:	2074 616d 6374 2168 7300 7075 2500 2075     t match!.sup.%u 
   c11e4:	7525 2520 2073 7325 2520 2064 6425 5300     %u %s %s %d %d.S
   c11f4:	6174 7574 2073 7055 6164 6574 0021 7325     tatus Update!.%s
   c1204:	2520 2073 6425 2520 2064 6425 2520 2064      %s %d %d %d %d 
   c1214:	6425 6800 6477 7000 7374 5b00 5550 5354     %d.hwd.pts.[PUTS
   c1224:	205d 6552 6563 7669 6465 5320 7274 6e69     ] Received Strin
   c1234:	2067 6f43 6d6d 6e61 3a64 2520 0073 646c     g Command: %s.ld
   c1244:	0074 646c 0062 6c77 0064 6c77 0062 495b     t.ldb.wld.wlb.[I
   c1254:	464e 5d4f 5220 6365 6965 6576 2064 544c     NFO] Received LT
   c1264:	2045 654d 7373 6761 3a65 2520 0073 495b     E Message: %s.[I
   c1274:	464e 5d4f 5220 6365 6965 6576 2064 4c42     NFO] Received BL
   c1284:	2045 654d 7373 6761 3a65 2520 0073 495b     E Message: %s.[I
   c1294:	464e 5d4f 5220 6365 6965 6576 2064 4258     NFO] Received XB
   c12a4:	6565 4d20 7365 6173 6567 203a 7325 2f00     ee Message: %s./
   c12b4:	4300 4243 6425 6d64 0070 6552 6f63 6472     .CCB%ddmp.Record
   c12c4:	4200 7461 6574 7972 4f00 6666 6f6c 6461     .Battery.Offload
   c12d4:	5300 6e65 7274 0079 6552 006d 6553 006e     .Sentry.Rem.Sen.
   c12e4:	7541 0074 6953 6e67 6c61 5300 6c6f 7750     Aut.Signal.SolPw
   c12f4:	0072 6142 5074 7277 6200 3234 3630 3139     r.BatPwr.b420691
   c1304:	2d30 6364 6234 352d 3437 2d33 3863 3162     0-dc4b-5743-c8b1
   c1314:	392d 6432 6530 3537 3831 6232 0030 3462     -92d0e75182b0.b4
   c1324:	3032 3936 3231 642d 3463 2d62 3735 3334     206912-dc4b-5743
   c1334:	632d 6238 2d31 3239 3064 3765 3135 3238     -c8b1-92d0e75182
   c1344:	3062 6200 3234 3630 3139 2d33 6364 6234     b0.b4206913-dc4b
   c1354:	352d 3437 2d33 3863 3162 392d 6432 6530     -5743-c8b1-92d0e
   c1364:	3537 3831 6232 0030 3462 3032 3936 3431     75182b0.b4206914
   c1374:	642d 3463 2d62 3735 3334 632d 6238 2d31     -dc4b-5743-c8b1-
   c1384:	3239 3064 3765 3135 3238 3062 5300 6163     92d0e75182b0.Sca
   c1394:	6e6e 6e69 2067 4200 746f 3a73 2520 0064     nning .Bots: %d.
   c13a4:	6e4f 4f00 6666 4200 746f 6431 7461 4900     On.Off.Bot1dat.I
   c13b4:	706e 7475 4320 6d6f 616d 646e 2500 3230     nput Command.%02
   c13c4:	2564 3230 2564 3430 2564 3230 2564 3230     d%02d%04d%02d%02
   c13d4:	2564 3230 0064 4343 5548 0042 4c5f 474f     d%02d.CCHUB._LOG
   c13e4:	742e 7478 2000 7453 7261 6974 676e 0020     .txt. Starting .
   c13f4:	4b4f 4300 4143 7342 6370 4300 4243 6425     OK.CCABspc.CCB%d
   c1404:	6e73 0073 4343 4241 7473 0070               sns.CCABstp.

000c1410 <_ZTVN8particle11SPISettingsE>:
	...
   c1418:	43f1 000b 40cd 000b 4113 000b               .C...@...A..

000c1424 <_ZTV5Timer>:
	...
   c142c:	4475 000b 44c9 000b 4179 000b               uD...D..yA..

000c1438 <_ZTV4File>:
	...
   c1440:	4111 000b 4121 000b 4161 000b 415b 000b     .A..!A..aA..[A..
   c1450:	40cf 000b 413b 000b 4135 000b 412f 000b     .@..;A..5A../A..
   c1460:	4c43 4145 4552 0044 5300 4f54 5050 4445     CLEARED..STOPPED
   c1470:	0000 6157 6e72 6e69 0067 4200 746f 2520     ..Warning..Bot %
   c1480:	0064 4c00 776f 4220 7461 6574 7972 203a     d..Low Battery: 
   c1490:	6425 0000 4453 4320 7261 2064 6146 6c69     %d..SD Card Fail
   c14a0:	6465 0000 5047 2f53 6f43 706d 7361 2073     ed..GPS/Compass 
   c14b0:	7245 6f72 0072 4c00 6165 206b 6873 7475     Error..Leak shut
   c14c0:	666f 0066 4c00 6165 206b 6564 6574 7463     off..Leak detect
   c14d0:	6465 0000 6e49 6f66 0000 6f4e 2074 6f63     ed..Info..Not co
   c14e0:	6e6e 6365 6574 2064 6f74 4220 454c 0000     nnected to BLE..
   c14f0:	7753 7469 6863 6e69 2067 4c42 2045 6f63     Switching BLE co
   c1500:	6e6e 0000 6548 6c6c 216f 0000 6353 6e61     nn..Hello!..Scan
   c1510:	696e 676e 6620 726f 4220 746f 0073 4f00     ning for Bots..O
   c1520:	204b 6877 6e65 6220 746f 2073 6572 6461     K when bots read
   c1530:	0079 0000                                   y...

000c1534 <_ZTV17Adafruit_GrayOLED>:
	...
   c1544:	7ec1 000b cf55 000b 7181 000b 75af 000b     .~..U....q...u..
   c1554:	75b1 000b 75e3 000b 75bf 000b 75d1 000b     .u...u...u...u..
   c1564:	74f1 000b 75af 000b 77db 000b 737f 000b     .t...u...w...s..
   c1574:	75fb 000b 7639 000b 7673 000b 76b9 000b     .u..9v..sv...v..
   c1584:	76d5 000b 7759 000b 40a5 000b               .v..Yw...@..

000c1590 <_ZL4font>:
   c1590:	0000 0000 3e00 4f5b 3e5b 6b3e 6b4f 1c3e     .....>[O[>>kOk>.
   c15a0:	7c3e 1c3e 3c18 3c7e 1c18 7d57 1c57 5e1c     >|>..<~<..W}W..^
   c15b0:	5e7f 001c 3c18 0018 e7ff e7c3 00ff 2418     .^...<.........$
   c15c0:	0018 e7ff e7db 30ff 3a48 0e06 2926 2979     .......0H:..&)y)
   c15d0:	4026 057f 0705 7f40 2505 5a3f e73c 5a3c     &@....@..%?Z<.<Z
   c15e0:	3e7f 1c1c 0808 1c1c 7f3e 2214 227f 5f14     .>......>.."."._
   c15f0:	005f 5f5f 0906 017f 007f 8966 6a95 6060     _.__......f..j``
   c1600:	6060 9460 ffa2 94a2 0408 047e 1008 7e20     ```.......~... ~
   c1610:	1020 0808 1c2a 0808 2a1c 0808 101e 1010      ...*....*......
   c1620:	0c10 0c1e 0c1e 3830 383e 0630 3e0e 060e     ......08>80..>..
   c1630:	0000 0000 0000 5f00 0000 0700 0700 1400     ......._........
   c1640:	147f 147f 2a24 2a7f 2312 0813 6264 4936     ....$*.*.#..db6I
   c1650:	2056 0050 0708 0003 1c00 4122 0000 2241     V P......."A..A"
   c1660:	001c 1c2a 1c7f 082a 3e08 0808 8000 3070     ..*...*..>....p0
   c1670:	0800 0808 0808 0000 6060 2000 0810 0204     ........``. ....
   c1680:	513e 4549 003e 7f42 0040 4972 4949 2146     >QIE>.B.@.rIIIF!
   c1690:	4941 334d 1418 7f12 2710 4545 3945 4a3c     AIM3.....'EEE9<J
   c16a0:	4949 4131 1121 0709 4936 4949 4636 4949     II1A!...6III6FII
   c16b0:	1e29 0000 0014 0000 3440 0000 0800 2214     ).......@4....."
   c16c0:	1441 1414 1414 4100 1422 0208 5901 0609     A......A"....Y..
   c16d0:	413e 595d 7c4e 1112 7c12 497f 4949 3e36     >A]YN|...|.III6>
   c16e0:	4141 2241 417f 4141 7f3e 4949 4149 097f     AAA".AAA>.IIIA..
   c16f0:	0909 3e01 4141 7351 087f 0808 007f 7f41     ...>AAQs......A.
   c1700:	0041 4020 3f41 7f01 1408 4122 407f 4040     A. @A?...."A.@@@
   c1710:	7f40 1c02 7f02 047f 1008 3e7f 4141 3e41     @..........>AAA>
   c1720:	097f 0909 3e06 5141 5e21 097f 2919 2646     .....>AQ!^...)F&
   c1730:	4949 3249 0103 017f 3f03 4040 3f40 201f     III2.....?@@@?. 
   c1740:	2040 3f1f 3840 3f40 1463 1408 0363 7804     @ .?@8@?c...c..x
   c1750:	0304 5961 4d49 0043 417f 4141 0402 1008     ..aYIMC..AAA....
   c1760:	0020 4141 7f41 0204 0201 4004 4040 4040      .AAA......@@@@@
   c1770:	0300 0807 2000 5454 4078 287f 4444 3838     ..... TTx@.(DD88
   c1780:	4444 2844 4438 2844 387f 5454 1854 0800     DDD(8DD(.8TTT...
   c1790:	097e 1802 a4a4 789c 087f 0404 0078 7d44     ~......x....x.D}
   c17a0:	0040 4020 3d40 7f00 2810 0044 4100 407f     @. @@=...(D..A.@
   c17b0:	7c00 7804 7804 087c 0404 3878 4444 3844     .|.x.x|...x8DDD8
   c17c0:	18fc 2424 1818 2424 fc18 087c 0404 4808     ..$$..$$..|....H
   c17d0:	5454 2454 0404 443f 3c24 4040 7c20 201c     TTT$..?D$<@@ |. 
   c17e0:	2040 3c1c 3040 3c40 2844 2810 4c44 9090     @ .<@0@<D(.(DL..
   c17f0:	7c90 6444 4c54 0044 3608 0041 0000 0077     .|DdTLD..6A...w.
   c1800:	0000 3641 0008 0102 0402 3c02 2326 3c26     ..A6.......<&#&<
   c1810:	a11e 61a1 3a12 4040 7a20 5438 5554 2159     ...a.:@@ z8TTUY!
   c1820:	5555 4179 5422 7854 2142 5455 4078 5420     UUyA"TTxB!UTx@ T
   c1830:	7955 0c40 521e 1272 5539 5555 3959 5454     Uy@..Rr.9UUUY9TT
   c1840:	5954 5539 5454 0058 4500 417c 0200 7d45     TY9UTTX..E|A..E}
   c1850:	0042 4501 407c 127d 1211 f07d 2528 f028     B..E|@}...}.(%(.
   c1860:	547c 4555 2000 5454 547c 0a7c 7f09 3249     |TUE. TT|T|...I2
   c1870:	4949 3249 443a 4444 323a 484a 3048 413a     III2:DDD:2JHH0:A
   c1880:	2141 3a7a 4042 7820 9d00 a0a0 3d7d 4242     A!z:B@ x....}=BB
   c1890:	3d42 403d 4040 3c3d ff24 2424 7e48 4349     B==@@@=<$.$$H~IC
   c18a0:	2b66 fc2f 2b2f 09ff f629 c020 7e88 0309     f+/./+..). ..~..
   c18b0:	5420 7954 0041 4400 417d 4830 4a48 3832      TTyA..D}A0HHJ28
   c18c0:	4040 7a22 7a00 0a0a 7d72 190d 7d31 2926     @@"z.z..r}..1}&)
   c18d0:	2f29 2628 2929 2629 4830 404d 3820 0808     )/(&)))&0HM@ 8..
   c18e0:	0808 0808 0808 2f38 c810 baac 102f 3428     ......8/..../.(4
   c18f0:	00fa 7b00 0000 1408 142a 2222 2a14 0814     ...{....*."".*..
   c1900:	0055 0055 aa55 aa55 aa55 55ff 55ff 00ff     U.U.U.U.U..U.U..
   c1910:	0000 00ff 1010 ff10 1400 1414 00ff 1010     ................
   c1920:	00ff 10ff f010 f010 1414 fc14 1400 f714     ................
   c1930:	ff00 0000 00ff 14ff f414 fc04 1414 1017     ................
   c1940:	101f 1f10 1f10 1414 1f14 1000 1010 00f0     ................
   c1950:	0000 1f00 1010 1010 101f 1010 f010 0010     ................
   c1960:	0000 10ff 1010 1010 1010 1010 10ff 0000     ................
   c1970:	ff00 0014 ff00 ff00 0000 101f 0017 fc00     ................
   c1980:	f404 1414 1017 1417 f414 f404 0000 00ff     ................
   c1990:	14f7 1414 1414 1414 00f7 14f7 1414 1417     ................
   c19a0:	1010 101f 141f 1414 14f4 1010 10f0 00f0     ................
   c19b0:	1f00 1f10 0000 1f00 0014 0000 14fc 0000     ................
   c19c0:	10f0 10f0 ff10 ff10 1414 ff14 1014 1010     ................
   c19d0:	001f 0000 f000 ff10 ffff ffff f0f0 f0f0     ................
   c19e0:	fff0 ffff 0000 0000 ff00 0fff 0f0f 0f0f     ................
   c19f0:	4438 3844 fc44 4a4a 344a 027e 0602 0206     8DD8D.JJJ4~.....
   c1a00:	027e 027e 5563 4149 3863 4444 043c 7e40     ~.~.cUIAc8DD<.@~
   c1a10:	1e20 0620 7e02 0202 a599 a5e7 1c99 492a      . ..~........*I
   c1a20:	1c2a 724c 7201 304c 4d4a 304d 4830 4878     *.Lr.rL0JMM00HxH
   c1a30:	bc30 5a62 3d46 493e 4949 7e00 0101 7e01     0.bZF=>III.~...~
   c1a40:	2a2a 2a2a 442a 5f44 4444 5140 444a 4040     *****DD_DD@QJD@@
   c1a50:	4a44 4051 0000 01ff e003 ff80 0000 0808     DJQ@............
   c1a60:	6b6b 3608 3612 3624 0f06 0f09 0006 1800     kk.6.6$6........
   c1a70:	0018 0000 1010 3000 ff40 0101 1f00 0101     .......0@.......
   c1a80:	001e 1d19 1217 3c00 3c3c 003c 0000 0000     .......<<<<.....

000c1a90 <_ZTV12Adafruit_GFX>:
	...
   c1aa0:	7ec1 000b cf55 000b 40a5 000b 75af 000b     .~..U....@...u..
   c1ab0:	75b1 000b 75e3 000b 75bf 000b 75d1 000b     .u...u...u...u..
   c1ac0:	74f1 000b 75af 000b 77db 000b 77d9 000b     .t...u...w...w..
   c1ad0:	75fb 000b 7639 000b 7673 000b 76b9 000b     .u..9v..sv...v..
   c1ae0:	76d5 000b 7759 000b                         .v..Yw..

000c1ae8 <_ZTV15Adafruit_SH110X>:
	...
   c1af0:	40a5 000b 40a5 000b 7ec1 000b cf55 000b     .@...@...~..U...
   c1b00:	7181 000b 75af 000b 75b1 000b 75e3 000b     .q...u...u...u..
   c1b10:	75bf 000b 75d1 000b 74f1 000b 75af 000b     .u...u...t...u..
   c1b20:	77db 000b 737f 000b 75fb 000b 7639 000b     .w...s...u..9v..
   c1b30:	7673 000b 76b9 000b 76d5 000b 7759 000b     sv...v...v..Yw..
   c1b40:	99e1 000b                                   ....

000c1b44 <_ZL12splash2_data>:
   c1b44:	0000 0060 0000 0000 0000 0000 0000 0000     ..`.............
   c1b54:	e000 0000 0000 0000 0000 0000 0000 0100     ................
   c1b64:	00e0 0000 0000 0000 0000 0000 0000 f001     ................
	...
   c1b80:	0300 00f0 0000 0000 0000 0000 0000 0000     ................
   c1b90:	f007 0000 0000 0000 0000 0000 0000 0700     ................
   c1ba0:	00f8 0000 0000 0000 0000 0000 0000 f80f     ................
   c1bb0:	0000 0300 00c0 007e 0100 00e0 0f7f 00f8     ......~.........
   c1bc0:	0000 c003 fe00 0000 e001 ff00 f8ef 0000     ................
   c1bd0:	0300 00c0 00fe 0100 00e0 ffff 00f8 0000     ................
   c1be0:	c003 f000 0000 0f00 7f00 7ffe 00c0 0300     ................
   c1bf0:	00c0 00f0 0000 000f fe3f f87f f13f cffb     ........?...?...
   c1c00:	fefc bcf3 ef3d 1fe0 7ffe 7fff fffb fedf     ....=...........
   c1c10:	fffe 3dbc e0ef c61f ffff fb7f dfff fefe     ...=............
   c1c20:	bcff ef3d 0fe0 c7e3 78fe c37b 1ede fff0     ..=......x{.....
   c1c30:	3dbc 00ef ff07 fc87 7b78 dec3 f01e 3cf8     .=......x{.....<
   c1c40:	ef3d 0100 ffff 00f0 c37b 1ec0 f0f0 3d3c     =.......{.....<=
   c1c50:	00ef f301 e07f fb3f cfc3 f0fe 3cf0 ef3d     ......?......<=.
   c1c60:	0300 3fe3 7f80 c3fb fedf f0f0 3d3c 00ef     ...?........<=..
   c1c70:	e707 003c 7b78 dec3 f01e 3cf0 ef3d 0700     ..<.x{.....<=...
   c1c80:	beff 7800 c37b 1ede f0f0 3d3c 00ef ff07     ...x{.....<=....
   c1c90:	00fe 7b78 dec3 f01e 3cf0 ef3d 0f00 feff     ..x{.....<=.....
   c1ca0:	7f00 fffb fedf f0f0 fd3f e0ef ff0f 00ff     ........?.......
   c1cb0:	fb7f dfff f0fe 3ff0 effd 0fe0 fff9 3e00     .......?.......>
   c1cc0:	f979 9ecf f0f0 3d1f e0e7 f11f 00ff 0000     y......=........
	...
   c1cd8:	1f00 ff80 7f00 ffff ffff ffff ffff e0ff     ................
   c1ce8:	001c 007f ff7f ffff b4fe 886d 188d 00e0     ..........m.....
   c1cf8:	1f00 7f00 ffff feff ad95 b57d e077 0000     ..........}.w...
   c1d08:	000f ff7f ffff a5fe 9dad 198d 00e0 0600     ................
   c1d18:	7f00 ffff feff adb5 b5ed e07e               ..........~.

000c1d24 <_ZTV15Adafruit_SH1107>:
	...
   c1d2c:	9b7d 000b 9b91 000b 7ec1 000b cf55 000b     }........~..U...
   c1d3c:	7181 000b 75af 000b 75b1 000b 75e3 000b     .q...u...u...u..
   c1d4c:	75bf 000b 75d1 000b 74f1 000b 75af 000b     .u...u...t...u..
   c1d5c:	77db 000b 737f 000b 75fb 000b 7639 000b     .w...s...u..9v..
   c1d6c:	7673 000b 76b9 000b 76d5 000b 7759 000b     sv...v...v..Yw..
   c1d7c:	99e1 000b                                   ....

000c1d80 <_ZZN15Adafruit_SH11075beginEhbE12init_128x128>:
   c1d80:	00d3 7fa8                                   ....

000c1d84 <_ZZN15Adafruit_SH11075beginEhbE4init>:
   c1d84:	d5ae 2051 4f81 8aad c0a0 00dc 60d3 22d9     ..Q .O.......`."
   c1d94:	35db 3fa8 a6a4 0000                         .5.?....

000c1d9c <_ZTVN5spark13EthernetClassE>:
	...
   c1da4:	a51b 000b a511 000b a507 000b a4fd 000b     ................
   c1db4:	a4f1 000b a4e5 000b ddcb 000b ddd3 000b     ................
   c1dc4:	a4d9 000b a4d1 000b a4c7 000b a4bd 000b     ................
   c1dd4:	de03 000b                                   ....

000c1dd8 <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
   c1dd8:	0800 1810 2820 3830 7341 6573 7472 6f69     .... (08Assertio
   c1de8:	466e 6961 756c 6572 6620 6c61 6573 7700     nFailure false.w
   c1df8:	7269 6e69 2e67 6c62 0065 7453 7261 2074     iring.ble.Start 
   c1e08:	6964 6373 766f 7265 6e69 2067 6573 7672     discovering serv
   c1e18:	6369 7365 002e 7341 6573 7472 6f69 466e     ices..AssertionF
   c1e28:	6961 756c 6572 6820 6c61 625f 656c 735f     ailure hal_ble_s
   c1e38:	6174 6b63 695f 696e 2874 756e 6c6c 7470     tack_init(nullpt
   c1e48:	2972 3d20 203d 5953 5453 4d45 455f 5252     r) == SYSTEM_ERR
   c1e58:	524f 4e5f 4e4f 0045 6550 7265 6420 7665     OR_NONE.Peer dev
   c1e68:	6369 2065 7369 6d20 7369 6973 676e 0021     ice is missing!.
   c1e78:	6146 6c69 6465 7420 206f 6c61 6f6c 6163     Failed to alloca
   c1e88:	6574 6d20 6d65 726f 2179 4600 6961 656c     te memory!.Faile
   c1e98:	2064 6f74 6120 7070 6e65 2064 6570 7265     d to append peer
   c1ea8:	4320 6e65 7274 6c61 6420 7665 6369 2e65      Central device.
   c1eb8:	4300 6e6f 656e 7463 6465 6220 2079 6543     .Connected by Ce
   c1ec8:	746e 6172 206c 6564 6976 6563 002e 6944     ntral device..Di
   c1ed8:	6373 6e6f 656e 7463 6465 6220 2079 6572     sconnected by re
   c1ee8:	6f6d 6574 6420 7665 6369 2e65 4600 6961     mote device..Fai
   c1ef8:	656c 2064 6f74 6120 7070 6e65 2064 6964     led to append di
   c1f08:	6373 766f 7265 6465 7320 7265 6976 6563     scovered service
   c1f18:	002e 7453 7261 2074 6964 6373 766f 7265     ..Start discover
   c1f28:	6e69 2067 6863 7261 6361 6574 6972 7473     ing characterist
   c1f38:	6369 2073 666f 7320 7265 6976 6563 203a     ics of service: 
   c1f48:	7325 002e 6143 6e6e 746f 6120 6464 6e20     %s..Cannot add n
   c1f58:	7765 7020 6565 2072 6564 6976 6563 002e     ew peer device..
   c1f68:	654e 2077 6570 6972 6870 7265 6c61 6920     New peripheral i
   c1f78:	2073 6f63 6e6e 6365 6574 2e64 4300 6168     s connected..Cha
   c1f88:	6172 7463 7265 7369 6974 2063 6964 6373     racteristic disc
   c1f98:	766f 7265 6465 002e 6944 6373 766f 7265     overed..Discover
   c1fa8:	6465 6320 6168 6172 7463 7265 7369 6974     ed characteristi
   c1fb8:	2763 2073 6168 646e 656c 6920 2073 6e69     c's handle is in
   c1fc8:	6176 696c 2e64 4600 6961 656c 2064 6f74     valid..Failed to
   c1fd8:	6120 7070 6e65 2064 6964 6373 766f 7265      append discover
   c1fe8:	6465 6320 6168 6172 7463 7265 7369 6974     ed characteristi
   c1ff8:	2e63 0000                                   c...

000c1ffc <_ZTVSt23_Sp_counted_ptr_inplaceIN8particle21BleCharacteristicImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   c2004:	a927 000b a989 000b aaff 000b a9b3 000b     '...............
   c2014:	a929 000b                                   )...

000c2018 <_ZTVSt23_Sp_counted_ptr_inplaceIN8particle14BleServiceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   c2020:	a923 000b a997 000b a925 000b a9b9 000b     #.......%.......
   c2030:	a949 000b                                   I...

000c2034 <_ZTVSt23_Sp_counted_ptr_inplaceIN8particle17BlePeerDeviceImplESaIS1_ELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   c203c:	a921 000b a9a5 000b b659 000b a9bf 000b     !.......Y.......
   c204c:	a969 000b                                   i...

000c2050 <_ZZNSt19_Sp_make_shared_tag5_S_tiEvE5__tag>:
	...
   c205c:	0000 34fb 5f9b 0080 8000 1000 0000 0000     ...4._..........
   c206c:	0000 7061 0070 5925 252d 2d6d 6425 2554     ..app.%Y-%m-%dT%
   c207c:	3a48 4d25 253a 2553 007a 7361 7463 6d69     H:%M:%S%z.asctim
   c208c:	0065 0000                                   e...

000c2090 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
   c2098:	d3a5 000b d3ab 000b d3e9 000b d3b9 000b     ................
   c20a8:	d3a7 000b                                   ....

000c20ac <_ZTV9IPAddress>:
	...
   c20b4:	d931 000b d921 000b d923 000b               1...!...#...

000c20c0 <_ZTV9USBSerial>:
	...
   c20c8:	da17 000b da7f 000b da55 000b cf55 000b     ........U...U...
   c20d8:	da47 000b da19 000b da29 000b da79 000b     G.......)...y...
   c20e8:	da39 000b da11 000b                         9.......

000c20f0 <_ZTVN5spark13CellularClassE>:
	...
   c20f8:	dbcf 000b dbc5 000b dbbb 000b db71 000b     ............q...
   c2108:	dbaf 000b dba3 000b ddcb 000b ddd3 000b     ................
   c2118:	db97 000b db8f 000b db85 000b db7b 000b     ............{...
   c2128:	de03 000b                                   ....

000c212c <_ZTV11USARTSerial>:
	...
   c2134:	dc09 000b dc75 000b dc4d 000b cf55 000b     ....u...M...U...
   c2144:	dc1d 000b dc39 000b dc2b 000b dc47 000b     ....9...+...G...
   c2154:	dc0b 000b dc0f 000b                         ........

000c215c <_ZTV7TwoWire>:
	...
   c2164:	dce3 000b dd2d 000b dd05 000b dce5 000b     ....-...........
   c2174:	dd0d 000b dd15 000b dd1d 000b dd25 000b     ............%...

000c2184 <_ZTVN5spark12NetworkClassE>:
	...
   c218c:	dd8b 000b dd95 000b dd9f 000b dda9 000b     ................
   c219c:	ddb3 000b ddbf 000b ddcb 000b ddd3 000b     ................
   c21ac:	dddb 000b dde7 000b ddef 000b ddf9 000b     ................
   c21bc:	de03 000b                                   ....

000c21c0 <_ZSt7nothrow>:
	...

000c21c1 <_ZTSSt19_Sp_make_shared_tag>:
   c21c1:	7453 3931 535f 5f70 616d 656b 735f 6168     St19_Sp_make_sha
   c21d1:	6572 5f64 6174 0067 0000                     red_tag....

000c21dc <_ZTISt19_Sp_make_shared_tag>:
   c21dc:	2290 000c 21c1 000c 6f6e 2074 6e65 756f     ."...!..not enou
   c21ec:	6867 7320 6170 6563 6620 726f 6620 726f     gh space for for
   c21fc:	616d 2074 7865 6170 736e 6f69 206e 5028     mat expansion (P
   c220c:	656c 7361 2065 7573 6d62 7469 6620 6c75     lease submit ful
   c221c:	206c 7562 2067 6572 6f70 7472 6120 2074     l bug report at 
   c222c:	7468 7074 3a73 2f2f 6367 2e63 6e67 2e75     https://gcc.gnu.
   c223c:	726f 2f67 7562 7367 292f 0a3a 2020 2020     org/bugs/):.    
   c224c:	3000 3231 3433 3635 3837 0039               .0123456789.

000c2258 <_ZTIN10__cxxabiv117__class_type_infoE>:
   c2258:	22f0 000c 2264 000c 2314 000c               ."..d"...#..

000c2264 <_ZTSN10__cxxabiv117__class_type_infoE>:
   c2264:	314e 5f30 635f 7878 6261 7669 3131 5f37     N10__cxxabiv117_
   c2274:	635f 616c 7373 745f 7079 5f65 6e69 6f66     _class_type_info
   c2284:	0045 0000                                   E...

000c2288 <_ZTVN10__cxxabiv117__class_type_infoE>:
   c2288:	0000 0000 2258 000c e2d1 000b e2e5 000b     ....X"..........
   c2298:	e479 000b e479 000b e34f 000b e293 000b     y...y...O.......
   c22a8:	e337 000b e2f9 000b e2c5 000b               7...........

000c22b4 <_ZTIN10__cxxabiv120__si_class_type_infoE>:
   c22b4:	22f0 000c 22c0 000c 2258 000c               ."..."..X"..

000c22c0 <_ZTSN10__cxxabiv120__si_class_type_infoE>:
   c22c0:	314e 5f30 635f 7878 6261 7669 3231 5f30     N10__cxxabiv120_
   c22d0:	735f 5f69 6c63 7361 5f73 7974 6570 695f     _si_class_type_i
   c22e0:	666e 456f 0000 0000                         nfoE....

000c22e8 <_ZTVN10__cxxabiv120__si_class_type_infoE>:
   c22e8:	0000 0000 22b4 000c e379 000b e38d 000b     ....."..y.......
   c22f8:	e479 000b e479 000b e34f 000b e293 000b     y...y...O.......
   c2308:	e44d 000b e3d9 000b e3a1 000b               M...........

000c2314 <_ZTISt9type_info>:
   c2314:	2290 000c 231c 000c                         ."...#..

000c231c <_ZTSSt9type_info>:
   c231c:	7453 7439 7079 5f65 6e69 6f66 5200 4545     St9type_info.REE
   c232c:	544e 6d20 6c61 6f6c 2063 7573 6363 6565     NT malloc succee
   c233c:	6564 0064 6d2f 746e 772f 726f 736b 6170     ded./mnt/workspa
   c234c:	6563 772f 726f 736b 6170 6563 472f 4343     ce/workspace/GCC
   c235c:	312d 2d30 6970 6570 696c 656e 6a2f 6e65     -10-pipeline/jen
   c236c:	696b 736e 472d 4343 312d 2d30 6970 6570     kins-GCC-10-pipe
   c237c:	696c 656e 342d 5f38 3032 3032 3131 3432     line-48_20201124
   c238c:	315f 3036 3136 3038 3436 2f31 7273 2f63     _1606180641/src/
   c239c:	656e 6c77 6269 6e2f 7765 696c 2f62 696c     newlib/newlib/li
   c23ac:	6362 732f 6474 696c 2f62 6172 646e 632e     bc/stdlib/rand.c
   c23bc:	6e00 0066 6e69 7469 0079 6e61 0000 0000     .nf.inity.an....

000c23cc <fpi.1>:
   c23cc:	0035 0000 fbce ffff 03cb 0000 0001 0000     5...............
   c23dc:	0000 0000                                   ....

000c23e0 <fpinan.0>:
   c23e0:	0034 0000 fbce ffff 03cb 0000 0001 0000     4...............
	...

000c23f8 <tinytens>:
   c23f8:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
   c2408:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
   c2418:	6f43 64ac 0628 1168                         Co.d(.h.

000c2420 <_ctype_>:
   c2420:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
   c2430:	2020 2020 2020 2020 2020 2020 2020 2020                     
   c2440:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
   c2450:	0410 0404 0404 0404 0404 1004 1010 1010     ................
   c2460:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
   c2470:	0101 0101 0101 0101 0101 0101 1010 1010     ................
   c2480:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
   c2490:	0202 0202 0202 0202 0202 0202 1010 1010     ................
   c24a0:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
   c2520:	4200 6c61 6f6c 2063 7573 6363 6565 6564     .Balloc succeede
   c2530:	0064 6d2f 746e 772f 726f 736b 6170 6563     d./mnt/workspace
   c2540:	772f 726f 736b 6170 6563 472f 4343 312d     /workspace/GCC-1
   c2550:	2d30 6970 6570 696c 656e 6a2f 6e65 696b     0-pipeline/jenki
   c2560:	736e 472d 4343 312d 2d30 6970 6570 696c     ns-GCC-10-pipeli
   c2570:	656e 342d 5f38 3032 3032 3131 3432 315f     ne-48_20201124_1
   c2580:	3036 3136 3038 3436 2f31 7273 2f63 656e     606180641/src/ne
   c2590:	6c77 6269 6e2f 7765 696c 2f62 696c 6362     wlib/newlib/libc
   c25a0:	732f 6474 696c 2f62 6467 6f74 2d61 6567     /stdlib/gdtoa-ge
   c25b0:	6874 7865 632e 0000                         thex.c..

000c25b8 <_C_numeric_locale>:
   c25b8:	1ff9 000c 1076 000c db18 2003 0043 4f50     ....v...... C.PO
   c25c8:	4953 0058 6d2f 746e 772f 726f 736b 6170     SIX./mnt/workspa
   c25d8:	6563 772f 726f 736b 6170 6563 472f 4343     ce/workspace/GCC
   c25e8:	312d 2d30 6970 6570 696c 656e 6a2f 6e65     -10-pipeline/jen
   c25f8:	696b 736e 472d 4343 312d 2d30 6970 6570     kins-GCC-10-pipe
   c2608:	696c 656e 342d 5f38 3032 3032 3131 3432     line-48_20201124
   c2618:	315f 3036 3136 3038 3436 2f31 7273 2f63     _1606180641/src/
   c2628:	656e 6c77 6269 6e2f 7765 696c 2f62 696c     newlib/newlib/li
   c2638:	6362 732f 6474 696c 2f62 706d 6572 2e63     bc/stdlib/mprec.
   c2648:	0063 0000 0000 0000                         c.......

000c2650 <__mprec_bigtens>:
   c2650:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
   c2660:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
   c2670:	bf3c 7f73 4fdd 7515                         <.s..O.u

000c2678 <__mprec_tens>:
   c2678:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
   c2688:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
   c2698:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
   c26a8:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
   c26b8:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
   c26c8:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
   c26d8:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
   c26e8:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
   c26f8:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
   c2708:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
   c2718:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
   c2728:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
   c2738:	9db4 79d9 7843 44ea                         ...yCx.D

000c2740 <p05.0>:
   c2740:	0005 0000 0019 0000 007d 0000               ........}...

000c274c <link_const_variable_data_end>:
   c274c:	000b6519 	.word	0x000b6519
   c2750:	000ba525 	.word	0x000ba525
   c2754:	000ba6c5 	.word	0x000ba6c5
   c2758:	000bcf45 	.word	0x000bcf45
   c275c:	000bd0b5 	.word	0x000bd0b5
   c2760:	000bd245 	.word	0x000bd245
   c2764:	000bd261 	.word	0x000bd261
   c2768:	000bdbd9 	.word	0x000bdbd9
   c276c:	000bdedd 	.word	0x000bdedd
